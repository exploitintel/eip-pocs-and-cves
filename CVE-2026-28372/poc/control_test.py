#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : GNU inetutils telnetd Control Test (No Injection)
# CVE            : CVE-2026-28372
# Vendor         : GNU / Free Software Foundation
# Product        : GNU inetutils telnetd
# Affected       : All versions through 2.7 (inclusive)
# Type           : Control Verification / Authentication Baseline
# CVSS           : N/A (Control Script)
# Platform       : Linux / Telnet
# Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Control test for CVE-2026-28372: Connect WITHOUT injecting CREDENTIALS_DIRECTORY
to verify that authentication is normally required.

This proves the exploit is the causal factor — without the injected env var,
login(1) correctly prompts for a username/password.
"""

import select
import socket
import sys
import time

# Telnet protocol constants
IAC = 0xFF; WILL = 0xFB; WONT = 0xFC; DO = 0xFD; DONT = 0xFE
SB = 0xFA; SE = 0xF0
TELOPT_ECHO = 0x01; TELOPT_SGA = 0x03; TELOPT_STATUS = 0x05
TELOPT_TTYPE = 0x18; TELOPT_NAWS = 0x1F; TELOPT_TSPEED = 0x20
TELOPT_LFLOW = 0x21; TELOPT_LINEMODE = 0x22; TELOPT_XDISPLOC = 0x23
TELOPT_NEW_ENVIRON = 0x27
TELQUAL_IS = 0x00; TELQUAL_SEND = 0x01

WILL_OPTS = {TELOPT_TTYPE, TELOPT_NEW_ENVIRON, TELOPT_TSPEED,
             TELOPT_XDISPLOC, TELOPT_NAWS, TELOPT_LINEMODE, TELOPT_LFLOW}
DO_OPTS = {TELOPT_ECHO, TELOPT_SGA, TELOPT_STATUS}


def process_data(sock, data):
    """Process telnet data, respond to negotiations, return text."""
    text = b''
    response = b''
    i = 0
    while i < len(data):
        if data[i] == IAC and i + 1 < len(data):
            cmd = data[i + 1]
            if cmd == IAC:
                text += bytes([IAC]); i += 2
            elif cmd in (DO, DONT) and i + 2 < len(data):
                opt = data[i + 2]
                if cmd == DO and opt in WILL_OPTS:
                    response += bytes([IAC, WILL, opt])
                else:
                    response += bytes([IAC, WONT, opt])
                i += 3
            elif cmd in (WILL, WONT) and i + 2 < len(data):
                opt = data[i + 2]
                if cmd == WILL and opt in DO_OPTS:
                    response += bytes([IAC, DO, opt])
                else:
                    response += bytes([IAC, DONT, opt])
                i += 3
            elif cmd == SB:
                end = data.find(bytes([IAC, SE]), i + 2)
                if end < 0: break
                sb = data[i+2:end]
                if sb:
                    opt = sb[0]; sb_cmd = sb[1] if len(sb) > 1 else -1
                    if opt == TELOPT_TTYPE and sb_cmd == TELQUAL_SEND:
                        response += bytes([IAC, SB, TELOPT_TTYPE, TELQUAL_IS]) + b'xterm' + bytes([IAC, SE])
                    elif opt == TELOPT_TSPEED and sb_cmd == TELQUAL_SEND:
                        response += bytes([IAC, SB, TELOPT_TSPEED, TELQUAL_IS]) + b'38400,38400' + bytes([IAC, SE])
                    elif opt == TELOPT_XDISPLOC and sb_cmd == TELQUAL_SEND:
                        response += bytes([IAC, SB, TELOPT_XDISPLOC, TELQUAL_IS]) + bytes([IAC, SE])
                    elif opt == TELOPT_NEW_ENVIRON and sb_cmd == TELQUAL_SEND:
                        # CONTROL TEST: Send EMPTY environment (no CREDENTIALS_DIRECTORY)
                        response += bytes([IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_IS, IAC, SE])
                i = end + 2
            else:
                i += 2
        else:
            text += data[i:i+1]; i += 1
    if response:
        sock.sendall(response)
    return text


def main():
    host = sys.argv[1] if len(sys.argv) > 1 else 'localhost'
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 2323

    print("=" * 60)
    print("  CONTROL TEST — Connection WITHOUT exploit")
    print("  (Should require authentication)")
    print("=" * 60)
    print(f"  Target: {host}:{port}")
    print()

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))
    sock.setblocking(False)
    print(f"[+] Connected")

    # Send NAWS
    sock.sendall(bytes([IAC, SB, TELOPT_NAWS, 0, 80, 0, 24, IAC, SE]))

    all_text = b''
    for rnd in range(20):
        time.sleep(0.5)
        ready = select.select([sock], [], [], 2)
        if ready[0]:
            try:
                data = sock.recv(8192)
            except Exception:
                data = b''
        else:
            data = b''
        if not data:
            if rnd > 8: break
            continue
        text = process_data(sock, data)
        all_text += text
        decoded = all_text.decode('ascii', errors='replace')
        if 'ogin:' in decoded or 'assword:' in decoded:
            break
        if '#' in decoded:
            break

    decoded = all_text.decode('ascii', errors='replace')
    sock.close()

    print(f"[*] Server response: {repr(decoded.strip()[-100:])}")
    print()

    if 'ogin:' in decoded or 'assword:' in decoded:
        print("[✓] CONTROL TEST PASSED — Authentication is required")
        print("    (login prompt received, proving the exploit is the causal factor)")
        print("=" * 60)
        sys.exit(0)
    elif '#' in decoded or '$ ' in decoded:
        print("[✗] CONTROL TEST FAILED — Got shell without exploit!")
        print("    (This would indicate a misconfigured lab)")
        print("=" * 60)
        sys.exit(1)
    else:
        print(f"[?] CONTROL TEST INCONCLUSIVE — Unexpected response")
        print("=" * 60)
        sys.exit(2)


if __name__ == '__main__':
    main()
