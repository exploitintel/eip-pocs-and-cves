#!/usr/bin/env python3
"""
mini-inetd.py — Minimal inetd replacement for lab use.

Listens on a TCP port and spawns telnetd for each connection,
passing the accepted socket as fd 0/1/2 (inetd convention).
This ensures getpeername(0) works correctly in telnetd.
"""

import os
import signal
import socket
import sys

TELNETD_PATH = "/usr/local/sbin/telnetd"
LISTEN_PORT = int(sys.argv[1]) if len(sys.argv) > 1 else 2323
LISTEN_HOST = "0.0.0.0"


def reap_children(signum, frame):
    """Reap zombie child processes."""
    while True:
        try:
            pid, _ = os.waitpid(-1, os.WNOHANG)
            if pid == 0:
                break
        except ChildProcessError:
            break


def main():
    signal.signal(signal.SIGCHLD, reap_children)

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((LISTEN_HOST, LISTEN_PORT))
    sock.listen(5)

    print(f"[mini-inetd] Listening on {LISTEN_HOST}:{LISTEN_PORT}", flush=True)
    print(f"[mini-inetd] Will exec {TELNETD_PATH} for each connection", flush=True)

    while True:
        try:
            conn, addr = sock.accept()
        except InterruptedError:
            continue

        print(f"[mini-inetd] Connection from {addr[0]}:{addr[1]}", flush=True)

        pid = os.fork()
        if pid == 0:
            # Child process — become telnetd
            sock.close()
            fd = conn.fileno()
            os.dup2(fd, 0)
            os.dup2(fd, 1)
            os.dup2(fd, 2)
            if fd > 2:
                os.close(fd)
            os.execv(TELNETD_PATH, ["telnetd"])
            # If execv fails:
            sys.exit(1)
        else:
            # Parent — close the accepted socket and loop
            conn.close()


if __name__ == "__main__":
    main()
