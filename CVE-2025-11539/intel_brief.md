# Intel Brief: CVE-2025-11539

## CVE Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-11539 |
| **Affected Software** | Grafana Image Renderer |
| **Vendor** | Grafana Labs |
| **Affected Versions** | 1.0.0 through 4.0.16 |
| **Patched Version** | 4.0.17 |
| **CVSS Score** | 9.9 (Critical) |
| **CVSS Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H |
| **CWE** | CWE-94 (Improper Control of Generation of Code / Code Injection) |
| **EPSS** | 0.5% (65.7th percentile) |
| **Published** | 2025-10-09 |

## Description

The Grafana Image Renderer plugin is vulnerable to **Remote Code Execution (RCE)** via an arbitrary file write vulnerability. The `/render/csv` and `/render` HTTP endpoints accept a user-controlled `filePath` query parameter that is passed directly to file system operations without any path traversal validation.

An attacker who can reach the image renderer's HTTP API can:
1. Supply a `filePath` containing directory traversal characters (`/`, `\`) via the query string
2. Cause the renderer to write attacker-controlled content to an arbitrary location on the filesystem
3. Write a malicious shared object (`.so` file) to a location where it will be loaded by the Chromium subprocess
4. Achieve remote code execution when Chromium loads the malicious shared library

### Prerequisites for Exploitation

1. **Authentication token known**: The default auth token is `-` (a single hyphen, configured in `default.json` as `"authToken": "-"`). If the operator has not changed this, an attacker can authenticate by sending `X-Auth-Token: -` in the HTTP header.
2. **Network access**: The image renderer listens on port 8081 by default. The attacker must be able to reach this port.

## Vulnerability Details

### Vulnerable Code Path

**File**: `src/browser/browser.ts`

The `exportCSV()` method (line 453) and `takeScreenshot()` method (line 308) both accept `options.filePath` from user input without validation:

```typescript
// In exportCSV() — the primary attack vector via /render/csv
async exportCSV(page: any, options: RenderOptions, signal: AbortSignal): Promise<RenderCSVResponse> {
    // ...
    let filePath = downloadFilePath;
    if (options.filePath) {
      fs.copyFileSync(downloadFilePath, options.filePath);  // ARBITRARY FILE WRITE
      // ...
    }
    return { filePath, fileName: path.basename(downloadFilePath) };
}
```

**File**: `src/service/http-server.ts`

The `renderCSV` handler (line 284) passes `req.query.filePath` directly from the HTTP query string into `options.filePath`:

```typescript
renderCSV = async (req, res, next) => {
    const options: RenderOptions = {
      url: req.query.url,
      filePath: req.query.filePath,  // USER-CONTROLLED, NO VALIDATION
      // ...
    };
    const result = await this.browser.renderCSV(options, signal);
```

**File**: `src/service/middlewares.ts`

Authentication is via `X-Auth-Token` header validated by `authTokenMiddleware`. Default token: `-`.

### Attack Flow

1. Attacker sends: `GET /render/csv?url=<grafana_url>&filePath=../../path/to/target.so` with `X-Auth-Token: -`
2. The renderer navigates to the URL, downloads the CSV
3. `fs.copyFileSync(downloadFilePath, options.filePath)` writes the downloaded content to the attacker-controlled path
4. If the attacker can control the downloaded CSV content (via a malicious URL), they can write arbitrary binary content
5. Writing a shared object to a path loaded by Chromium (e.g., via `LD_PRELOAD` or library search paths) yields code execution

### The Fix (PR #801)

The fix adds an `assertNoPathTraversal()` function that validates `filePath` before any file operations:

```typescript
function assertNoPathTraversal(path?: string | null) {
  if (!path) {
    return;
  }
  if (path.indexOf('/') !== -1 || path.indexOf('\\') !== -1 || path === '..') {
    throw boom.badRequest('File path should not include directories');
  }
}
```

This function is called at the top of both `takeScreenshot()` and `exportCSV()` methods.

## Repository Information

| Field | Value |
|-------|-------|
| **Repository URL** | https://github.com/grafana/grafana-image-renderer.git |
| **Vulnerable Version Tag** | `v4.0.16` (checked out) |
| **Fix Commit** | `1858c2c51347b23f43b1d288bc9222f16030e3f9` |
| **Fix PR** | [#801](https://github.com/grafana/grafana-image-renderer/pull/801) — "fix: assert no path traversal in renders" |
| **Patched Version Tag** | `v4.0.17` |
| **Fix Author** | Mariell Hoversholm (Proximyst), Kristian Bremberg |

## Build System & Dependencies

| Field | Value |
|-------|-------|
| **Primary Language** | TypeScript (Node.js) |
| **Build System** | npm / yarn |
| **Build Command** | `yarn install && yarn run build` (compiles TS to `build/`) |
| **Runtime** | Node.js >= 22 |
| **Container Base** | `node:22-alpine` (build), `gcr.io/distroless/nodejs22-debian12` (runtime) |
| **Entry Point** | `build/app.js server --config=config.json` |
| **Default Port** | 8081 |

### Key Dependencies

| Dependency | Purpose |
|-----------|---------|
| `express` ^4.21.1 | HTTP server framework |
| `puppeteer` ^22.8.2 | Headless Chrome automation |
| `@hapi/boom` ^10.0.0 | HTTP error handling |
| `chokidar` ^3.5.2 | File watcher (used in CSV download) |
| `typescript` ^5.8.3 | TypeScript compiler |
| Chromium 141.0.7390.54 | Browser binary (bundled in Docker image) |

### Dockerfile Build Strategy

The project Dockerfile:
1. Uses `debian:12-slim` to extract Chromium and font packages
2. Uses `node:22-alpine` to build the TypeScript application
3. Copies build artifacts into a distroless Node.js runtime image
4. Installs Chromium via Debian package extraction (not npm/puppeteer download)

**For lab reproduction**: A simplified build approach using `node:22` base with `apt-get install chromium` is recommended instead of the complex multi-stage build.

## Lab Setup Notes

### Minimal Lab Architecture

The lab needs two containers:
1. **Grafana** (grafana/grafana-enterprise) — provides the dashboards/panels the renderer targets
2. **Image Renderer** (built from source at v4.0.16) — the vulnerable target

### Environment Variables

```
# Grafana container
GF_RENDERING_SERVER_URL=http://renderer:8081/render
GF_RENDERING_CALLBACK_URL=http://grafana:3000/

# Renderer container (defaults work for exploitation)
# Default auth token is "-" from default.json
# CHROME_BIN=/usr/bin/chromium
# NODE_ENV=production
```

### Auth Token Configuration

The default config (`default.json`) sets `"authToken": "-"`. This means:
- The `X-Auth-Token: -` header will authenticate any request
- This is the exact scenario described in the CVE advisory as a prerequisite for exploitation

## Public Exploits

**None found** — No public exploit code exists on ExploitDB, Metasploit, GitHub, or other tracked sources. No Nuclei templates are available.

This means the PoC must be written from scratch based on the vulnerability analysis above.

## References

| Source | URL |
|--------|-----|
| Grafana Security Advisory | https://grafana.com/security/security-advisories/cve-2025-11539/ |
| GitHub Release v4.0.17 | https://github.com/grafana/grafana-image-renderer/releases/tag/v4.0.17 |
| Fix PR #801 | https://github.com/grafana/grafana-image-renderer/pull/801 |
| Fix Commit | https://github.com/grafana/grafana-image-renderer/commit/1858c2c51347b23f43b1d288bc9222f16030e3f9 |
| Source Repository | https://github.com/grafana/grafana-image-renderer |

## PoC Strategy Recommendation

The PoC should demonstrate the arbitrary file write primitive:

1. **Setup**: Deploy Grafana + vulnerable image renderer (v4.0.16) in Docker
2. **Trigger**: Send a crafted HTTP request to `/render/csv` with:
   - `X-Auth-Token: -` header
   - `url` parameter pointing to a Grafana CSV export URL (or any URL that returns content)
   - `filePath` parameter containing path traversal (e.g., `../../tmp/pwned.txt`)
3. **Verify**: Confirm the file was written to the traversal target path
4. **RCE escalation** (optional): Demonstrate writing a malicious `.so` to a Chromium library path

The simplest PoC verifies the file write by checking that a file appears at an unexpected path in the container. Full RCE via shared object injection is more complex and depends on the specific Chromium library loading paths.
