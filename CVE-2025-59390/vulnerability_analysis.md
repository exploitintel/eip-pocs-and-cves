# Vulnerability Analysis: CVE-2025-59390

## Root Cause

The Apache Druid Kerberos authenticator (`druid-kerberos` extension) uses a **cryptographically weak pseudo-random number generator (PRNG)** to generate authentication cookie signing secrets when the operator omits the `druid.auth.authenticator.kerberos.cookieSignatureSecret` configuration property.

When this property is not set (it was optional with a default of "Random value"):
1. The `KerberosAuthenticator` constructor accepts `null` for `cookieSignatureSecret` without validation (line 109).
2. The `getInitParameters()` method (line 384) conditionally passes the secret to the servlet filter — when `null`, the `signature.secret` parameter is simply omitted.
3. During filter initialization (lines 141-144), the anonymous `AuthenticationFilter.init()` override detects the missing secret and generates a fallback:
   ```java
   signatureSecret = Long.toString(ThreadLocalRandom.current().nextLong());
   ```

`java.util.concurrent.ThreadLocalRandom` is a **linear congruential generator (LCG)** — it is not cryptographically secure. The generated secret is the decimal string representation of a Java `long` value (e.g., `"-7234891234567890123"`). This secret is then used as the HMAC-SHA256 key for signing all Hadoop authentication cookies (`hadoop.auth`).

The fundamental weakness is twofold:
- **Predictable output**: ThreadLocalRandom's LCG algorithm makes outputs predictable if any state can be inferred (thread ID + nanotime at initialization).
- **Constrained keyspace**: The secret is `Long.toString(nextLong())` — a decimal string of at most 20 characters representing a signed 64-bit integer. While 2^64 is large, the string representation limits entropy further, and LCG properties reduce the effective keyspace below 2^64.

Additionally, each Druid node generates its own independent secret at JVM startup, meaning:
- Different nodes in a cluster have different secrets (cookies valid on one node are rejected by others).
- Restarting a node changes the secret (all existing cookies become invalid).
- The secret lifetime starts fresh at each restart, making timing-based seed inference feasible.

## Vulnerable File(s) and Function(s)

### Primary Vulnerable File
**File:** `extensions-core/druid-kerberos/src/main/java/org/apache/druid/security/kerberos/KerberosAuthenticator.java`

### Vulnerable Location 1: Constructor (line 109)
```java
// Line 97-119
@JsonCreator
public KerberosAuthenticator(
    @JsonProperty("serverPrincipal") String serverPrincipal,
    @JsonProperty("serverKeytab") String serverKeytab,
    @JsonProperty("authToLocal") String authToLocal,
    @JsonProperty("cookieSignatureSecret") String cookieSignatureSecret,  // CAN BE NULL
    @JsonProperty("authorizerName") String authorizerName,
    @JsonProperty("name") String name,
    @JacksonInject @Self DruidNode node
)
{
    this.serverKeytab = serverKeytab;
    this.authToLocal = authToLocal == null ? "DEFAULT" : authToLocal;
    this.cookieSignatureSecret = cookieSignatureSecret;  // NO VALIDATION - null accepted
    ...
}
```

### Vulnerable Location 2: getInitParameters() (lines 377-388)
```java
public Map<String, String> getInitParameters()
{
    Map<String, String> params = new HashMap<>();
    params.put("kerberos.principal", serverPrincipal);
    params.put("kerberos.keytab", serverKeytab);
    params.put(AuthenticationFilter.AUTH_TYPE, DruidKerberosAuthenticationHandler.class.getName());
    params.put("kerberos.name.rules", authToLocal);
    if (cookieSignatureSecret != null) {    // CONDITIONAL - omitted when null
        params.put("signature.secret", cookieSignatureSecret);
    }
    return params;
}
```

### Vulnerable Location 3: Filter init() (lines 141-144)
```java
String signatureSecret = config.getProperty(configPrefix + SIGNATURE_SECRET);
if (signatureSecret == null) {
    signatureSecret = Long.toString(ThreadLocalRandom.current().nextLong());  // WEAK PRNG
    log.warn("'signature.secret' configuration not set, using a random value as secret");
}
```

## Triggering Input

The vulnerability is triggered by the **absence of configuration** — specifically, when the Druid operator does not set `druid.auth.authenticator.kerberos.cookieSignatureSecret` in the Druid configuration.

Once the vulnerable state exists (weak secret in use), the exploit involves:

### Step 1: Obtain a signed cookie
The attacker needs a valid `hadoop.auth` cookie from the target Druid instance. This can be obtained by:
- Authenticating once via Kerberos (SPNEGO) to the target
- Intercepting any user's cookie on the network (if HTTP, not HTTPS)
- Reading a cookie from any user's browser or cookie jar

### Step 2: Extract token and signature
The `hadoop.auth` cookie has the format:
```
u=<username>&p=<principal>&t=<auth_type>&e=<expiration_timestamp>&s=<base64_hmac_sha256>
```

Example:
```
u=admin&p=admin@EXAMPLE.COM&t=kerberos&e=1735689600000&s=abc123base64signature==
```

The attacker splits on the last `&s=` to get:
- `token_string` = `u=admin&p=admin@EXAMPLE.COM&t=kerberos&e=1735689600000`
- `signature` = `abc123base64signature==`

### Step 3: Brute-force the secret
The secret is `Long.toString(ThreadLocalRandom.current().nextLong())` — a decimal string like `"-7234891234567890123"`.

The attacker iterates over candidate long values, for each:
1. Convert to string: `candidate_secret = str(candidate_long)`
2. Encode to UTF-8 bytes: `secret_bytes = candidate_secret.encode('utf-8')`
3. Compute HMAC-SHA256: `hmac = HMAC_SHA256(secret_bytes, token_string.encode('utf-8'))`
4. Base64 encode: `computed_sig = base64_encode(hmac)`
5. Compare to observed signature

### Step 4: Forge arbitrary cookies
With the known secret, the attacker crafts a new token for any user and any expiration:
```
u=druid_admin&p=druid_admin@EXAMPLE.COM&t=kerberos&e=9999999999999
```
Then signs it with HMAC-SHA256 using the recovered secret and appends `&s=<forged_signature>`.

## Attack Scenario

1. **Prerequisite**: Target runs Apache Druid ≤34.0.0 with `druid-kerberos` extension loaded AND `cookieSignatureSecret` not explicitly configured.

2. **Reconnaissance**: Attacker accesses any Druid endpoint and observes the `WWW-Authenticate: Negotiate` response header, confirming Kerberos auth is enabled.

3. **Cookie acquisition**: Attacker authenticates once via SPNEGO (using their own low-privilege Kerberos credentials) or intercepts a cookie from another user. The response contains a `Set-Cookie: hadoop.auth="<signed_token>"` header.

4. **Secret recovery**: Attacker runs an offline brute-force attack against the HMAC-SHA256 secret. Since the secret is derived from `ThreadLocalRandom.current().nextLong()`, the attacker can:
   - **Approach A**: Enumerate all possible long values (2^64 space — feasible with knowledge of ThreadLocalRandom seeding behavior, reducible to ~2^48 or less by correlating startup time and thread ID).
   - **Approach B**: If the attacker can infer the approximate JVM startup time and thread scheduling (e.g., from HTTP response headers like `Date` or Druid version/uptime endpoints), they can narrow the ThreadLocalRandom seed space to a practical brute-force window.

5. **Cookie forgery**: Once the secret is recovered, the attacker forges a `hadoop.auth` cookie for any user (e.g., `druid_system`, `admin`, or any principal) with an arbitrary expiration timestamp.

6. **Authentication bypass**: The attacker sends requests to Druid endpoints with the forged cookie. The Kerberos filter validates the cookie signature against the weak secret, the signature matches, and the attacker is authenticated as the forged user without ever performing Kerberos authentication.

## Impact

**Severity: CRITICAL (CVSS 9.8)**

- **Authentication Bypass**: Complete bypass of Kerberos authentication. The attacker can impersonate any user.
- **Confidentiality**: Full read access to all Druid data, queries, metadata, and configuration.
- **Integrity**: Ability to execute arbitrary Druid SQL queries, ingest/modify data, change configurations.
- **Availability**: Ability to shut down services, cancel tasks, or execute resource-exhausting queries.

The attack is:
- **Remote**: Exploitable over the network
- **Unauthenticated**: While initial cookie acquisition requires some Kerberos access, the secret recovery and forgery is offline — and the forged cookie bypasses auth entirely
- **Low complexity**: Standard HMAC-SHA256 brute-force with a constrained keyspace

## Authentication Requirements

### Pre-auth vs Authenticated
The vulnerability itself exists in the **configuration/initialization** of the authenticator — no authentication is required for the vulnerable state to exist.

However, to **exploit** the vulnerability, the attacker needs:
1. One valid signed cookie (obtained via SPNEGO authentication with their own Kerberos credentials, or via network interception)
2. Network access to the Druid HTTP endpoints (default ports: 8081 coordinator, 8082 broker, 8083 historical, 8888 router)

### Authentication Flow for PoC
For the PoC to demonstrate the vulnerability end-to-end:

1. **Kerberos setup**: The lab needs a KDC (MIT Kerberos or similar) with:
   - A service principal: `HTTP/<druid-hostname>@REALM` with keytab
   - A user principal: `testuser@REALM` with password
2. **Initial SPNEGO auth**: Use `curl --negotiate -u:` to authenticate and get the `hadoop.auth` cookie
3. **Offline brute-force**: Extract the cookie, brute-force the HMAC secret
4. **Cookie forgery**: Forge a cookie for a different (higher-privilege) user
5. **Verify access**: Use the forged cookie to access Druid endpoints as the forged user

### Simplified PoC (No Full Kerberos)
A simpler PoC can directly demonstrate the weakness at the code level:
1. Start Druid 34.0.0 with Kerberos authenticator configured (no explicit cookieSignatureSecret)
2. Show from logs that a weak random secret was generated
3. Use Java/Python to directly compute the HMAC with a known token and show that the secret is recoverable from a single token+signature pair by brute-forcing ThreadLocalRandom outputs

## Fix Assessment

### Fix Is Complete

The fix (commit `142d319f0a20ce2be59707db0abf3c52dfa35d0f`) correctly addresses the root cause:

1. **Removes ThreadLocalRandom import** — eliminates the weak PRNG entirely
2. **Constructor validation** (lines 107-112 in fixed version): Throws `DruidException` if `cookieSignatureSecret` is `null` or empty — prevents Druid from starting with a missing secret
3. **Filter init validation** (lines 147-151 in fixed version): Throws `DruidException` if the secret is missing in the filter config — defense-in-depth
4. **Unconditional secret passing** (line 390 in fixed version): Always sets `signature.secret` in filter params, removing the conditional `if (cookieSignatureSecret != null)` check

The fix addresses the vulnerability at two levels (constructor and filter init), providing defense in depth. The approach of making the property mandatory forces operators to explicitly set a secret, which is the correct design pattern for cryptographic secrets.

### Minor Observation
The fix does **not** enforce any minimum length or entropy requirement on the operator-provided secret. An operator could set `cookieSignatureSecret=a` which would be trivially guessable. However, this is a different vulnerability class (operator misconfiguration vs. insecure default) and is outside the scope of CVE-2025-59390.

The fix does **not** enforce the use of `SecureRandom` for any auto-generation scenario, because it eliminated auto-generation entirely. This is the correct approach — forcing explicit configuration is more secure than trying to auto-generate securely, especially in distributed environments where all nodes need the same secret.

## Potential Bypass Vectors

None identified. The fix is comprehensive:
- No alternative code path can reach the filter init without the secret being set
- The constructor validation fires before any filter initialization occurs
- The `DruidException` is a hard failure that prevents Druid startup
- There is no way to pass a null secret through Jackson deserialization that would bypass the null check (empty string is also caught)

## Escalation Path

**Authentication bypass → Full cluster compromise**

If the attacker successfully forges a cookie for a privileged user (e.g., a superuser principal), they gain:

1. **SQL execution**: Via the Druid SQL API (`/druid/v2/sql`), the attacker can read all data stored in Druid.
2. **Task submission**: Via the Overlord API (`/druid/indexer/v1/task`), the attacker can submit ingestion tasks that execute arbitrary operations.
3. **Configuration access**: Via coordinator/router APIs, the attacker can read and potentially modify cluster configuration.
4. **Potential RCE**: If Druid is configured with certain extensions (e.g., `druid-lookups-cached-global` with arbitrary URIs, or custom ingestion specs that invoke external processes), the attacker could potentially achieve remote code execution by submitting malicious task specs. The Druid task submission API allows specifying `ioConfig` with arbitrary input sources — some of which (like `local` or `http`) could be abused.

The primary escalation chain: **Weak cookie secret → Cookie forgery → Auth bypass → SQL injection / Task submission → Data exfiltration / Potential RCE**

## Related Attack Surface

None identified. The vulnerability is isolated to the `KerberosAuthenticator` class in the `druid-kerberos` extension:

- **Other authenticators checked**: `BasicHTTPAuthenticator` (druid-basic-security), `JwtAuthenticator` and `Pac4jAuthenticator` (druid-pac4j) — none use ThreadLocalRandom for security purposes.
- **ThreadLocalRandom in other extensions**: Found only in `druid-basic-security` for non-security sleep jitter delays (retry timing). Not a vulnerability.
- **No other cookie signing code**: The `hadoop.auth` cookie signing is specific to the Kerberos authenticator. Other authenticators use different session management mechanisms.

## Build System

| Field | Value |
|---|---|
| **Build System** | Apache Maven 3.9+ |
| **Java Version** | 11 (compile target), 17 (Docker runtime) |
| **Primary Language** | Java |

### Build Commands

**Full project build (from source root):**
```bash
mvn -B -ff -q install -Pdist,bundle-contrib-exts -Pskip-static-checks,skip-tests -Dmaven.javadoc.skip=true -T1C
```

**Kerberos extension only:**
```bash
mvn -B -pl extensions-core/druid-kerberos -am package -DskipTests
```

**Run tests for the kerberos module:**
```bash
mvn -B -pl extensions-core/druid-kerberos test
```

### Dependencies

**System/Build dependencies:**
- JDK 11+ (compile), JDK 17 recommended (runtime)
- Apache Maven 3.9+
- Python 3 (for build scripts)

**Key Java dependencies (managed via Maven):**
- `org.apache.hadoop:hadoop-common:3.3.6` — Hadoop core
- `org.apache.hadoop:hadoop-auth:3.3.6` — Provides `AuthenticationFilter`, `Signer`, `SignerSecretProvider`
- `org.apache.druid:druid-processing:34.0.0` — Druid core
- `org.apache.druid:druid-server:34.0.0` — Druid server framework
- Jetty (embedded via Druid) — HTTP server
- Jackson (JSON serialization)

### Runtime Requirements

**For lab testing using the official Docker image (recommended):**
- Docker image: `apache/druid:34.0.0` (vulnerable version)
- PostgreSQL (metadata store) — `postgres:latest`
- ZooKeeper (coordination) — `zookeeper:3.5.10`
- MIT Kerberos KDC container (for full SPNEGO testing)

**Druid configuration for vulnerability trigger:**
```properties
# Add druid-kerberos to extension load list
druid_extensions_loadList=["druid-histogram", "druid-datasketches", "druid-lookups-cached-global", "postgresql-metadata-storage", "druid-multi-stage-query", "druid-kerberos"]

# Configure Kerberos authenticator
druid_auth_authenticatorChain=["kerberos"]
druid_auth_authenticator_kerberos_type=kerberos
druid_auth_authenticator_kerberos_serverPrincipal=HTTP/_HOST@EXAMPLE.COM
druid_auth_authenticator_kerberos_serverKeytab=/etc/security/keytabs/druid.keytab
druid_auth_authenticator_kerberos_authorizerName=allowAll

# NOTE: cookieSignatureSecret is deliberately NOT SET to trigger vulnerability
# druid_auth_authenticator_kerberos_cookieSignatureSecret=...

druid_auth_authorizers=["allowAll"]
druid_auth_authorizer_allowAll_type=allowAll
```

**Network setup:**
- Druid services expose HTTP on default ports (8081, 8082, 8083, 8091, 8888)
- KDC should be accessible from all Druid containers (port 88 TCP/UDP)
- All containers should share a common `/etc/krb5.conf`

**Existing Docker Compose reference:**
- `distribution/docker/docker-compose.yml` — base Druid cluster composition
- `distribution/docker/environment` — base environment variables
- These need to be extended with KDC container and Kerberos configuration

### Alternative: Code-Level PoC (No Full Druid Deployment)

For a simpler PoC that demonstrates the cryptographic weakness without a full Druid cluster:

1. Use the Hadoop `Signer` class directly with a known ThreadLocalRandom-derived secret
2. Sign a token, then show that the secret can be brute-forced
3. Forge a new token with the recovered secret
4. This requires only `hadoop-auth-3.3.6.jar` and its dependencies

This approach avoids the complexity of setting up a full Kerberos environment while still definitively proving the vulnerability.
