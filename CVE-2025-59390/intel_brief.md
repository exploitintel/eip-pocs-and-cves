# Intel Brief: CVE-2025-59390

## CVE Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-59390 |
| **Affected Software** | Apache Druid |
| **Vendor** | Apache Software Foundation |
| **Affected Versions** | All versions through 34.0.0 |
| **Patched Version** | 35.0.0 |
| **CVSS Score** | 9.8 (Critical) |
| **CVSS Vector** | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| **EPSS** | 0.1% (22.5th percentile) |
| **CWE** | CWE-338 (Use of Cryptographically Weak Pseudo-Random Number Generator) |
| **Published** | 2025-11-26 |

## Description

Apache Druid's Kerberos authenticator uses a **weak fallback secret** when the `druid.auth.authenticator.kerberos.cookieSignatureSecret` configuration property is not explicitly set. When this property is absent, the cookie signing secret is generated at runtime using `ThreadLocalRandom.current().nextLong()`, which is **not a cryptographically secure random number generator**.

This allows an attacker to:
1. **Predict or brute-force** the secret used to sign authentication cookies
2. **Forge authentication tokens** by computing valid HMAC-SHA256 signatures
3. **Bypass Kerberos authentication** entirely

Additionally, each Druid process generates its own independent fallback secret, causing **inconsistent secrets across cluster nodes** in distributed deployments.

## Vulnerability Mechanism (Technical Detail)

### Vulnerable Code Path

**File:** `extensions-core/druid-kerberos/src/main/java/org/apache/druid/security/kerberos/KerberosAuthenticator.java`

**Two vulnerable locations:**

1. **Constructor (`getInitParameters` method, line ~384):** When `cookieSignatureSecret` is null (not configured), the `signature.secret` parameter is simply omitted from the filter initialization params:
   ```java
   if (cookieSignatureSecret != null) {
       params.put("signature.secret", cookieSignatureSecret);
   }
   ```

2. **Filter init (line ~141-144):** When `signature.secret` is null in the config, a weak fallback is used:
   ```java
   String signatureSecret = config.getProperty(configPrefix + SIGNATURE_SECRET);
   if (signatureSecret == null) {
       signatureSecret = Long.toString(ThreadLocalRandom.current().nextLong());
       log.warn("'signature.secret' configuration not set, using a random value as secret");
   }
   ```

### Signing Mechanism

The secret is used as the key for **HMAC-SHA256** signing of Hadoop authentication cookies:
- Cookie format: `hadoop.auth=<token_string>&s=<base64_hmac_sha256_signature>`
- The `Signer` class (from `hadoop-auth`) computes: `HMAC-SHA256(secret_bytes, token_string)`
- Token string format: `<username> <auth_type> <expiration_timestamp>`

### Why ThreadLocalRandom is Weak

- `ThreadLocalRandom` uses a **linear congruential generator** (LCG) internally
- The secret space is a Java `long` (2^64 values), BUT:
  - The seed is derived from `Thread.currentThread().getId()` mixed with system nanotime
  - LCG outputs are predictable if any output is observed
  - Even without observing an output, the string representation `Long.toString(nextLong())` limits the keyspace to decimal string representations of 64-bit signed longs
- Brute-force approach: Iterate over possible `ThreadLocalRandom` seeds or directly over long values, computing HMAC-SHA256 for each candidate and comparing against an observed cookie signature

### Preconditions for Exploitation

1. Apache Druid must have the **Kerberos authenticator extension enabled** (`druid-kerberos`)
2. The `druid.auth.authenticator.kerberos.cookieSignatureSecret` configuration **must NOT be explicitly set** (default/omitted configuration)
3. The attacker needs to **obtain a valid signed authentication cookie** (e.g., by authenticating via Kerberos once, or by intercepting one via network)
4. The attacker then brute-forces the signing secret and forges cookies for arbitrary users

## Repository Information

| Field | Value |
|---|---|
| **Repository URL** | https://github.com/apache/druid.git |
| **Vulnerable Version Tag** | `druid-34.0.0` (checked out) |
| **Fix Commit** | `142d319f0a20ce2be59707db0abf3c52dfa35d0f` |
| **Fix PR** | https://github.com/apache/druid/pull/18368 |
| **Patched Version Tag** | `druid-35.0.0` |
| **Fix Author** | Karan Kumar |
| **Fix Date** | 2025-08-06 |

## Fix Description

The fix (PR #18368 "Making optional configs mandatory") makes three changes:

1. **Removes ThreadLocalRandom import** — eliminates the weak PRNG fallback entirely
2. **Mandatory secret validation in constructor** — throws `DruidException` if `cookieSignatureSecret` is null or empty:
   ```java
   if (cookieSignatureSecret == null || cookieSignatureSecret.isEmpty()) {
       throw DruidException.forPersona(DruidException.Persona.OPERATOR)
           .ofCategory(DruidException.Category.INVALID_INPUT)
           .build("[%s] is not set for Kerberos authenticator", COOKIE_SIGNATURE_SECRET_KEY);
   }
   ```
3. **Mandatory secret validation in filter init** — throws `DruidException` instead of generating a weak fallback:
   ```java
   if (signatureSecret == null) {
       throw DruidException.defensive(
           "Config property[%s] is not set for Kerberos authenticator",
           SIGNATURE_SECRET
       );
   }
   ```
4. **Unconditional secret passing** — always sets `signature.secret` in filter params (no conditional check)

## Affected Files

| File | Role |
|---|---|
| `extensions-core/druid-kerberos/src/main/java/org/apache/druid/security/kerberos/KerberosAuthenticator.java` | Vulnerable authenticator class |
| `extensions-core/druid-kerberos/src/test/java/org/apache/druid/security/kerberos/KerberosAuthenticatorTest.java` | New tests added by fix |
| `docs/development/extensions-core/druid-kerberos.md` | Documentation updated |

## Build System

| Field | Value |
|---|---|
| **Build System** | Apache Maven (`pom.xml`) |
| **Primary Language** | Java |
| **Java Version** | 11+ (compile target) |
| **Maven Artifact** | `org.apache.druid.extensions:druid-kerberos` |
| **Parent Artifact** | `org.apache.druid:druid:34.0.0` |

### Key Dependencies

| Dependency | Version | Purpose |
|---|---|---|
| `hadoop-common` | 3.3.6 | Hadoop core libraries |
| `hadoop-auth` | 3.3.6 | Provides `AuthenticationFilter`, `Signer`, `SignerSecretProvider` |
| `druid-processing` | 34.0.0 | Druid core processing |
| `druid-server` | 34.0.0 | Druid server framework |
| Jetty (embedded) | via Druid | HTTP server |

### Docker / Lab Setup Notes

- Official Docker image: `apache/druid:34.0.0` (vulnerable version)
- Existing `docker-compose.yml` at `distribution/docker/docker-compose.yml` uses image `apache/druid:34.0.0`
- Requires: PostgreSQL (metadata store), ZooKeeper (coordination)
- Config env file at `distribution/docker/environment`
- To trigger vulnerability, must add `druid-kerberos` to `druid_extensions_loadList` and configure Kerberos auth WITHOUT setting `cookieSignatureSecret`
- Default extension list does NOT include `druid-kerberos` — it must be explicitly enabled

## Public Exploits

### Exploit #1: Daeda1usUK/CVE-2025-59390- (GitHub)
| Field | Value |
|---|---|
| **Platform ID** | 65342 |
| **Source** | nomisec (GitHub) |
| **Classification** | WRITEUP |
| **Reliability** | Theoretical |
| **Complexity** | Moderate |
| **Attack Type** | auth_bypass |
| **Stars** | 1 |
| **URL** | https://github.com/Daeda1usUK/CVE-2025-59390- |

**Assessment:** This is a **writeup only** — contains a README describing the vulnerability but no working exploit code. It states it can "crack the Kerberos signature in Apache Druid and also, any integer created by ThreadLocalRandom" but the repository contains only documentation. Classified as theoretical. **No trojan indicators.**

### PoC Strategy (For Lab Build Agent)

Since no working public PoC exists, one must be written. The approach:

1. **Lab Setup:** Deploy Druid 34.0.0 with Kerberos authenticator enabled but WITHOUT `cookieSignatureSecret` configured. This requires a KDC (MIT Kerberos or similar) in the lab environment.

2. **Obtain a signed cookie:** Authenticate legitimately to get a `hadoop.auth` cookie containing the HMAC-SHA256 signature.

3. **Brute-force the secret:** 
   - Extract the token string and signature from the cookie
   - The secret is `Long.toString(ThreadLocalRandom.current().nextLong())` — a decimal string representation of a Java long
   - Iterate over candidate long values, compute HMAC-SHA256 of the token string, compare to the observed signature
   - ThreadLocalRandom's LCG can be reverse-engineered from a single output to narrow the search space

4. **Forge a cookie:** Once the secret is known, compute a valid HMAC-SHA256 signature for an arbitrary token (e.g., different user, extended expiration).

**Alternative simpler PoC approach:** Since the vulnerability is in the weak PRNG, a simpler demonstration could:
- Start a Druid instance with Kerberos auth (no explicit secret)
- Show that the generated secret is a plain `Long.toString()` value
- Demonstrate that ThreadLocalRandom output is predictable by recovering the seed
- Forge a valid cookie signature using the recovered secret

## References

| Type | URL |
|---|---|
| Vendor Advisory | https://lists.apache.org/thread/jwjltllnntgj1sb9wzsjmvwm9f8rlhg8 |
| Mailing List (oss-security) | http://www.openwall.com/lists/oss-security/2025/11/26/1 |
| GitHub Advisory | https://github.com/advisories/GHSA-w88f-4875-99c8 |
| Fix PR | https://github.com/apache/druid/pull/18368 |
| Fix Commit | https://github.com/apache/druid/commit/142d319f0a20ce2be59707db0abf3c52dfa35d0f |
| Source Repository | https://github.com/apache/druid |
| Docker Image (Vulnerable) | docker.io/apache/druid:34.0.0 |
| GHSA ID | GHSA-w88f-4875-99c8 |
| MITRE ATT&CK | T1552 - Unsecured Credentials |

## Key Takeaways for Downstream Agents

1. **Lab Build Agent:** Use the official `apache/druid:34.0.0` Docker image. The existing `docker-compose.yml` in the repo is a great starting point. You'll need to add a Kerberos KDC container and configure the Kerberos authenticator extension WITHOUT setting `cookieSignatureSecret`. Alternatively, the vulnerability can be demonstrated at the unit level by instantiating `KerberosAuthenticator` and showing the weak secret generation.

2. **PoC Agent:** The cookie signing uses HMAC-SHA256 with the secret. The secret is `Long.toString(ThreadLocalRandom.current().nextLong())`. A Java or Python brute-forcer that iterates candidate longs and computes HMAC-SHA256 is the core of the PoC. Consider also a code-level demonstration showing ThreadLocalRandom predictability.

3. **Verification Agent:** Compare behavior on Druid 34.0.0 (accepts startup without secret, generates weak one) vs Druid 35.0.0 (refuses to start without explicit secret).
