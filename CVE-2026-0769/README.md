# CVE-2026-0769 - Langflow Eval Injection Remote Code Execution

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2026-0769 |
| Component | [Langflow](https://github.com/langflow-ai/langflow) |
| Type | CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code (Eval Injection) |
| CVSS | 9.8 (Critical) — `CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| EPSS | 1.1% (77.5th percentile) |
| Affected | Langflow 1.0.0 through 1.8.0 (latest) |
| Fix | **None — 0-day, no fix exists** |
| Author | Exploit Intelligence Platform |
| Date | 2026-01-23 |

## Vulnerability Details

Langflow versions 1.0.0 through 1.8.0 (latest) contain a critical Remote Code Execution (RCE) vulnerability in the `eval_custom_component_code()` function. User-supplied Python code is passed directly to `exec()` without any sandboxing, input validation, or execution restrictions, allowing remote attackers to execute arbitrary commands on the server. Combined with the default `AUTO_LOGIN=True` configuration, this vulnerability is exploitable by **unauthenticated remote attackers** against any default Langflow deployment.

**This is a 0-day vulnerability — no patch exists.** The ZDI advisory (ZDI-26-035) recommends restricting interaction with the product as the only mitigation.

The root cause is the unrestricted use of Python's `exec()` builtin to execute user-supplied Python code received via HTTP API endpoints. The Langflow application accepts arbitrary Python source code strings through its custom component API (`POST /api/v1/custom_component`) and passes them directly to `exec()` without any sandboxing, code validation, allowlisting, or restriction on operations.

The vulnerability chain spans multiple files:
1. **API entry points** (`endpoints.py`) receive user-supplied Python code as a string via the `code` field in POST requests.
2. **`eval_custom_component_code()`** (`custom/eval.py`) orchestrates the execution by calling `extract_class_name()` and `create_class()`.
3. **`create_class()`** (`utils/validate.py`) prepends default imports, parses with `ast.parse()` (syntax-only validation), and calls two separate `exec()` functions:
   - `prepare_global_scope()` at line 293 — executes module-level definitions (imports, assignments, classes, functions)
   - `build_class_constructor()` at line 338 — executes the class definition itself

The only constraint is that the submitted code must contain a class inheriting from a base with "Component" or "LC" in its name — a trivial requirement that attackers satisfy by wrapping their payload in a minimal class skeleton.

Combined with `AUTO_LOGIN=True` (enabled by default), the `GET /api/v1/auto_login` endpoint returns a valid 365-day superuser JWT with **zero credentials**, making the entire attack chain unauthenticated.

In versions 1.5+, the vulnerable code was refactored from `langflow.utils.validate` to `lfx.custom.validate`, but the vulnerability persists identically.

### Attack Chain

```
1. GET /api/v1/auto_login → Obtain 365-day superuser JWT (no credentials needed)
2. POST /api/v1/custom_component with malicious Python code wrapped in Component subclass
3. eval_custom_component_code() → create_class() → prepare_global_scope() → exec() at line 293
4. Module-level assignment statements execute arbitrary OS commands on the server
```

### Attack Flow Diagram

```
┌─────────────┐      GET /api/v1/auto_login       ┌──────────────────┐
│   Attacker   │ ──────────────────────────────────▶│    Langflow      │
│  (No creds)  │◀────── 365-day superuser JWT ──────│    (port 7860)   │
│              │                                    │                  │
│              │  POST /api/v1/custom_component     │  eval_custom_    │
│              │  Authorization: Bearer <JWT>       │  component_code()│
│              │  {"code": "<malicious_python>"}    │        │         │
│              │ ──────────────────────────────────▶│        ▼         │
│              │                                    │  create_class()  │
│              │                                    │        │         │
│              │                                    │   ┌────┴────┐    │
│              │                                    │   ▼         ▼    │
│              │         HTTP 200                   │ exec()   exec()  │
│              │◀───────────────────────────────────│ (ln 293) (ln 338)│
│              │                                    │   ▼              │
│              │    Arbitrary code executed          │ FULL RCE        │
└─────────────┘    on the server                    └──────────────────┘
```

### Vulnerable API Endpoints

| Endpoint | Method | Auth Required | Vulnerability |
|---|---|---|---|
| `/api/v1/auto_login` | GET | **None** | Returns superuser JWT (auth bypass) |
| `/api/v1/custom_component` | POST | Bearer JWT | Code exec via `eval_custom_component_code()` |
| `/api/v1/custom_component/update` | POST | Bearer JWT | Same code exec chain, different entry point |
| `/api/v1/validate/code` | POST | Bearer JWT | Independent `validate_code()` exec path |

### Payload Requirements

For `/api/v1/custom_component` and `/api/v1/custom_component/update`:
- Code **must** contain a class inheriting from a base with "Component" or "LC" in its name
- Module-level RCE code **must** be assignment statements (`_x = os.system(...)`) — bare expressions are silently ignored by `prepare_global_scope()`
- Class-body assignments also work via the separate `build_class_constructor()` path

For `/api/v1/validate/code`:
- Code must contain a `def` statement (FunctionDef AST node)
- Function body does NOT execute — use **default argument expressions** for RCE
- Use `__import__()` since imports are not available in the exec scope

### Fix

**No fix exists.** This is an unpatched 0-day vulnerability.

The vulnerability is architectural — `exec()` of user-supplied code is the intentional design of Langflow's custom component system. A proper fix would require one of:

1. **Sandboxed execution**: Running user code in an isolated environment (e.g., subprocess, container, seccomp, or a Python sandbox like RestrictedPython)
2. **AST allowlisting**: Implementing a strict allowlist of permitted AST node types and blocking dangerous operations (though Python sandbox escapes are well-documented)
3. **Removing dynamic execution**: Eliminating the ability to execute arbitrary code entirely

**Recommended mitigations** (per ZDI-26-035):
- Restrict network access to Langflow deployments
- Disable `AUTO_LOGIN` and enforce strong authentication
- Run Langflow in an isolated network segment
- Do not expose Langflow to untrusted networks

## Lab Setup

### Architecture

```
┌─────────────────────────────────────────────────────┐
│                 Docker Environment                   │
│                                                      │
│  ┌────────────────────────────────────────────────┐  │
│  │       cve-2026-0769-vulnerable                 │  │
│  │       langflowai/langflow:1.3.2                │  │
│  │       Port: 7860                               │  │
│  │       AUTO_LOGIN=true (default)                │  │
│  │       SQLite embedded (no external DB)          │  │
│  └────────────────────────────────────────────────┘  │
│                        │                             │
│                   lab-net (bridge)                    │
└────────────────────────┼─────────────────────────────┘
                         │
                    localhost:7860
```

### Quick Start

```bash
cd CVE-2026-0769

# Start (pre-built image, no build needed)
docker compose up -d

# Wait ~30 seconds for Langflow to initialize, then run the exploit
python3 poc/poc.py 127.0.0.1 7860

# Cleanup
docker compose down
```

### Container Details

| Container | Role | Base | Host Port | Description |
|---|---|---|---|---|
| `cve-2026-0769-vulnerable` | Target | `langflowai/langflow:1.3.2` | `7860` | Langflow with AUTO_LOGIN=True (default) |

### Environment Variables

| Variable | Value | Purpose |
|---|---|---|
| `LANGFLOW_AUTO_LOGIN` | `true` | Enables unauthenticated auto_login endpoint |
| `LANGFLOW_HOST` | `0.0.0.0` | Listen on all interfaces |
| `LANGFLOW_PORT` | `7860` | HTTP API port |

### Default Credentials

| Service | Username | Password |
|---|---|---|
| Langflow | `langflow` | `langflow` |

Note: With `AUTO_LOGIN=True` (default), no credentials are needed — the `/api/v1/auto_login` endpoint returns a superuser JWT automatically.

### Verify the Lab

```bash
# Check container status (wait ~30 seconds for startup)
docker compose ps

# Verify API is responding
curl http://localhost:7860/health
# Expected: {"status": "ok"}

# Verify version
curl http://localhost:7860/api/v1/version
# Expected: {"version": "1.3.2", "main_version": "1.3.2", "package": "Langflow"}
```

## PoC Usage

Four PoC scripts are provided, each demonstrating a different attack vector. All scripts use Python 3 stdlib only — no external dependencies required.

### Primary PoC (`poc/poc.py`)

Demonstrates the full attack chain: unauthenticated token retrieval → module-level code execution via `prepare_global_scope()`.

```bash
python3 poc/poc.py <target_ip> <port> [container_name]

# Run against the lab
python3 poc/poc.py 127.0.0.1 7860
```

### Expected Output (Vulnerable)

```
============================================================
  CVE-2026-0769: Langflow Eval Injection RCE PoC
  Target: http://127.0.0.1:7860
  Vector: POST /api/v1/custom_component (module-level exec)
============================================================

[*] Step 1: Requesting auto_login token...
[+] Got superuser JWT: eyJhbGciOiJIUzI1...

[*] Step 2: Sending malicious payload to /api/v1/custom_component
[+] Server responded with HTTP 200

[*] Step 3: Verifying exploitation...
[+] ============================================
[+]  VULNERABILITY CONFIRMED: CVE-2026-0769
[+]  Remote Code Execution via eval injection
[+] ============================================
[+] id: uid=1000(user) gid=0(root) groups=0(root)
[+] hostname: <container_id>
[+] RESULT: VULNERABILITY CONFIRMED
```

### Vector 2: Class-Body Exec (`poc/poc_vector2_classbody.py`)

Places RCE code in the class body (as class-level assignments) instead of module level. Exercises a **different** `exec()` call — `build_class_constructor()` at `validate.py:338`.

```bash
python3 poc/poc_vector2_classbody.py <target_ip> <port> [container_name]
```

### Vector 3: Update Endpoint (`poc/poc_vector3_update_endpoint.py`)

Exploits the same code execution chain via an **alternative API endpoint**: `POST /api/v1/custom_component/update`.

```bash
python3 poc/poc_vector3_update_endpoint.py <target_ip> <port> [container_name]
```

### Vector 4: Validate Code Endpoint (`poc/poc_vector4_validate_code.py`)

Exploits a **completely independent vulnerability** in `POST /api/v1/validate/code` using Python's default argument evaluation behavior to achieve RCE during `exec()` of a FunctionDef.

```bash
python3 poc/poc_vector4_validate_code.py <target_ip> <port> [container_name]
```

## Verification

### Vulnerable Instance (Langflow 1.3.2)

All four attack vectors confirmed on the vulnerable instance:

| Vector | Endpoint | exec() Path | Result |
|---|---|---|---|
| Module-level exec | `POST /api/v1/custom_component` | `prepare_global_scope()` line 293 | RCE Confirmed |
| Class-body exec | `POST /api/v1/custom_component` | `build_class_constructor()` line 338 | RCE Confirmed |
| Update endpoint | `POST /api/v1/custom_component/update` | `prepare_global_scope()` line 293 | RCE Confirmed |
| Validate code | `POST /api/v1/validate/code` | `validate_code()` line 57 | RCE Confirmed |

**Evidence of exploitation:**
- Commands execute as `uid=1000(user) gid=0(root) groups=0(root)`
- Arbitrary files can be written to and read from the container filesystem
- System information (`hostname`, `uname -a`) retrieved via command execution
- `/etc/passwd` contents exfiltrated via file read

### Patched Instance

**No patched version exists.** This is a 0-day vulnerability with no fix available through the latest release (v1.8.0). The ZDI advisory was published after the vendor failed to respond to multiple follow-ups over a 6-month period.

## Files

| File | Description |
|---|---|
| `poc/poc.py` | Primary PoC — module-level exec via `/api/v1/custom_component` |
| `poc/poc_vector2_classbody.py` | Vector 2 — class-body exec via `build_class_constructor()` |
| `poc/poc_vector3_update_endpoint.py` | Vector 3 — alternative `/api/v1/custom_component/update` endpoint |
| `poc/poc_vector4_validate_code.py` | Vector 4 — independent `/api/v1/validate/code` exec path |
| `docker-compose.yml` | Lab environment with vulnerable Langflow 1.3.2 |
| `intel_brief.md` | CVE intelligence brief |
| `vulnerability_analysis.md` | Root cause analysis and related attack surface |
| `lab_build_report.md` | Lab construction documentation |
| `poc_verification_report.md` | Verification test results for all 4 vectors |

## References

- [NVD Entry](https://nvd.nist.gov/vuln/detail/CVE-2026-0769)
- [ZDI Advisory (ZDI-26-035)](https://www.zerodayinitiative.com/advisories/ZDI-26-035/)
- [GitHub Advisory (GHSA-5v3c-9g74-93w7)](https://github.com/advisories/GHSA-5v3c-9g74-93w7)
- [Langflow Source Repository](https://github.com/langflow-ai/langflow)
- [PyPI Package (1.3.2)](https://pypi.org/project/langflow/1.3.2/)
- [Docker Image](https://hub.docker.com/r/langflowai/langflow/tags?name=1.3.2)

## Timeline

| Date | Event |
|---|---|
| 2025-07-18 | ZDI reports vulnerability to Langflow vendor (ZDI-CAN-26972) |
| 2025-09-11 | ZDI follow-up — no vendor response |
| 2025-10-10 | ZDI follow-up — no vendor response |
| 2025-12-10 | ZDI follow-up — no vendor response |
| 2026-01-09 | ZDI publishes advisory ZDI-26-035 (0-day disclosure) |
| 2026-01-23 | CVE-2026-0769 published in NVD |
| As of v1.8.0 | **No fix available** |

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2026-0769 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
