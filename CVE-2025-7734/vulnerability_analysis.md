# Vulnerability Analysis: CVE-2025-7734

## Overview

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-7734 |
| **Type** | Stored Cross-Site Scripting (XSS) |
| **CWE** | CWE-79 — Improper Neutralization of Input During Web Page Generation |
| **CVSS** | 8.7 (HIGH) — CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N |
| **Affected Software** | GitLab CE/EE 14.2.0 – 18.0.5, 18.1.0 – 18.1.3, 18.2.0 – 18.2.1 |

---

## Root Cause

**Text-to-HTML confusion in `wrapNodes()`.** The function treats DOM `textContent` (decoded plain text) as trusted HTML by assigning it to `innerHTML`.

The `wrapNodes()` function in `app/assets/javascripts/code_navigation/utils/dom_utils.js` (line 28-34) takes a `text` parameter derived from `elm.textContent` of a `<span>` element in the code viewer. It passes this text through `wrapSpacesWithSpans()` — which performs string replacements for spaces and tabs to produce HTML spans — and then assigns the result to `wrapper.innerHTML`. When the source text contains HTML-like strings (which is perfectly normal for code displayed in a code viewer), those strings get parsed as actual DOM elements, executing any embedded JavaScript event handlers.

The critical insight is that `textContent` returns the **decoded text** of an element (e.g., `<img onerror=alert()>` as literal characters), but `innerHTML` **parses** it as HTML. This creates the XSS vector: the text of a source code file becomes live HTML.

### Vulnerable Code (Pre-Fix)

**File:** `app/assets/javascripts/code_navigation/utils/dom_utils.js`, lines 28-34

```javascript
const wrapNodes = (text, classList, dataset) => {
  const wrapper = createSpan();
  // eslint-disable-next-line no-unsanitized/property
  wrapper.innerHTML = wrapSpacesWithSpans(text);  // <-- XSS: text parsed as HTML
  wrapper.childNodes.forEach((el) => wrapTextWithSpan(el, text, classList, dataset));
  return wrapper.childNodes;
};
```

**Called from:** `app/assets/javascripts/code_navigation/utils/index.js`, lines 10-19

```javascript
const deprecatedNodeUpdate = ({ d, line, wrapTextNodes }) => {
  let charCount = 0;

  if (wrapTextNodes) {
    line.childNodes.forEach((elm) => {
      // Highlight.js does not wrap all text nodes by default
      elm.replaceWith(...wrapNodes(elm.textContent, elm.classList, elm.dataset));
      //                          ^^^^^^^^^^^^^^^ textContent becomes innerHTML
    });
    wrappedLines.add(line);
  }
  // ...
};
```

### Secondary Vulnerable Code (Pre-Fix)

**File:** `app/assets/javascripts/blob/viewer/index.js`, line 49

```javascript
viewer.innerHTML = data.html;  // <-- Unsanitized server response assigned to innerHTML
```

---

## Vulnerable File(s) and Function(s)

| # | File | Function | Lines | Role |
|---|---|---|---|---|
| 1 | `app/assets/javascripts/code_navigation/utils/dom_utils.js` | `wrapNodes()` | 28-34 | **Primary XSS sink** — assigns unsanitized text to `innerHTML` |
| 2 | `app/assets/javascripts/code_navigation/utils/index.js` | `deprecatedNodeUpdate()` | 10-34 | **Caller** — passes `elm.textContent` to `wrapNodes()` |
| 3 | `app/assets/javascripts/code_navigation/utils/index.js` | `addInteractionClass()` | 36-84 | **Dispatcher** — routes to `deprecatedNodeUpdate` when `d.end_line === undefined` |
| 4 | `app/assets/javascripts/code_navigation/store/actions.js` | `showBlobInteractionZones()` | 34-40 | **Vuex action** — iterates over LSIF data entries and calls `addInteractionClass` |
| 5 | `app/assets/javascripts/blob/viewer/index.js` | `loadViewer()` | 37-57 | **Secondary XSS sink** — assigns server HTML to `viewer.innerHTML` |

---

## Triggering Input

### Attack Surface 1: Code Navigation `wrapNodes` (Primary)

**Two inputs are required simultaneously:**

1. **Source file containing XSS payload** — A file in the repository that contains HTML/JavaScript within its text. For example, a Python file:
   ```python
   # payload.py
   x = "<img/src/onerror=alert(document.domain)>"
   ```

2. **Legacy LSIF code navigation artifact** — A JSON array served from a CI job artifact, with entries that do NOT have the `end_line` property (this forces the deprecated code path):
   ```json
   [
     {
       "start_line": 0,
       "start_char": 0,
       "hover": {
         "language": "python",
         "value": "x"
       }
     }
   ]
   ```

**Conditions for trigger:**
- `d.end_line === undefined` — legacy LSIF format, triggers `deprecatedNodeUpdate()` instead of the new `TreeWalker` path
- `wrapTextNodes === true` — controls whether `wrapNodes()` is called (set by the blob viewer page when initializing code navigation)
- The line containing the payload must be referenced by the LSIF data entry's `start_line`

### Attack Surface 2: Blob Viewer `loadViewer` (Secondary)

**Input:** Server AJAX response with malicious HTML in `data.html` field. This is harder to exploit directly because the server-side Rails app should sanitize the HTML before serving. However, it represents a defense-in-depth failure — if an attacker could control the server response (e.g., via a stored XSS in the Rails layer or a man-in-the-middle), the client would execute it.

---

## Attack Scenario

### Step-by-Step Exploitation (Primary Vector)

1. **Attacker prerequisites:**
   - Authenticated GitLab user with at least Developer role (write access to a project)
   - Ability to push code and run CI pipelines

2. **Step 1 — Create malicious source file:**
   The attacker commits a source file (e.g., `payload.py`) containing the XSS payload within its text content:
   ```python
   variable = "<img/src/onerror=alert(document.cookie)>"
   ```
   The payload is valid source code (a string literal in Python/Ruby/JavaScript), so it won't be flagged by any code review tooling.

3. **Step 2 — Create legacy LSIF artifact:**
   The attacker creates a `.gitlab-ci.yml` that generates a code intelligence artifact in the legacy format (no `end_line` properties). The LSIF data is a JSON file stored as a CI job artifact:
   ```yaml
   code_navigation:
     script:
       - echo '[{"start_line":1,"start_char":0,"hover":{"language":"python","value":"variable"}}]' > lsif/payload.py.json
     artifacts:
       reports:
         lsif: lsif/payload.py.json
   ```

4. **Step 3 — Victim views the file:**
   When any user navigates to the blob view of `payload.py` in the GitLab web UI:
   - The blob viewer loads and renders the file with syntax highlighting
   - The code navigation component fetches the LSIF artifact JSON
   - Since `end_line` is missing, `deprecatedNodeUpdate()` is called
   - `wrapNodes(elm.textContent, ...)` processes each child node
   - The `<span>` containing `<img/src/onerror=alert(document.cookie)>` as text has its `textContent` passed to `innerHTML`
   - The browser parses the `<img>` tag and fires the `onerror` handler
   - **JavaScript executes in the victim's GitLab session context**

5. **Step 4 — Impact realized:**
   - Attacker's JavaScript runs with the victim's session cookies and CSRF tokens
   - Can make API calls as the victim (change email, add SSH keys, create tokens)
   - Can steal session tokens and gain persistent access
   - Can modify code in other projects the victim has access to

---

## Impact

| Impact | Description |
|---|---|
| **Stored XSS** | Payload persists in the repository; executes every time the file is viewed |
| **Account Takeover** | Attacker can steal session cookies, create personal access tokens, or change credentials |
| **Cross-Scope (S:C)** | XSS runs in GitLab's origin, can affect other projects and groups the victim belongs to |
| **Confidentiality (C:H)** | Full access to victim's private repositories, issues, merge requests, and CI/CD variables |
| **Integrity (I:H)** | Can modify code, approve merge requests, trigger pipelines on behalf of the victim |
| **CSP Bypass Potential** | The XSS runs from a legitimate GitLab DOM mutation, potentially bypassing CSP policies on self-hosted instances |

---

## Authentication Requirements

### Attacker Authentication
- **Required:** Authenticated GitLab user with **Developer** role (or higher) on a project
- **Mechanism:** Standard GitLab login (username/password, LDAP, SAML, OAuth) or Personal Access Token
- **Default credentials (GitLab Docker image):** The root user password is set during initialization. In Docker, it can be configured via `GITLAB_ROOT_PASSWORD` environment variable. Default if not set: auto-generated, viewable via `docker exec <container> grep 'Password:' /etc/gitlab/initial_root_password`
- **Login endpoint:** `POST /users/sign_in` (web) or `POST /oauth/token` (API)
- **API token:** `Private-Token` header or `access_token` query parameter

### Victim Authentication
- **Required:** Any authenticated GitLab user who can view the repository
- **No special role needed:** Even Guest/Reporter access triggers the XSS by viewing the file

### For PoC Lab
- Use the root account or create a user via the API
- Create a project, push the payload file, and set up the LSIF artifact
- The PoC should authenticate via API token for artifact upload and use a browser session (or headless browser) for the victim view

---

## Fix Assessment

### Fix Applied (Commit `8370acfa`)
The fix wraps both `innerHTML` assignments with DOMPurify's `sanitize()` function:

1. **`dom_utils.js`:** `wrapper.innerHTML = sanitize(wrapSpacesWithSpans(text))` — strips dangerous tags and event handlers
2. **`viewer/index.js`:** `viewer.innerHTML = sanitize(data.html)` — sanitizes server-provided HTML

### DOMPurify Configuration Analysis
- **Version:** 3.2.6 — no known unpatched XSS vulnerabilities
- **Config:** Strips event handlers (`onerror`, `onclick`, etc.), removes `<script>`, `<iframe>` tags
- **`ALLOW_UNKNOWN_PROTOCOLS: true`:** Does NOT allow `javascript:` or `data:` URIs — these are blocked by `IS_SCRIPT_OR_DATA` regex
- **`ADD_TAGS: ['use', 'gl-emoji', 'copy-code']`:** Safe — `<use>` has dedicated href validation hook; custom elements are inert
- **Impact on payload:** `<img/src/onerror=alert()>` → `<img src="">` (event handler stripped, tag preserved)

### Follow-Up Hardening (Commit `bcb8c0a7`, 2025-09-24)
Added lodash `escape()` to HTML-encode the text before processing, providing defense-in-depth independent of DOMPurify.

### Assessment: **Fix is thorough and complete**

The fix addresses both vulnerable code paths with DOMPurify sanitization. The DOMPurify configuration is robust:
- No known bypasses for version 3.2.6
- Event handlers are universally stripped
- Dangerous tags (`<script>`, `<iframe>`) are removed
- The follow-up `escape()` hardening adds a second layer of defense
- No other `innerHTML` assignments with `no-unsanitized/property` ESLint suppressions exist elsewhere in the JavaScript codebase

---

## Potential Bypass Vectors

No concrete bypass vectors identified for the fixed version. Theoretical considerations:

1. **DOMPurify mXSS (mutation XSS):** Version 3.2.6 patches all known mXSS vectors. Future browser parsing changes could theoretically introduce new ones, but none are currently exploitable.
2. **Config override via `sanitize()` caller:** The `sanitize(val, config)` function accepts a config override. Both fix call sites pass no custom config, so defaults apply. If a future code change passes a permissive config, it could reintroduce the vulnerability.
3. **Alternative text injection paths:** If there were other callers of `wrapNodes()` or other functions that assign user-controlled text to `innerHTML`, they could be vulnerable. No such paths were found in the current codebase.

---

## Escalation Path

**Stored XSS → Full Account Takeover:**

1. **Session hijacking:** The XSS payload can read `document.cookie` and exfiltrate session tokens to an attacker-controlled server.
2. **Personal Access Token creation:** Via the GitLab REST API (`POST /api/v4/personal_access_tokens` with the victim's session), the attacker can create a long-lived token with full API scopes.
3. **SSH key injection:** The attacker can add their SSH public key to the victim's account via `POST /api/v4/user/keys`, gaining persistent Git access.
4. **CI/CD variable exfiltration:** If the victim has maintainer/owner access, the attacker can read CI/CD variables (which may contain secrets, cloud credentials, or deployment keys).
5. **Supply chain attack:** The attacker can modify code in repositories the victim has write access to, inject backdoors, and approve their own merge requests using the victim's identity.

The primary primitive (stored XSS) directly enables full account takeover without additional vulnerabilities needed.

---

## Related Attack Surface

### Same Vulnerability Pattern in Codebase

No additional instances of the same vulnerability pattern were found:

- **`innerHTML` assignments:** Only two `no-unsanitized/property` ESLint suppressions exist in the JavaScript codebase, both in the files targeted by the fix. All other `innerHTML` assignments in Vue components go through template rendering (which auto-escapes by default) or use DOMPurify.
- **`wrapNodes()` callers:** Only `deprecatedNodeUpdate()` calls `wrapNodes()`. No other code paths invoke it.
- **`loadViewer()` usage:** Called from `BlobViewer.switchToViewer()` and `initAuxiliaryViewer()`. Both paths use the same `loadViewer()` function that the fix patches.

### Note on `wrapTextNodes` Flag

The `wrapTextNodes` flag is passed as a prop to the code navigation `App` component from the server-rendered page. When `true`, it enables the vulnerable `wrapNodes()` call path. The default is `false` in state, but tests consistently use `true`, indicating it is `true` in production blob views where highlight.js leaves unwrapped text nodes.

**Even without `wrapTextNodes === true`, the `deprecatedNodeUpdate()` function still runs** (finding the correct child node by character offset), but it doesn't call `wrapNodes()` — so the innerHTML XSS does not trigger. The vulnerability specifically requires the `wrapTextNodes` branch.

---

## Build System

| Field | Value |
|---|---|
| **Primary Language** | JavaScript (Vue.js 2.x, Webpack) within Ruby on Rails monolith |
| **Package Manager** | Yarn (yarn.lock present) |
| **Build Tool** | Webpack (`config/webpack.config.js`) |
| **Test Framework** | Jest (`jest.config.js`) |
| **Key Dependencies** | DOMPurify 3.2.6, Vue.js 2, Vuex, Axios, highlight.js, jQuery |

---

## Build Commands

### For PoC Reproduction (Recommended: Docker Image)

The vulnerability is in client-side JavaScript. Building from source is unnecessary. Use the official GitLab Docker image at a vulnerable version:

```bash
# Pull vulnerable version
docker pull gitlab/gitlab-ce:18.0.5-ce.0

# Run GitLab CE
docker run -d \
  --hostname gitlab.local \
  -p 80:80 -p 443:443 -p 2222:22 \
  --name gitlab \
  -e GITLAB_ROOT_PASSWORD="P@ssw0rd123!" \
  -e GITLAB_OMNIBUS_CONFIG="external_url 'http://gitlab.local'; gitlab_rails['initial_root_password']='P@ssw0rd123!';" \
  --shm-size 512m \
  gitlab/gitlab-ce:18.0.5-ce.0
```

### For Frontend Unit Test Reproduction

```bash
yarn install
yarn jest spec/frontend/code_navigation/utils/index_spec.js
```

---

## Dependencies

### Runtime (Docker Image — all included)
- Ruby on Rails application server (Puma)
- PostgreSQL database
- Redis cache
- Gitaly (Git RPC server)
- Nginx reverse proxy
- Sidekiq background workers

### For PoC Script
- Python 3 with `requests` library (for API calls)
- A web browser or headless browser (Selenium/Playwright) for verifying XSS execution
- `curl` / `jq` for API interaction

---

## Runtime Requirements

### Docker Resources
- **RAM:** 4GB minimum (8GB recommended)
- **Disk:** ~5GB for the image
- **CPU:** 2+ cores recommended
- **Startup time:** 3-5 minutes for full initialization (wait for health check)

### Network Setup
- Port 80 (HTTP) — GitLab web interface
- Port 443 (HTTPS) — if HTTPS configured
- Port 22/2222 (SSH) — Git over SSH

### Health Check
```bash
# Wait for GitLab to be ready
until curl -s http://localhost/-/health | grep -q 'GitLab OK'; do sleep 5; done
```

### PoC Workflow
1. Start GitLab container (v18.0.5-ce.0)
2. Wait for health check to pass
3. Create a project via API
4. Push a source file containing XSS payload
5. Upload legacy LSIF artifact (JSON without `end_line`) via CI or artifacts API
6. Navigate to the file in the blob viewer
7. Observe XSS execution (JavaScript alert, cookie exfiltration, etc.)

### LSIF Artifact Upload
The LSIF artifact can be uploaded in two ways:
1. **Via CI pipeline:** Create `.gitlab-ci.yml` with a `code_navigation` job that produces the LSIF JSON as an artifact with `reports: lsif:` configuration
2. **Via Artifacts API:** `POST /api/v4/projects/:id/jobs/:job_id/artifacts` — requires a completed CI job

### Key API Endpoints for PoC
- `POST /api/v4/projects` — Create project
- `POST /api/v4/projects/:id/repository/files/:file_path` — Create files
- `POST /api/v4/projects/:id/repository/commits` — Create commits with multiple files
- `GET /api/v4/projects/:id/jobs` — List CI jobs
- `GET /:namespace/:project/-/blob/:branch/:file` — Blob viewer page (victim URL)
- `GET /:namespace/:project/-/jobs/:id/artifacts/raw/lsif/:file.json` — Code navigation data endpoint
