/**
 * CVE-2025-7734 Bypass Test 2 â€” Advanced payloads and loadViewer path
 *
 * Tests:
 * 1. DOMPurify config-specific attacks targeting ALLOW_UNKNOWN_PROTOCOLS and ADD_TAGS
 * 2. loadViewer() path (sanitizing server HTML)
 * 3. Edge cases in wrapSpacesWithSpans + DOMPurify interaction
 * 4. Mutation XSS payloads for DOMPurify 3.2.x
 */

const { JSDOM } = require('jsdom');
const createDOMPurify = require('dompurify');

const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
  url: 'http://gitlab.local',
  runScripts: 'dangerously',
  pretendToBeVisual: true,
});
const window = dom.window;
const document = window.document;
const DOMPurify = createDOMPurify(window);

// GitLab's DOMPurify config
const defaultConfig = {
  ADD_TAGS: ['use', 'gl-emoji', 'copy-code'],
  FORBID_ATTR: ['data-remote', 'data-url', 'data-type', 'data-method',
    'data-disable-with', 'data-disabled', 'data-disable', 'data-turbo'],
  FORBID_TAGS: ['style', 'mstyle', 'form'],
  ALLOW_UNKNOWN_PROTOCOLS: true,
};

// GitLab hooks
const TEMPORARY_ATTRIBUTE = 'data-temp-href-target';
DOMPurify.addHook('beforeSanitizeAttributes', (node) => {
  if (node.tagName === 'A' && node.hasAttribute('target')) {
    node.setAttribute(TEMPORARY_ATTRIBUTE, node.getAttribute('target'));
  }
});
DOMPurify.addHook('afterSanitizeAttributes', (node) => {
  if (node.tagName === 'A' && node.hasAttribute(TEMPORARY_ATTRIBUTE)) {
    node.setAttribute('target', node.getAttribute(TEMPORARY_ATTRIBUTE));
    node.removeAttribute(TEMPORARY_ATTRIBUTE);
    if (node.getAttribute('target') === '_blank') {
      const rel = node.getAttribute('rel');
      const attrs = new Set(rel ? rel.toLowerCase().split(' ') : []);
      attrs.add('noopener');
      attrs.add('noreferrer');
      node.setAttribute('rel', Array.from(attrs).join(' '));
    }
  }
  if (node.tagName && node.tagName.toLowerCase() === 'use') {
    for (const attr of ['href', 'xlink:href']) {
      if (node.hasAttribute(attr)) {
        const href = node.getAttribute(attr);
        if (!href.match(/^#/)) node.removeAttribute(attr);
      }
    }
  }
});

function sanitize(val, config) {
  return DOMPurify.sanitize(val, { ...defaultConfig, ...config });
}

// ============================================================
// XSS Detection (more thorough)
// ============================================================
function detectXSS(html) {
  const container = document.createElement('div');
  container.innerHTML = html;
  const issues = [];

  // Check for event handlers on ALL elements
  const allEls = container.querySelectorAll('*');
  for (const el of allEls) {
    for (const attr of el.attributes) {
      if (attr.name.startsWith('on')) {
        issues.push(`Event handler <${el.tagName.toLowerCase()} ${attr.name}="${attr.value}">`);
      }
    }
  }

  // Check for dangerous URIs in href/src/action
  for (const el of allEls) {
    for (const attr of ['href', 'src', 'action', 'formaction', 'data', 'codebase', 'lowsrc', 'dynsrc']) {
      const val = el.getAttribute(attr);
      if (val && /^\s*(javascript|data|vbscript)\s*:/i.test(val)) {
        issues.push(`Dangerous URI <${el.tagName.toLowerCase()} ${attr}="${val.substring(0, 80)}">`);
      }
    }
  }

  // Check for script/iframe/object/embed
  for (const tag of ['script', 'iframe', 'object', 'embed', 'applet', 'base']) {
    const found = container.querySelectorAll(tag);
    if (found.length) issues.push(`Dangerous element <${tag}> (${found.length})`);
  }

  // Check for style elements or attributes (CSS injection)
  if (container.querySelectorAll('style').length) {
    issues.push('Style element found (CSS injection possible)');
  }

  return issues;
}

// ============================================================
// Test Suites
// ============================================================

console.log('â•â•â• CVE-2025-7734 BYPASS TEST 2 â€” Advanced Payloads â•â•â•');
console.log(`DOMPurify version: ${DOMPurify.version}\n`);

let totalTests = 0;
let bypasses = 0;

function test(name, html, context = 'sanitize') {
  totalTests++;
  const sanitized = sanitize(html);
  const issues = detectXSS(sanitized);

  if (issues.length > 0) {
    bypasses++;
    console.log(`ðŸš¨ BYPASS [${context}]: ${name}`);
    console.log(`   Input:     ${html.substring(0, 150)}`);
    console.log(`   Sanitized: ${sanitized.substring(0, 150)}`);
    console.log(`   Issues:    ${issues.join('; ')}`);
    console.log('');
  }
  return { sanitized, issues };
}

// === Suite 1: ALLOW_UNKNOWN_PROTOCOLS edge cases ===
console.log('â”€â”€ Suite 1: Protocol URI tests (ALLOW_UNKNOWN_PROTOCOLS: true) â”€â”€');

test('javascript: in href', '<a href="javascript:alert(1)">x</a>');
test('javascript: with spaces', '<a href="  javascript:alert(1)">x</a>');
test('javascript: with newline', '<a href="java\nscript:alert(1)">x</a>');
test('javascript: with tab', '<a href="java\tscript:alert(1)">x</a>');
test('javascript: with entities', '<a href="&#106;avascript:alert(1)">x</a>');
test('javascript: with hex', '<a href="&#x6A;avascript:alert(1)">x</a>');
test('javascript: URL-encoded', '<a href="javascript%3Aalert(1)">x</a>');
test('data: URI html', '<a href="data:text/html,<script>alert(1)</script>">x</a>');
test('data: URI base64', '<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">x</a>');
test('vbscript: href', '<a href="vbscript:MsgBox(1)">x</a>');
test('custom: protocol', '<a href="custom://test">x</a>');
test('file: protocol', '<a href="file:///etc/passwd">x</a>');
test('blob: protocol', '<a href="blob:http://evil.com/uuid">x</a>');

// === Suite 2: ADD_TAGS custom element attacks ===
console.log('\nâ”€â”€ Suite 2: Custom element attacks (ADD_TAGS) â”€â”€');

test('gl-emoji with event handler', '<gl-emoji onmouseover="alert(1)">x</gl-emoji>');
test('gl-emoji with data-url', '<gl-emoji data-url="http://evil.com" data-remote="true">x</gl-emoji>');
test('copy-code with handler', '<copy-code onclick="alert(1)">x</copy-code>');
test('use with xlink:href js', '<svg><use xlink:href="javascript:alert(1)"></use></svg>');
test('use with data: href', '<svg><use href="data:image/svg+xml,<svg onload=alert(1)/>"></use></svg>');
test('use in math context', '<math><use href="javascript:alert(1)"></use></math>');

// === Suite 3: Hook exploitation attempts ===
console.log('\nâ”€â”€ Suite 3: Hook exploitation â”€â”€');

test('A tag target preservation', '<a href="http://evil.com" target="_blank">x</a>');
test('A tag with target=javascript', '<a href="#" target="javascript:alert(1)">x</a>');
test('A tag temp attr directly', '<a data-temp-href-target="javascript:alert(1)" href="#">x</a>');
test('Background color via gl-label', '<span class="gl-label-text" style="background-color:red;background-image:url(javascript:alert(1))">x</span>');

// === Suite 4: mXSS mutation payloads for DOMPurify 3.2.x ===
console.log('\nâ”€â”€ Suite 4: Mutation XSS payloads â”€â”€');

test('mXSS math mtext', '<math><mtext><table><mglyph><style><!--</style><img src onerror=alert(1)>');
test('mXSS nesting depth', '<div>'.repeat(600) + '<img src=x onerror=alert(1)>' + '</div>'.repeat(600));
test('mXSS svg desc', '<svg><desc><table><template><img src=x onerror=alert(1)>');
test('mXSS annotation-xml', '<math><annotation-xml encoding="text/html"><img src=x onerror=alert(1)></annotation-xml></math>');
test('mXSS select option', '<select><template><img src=x onerror=alert(1)></template></select>');
test('mXSS table template', '<table><template><img src=x onerror=alert(1)></template></table>');
test('mXSS mglyph', '<math><mtext><mglyph><img src=x onerror=alert(1)></mglyph></mtext></math>');
test('mXSS malignmark', '<math><mtext><malignmark><img src=x onerror=alert(1)></malignmark></mtext></math>');
test('mXSS button nesting', '<math><mtext><table><button><img src=x onerror=alert(1)></button></table></mtext></math>');
test('mXSS svg title img', '<svg><title><img src=x onerror=alert(1)>');

// === Suite 5: loadViewer path â€” sanitizing full HTML documents ===
console.log('\nâ”€â”€ Suite 5: loadViewer path (full HTML sanitization) â”€â”€');

const blobHtml1 = `
<div class="blob-content">
  <pre class="code highlight">
    <code><span class="hljs-keyword">variable</span> = <span class="hljs-string">"&lt;img src=x onerror=alert(1)&gt;"</span></code>
  </pre>
</div>
<script>alert('injected')</script>`;

const blobHtml2 = `
<div class="blob-content">
  <pre class="code highlight">
    <code><span class="hljs-keyword">x</span></code>
  </pre>
</div>
<img src=x onerror=alert(document.cookie)>`;

const blobHtml3 = `
<div class="blob-content" data-path="payload.py">
  <pre class="code highlight" data-code-navigation-path="/api/code_nav">
    <code><span class="hljs-keyword">import</span> os</code>
  </pre>
</div>
<a href="javascript:alert(1)">click</a>`;

test('Blob with script injection', blobHtml1, 'loadViewer');
test('Blob with img onerror', blobHtml2, 'loadViewer');
test('Blob with javascript: link', blobHtml3, 'loadViewer');

// === Suite 6: Post-sanitization DOM interaction ===
console.log('\nâ”€â”€ Suite 6: Post-sanitization wrapTextWithSpan interaction â”€â”€');

// Test the full fixed wrapNodes flow including wrapTextWithSpan
const createSpan = (content, classList) => {
  const span = document.createElement('span');
  span.innerText = content;
  span.classList = classList || '';
  return span;
};

const wrapSpacesWithSpans = (text) =>
  text.replace(/ /g, createSpan(' ').outerHTML).replace(/\t/g, createSpan('	').outerHTML);

const isTextNode = ({ nodeType }) => nodeType === 3;
const isBlank = (str) => !str || /^\s*$/.test(str);
const isMatch = (s1, s2) => !isBlank(s1) && s1.trim() === s2.trim();

const wrapTextWithSpan = (el, text, classList, dataset) => {
  if (isTextNode(el) && isMatch(el.textContent, text)) {
    const newEl = createSpan(text.trim(), classList);
    Object.assign(newEl.dataset, dataset);
    el.replaceWith(newEl);
  }
};

function fullWrapNodesTest(text, classList, dataset) {
  const wrapper = createSpan();
  const unSafeHtml = wrapSpacesWithSpans(text);
  wrapper.innerHTML = sanitize(unSafeHtml);
  wrapper.childNodes.forEach((el) => wrapTextWithSpan(el, text, classList, dataset));

  // Now check if the result has any XSS
  const issues = detectXSS(wrapper.outerHTML);
  return { wrapper, issues };
}

// Test with attacker-controlled dataset values
const testDatasets = [
  { name: 'Normal dataset', dataset: { charIndex: '0', lineIndex: '0' } },
  { name: 'Dataset with onclick', dataset: { onclick: 'alert(1)' } },
  { name: 'Dataset with data-remote', dataset: { remote: 'true', url: 'http://evil.com' } },
];

for (const { name, dataset } of testDatasets) {
  totalTests++;
  const text = '<img/src/onerror=alert(1)>';
  const result = fullWrapNodesTest(text, 'hljs-string', dataset);
  if (result.issues.length > 0) {
    bypasses++;
    console.log(`ðŸš¨ BYPASS [wrapTextWithSpan]: ${name}`);
    console.log(`   Issues: ${result.issues.join('; ')}`);
    console.log(`   HTML: ${result.wrapper.outerHTML.substring(0, 200)}`);
  }
}

// === Suite 7: Timing-based (double processing) ===
console.log('\nâ”€â”€ Suite 7: Double processing tests â”€â”€');

// What if wrapNodes is called twice on the same content?
function doubleWrapTest(text) {
  totalTests++;
  const wrapper1 = createSpan();
  wrapper1.innerHTML = sanitize(wrapSpacesWithSpans(text));

  // Simulate second call on the result
  const resultText = wrapper1.textContent;
  const wrapper2 = createSpan();
  wrapper2.innerHTML = sanitize(wrapSpacesWithSpans(resultText));

  const issues = detectXSS(wrapper2.outerHTML);
  if (issues.length > 0) {
    bypasses++;
    console.log(`ðŸš¨ BYPASS [double process]: text="${text}"`);
    console.log(`   Issues: ${issues.join('; ')}`);
  }
}

doubleWrapTest('<img/src/onerror=alert(1)>');
doubleWrapTest('<script>alert(1)</script>');
doubleWrapTest('<svg/onload=alert(1)>');

// ============================================================
// Summary
// ============================================================
console.log('\nâ•â•â• FINAL SUMMARY â•â•â•');
console.log(`Total tests:    ${totalTests}`);
console.log(`Bypasses found: ${bypasses}`);

if (bypasses > 0) {
  console.log('\nðŸš¨ BYPASSES DETECTED! The fix may be incomplete.');
} else {
  console.log('\nâœ… No bypasses found across all test suites.');
  console.log('   DOMPurify 3.2.6 with GitLab\'s configuration effectively');
  console.log('   neutralizes all tested XSS vectors.');
}
