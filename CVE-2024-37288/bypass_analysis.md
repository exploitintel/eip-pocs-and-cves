# Bypass Analysis: CVE-2024-37288

## Executive Summary

**No bypass was found.** After exhaustive testing of 14 distinct bypass vectors against the patched Kibana 8.15.1 container, the fix for CVE-2024-37288 is confirmed to be **complete and effective**. The `safeLoad()` function in js-yaml v3.14.1 robustly blocks all JavaScript-specific YAML types (`!!js/function`, `!!js/regexp`, `!!js/undefined`), and no alternative code path, encoding trick, or injection technique was found to circumvent this protection.

**Confidence level: HIGH (95%)** — The fix addresses the root cause (unsafe YAML schema selection) rather than a symptom, and the `DEFAULT_SAFE_SCHEMA` rejects all dangerous type handlers at the parsing engine level.

## Fix Under Test

- **Fix Commit**: `21877f5f9c556d54a6abc7256cbec07bc4861ef0` (8.15 backport)
- **Fix Summary**: Replaces `load()` → `safeLoad()` and `dump()` → `safeDump()` across 33 files
- **Primary Change**: `x-pack/plugins/integration_assistant/server/graphs/ecs/pipeline.ts` line 175:
  ```diff
  - const ingestPipeline = load(renderedTemplate) as IngestPipeline;
  + const ingestPipeline = safeLoad(renderedTemplate) as IngestPipeline;
  ```
- **Import Change**: `import { load } from 'js-yaml'` → `import { safeLoad } from 'js-yaml'`
- **ESLint Rule**: `@kbn/eslint/no_unsafe_js_yaml` added to prevent regression
- **Library**: js-yaml remains at v3.14.1 (function call changed, library not upgraded)

## Test Environment

| Component | Vulnerable | Patched |
|---|---|---|
| **Container** | `cve-2024-37288-kibana` | `cve-2024-37288-kibana-patched` |
| **Kibana Version** | 8.15.0 | 8.15.1 |
| **js-yaml Version** | 3.14.1 | 3.14.1 |
| **Vulnerable Code** | `(0, _jsYaml.load)(renderedTemplate)` | `(0, _jsYaml.safeLoad)(renderedTemplate)` |
| **Elasticsearch** | 8.15.0 (shared) | 8.15.0 (shared) |

## Bypass Vectors Tested

### Vector 1: %TAG Directive Injection — FAILED

**Hypothesis**: YAML `%TAG` directives redefine tag URI prefixes. If we redefine `!!` to point to `tag:yaml.org,2002:js/`, then `!!function` would resolve to `!!js/function`.

**Test**:
```yaml
%TAG !! tag:yaml.org,2002:js/
---
test: !!function >
  function() { return 42; }
```

**Result**: **BLOCKED** — `safeLoad()` resolves the full tag URI correctly (`tag:yaml.org,2002:js/function`) but rejects it because the `DEFAULT_SAFE_SCHEMA` does not include a handler for this type. The schema check operates on the resolved URI, not the shorthand.

**Also tested**: Custom `%TAG !js!` prefix → Same result (BLOCKED).

### Vector 2: YAML Version Directive Override — FAILED

**Hypothesis**: The `%YAML 1.1` or `%YAML 1.2` directive might influence schema selection in the parser.

**Test**:
```yaml
%YAML 1.1
---
test: !!js/function >
  function() { return 42; }
```

**Result**: **BLOCKED** — The `%YAML` directive controls parsing behavior (e.g., boolean handling) but does NOT change the type schema. `safeLoad()` always uses `DEFAULT_SAFE_SCHEMA` regardless of the YAML version directive.

### Vector 3: Tag Encoding Bypasses — FAILED

**Hypothesis**: Alternative encodings of the tag name might evade the tag matching logic.

| Encoding | Payload | Result |
|---|---|---|
| Explicit URI | `!<tag:yaml.org,2002:js/function>` | BLOCKED — Same resolved URI |
| URL-encoded slash | `!!js%2Ffunction` | BLOCKED — `%2F` not decoded, different URI |
| Mixed case | `!!js/Function` | BLOCKED — Case-sensitive matching |
| Null byte | `!!js/function\x00` | BLOCKED — "null byte not allowed in input" |
| Unicode fullwidth | `!!\uff4a\uff53/function` | BLOCKED — "tag name cannot contain such characters" |

**Result**: All encoding variants are **BLOCKED**. The tag resolution is strict and does not normalize, decode, or canonicalize tag names.

### Vector 4: Prototype Pollution via safeLoad — FAILED

**Hypothesis**: YAML documents with `__proto__` or `constructor.prototype` keys might pollute `Object.prototype` when parsed by `safeLoad()`.

**Tests**:
```yaml
# Test 1: Direct __proto__
__proto__:
  polluted: true

# Test 2: constructor.prototype  
constructor:
  prototype:
    polluted: true

# Test 3: Nested __proto__
a:
  __proto__:
    polluted: true
```

**Result**: **NO global prototype pollution**. In js-yaml v3.14.1:
- `__proto__` key assignment changes the parsed object's own prototype chain (`Object.setPrototypeOf(result, value)`) but does NOT modify `Object.prototype` globally
- `constructor.prototype` creates a regular property that shadows the inherited `constructor` — it does not modify `Object` itself
- After all tests, `{}.polluted === undefined` and `Object.prototype` has no injected properties

### Vector 5: Nunjucks Template Injection (SSTI) — FAILED

**Hypothesis**: With `autoescape: false`, template syntax (`{{ }}`, `{% %}`) injected into variable values might be evaluated by Nunjucks.

**Test**:
```javascript
const template = nunjucks.compile("Hello {{ name }}", env);
template.render({ name: "{{ 7*7 }}" });  // Returns "Hello {{ 7*7 }}", NOT "Hello 49"
template.render({ name: "{% for i in range(3) %}X{% endfor %}" });  // Returns literal string
```

**Result**: **NOT VULNERABLE** — Nunjucks `template.render()` substitutes variable values literally. Template syntax within values is NOT re-parsed or evaluated. The `autoescape: false` setting only controls HTML escaping of output, not template parsing of values.

### Vector 6: YAML Structure Injection via packageName — FAILED (for RCE)

**Hypothesis**: The `PackageName` Zod validation is `z.string().min(1)` with no character restrictions. If `packageName` contains newlines, the Nunjucks-rendered YAML structure changes, potentially injecting arbitrary YAML keys or processors.

**Test**: `packageName = "test\ninjected_key: injected_value"`

**Result**: The injection causes a YAML parse error (`duplicated mapping key` at the second template position where `package_name` is used in `target_field: {{ package_name }}.{{ data_stream_name }}`).

**Analysis**:
- With carefully crafted newlines, it may be possible to inject top-level YAML keys
- However, `safeLoad()` only produces safe types (strings, numbers, maps, sequences) — no code execution possible
- The injected YAML structure would need to survive both template positions where `package_name` is rendered
- **DoS potential**: YAML parse errors could crash the request handler (depends on error handling)
- **NOT a code execution bypass**: Even successful structure injection produces only safe JavaScript objects

**Defense-in-depth recommendation**: Add character validation to `PackageName` and `DataStreamName` schemas (reject newlines, YAML special characters).

### Vector 7: YAML Anchor/Alias Bomb (DoS) — FAILED

**Hypothesis**: Exponential expansion via YAML anchors (`&`) and aliases (`*`) could cause resource exhaustion.

**Test**: 4-level nested anchor bomb (10×10×10×10 = 10,000 elements):
```yaml
a: &a ["x","x","x","x","x","x","x","x","x","x"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c,*c]
```

**Result**: Parsed in **2ms** producing 46,925 bytes — no significant DoS impact. js-yaml v3.14.1 resolves aliases by reference (shared objects), so the in-memory size is much smaller than the serialized form. Deeper nesting could potentially cause issues, but the rendered YAML from the Nunjucks template has a fixed structure that limits anchor injection.

### Vector 8: Schema Override via Options — NOT EXPLOITABLE

**Hypothesis**: `safeLoad()` internally calls `load()` with `{schema: DEFAULT_SAFE_SCHEMA}`. Could options be injected to override the schema?

**Finding**: `safeLoad()` implementation:
```javascript
function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}
```

The `common.extend()` merges `{ schema: DEFAULT_SAFE_SCHEMA }` with the `options` parameter. If `options` contains a `schema` property, it WOULD override `DEFAULT_SAFE_SCHEMA`. In testing, `safeLoad(payload, {schema: DEFAULT_FULL_SCHEMA})` does indeed allow `!!js/function`.

**However**: The attacker cannot control the `options` parameter. In the patched code, `safeLoad()` is called without any options:
```javascript
const ingestPipeline = safeLoad(renderedTemplate);
```

This is a **code-level** concern, not a YAML-level bypass. It's relevant for developers (don't pass untrusted options to safeLoad), but an external attacker cannot exploit this.

## Additional Investigation

### Other Code Paths
- **Categorization graph** (`/api/integration_assistant/categorization`): Does NOT use `load()` or YAML parsing — processes pipeline objects directly
- **Related graph** (`/api/integration_assistant/related`): Does NOT use YAML parsing
- **Check pipeline** (`/api/integration_assistant/check_pipeline`): Takes pipeline object, sends to ES — no YAML parsing
- **Build integration** (`/api/integration_assistant/build_integration`): Uses `yaml.dump()`/`yaml.safeDump()` for serialization only (output direction)
- **Only the ECS graph** (`/api/integration_assistant/ecs`) contains YAML deserialization via `load()`/`safeLoad()`

### ESLint Exemptions
- Three `.buildkite/` CI pipeline files have `eslint-disable @kbn/eslint/no_unsafe_js_yaml` for `dump()` usage
- These are **build-time tooling**, not runtime Kibana code — they are not accessible via the web API
- **NOT an attack surface**

### js-yaml Library Version
- The fix changes function calls but does NOT upgrade js-yaml from v3.14.1
- js-yaml v3 is deprecated; v4.x renamed `safeLoad` to `load` (safe by default) and removed the unsafe variant entirely
- While v3.14.1 `safeLoad()` is effective, upgrading to v4.x would provide additional defense-in-depth by eliminating the unsafe functions from the API surface entirely
- **No known vulnerabilities in js-yaml v3.14.1's `safeLoad()` implementation**

## Bypass Script

**Location**: `poc/bypass_poc.py`

The script runs 14 automated tests against a Kibana container:
```bash
python3 bypass_poc.py cve-2024-37288-kibana-patched   # Test patched container
python3 bypass_poc.py cve-2024-37288-kibana            # Test vulnerable container
```

Additional manual tests: `poc/bypass_tests.js`

## Conclusion

### Fix Assessment: COMPLETE ✅

The CVE-2024-37288 fix is **thorough and effective**. The change from `load()` to `safeLoad()` addresses the root cause — the use of `DEFAULT_FULL_SCHEMA` which includes JavaScript-specific YAML type handlers. The `DEFAULT_SAFE_SCHEMA` used by `safeLoad()`:

1. **Rejects all JavaScript types**: `!!js/function`, `!!js/regexp`, `!!js/undefined` are all blocked with clear error messages
2. **Cannot be overridden from YAML**: No YAML directive (`%TAG`, `%YAML`) can change the schema
3. **Encoding-resistant**: Tag resolution is strict — no normalization, URL decoding, or case folding
4. **No prototype pollution**: Object construction does not pollute global prototypes
5. **Covers all code paths**: The only YAML deserialization in the Integration Assistant is in `pipeline.ts`, and it's patched
6. **Prevents regression**: The ESLint rule `@kbn/eslint/no_unsafe_js_yaml` blocks future introduction of unsafe calls

### Defense-in-Depth Recommendations

While the fix is complete for CVE-2024-37288, the following improvements would harden the system further:

1. **Upgrade js-yaml to v4.x**: Eliminates the unsafe `load()` API entirely (v4 `load()` is safe by default)
2. **Validate `packageName` and `dataStreamName`**: Add character restrictions (reject newlines, YAML special characters) to prevent YAML structure injection → DoS
3. **Sanitize AI model output**: Validate that ECS mapping values conform to expected formats before template rendering
4. **Add `autoescape: true` to Nunjucks**: While not currently exploitable, this provides defense against future template-based attacks

### Confidence Level

**HIGH (95%)** — The analysis covered all standard bypass categories (encoding, alternative paths, injection, prototype pollution, SSTI, DoS) and found no viable bypass. The 5% uncertainty accounts for:
- Potential undiscovered vulnerabilities in js-yaml v3.14.1's `safeLoad()` implementation
- Complex interaction effects between Nunjucks rendering and YAML parsing not covered by our tests
- Future changes to the codebase that might reintroduce vulnerable patterns (mitigated by ESLint rule)
