#!/usr/bin/env node
// CVE-2024-37288 Vulnerable Demo Server
//
// Exposes Kibana's js-yaml v3.14.1 load() function and the Integration
// Assistant's createPipeline() function via HTTP endpoints, simulating
// the attack surface where attacker-influenced data reaches yaml.load().
//
// Endpoints:
//   POST /api/yaml/parse       - Parse YAML with vulnerable yaml.load() (CWE-502)
//   POST /api/yaml/safe-parse  - Parse YAML with safe yaml.safeLoad() (fix verification)
//   POST /api/pipeline/create  - Call actual createPipeline() with crafted state
//   GET  /health               - Health check
//   GET  /                     - Info page

'use strict';

const http = require('http');
const url = require('url');

// js-yaml v3.14.1 — the vulnerable version bundled with Kibana 8.15.0
// DEFAULT_FULL_SCHEMA supports !!js/function, !!js/regexp, !!js/undefined
const yaml = require('js-yaml');
const yamlVersion = require('js-yaml/package.json').version;

// Make require() available in new Function() scope.
// js-yaml's !!js/function handler creates functions via new Function(params, body),
// which runs in the global scope. In Kibana's actual runtime, these functions
// execute in module contexts where require() is available. We simulate this by
// exposing require globally, matching the real execution environment.
global.require = require;

// Attempt to load createPipeline from the Integration Assistant plugin
let createPipeline = null;
try {
    const mod = require('/usr/share/kibana/node_modules/@kbn/integration-assistant-plugin/server/graphs/ecs/pipeline');
    createPipeline = mod.createPipeline;
    console.log('[+] createPipeline() loaded from Integration Assistant plugin');
} catch (e) {
    console.log('[-] createPipeline() unavailable: ' + e.message.split('\n')[0]);
    console.log('[*] /api/pipeline/create endpoint will return 503');
}

/**
 * Walk a parsed YAML object tree and find dangerous deserialized types:
 * - Functions (from !!js/function) — execute and capture output
 * - RegExp objects (from !!js/regexp) — report pattern
 * - undefined values (from !!js/undefined) — report presence
 */
function findDangerousTypes(obj, path, results) {
    if (!results) results = [];
    if (!path) path = '';

    if (typeof obj === 'function') {
        const finding = { path: path || '(root)', type: 'function' };
        try {
            finding.output = String(obj()).substring(0, 4000);
            finding.executed = true;
        } catch (e) {
            finding.error = e.message;
            finding.executed = false;
        }
        results.push(finding);
    } else if (obj instanceof RegExp) {
        results.push({ path: path || '(root)', type: 'regexp', pattern: String(obj) });
    } else if (typeof obj === 'undefined') {
        results.push({ path: path || '(root)', type: 'undefined' });
    } else if (obj && typeof obj === 'object' && !Array.isArray(obj)) {
        for (const [k, v] of Object.entries(obj)) {
            findDangerousTypes(v, path ? path + '.' + k : k, results);
        }
    } else if (Array.isArray(obj)) {
        obj.forEach(function (v, i) {
            findDangerousTypes(v, path + '[' + i + ']', results);
        });
    }

    return results;
}

function readBody(req) {
    return new Promise(function (resolve, reject) {
        var body = '';
        req.on('data', function (chunk) { body += chunk; });
        req.on('end', function () { resolve(body); });
        req.on('error', reject);
    });
}

var server = http.createServer(function (req, res) {
    var parsed = url.parse(req.url);
    res.setHeader('Content-Type', 'application/json');

    // GET /
    if (req.method === 'GET' && parsed.pathname === '/') {
        res.end(JSON.stringify({
            service: 'Kibana Integration Assistant YAML Parser (VULNERABLE)',
            cve: 'CVE-2024-37288',
            description: 'Demonstrates unsafe js-yaml v3 load() deserialization in Kibana 8.15.0',
            endpoints: {
                'POST /api/yaml/parse': 'Parse YAML with vulnerable yaml.load() — supports !!js/function RCE',
                'POST /api/yaml/safe-parse': 'Parse YAML with yaml.safeLoad() — rejects dangerous types (fix)',
                'POST /api/pipeline/create': 'Call actual createPipeline() with crafted state object',
                'GET /health': 'Health check with version info'
            }
        }));
        return;
    }

    // GET /health
    if (req.method === 'GET' && parsed.pathname === '/health') {
        res.end(JSON.stringify({
            status: 'ok',
            vulnerable: true,
            jsyaml_version: yamlVersion,
            createPipeline_available: createPipeline !== null
        }));
        return;
    }

    if (req.method !== 'POST') {
        res.writeHead(404);
        res.end(JSON.stringify({ error: 'Not Found' }));
        return;
    }

    readBody(req).then(function (body) {
        // POST /api/yaml/parse — VULNERABLE: calls yaml.load()
        if (parsed.pathname === '/api/yaml/parse') {
            try {
                var input = JSON.parse(body);
                if (!input.yaml || typeof input.yaml !== 'string') {
                    res.writeHead(400);
                    res.end(JSON.stringify({ error: 'Provide {"yaml": "<yaml string>"}' }));
                    return;
                }

                // VULNERABLE: yaml.load() uses DEFAULT_FULL_SCHEMA
                // which supports !!js/function, !!js/regexp, !!js/undefined
                var result = yaml.load(input.yaml);

                // Walk the result and find/execute dangerous deserialized types
                var findings = findDangerousTypes(result);

                if (findings.length > 0) {
                    res.end(JSON.stringify({
                        status: 'dangerous_types_deserialized',
                        note: 'yaml.load() with DEFAULT_FULL_SCHEMA created dangerous JavaScript objects',
                        findings: findings
                    }));
                } else {
                    res.end(JSON.stringify({
                        status: 'parsed',
                        result_type: typeof result,
                        result_keys: result && typeof result === 'object' ? Object.keys(result) : null
                    }));
                }
            } catch (e) {
                res.writeHead(500);
                res.end(JSON.stringify({ status: 'error', error: e.message }));
            }
            return;
        }

        // POST /api/yaml/safe-parse — SAFE: calls yaml.safeLoad()
        if (parsed.pathname === '/api/yaml/safe-parse') {
            try {
                var input = JSON.parse(body);
                if (!input.yaml || typeof input.yaml !== 'string') {
                    res.writeHead(400);
                    res.end(JSON.stringify({ error: 'Provide {"yaml": "<yaml string>"}' }));
                    return;
                }

                // SAFE: safeLoad() uses DEFAULT_SAFE_SCHEMA — rejects !!js/* types
                var result = yaml.safeLoad(input.yaml);
                res.end(JSON.stringify({
                    status: 'safe_parsed',
                    result_type: typeof result,
                    note: 'safeLoad() successfully parsed — no dangerous types'
                }));
            } catch (e) {
                res.end(JSON.stringify({
                    status: 'rejected',
                    error: e.message.split('\n')[0],
                    note: 'safeLoad() correctly rejected dangerous YAML type'
                }));
            }
            return;
        }

        // POST /api/pipeline/create — calls actual createPipeline()
        if (parsed.pathname === '/api/pipeline/create') {
            if (!createPipeline) {
                res.writeHead(503);
                res.end(JSON.stringify({
                    error: 'createPipeline() is not available in this environment',
                    note: 'The Integration Assistant plugin module could not be loaded'
                }));
                return;
            }

            try {
                var state = JSON.parse(body);
                var pipeline = createPipeline(state);

                // Walk the pipeline result for dangerous types
                var findings = findDangerousTypes(pipeline);

                if (findings.length > 0) {
                    res.end(JSON.stringify({
                        status: 'rce_via_createPipeline',
                        note: 'createPipeline() rendered YAML with !!js/function via Nunjucks → yaml.load()',
                        findings: findings,
                        pipeline_keys: pipeline ? Object.keys(pipeline) : null,
                        processor_count: pipeline && pipeline.processors ? pipeline.processors.length : 0
                    }));
                } else {
                    res.end(JSON.stringify({
                        status: 'pipeline_created',
                        pipeline_keys: pipeline ? Object.keys(pipeline) : null,
                        processor_count: pipeline && pipeline.processors ? pipeline.processors.length : 0
                    }));
                }
            } catch (e) {
                res.writeHead(500);
                res.end(JSON.stringify({ status: 'error', error: e.message }));
            }
            return;
        }

        res.writeHead(404);
        res.end(JSON.stringify({ error: 'Not Found' }));
    }).catch(function (e) {
        res.writeHead(500);
        res.end(JSON.stringify({ status: 'error', error: e.message }));
    });
});

var PORT = 8080;
server.listen(PORT, '0.0.0.0', function () {
    console.log('[*] CVE-2024-37288 Vulnerable Demo Server');
    console.log('[*] js-yaml ' + yamlVersion + ' with DEFAULT_FULL_SCHEMA');
    console.log('[*] createPipeline: ' + (createPipeline ? 'available' : 'unavailable'));
    console.log('[*] Listening on 0.0.0.0:' + PORT);
});
