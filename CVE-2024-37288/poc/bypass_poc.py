#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CVE-2024-37288 — Kibana YAML Deserialization Bypass Analysis
# Author         : Exploit Intelligence Platform
# Vendor         : Elastic
# Software       : Kibana 8.15.1 (patched)
# CVE            : CVE-2024-37288
# CWE            : CWE-502 (Deserialization of Untrusted Data)
# CVSS           : 9.9 (CRITICAL)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2024-37288 Bypass Analysis PoC
===================================
Tests multiple bypass vectors against the patched Kibana 8.15.1 container
to determine if the fix (load() -> safeLoad()) can be circumvented.

The fix replaces js-yaml v3.14.1's unsafe load() function with safeLoad(),
which uses DEFAULT_SAFE_SCHEMA instead of DEFAULT_FULL_SCHEMA, blocking
JavaScript-specific YAML types (!!js/function, !!js/regexp, !!js/undefined).

This script tests all identified bypass vectors:
  1. %TAG directive injection (redefine tag prefix to resolve to js/ types)
  2. YAML version directive override (attempt schema change via %YAML)
  3. Explicit tag URI with encoding (URL encoding, unicode, null bytes)
  4. Prototype pollution via safeLoad (__proto__, constructor.prototype)
  5. Nunjucks template injection (SSTI via variable values)
  6. YAML structure injection via unsanitized packageName (newlines)
  7. YAML anchor bomb (DoS via exponential expansion)
  8. Alternative YAML types (!!binary, !!merge, etc.)

Result: ALL bypass attempts FAIL. The fix is complete.

Usage:
    python3 bypass_poc.py <container_name>
    python3 bypass_poc.py cve-2024-37288-kibana-patched
"""

import subprocess
import sys
import json
import textwrap


def run_in_container(container: str, js_code: str, timeout: int = 30) -> tuple[int, str, str]:
    """Execute JavaScript code inside the Kibana container."""
    node_path = "/usr/share/kibana/node/glibc-217/bin/node"
    try:
        result = subprocess.run(
            ["docker", "exec", "-w", "/usr/share/kibana", container, node_path, "-e", js_code],
            capture_output=True, text=True, timeout=timeout,
        )
        return result.returncode, result.stdout.strip(), result.stderr.strip()
    except subprocess.TimeoutExpired:
        return -1, "", "TIMEOUT"
    except Exception as e:
        return -1, "", str(e)


def test_vector(container: str, name: str, js_code: str) -> dict:
    """Run a bypass test vector and return results."""
    code, stdout, stderr = run_in_container(container, js_code)
    # Only count as bypass if the output starts with "BYPASS:" (our explicit marker)
    bypassed = stdout.strip().startswith("BYPASS:")
    return {
        "name": name,
        "success": code == 0,
        "bypassed": bypassed,
        "output": stdout,
        "error": stderr[:200] if stderr else "",
    }


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <container_name>")
        print(f"  e.g.: {sys.argv[0]} cve-2024-37288-kibana-patched")
        sys.exit(1)

    container = sys.argv[1]
    print("=" * 70)
    print("CVE-2024-37288: Bypass Analysis Against Patched Container")
    print("=" * 70)
    print(f"\nTarget container: {container}")

    # Verify container is running and get version
    code, stdout, stderr = run_in_container(container, '''
const pkg = require("/usr/share/kibana/package.json");
const yamlPkg = require("js-yaml/package.json");
console.log(JSON.stringify({
    kibana_version: pkg.version,
    jsyaml_version: yamlPkg.version
}));
''')
    if code != 0:
        print(f"\n[ERROR] Cannot connect to container {container}: {stderr}")
        sys.exit(1)

    info = json.loads(stdout)
    print(f"  Kibana version: {info['kibana_version']}")
    print(f"  js-yaml version: {info['jsyaml_version']}")

    # Verify the fix is applied
    code, stdout, stderr = run_in_container(container, '''
const fs = require("fs");
const code = fs.readFileSync("/usr/share/kibana/node_modules/@kbn/integration-assistant-plugin/server/graphs/ecs/pipeline.js", "utf8");
const hasSafeLoad = code.includes("safeLoad");
const hasUnsafeLoad = /[^e]load\\b/.test(code.replace(/safeLoad/g, ""));
console.log(JSON.stringify({ hasSafeLoad, hasUnsafeLoad }));
''')
    fix_info = json.loads(stdout)
    fix_applied = fix_info["hasSafeLoad"] and not fix_info["hasUnsafeLoad"]
    print(f"  Fix applied: {'YES' if fix_applied else 'NO'} (safeLoad={fix_info['hasSafeLoad']}, unsafeLoad={fix_info['hasUnsafeLoad']})")

    results = []
    total_bypassed = 0

    # =========================================================================
    # VECTOR 1: %TAG Directive Injection
    # =========================================================================
    print("\n" + "-" * 70)
    print("[1] %TAG Directive Injection")
    print("    Hypothesis: Redefine !! tag prefix to resolve to js/ URI")
    print("-" * 70)

    r = test_vector(container, "TAG_redirect_!!", '''
const yaml = require("js-yaml");
try {
    const payload = "%TAG !! tag:yaml.org,2002:js/\\n---\\ntest: !!function >\\n  function() { return 42; }";
    const result = yaml.safeLoad(payload);
    if (typeof result.test === "function") {
        console.log("BYPASS: !!function resolved via %TAG redirect");
    } else {
        console.log("SAFE: Parsed but not a function, type=" + typeof result.test);
    }
} catch(e) {
    console.log("BLOCKED: " + e.message.slice(0,100));
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    r = test_vector(container, "TAG_custom_!js!", '''
const yaml = require("js-yaml");
try {
    const payload = "%TAG !js! tag:yaml.org,2002:js/\\n---\\ntest: !js!function >\\n  function() { return 42; }";
    const result = yaml.safeLoad(payload);
    console.log(typeof result.test === "function" ? "BYPASS" : "SAFE: type=" + typeof result.test);
} catch(e) {
    console.log("BLOCKED: " + e.message.slice(0,100));
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    # =========================================================================
    # VECTOR 2: YAML Version Directive
    # =========================================================================
    print("\n" + "-" * 70)
    print("[2] YAML Version Directive Override")
    print("    Hypothesis: %YAML directive might change schema selection")
    print("-" * 70)

    for version in ["1.1", "1.2"]:
        r = test_vector(container, f"YAML_{version}_directive", f'''
const yaml = require("js-yaml");
try {{
    const payload = "%YAML {version}\\n---\\ntest: !!js/function >\\n  function() {{ return 42; }}";
    const result = yaml.safeLoad(payload);
    console.log(typeof result.test === "function" ? "BYPASS" : "SAFE");
}} catch(e) {{
    console.log("BLOCKED: " + e.message.slice(0,100));
}}
''')
        results.append(r)
        print(f"    YAML {version}: {r['output']}")

    # =========================================================================
    # VECTOR 3: Tag Encoding Bypasses
    # =========================================================================
    print("\n" + "-" * 70)
    print("[3] Tag Encoding Bypasses")
    print("    Hypothesis: Encoding variants might evade tag matching")
    print("-" * 70)

    encoding_tests = [
        ("Explicit URI", '!<tag:yaml.org,2002:js/function> "function(){return 42}"'),
        ("URL-encoded slash", '!!js%2Ffunction "function(){return 42}"'),
        ("Mixed case", '!!js/Function "function(){return 42}"'),
        ("Null byte", '!!js/function\\x00 "function(){return 42}"'),
        ("Unicode fullwidth", '!!\\uff4a\\uff53/function "function(){return 42}"'),
    ]

    for name, tag_payload in encoding_tests:
        # Need to escape the payload properly for the JS string
        r = test_vector(container, f"Encoding_{name}", f'''
const yaml = require("js-yaml");
try {{
    const result = yaml.safeLoad('test: {tag_payload}');
    console.log(typeof result.test === "function" ? "BYPASS" : "SAFE: type=" + typeof result.test);
}} catch(e) {{
    console.log("BLOCKED: " + e.message.slice(0,80));
}}
''')
        results.append(r)
        print(f"    {name}: {r['output']}")

    # =========================================================================
    # VECTOR 4: Prototype Pollution
    # =========================================================================
    print("\n" + "-" * 70)
    print("[4] Prototype Pollution via safeLoad")
    print("    Hypothesis: __proto__ or constructor keys might pollute Object.prototype")
    print("-" * 70)

    r = test_vector(container, "Proto_pollution", '''
const yaml = require("js-yaml");

// Test __proto__ pollution
yaml.safeLoad("__proto__:\\n  polluted1: yes");
const test1 = {}.polluted1;

// Test constructor.prototype pollution
yaml.safeLoad("constructor:\\n  prototype:\\n    polluted2: yes");
const test2 = {}.polluted2;

// Test nested __proto__
yaml.safeLoad("a:\\n  __proto__:\\n    polluted3: yes");
const test3 = {}.polluted3;

// Check global state
const globalPolluted = test1 !== undefined || test2 !== undefined || test3 !== undefined;
if (globalPolluted) {
    console.log("BYPASS: Global prototype pollution detected! " + JSON.stringify({test1, test2, test3}));
} else {
    console.log("SAFE: No global prototype pollution (__proto__=" + test1 + ", constructor=" + test2 + ", nested=" + test3 + ")");
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    # =========================================================================
    # VECTOR 5: Nunjucks Template Injection (SSTI)
    # =========================================================================
    print("\n" + "-" * 70)
    print("[5] Nunjucks Template Injection (SSTI)")
    print("    Hypothesis: Template syntax in variables might be evaluated")
    print("-" * 70)

    r = test_vector(container, "Nunjucks_SSTI", '''
const nunjucks = require("nunjucks");
const env = new nunjucks.Environment(null, { autoescape: false });
const template = nunjucks.compile("Hello {{ name }}", env);

// Test template syntax injection
const tests = [
    { name: "{{ 7*7 }}", expected: "Hello {{ 7*7 }}" },
    { name: "{% for i in range(3) %}X{% endfor %}", expected: "Hello {% for i in range(3) %}X{% endfor %}" },
];

let bypassed = false;
for (const t of tests) {
    const result = template.render({ name: t.name });
    if (result !== t.expected) {
        console.log("BYPASS: Template syntax was evaluated! Got: " + result);
        bypassed = true;
    }
}
if (!bypassed) {
    console.log("SAFE: Template syntax in variables is NOT evaluated (rendered literally)");
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    # =========================================================================
    # VECTOR 6: YAML Structure Injection via packageName
    # =========================================================================
    print("\n" + "-" * 70)
    print("[6] YAML Structure Injection via packageName")
    print("    Hypothesis: Newlines in packageName inject YAML structure")
    print("-" * 70)

    r = test_vector(container, "YAML_structure_injection", '''
const yaml = require("js-yaml");
const nunjucks = require("nunjucks");

const templatesPath = "/usr/share/kibana/node_modules/@kbn/integration-assistant-plugin/server/templates";
const env = new nunjucks.Environment(new nunjucks.FileSystemLoader(templatesPath), { autoescape: false });
env.addFilter("startswith", function(str, prefix) { return str.startsWith(prefix); });

const template = env.getTemplate("pipeline.yml.njk");

// Try injecting YAML key via newline in packageName
const maliciousName = "test\\ninjected_key: injected_value";
const values = {
    processors: [{ rename: { field: "a", target_field: "b", ignore_missing: true } }],
    ecs_version: "8.11.0",
    package_name: maliciousName,
    data_stream_name: "stream",
    log_format: "json",
    fields_to_remove: []
};

try {
    const rendered = template.render(values);
    const parsed = yaml.safeLoad(rendered);
    if (parsed && parsed.injected_key) {
        // Even if key injection works, check if it can contain dangerous types
        console.log("PARTIAL: YAML key injection succeeded (value=" + parsed.injected_key + ") but only safe types");
    } else {
        console.log("SAFE: No key injection in parsed result");
    }
} catch(e) {
    console.log("SAFE: Structure injection caused YAML parse error: " + e.message.slice(0,80));
    console.log("NOTE: Parse error = DoS potential but NOT code execution");
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    # =========================================================================
    # VECTOR 7: YAML Anchor/Alias Bomb (DoS)
    # =========================================================================
    print("\n" + "-" * 70)
    print("[7] YAML Anchor/Alias Bomb (DoS)")
    print("    Hypothesis: Exponential expansion via anchors causes resource exhaustion")
    print("-" * 70)

    r = test_vector(container, "Anchor_bomb", '''
const yaml = require("js-yaml");
const bomb = `
a: &a ["x","x","x","x","x","x","x","x","x","x"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c,*c]
`;
const start = Date.now();
const result = yaml.safeLoad(bomb);
const elapsed = Date.now() - start;
const size = JSON.stringify(result).length;
if (elapsed > 1000) {
    console.log("PARTIAL_DOS: Parsing took " + elapsed + "ms, output " + size + " bytes");
} else {
    console.log("SAFE: Anchor bomb parsed in " + elapsed + "ms (" + size + " bytes) - no significant DoS");
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    # =========================================================================
    # VECTOR 8: safeLoad + schema override via options
    # =========================================================================
    print("\n" + "-" * 70)
    print("[8] safeLoad with Schema Override")
    print("    Hypothesis: Can options be injected to change the schema?")
    print("-" * 70)

    r = test_vector(container, "Schema_override", '''
const yaml = require("js-yaml");

// safeLoad internally calls load({schema: DEFAULT_SAFE_SCHEMA})
// Check if there is any way for YAML content to influence the schema
console.log("safeLoad source: " + yaml.safeLoad.toString().replace(/\\s+/g, " ").slice(0, 120));

// Even if we pass FULL_SCHEMA as option, safeLoad overrides it
// (this is a code-level attack, not a YAML-level bypass)
try {
    const r = yaml.safeLoad("test: !!js/function \\"function(){return 42}\\"", {schema: yaml.DEFAULT_FULL_SCHEMA});
    if (typeof r.test === "function") {
        console.log("CODE_LEVEL_ONLY: safeLoad with FULL_SCHEMA works, but attacker cannot control options");
    }
} catch(e) {
    console.log("BLOCKED: Even with FULL_SCHEMA option, blocked: " + e.message.slice(0,80));
}
''')
    results.append(r)
    print(f"    Result: {r['output']}")

    # =========================================================================
    # Summary
    # =========================================================================
    print("\n" + "=" * 70)
    print("BYPASS ANALYSIS SUMMARY")
    print("=" * 70)

    bypassed_count = sum(1 for r in results if r["bypassed"])
    total = len(results)

    for r in results:
        status = "[BYPASS!]" if r["bypassed"] else "[SAFE]"
        print(f"  {status} {r['name']}")

    print(f"\nTotal tests: {total}")
    print(f"Bypasses found: {bypassed_count}")

    if bypassed_count > 0:
        print("\n[!!!] FIX IS INCOMPLETE — bypass(es) found!")
        sys.exit(1)
    else:
        print("\n[OK] FIX IS COMPLETE — no bypasses found")
        print("     safeLoad() in js-yaml 3.14.1 effectively blocks all")
        print("     JavaScript-specific YAML types. The CVE-2024-37288 fix")
        print("     adequately addresses the root cause.")
        sys.exit(0)


if __name__ == "__main__":
    main()
