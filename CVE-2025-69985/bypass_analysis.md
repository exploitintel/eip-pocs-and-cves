# Bypass Analysis: CVE-2025-69985

## Summary

**Fix Status: INCOMPLETE — Multiple bypasses confirmed on the patched version.**

Three distinct bypass vectors were identified and verified against the latest patched version (FUXA master branch, commit `427d2f63`). The most critical bypass — JWT token forgery via hardcoded secret — achieves full unauthenticated RCE on the patched version with `secureEnabled=true`, using a completely different technique than the original Referer-based bypass.

---

## Fix Analysis

### What the Fix Addresses

The CVE-2025-69985 fix spans multiple commits, with the **actual effective fix** being commit `5e7679b0` ("Security Fix: Node‑RED Auth Hardening + Legacy Mode Compatibility #2182"):

1. **Node-RED `httpNodeRoot` changed from `/` to `/dashboard`** — Previously, `app.use('/', allowDashboard, RED.httpNode)` intercepted ALL HTTP requests through the `allowDashboard` middleware. This middleware contained a Referer header check that, when bypassed, allowed unauthenticated access to all API endpoints. By changing the mount to `/dashboard`, the `allowDashboard` middleware no longer intercepts API routes like `/api/runscript`.

2. **Referer bypass removed from `allowDashboard`** — The old Referer check (`['/editor', '/viewer', '/lab', '/home', '/fuxa', '/flows', '/nodered'].some(p => referer.includes(p))`) was replaced with proper JWT token and API key verification.

3. **`child_process` and `net` removed from Node-RED globals** — Now only available when `settings.nodeRedUnsafeModules` is explicitly enabled.

Additionally:
- Commit `37f9876f` ("security: fix auth bypass in heartbeat token refresh") — Fixed token forgery via `x-auth-user` header injection and added `isAuthenticated` flag to `verifyToken`.
- Commit `4246c40a` ("feat: enforcing auth middleware and validating/sandboxing the destination path") — Added auth middleware to `/api/upload` and path traversal protection.

### What the Fix Does NOT Address

1. **Hardcoded JWT secret** — The default secret `frangoteam751` remains hardcoded in `server/api/jwt-helper.js` line 6. No fix commit changes this or requires users to set a custom secret.
2. **`verifyToken` never rejects** — The middleware auto-generates guest JWTs and always calls `next()`, never returning 401.
3. **Insecure default configuration** — `secureEnabled` defaults to `false`/`undefined`, disabling ALL authentication.
4. **No code execution sandboxing** — `runTestScript` still uses `Module._compile()` with unrestricted Node.js access.
5. **`requireAuth` Referer bypass preserved** — The function in `jwt-helper.js` still trusts the Referer header, though it's now only used for Node-RED legacy mode.

---

## Bypass 1: JWT Token Forgery via Hardcoded Secret (CRITICAL)

### Hypothesis

The JWT signing secret defaults to `frangoteam751` (hardcoded at `server/api/jwt-helper.js:6`). None of the fix commits change this default or require configuration of a custom secret when enabling `secureEnabled=true`. An attacker who knows this default (it's in the public source code) can forge admin JWTs and bypass all authentication.

### Method

1. Construct a JWT payload with `{id: "admin", groups: -1}` (where `-1` is the admin group constant)
2. Sign it with HS256 using the known default secret `frangoteam751`
3. Send to `/api/runscript` with `x-access-token: <forged_token>` header
4. The `verifyToken` middleware validates the token against the same secret → `req.userId = "admin"`, `req.userGroups = -1`, `req.isAuthenticated = true`
5. `verifyGroups` returns admin permission (`-1`)
6. `isAuthorised` confirms admin access → RCE achieved

### Bypass Script

**Location**: `poc/bypass_poc.py`

**Usage**: `python3 bypass_poc.py <target> 1881 --bypass 1 -c "id"`

### Test Results — SUCCESSFUL ✅

**Against PATCHED container** (commit `427d2f63`, `secureEnabled=true`):
```
[*] Step 1: Verify auth is enforced (no token)...
    HTTP 400: {"error":"unauthorized_error","message":"Unauthorized!"}

[*] Step 2: Forging admin JWT with hardcoded secret...
    Token: eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJpZCI6I...

[*] Step 3: Executing RCE with forged admin token...
    HTTP 200

[+] SUCCESS — BYPASS CONFIRMED!
[+] Forged JWT with hardcoded secret achieved RCE on patched version!

COMMAND OUTPUT: uid=0(root) gid=0(root) groups=0(root)
```

**Against VULNERABLE container** (v1.2.8, Referer bypass path):
```
[*] Step 1: Verify auth is enforced (no token)...
    HTTP 401: {"error":"unauthorized_error","message":"Authentication required!"}

[*] Step 3: Executing RCE with forged admin token...
    HTTP 200

[+] SUCCESS — uid=0(root) gid=0(root) groups=0(root)
```

**Confirmation**: This bypass uses a completely DIFFERENT technique (JWT forgery) than the original PoC (Referer header spoofing). It works on BOTH vulnerable and patched versions.

### Severity Assessment

- **CVSS**: 9.8 CRITICAL (same as original CVE — unauthenticated RCE)
- **Impact**: Full arbitrary code execution as root on the target system
- **Pre-auth**: Yes — no credentials required, only knowledge of the default secret (publicly available in source code)
- **Exploitability**: Trivial — requires only constructing a JWT with a known secret
- **Constitutes new vulnerability**: Arguably yes — this is CWE-798 (Use of Hard-coded Credentials) rather than CWE-288 (Authentication Bypass via Alternate Path)

### Recommended Fix

1. Generate a random secret on first startup when `secureEnabled=true`
2. Refuse to start with the default secret `frangoteam751` when security is enabled
3. Display a warning if the secret is not explicitly configured
4. Consider using asymmetric JWT signing (RS256) instead of shared-secret HS256

---

## Bypass 2: Insecure Default Configuration (HIGH)

### Hypothesis

The fix only takes effect when `secureEnabled=true`. However, the default configuration ships with `secureEnabled` set to `false`/`undefined`. With the default configuration, the `verifyApiOrToken` middleware immediately calls `next()` without any authentication check, and `verifyGroups` returns `-1` (admin permission).

### Method

1. Send POST `/api/runscript` with RCE payload — NO authentication headers needed
2. `verifyApiOrToken` → `!runtime.settings.secureEnabled` (undefined) → `true` → `next()`
3. `verifyGroups` → `secureEnabled=false` → returns `-1` (admin)
4. `isAuthorised` → `admin=true` → passes
5. `runTestScript` → arbitrary code execution

### Test Results — SUCCESSFUL ✅

**Against PATCHED container with DEFAULT config** (`secureEnabled=false`):
```
[*] Sending POST /api/runscript (no auth headers)...
    HTTP 200

[+] SUCCESS — BYPASS CONFIRMED!
[+] Default config allows unauthenticated RCE on patched version!

COMMAND OUTPUT: uid=0(root) gid=0(root) groups=0(root)
```

**Against PATCHED container with `secureEnabled=true`**:
```
[*] Sending POST /api/runscript (no auth headers)...
    HTTP 400: {"error":"unauthorized_error","message":"Unauthorized!"}
[-] RCE blocked — secureEnabled is true
```

### Severity Assessment

- **CVSS**: 9.8 CRITICAL (unauthenticated RCE)
- **Impact**: Full admin-level RCE on every default FUXA installation
- **Scope**: ALL FUXA installations that have not explicitly enabled `secureEnabled=true`
- **Constitutes new vulnerability**: This is the same fundamental design flaw — insecure by default. Could be classified as CWE-1188 (Initialization with an Insecure Default).

### Recommended Fix

1. Enable `secureEnabled=true` by default
2. Force security setup on first run (require admin account creation)
3. Add a startup warning when running without authentication
4. Remove the `secureEnabled=false` → "skip all auth" code path

---

## Bypass 3: Information Disclosure via Guest Pass-through (MEDIUM)

### Hypothesis

The `verifyToken` middleware NEVER rejects requests. When no `x-access-token` is provided, it auto-generates a guest JWT and always calls `next()`. With `secureEnabled=true`, this means unauthenticated users get guest-level access to all endpoints. Many endpoints don't have additional authorization checks beyond the middleware.

### Method

1. Send GET requests to various API endpoints with NO authentication headers
2. `verifyApiOrToken` → `secureEnabled=true` → calls `verifyToken`
3. `verifyToken` → no token → generates guest token → `userId="guest"` → `next()` (NEVER rejects)
4. Endpoints without additional group/permission checks return data

### Test Results — SUCCESSFUL ✅

**Against PATCHED container with `secureEnabled=true`**:

| Endpoint | Status | Data Exposed |
|----------|--------|-------------|
| GET /api/project | 200 | SCADA project configs, device definitions |
| GET /api/settings | 200 | Filesystem paths (appDir, dbDir, workDir), server config |
| GET /api/alarms | 200 | Alarm configurations |
| GET /api/users | 401 | BLOCKED (has additional admin check) |

3 out of 4 tested endpoints are accessible to unauthenticated guests.

### Severity Assessment

- **CVSS**: ~5.3 MEDIUM (CWE-200: Exposure of Sensitive Information)
- **Impact**: Reconnaissance data for further attacks; SCADA device configuration exposure
- **ICS Context**: In SCADA/HMI environments, project data may contain industrial control device connection strings (Modbus, OPC-UA, BACnet)
- **Constitutes new vulnerability**: This is a design flaw in `verifyToken` (CWE-306: Missing Authentication for Critical Function)

### Recommended Fix

1. `verifyToken` should return 401 when no valid token is provided (instead of auto-generating guest JWT)
2. Add explicit authorization checks to all data-access endpoints
3. Implement a whitelist of endpoints accessible without authentication (e.g., `/api/version`, `/api/auth/login`)

---

## Vulnerability Chain Deep-Dive

### How the Original Vulnerability Actually Worked (v1.2.8)

The actual vulnerability mechanism on v1.2.8 was more subtle than the Referer bypass in `requireAuth`. The Node-RED integration mounted a global middleware at the root path:

```javascript
// server/integrations/node-red/index.js (v1.2.8)
app.use('/', allowDashboard, RED.httpNode);  // Intercepts ALL requests
```

The `allowDashboard` middleware checked the Referer header with patterns like `/fuxa`, `/editor`, etc. If matched, it called `next()`. If not matched, it fell through to `requireAuth` which returned 401 without a valid token.

This means:
- **Without Referer**: `allowDashboard` → `requireAuth` → 401
- **With Referer containing `/fuxa`**: `allowDashboard` → `next()` → API route → `verifyApiOrToken` → `secureEnabled=false` → admin → RCE

The `requireAuth` function in `jwt-helper.js` was never directly called for `/api/runscript` — it was only used as a fallback in the `allowDashboard` middleware.

### How the Fix Works

The fix (commit `5e7679b0`) changes the Node-RED mount from `/` to `/dashboard`, so `allowDashboard` no longer intercepts API routes. API requests go directly through `verifyApiOrToken` → `verifyToken`.

### Why the Fix is Incomplete

1. The hardcoded JWT secret (`frangoteam751`) allows token forgery, achieving the same result as the Referer bypass — full admin RCE.
2. The default `secureEnabled=false` configuration means the fix only works for explicitly configured installations.
3. The `verifyToken` function still never rejects guests, leaking data through endpoints without additional authorization.

---

## Files

| File | Purpose |
|------|---------|
| `poc/bypass_poc.py` | Comprehensive bypass PoC (all 3 vectors) |
| `Dockerfile.patched` | Patched container Dockerfile |

## Containers Used

| Container | Image | Config | Role |
|-----------|-------|--------|------|
| `cve-2025-69985-vulnerable` | `frangoteam/fuxa:1.2.8` | secureEnabled=undefined | Original vulnerable version |
| `cve-2025-69985-patched` | `lab-patched` (master 427d2f63) | secureEnabled=true | Patched with security enabled |
| `cve-2025-69985-patched-default` | `lab-patched` (master 427d2f63) | secureEnabled=false | Patched with default config |

---

## Confidence Assessment

| Bypass | Confidence | Verified |
|--------|-----------|----------|
| Bypass 1 (JWT Forgery) | **100%** — Confirmed RCE on patched container | ✅ |
| Bypass 2 (Insecure Default) | **100%** — Confirmed RCE on patched default | ✅ |
| Bypass 3 (Info Disclosure) | **100%** — 3/4 endpoints exposed as guest | ✅ |

**Overall assessment**: The fix for CVE-2025-69985 addresses the specific Referer header bypass vector but leaves multiple alternative attack paths open. The most critical (Bypass 1: JWT token forgery) achieves the identical impact — unauthenticated RCE — using a different mechanism. The fix should be considered **incomplete**.
