# Bypass Analysis: CVE-2026-28370

## Executive Summary

**Bypass Result: NO BYPASS FOUND -- Fix is COMPLETE**

The fix for CVE-2026-28370 (commit `5b57e2b32a6d02992a28d9a671ebba5e308fd141`) completely eliminates the `eval()` injection vulnerability by replacing string expression building with direct closure-based function composition. Seven distinct bypass hypotheses were tested against the patched version (Vitrage 12.0.1), encompassing 30+ individual payloads across multiple attack categories. **All bypass attempts failed.** The fix addresses the root cause (using `eval()` on user-controlled input) rather than attempting to sanitize input, making it fundamentally resistant to bypass.

**Confidence Level: HIGH (95%+)** -- The fix eliminates the entire attack class, not just specific payloads.

---

## Fix Under Analysis

| Field | Value |
|---|---|
| **Fix Commit** | `5b57e2b32a6d02992a28d9a671ebba5e308fd141` |
| **Fix Title** | "Replace eval with function matching" |
| **Vulnerable Version Tested** | Vitrage 12.0.0 (tag `12.0.0`) |
| **Patched Version Tested** | Vitrage 12.0.1 (tag `12.0.1`) |
| **Test Environment** | Docker containers (`python:3.10-slim-bookworm`) |

### What the Fix Changes

The fix makes a **fundamental architectural change** to the query predicate builder:

| Aspect | Before (Vulnerable) | After (Patched) |
|---|---|---|
| **Approach** | Build expression string -> `eval()` | Build function closures directly |
| **User input handling** | Interpolated into code string via `_evaluable_str()` | Captured as closure variables (`f=field, v=value`) |
| **Operator resolution** | Part of concatenated string | Lookup in fixed `ops` dict -> `operator.*` functions |
| **Logical operators** | String joining with `' and '`/`' or '` | `all()`/`any()` over predicate lists |
| **Dangerous functions** | `eval()`, `_evaluable_str()`, `_create_query_expression()`, `_join_logical_operator()` | All removed |
| **Added** | N/A | `import operator`, `ops` dict, `_create_query_function()` |

### Key Security Property

In the patched code, user-supplied values (field names, comparison values) are **never** part of any code string. They exist only as data values captured in Python closures:

```python
# PATCHED -- user values are closure variables, not code
lambda item, f=field, v=value: op_func(item.get(f), v)
```

This means regardless of what characters or content the user supplies (quotes, Python code, special characters, etc.), the values are always treated as **data to compare against**, never as **code to execute**.

---

## Bypass Hypotheses Tested

### Hypothesis 1: Original eval() Injection Payloads

**Rationale**: Test whether the original CVE payloads (single-quote breakout from string literal) have any effect on the patched code.

**Payloads tested** (4 variants):
1. Value injection: `{"==": {"x": "' + str(open(...)...) + '"}}`
2. Key injection: `{"==": {"' + str(open(...)...) + '": "x"}}`
3. `__import__` injection: `{"==": {"x": "' + str(__import__('os').popen('...').read()) + '"}}`
4. Double-quote variant: `{"==": {"x": "\" + str(open(...)...) + \""}}`

**Result**: All failed -- Payloads treated as literal string values for comparison. No code execution occurred.

**Why it fails**: There is no `eval()` call and no string expression construction. The malicious string `"' + str(open(...)) + '"` is simply stored as the closure variable `v` and compared using `operator.eq(item.get(f), v)`. The single quotes have no special meaning.

---

### Hypothesis 2: Type Confusion via Non-String JSON Values

**Rationale**: JSON can encode dicts, lists, booleans, null, and special floats as values. Test if non-string types cause unexpected code evaluation.

**Payloads tested** (5 variants):
1. Dict as comparison value: `{"==": {"x": {"__import__('os')...": True}}}`
2. List as comparison value: `{"==": {"x": ["__import__('os')..."]}}`
3. Boolean value: `{"==": {"x": True}}`
4. Null value: `{"==": {"x": None}}`
5. Infinity: `{"==": {"x": Infinity}}`

**Result**: All failed -- Non-string values are compared using `operator.eq()` which simply calls Python's comparison protocol. No code execution.

**Why it fails**: The `operator.*` functions compare values using standard Python comparison methods (`__eq__`, etc.). For JSON-decoded types (str, int, float, bool, None, dict, list), these methods are all safe -- they perform data comparison only.

---

### Hypothesis 3: Operator Key Injection

**Rationale**: The fix uses the top-level dict key as the operator name, looked up in the `ops` dict. Test if crafted operator keys can bypass the fixed lookup.

**Payloads tested** (6 variants):
1. Python expression as operator: `{"__import__('os').system(...)": {"x": "y"}}`
2. Lambda as operator: `{"lambda: ...": {"x": "y"}}`
3. `eval` as operator: `{"eval": {"x": "y"}}`
4. `exec` as operator: `{"exec": {"x": "y"}}`
5. Single equals: `{"=": {"x": "y"}}`
6. Empty string: `{"": {"x": "y"}}`

**Result**: All failed -- All invalid operators correctly raise `VitrageError('invalid partial query format', ...)`.

**Why it fails**: The code checks `parent_operator in operators` (a fixed list of 6 comparison operators) and `parent_operator in logical_operations` (a fixed list: `'and'`, `'or'`). Any operator not in these lists falls to the `else` clause which raises `VitrageError`. The operator string is never evaluated as code.

---

### Hypothesis 4: Python Dunder Method / Special Method Abuse

**Rationale**: Test if Python special method strings, format strings, or template syntax can trigger code evaluation when used as comparison values.

**Payloads tested** (5 variants):
1. Class hierarchy traversal: `"__class__.__mro__[1].__subclasses__()"`
2. Format string injection: `"{0.__class__.__init__.__globals__}"`
3. Template syntax: `"${7*7}"`
4. Null byte injection: `"\x00' + __import__('os')..."`
5. Very long string (100KB): Buffer overflow attempt

**Result**: All failed -- All values treated as literal strings for comparison.

**Why it fails**: The comparison is `operator.eq(item.get(f), v)` where `v` is the literal Python string object. No template rendering, format string processing, or string evaluation occurs.

---

### Hypothesis 5: Unicode Normalization / Encoding Bypass

**Rationale**: Test if Unicode variants of the quote character or encoding tricks can cause the patched code to interpret values as code.

**Payloads tested** (6 variants):
1. Unicode left/right single quotation marks (`\u2018`/`\u2019`)
2. Full-width apostrophe (`\uff07`)
3. ASCII single quote (`\u0027` -- same as `'`)
4. Escaped backslash + quote
5. URL-encoded quote (`%27`)
6. Null byte before quote

**Result**: All failed -- Encoding variations have no effect because there is no string parsing or expression evaluation.

**Why it fails**: In the old code, encoding tricks could potentially bypass string escaping. In the patched code, there is no string escaping, no string construction, and no evaluation -- so encoding has no relevance.

---

### Hypothesis 6: Logical Operator Structure Manipulation

**Rationale**: Test if malformed logical operator structures (wrong types, deep nesting) can cause unexpected code paths.

**Payloads tested** (5 variants):
1. `and` with dict value instead of list (should be rejected)
2. `or` with string value instead of list (should be rejected)
3. Deeply nested logical operators with injection payloads
4. Mixed safe and malicious sub-expressions in `and`
5. Empty list for `and` operator

**Result**: All failed -- Malformed structures correctly raise `VitrageError`. Valid nested structures with injection payloads treat them as literal comparison values.

**Why it fails**: The code validates that logical operators receive lists (`isinstance(query, list)`). Deeply nested valid structures still resolve to closure-based predicates -- the injection payloads within are just literal string values.

---

### Hypothesis 7: Operator Module Function Side Effects

**Rationale**: Test if specific value types (NaN, type mismatches, large dicts) can cause the `operator.*` functions to have unexpected side effects.

**Payloads tested** (4 variants):
1. NaN comparison (NaN != NaN behavior)
2. Type mismatch (string vs int with `<` operator)
3. Multiple keys in comparison dict (implicit AND with injection attempts)
4. Very large comparison dict (100 keys)

**Result**: All failed -- NaN comparisons return False (expected). Type mismatches raise TypeError (safe). Large dicts simply create many predicates (no code execution).

**Why it fails**: The `operator.*` functions implement standard Python comparison semantics. They have no side effects that could lead to code execution, regardless of the input values.

---

## Conclusion

### Fix Assessment: COMPLETE

The fix for CVE-2026-28370 is **fundamentally sound and complete**. It addresses the vulnerability at the root cause level by:

1. **Removing the dangerous sink** -- `eval()` is completely eliminated
2. **Removing the dangerous construction** -- No expression strings are ever built from user input
3. **Using a safe alternative** -- Closure-based function composition with the `operator` module
4. **Proper value handling** -- User values are captured as closure variables, never interpolated into code

### Why No Bypass is Possible

The fix changes the **entire approach** from "interpret user input as code" to "use user input as data". This eliminates the entire class of eval injection attacks, not just specific payloads. Key properties:

- **No code strings constructed** -- Nothing to break out of
- **No `eval()` or `exec()`** -- No code evaluation sink
- **Fixed operator mapping** -- Only 6 comparison operators and 2 logical operators are accepted
- **Value isolation** -- User values exist only as Python objects in closures, never as text in code strings

### Confidence Level: HIGH (95%+)

The remaining 5% uncertainty accounts for:
- Theoretical Python interpreter bugs that could cause `operator.eq()` to execute arbitrary code (extremely unlikely)
- Future code changes that might reintroduce dangerous patterns
- Undiscovered Python language-level issues with closure variable capture

### Bypass Script Location

`poc/bypass_poc.py` -- Tests all 7 hypotheses (30+ payloads) against the patched version

### Test Summary

| Hypothesis | Payloads | Result |
|---|---|---|
| H1: Original eval injection | 4 | Fix holds |
| H2: Type confusion | 5 | Fix holds |
| H3: Operator key injection | 6 | Fix holds |
| H4: Dunder/special method abuse | 5 | Fix holds |
| H5: Unicode/encoding bypass | 6 | Fix holds |
| H6: Logical operator manipulation | 5 | Fix holds |
| H7: Operator module side effects | 4 | Fix holds |
| **Total** | **35** | **No bypass found** |
