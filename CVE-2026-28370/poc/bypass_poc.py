#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OpenStack Vitrage eval() Fix Bypass Attempt
# CVE            : CVE-2026-28370
# Vendor         : OpenStack
# Product        : Vitrage
# Affected       : All versions before 12.0.1, 13.0.0, 14.0.0, 15.0.0
# Type           : CWE-95 - Eval Injection
# CVSS           : 9.1 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28370 Bypass Attempt Against Patched Vitrage

Tests whether the fix (commit 5b57e2b3 - "Replace eval with function matching")
in OpenStack Vitrage can be bypassed to achieve code execution.

The fix removes eval() entirely and replaces string expression building with
direct closure-based function composition using the operator module.

This script tests 7 bypass hypotheses against the PATCHED version:

  Hypothesis 1: Original eval injection payloads (single-quote breakout)
  Hypothesis 2: Type confusion via non-string values (dict/list/None)
  Hypothesis 3: Operator key injection (unsupported operators)
  Hypothesis 4: Prototype pollution / dunder method abuse
  Hypothesis 5: Unicode normalization / encoding bypass
  Hypothesis 6: Python expression injection via operator.eq side effects
  Hypothesis 7: Recursive/nested structure exploitation

RESULT: ALL bypass attempts FAIL — fix is COMPLETE.

PREREQUISITES:
  - OpenStack Vitrage 12.0.1+ (patched version)

REFERENCES:
  - CVE-2026-28370
  - https://github.com/openstack/vitrage/commit/5b57e2b32a6d02992a28d9a671ebba5e308fd141
"""

import sys
import os
import json
import traceback

# ============================================================================
# Configuration
# ============================================================================
EVIDENCE_DIR = "/tmp/poc_evidence"
BYPASS_MARKER = os.path.join(EVIDENCE_DIR, "bypass_proof.txt")

# ============================================================================
# Color output helpers
# ============================================================================
GREEN = "\033[92m"
RED = "\033[91m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

def info(msg):
    print(f"{CYAN}[*]{RESET} {msg}")

def success(msg):
    print(f"{GREEN}[+]{RESET} {msg}")

def fail(msg):
    print(f"{RED}[-]{RESET} {msg}")

def warn(msg):
    print(f"{YELLOW}[!]{RESET} {msg}")

def header(msg):
    print(f"\n{BOLD}{'='*70}")
    print(f"  {msg}")
    print(f"{'='*70}{RESET}\n")


# ============================================================================
# Dummy graph vertex for predicate invocation
# ============================================================================
class FakeVertex:
    """Mimics a Vitrage graph vertex object."""
    def __init__(self, data=None):
        self._data = data or {}

    def get(self, key):
        return self._data.get(key, "")

    def __repr__(self):
        return f"FakeVertex({self._data})"


def clean_marker():
    """Remove bypass evidence marker file if it exists."""
    if os.path.exists(BYPASS_MARKER):
        os.remove(BYPASS_MARKER)


def check_bypass():
    """Check if the bypass marker file was created (indicating code execution)."""
    if os.path.exists(BYPASS_MARKER):
        with open(BYPASS_MARKER, 'r') as f:
            content = f.read()
        return True, content
    return False, None


# ============================================================================
# Bypass Hypothesis 1: Original eval injection (single-quote breakout)
# ============================================================================
def test_original_injection():
    """Test the original CVE payload against the patched version.

    The original attack breaks out of a string literal in an eval() expression
    by injecting a single quote. Since eval() is removed, this should fail.
    """
    header("HYPOTHESIS 1: Original eval() Injection Payloads")

    from vitrage.graph.query import create_predicate

    payloads = [
        # Original value injection
        {"==": {"x": "' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('BYPASS1')) + '"}},
        # Key injection
        {"==": {"' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('BYPASS1-KEY')) + '": "x"}},
        # __import__ injection
        {"==": {"x": "' + str(__import__('os').popen('touch /tmp/poc_evidence/bypass_proof.txt').read()) + '"}},
        # Double-quote variant
        {"==": {"x": '" + str(open("/tmp/poc_evidence/bypass_proof.txt","w").write("BYPASS1-DQ")) + "'}},
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        info(f"Testing payload variant {i+1}: {json.dumps(payload)[:100]}...")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                # Try to invoke it
                try:
                    vertex = FakeVertex({"x": "anything"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass - payload treated as literal data (EXPECTED)")
        except Exception as e:
            info(f"  Exception: {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Bypass Hypothesis 2: Type confusion via non-string JSON values
# ============================================================================
def test_type_confusion():
    """Test if non-string value types cause unexpected behavior.

    JSON can encode dicts, lists, booleans, null, and numbers as values.
    Test if any of these cause the patched code to evaluate code strings.
    """
    header("HYPOTHESIS 2: Type Confusion via Non-String Values")

    from vitrage.graph.query import create_predicate

    payloads = [
        # Dict as value
        {"==": {"x": {"__import__('os').system('touch /tmp/poc_evidence/bypass_proof.txt')": True}}},
        # List as value
        {"==": {"x": ["__import__('os').system('touch /tmp/poc_evidence/bypass_proof.txt')"]}},
        # Boolean as value
        {"==": {"x": True}},
        # None as value
        {"==": {"x": None}},
        # Numeric with special value
        {"==": {"x": float('inf')}},
        # Dict as key (will this be iterable?)
        # Note: JSON doesn't allow dict keys but Python does
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        info(f"Testing type confusion variant {i+1}...")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                try:
                    vertex = FakeVertex({"x": "anything"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass (EXPECTED)")
        except Exception as e:
            info(f"  Exception: {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Bypass Hypothesis 3: Operator key injection
# ============================================================================
def test_operator_injection():
    """Test if crafted operator keys can bypass the fixed ops dict.

    The fix uses a fixed 'ops' dict mapping operator strings to operator.*
    functions. Test if we can inject an unsupported operator or manipulate
    the lookup.
    """
    header("HYPOTHESIS 3: Operator Key Injection")

    from vitrage.graph.query import create_predicate

    payloads = [
        # Try Python expression as operator
        {"__import__('os').system('touch /tmp/poc_evidence/bypass_proof.txt')": {"x": "y"}},
        # Try lambda as operator string
        {"lambda: __import__('os').system('id')": {"x": "y"}},
        # Try eval as operator
        {"eval": {"x": "y"}},
        # Try exec as operator
        {"exec": {"x": "y"}},
        # Try = (single equals - was commented out in old code)
        {"=": {"x": "y"}},
        # Try empty string operator
        {"": {"x": "y"}},
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        info(f"Testing operator injection variant {i+1}: key='{list(payload.keys())[0][:60]}'")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                try:
                    vertex = FakeVertex({"x": "y"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass - invalid operator rejected (EXPECTED)")
        except Exception as e:
            info(f"  Exception raised (EXPECTED): {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Bypass Hypothesis 4: Python dunder / special method abuse
# ============================================================================
def test_dunder_abuse():
    """Test if Python special methods on values cause code execution.

    When operator.eq(a, b) is called, Python invokes a.__eq__(b) or
    b.__eq__(a). For JSON-decoded values (str, int, float, bool, None,
    dict, list), these are all safe standard methods.

    However, test if any edge case triggers unexpected behavior.
    """
    header("HYPOTHESIS 4: Python Dunder Method / Special Method Abuse")

    from vitrage.graph.query import create_predicate

    payloads = [
        # String with repr-like content
        {"==": {"x": "__class__.__mro__[1].__subclasses__()"}},
        # String with format spec
        {"==": {"x": "{0.__class__.__init__.__globals__}"}},
        # String with template syntax
        {"==": {"x": "${7*7}"}},
        # Null byte injection
        {"==": {"x": "normal\x00' + __import__('os').system('id') + '"}},
        # Very long string (potential buffer issues)
        {"==": {"x": "A" * 100000}},
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        val = str(list(payload.values())[0])[:80]
        info(f"Testing dunder abuse variant {i+1}: {val}...")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                try:
                    vertex = FakeVertex({"x": "anything"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass - value treated as data (EXPECTED)")
        except Exception as e:
            info(f"  Exception: {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Bypass Hypothesis 5: Unicode normalization / encoding bypass
# ============================================================================
def test_unicode_bypass():
    """Test if Unicode normalization or encoding tricks can bypass the fix.

    In the old code, the single quote was the injection character. Test if
    Unicode variants of quotes or other encoding tricks have any effect.
    """
    header("HYPOTHESIS 5: Unicode Normalization / Encoding Bypass")

    from vitrage.graph.query import create_predicate

    payloads = [
        # Unicode single quote variants
        {"==": {"x": "\u2018 + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('UNICODE')) + \u2019"}},
        # Full-width single quote
        {"==": {"x": "\uff07 + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('FULLWIDTH')) + \uff07"}},
        # Unicode right single quotation mark
        {"==": {"x": "\u0027 + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('U0027')) + \u0027"}},
        # Escaped backslash + quote
        {"==": {"x": "\\' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('ESCAPED')) + \\'"}},
        # URL-encoded-style
        {"==": {"x": "%27 + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('URLENC')) + %27"}},
        # Null byte before quote
        {"==": {"x": "\x00' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('NULL')) + '"}},
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        info(f"Testing unicode/encoding variant {i+1}...")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                try:
                    vertex = FakeVertex({"x": "anything"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass - encoding has no effect (EXPECTED)")
        except Exception as e:
            info(f"  Exception: {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Bypass Hypothesis 6: Logical operator manipulation
# ============================================================================
def test_logical_operator_abuse():
    """Test if crafted logical operator structures can cause issues.

    The fix handles 'and' and 'or' operators. Test edge cases like
    deeply nested structures, mixed types, etc.
    """
    header("HYPOTHESIS 6: Logical Operator Structure Manipulation")

    from vitrage.graph.query import create_predicate

    payloads = [
        # 'and' with non-list value (should raise error)
        {"and": {"==": {"x": "' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('AND-DICT')) + '"}}},
        # 'or' with string value
        {"or": "' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('OR-STR')) + '"},
        # Deeply nested (potential recursion issues)
        {"and": [{"or": [{"and": [{"==": {"x": "' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('DEEP')) + '"}}]}]}]},
        # Mixed operator in list
        {"and": [{"==": {"x": "safe"}}, {"==": {"y": "' + str(open('/tmp/poc_evidence/bypass_proof.txt','w').write('MIX')) + '"}}]},
        # Empty list
        {"and": []},
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        info(f"Testing logical operator variant {i+1}...")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                try:
                    vertex = FakeVertex({"x": "safe", "y": "anything"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass (EXPECTED)")
        except Exception as e:
            info(f"  Exception raised (EXPECTED): {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Bypass Hypothesis 7: Operator module function abuse
# ============================================================================
def test_operator_abuse():
    """Test if the operator module functions themselves can be abused.

    The fix uses operator.eq, operator.lt, etc. These functions simply
    call Python's comparison protocol. Test if supplying specific values
    can cause the comparison to have side effects.
    """
    header("HYPOTHESIS 7: Operator Module Function Side Effects")

    from vitrage.graph.query import create_predicate

    # Test with values that might trigger unusual comparison behavior
    payloads = [
        # NaN (NaN != NaN is True, NaN == NaN is False)
        {"==": {"x": float('nan')}},
        # Compare with different types
        {"<": {"x": "string_compared_to_int"}},
        # Multiple keys in comparison dict (implicit AND)
        {"==": {"a": "1", "b": "2", "c": "' + str(1) + '"}},
        # Very large comparison dict
        {"==": {f"key_{i}": "val" for i in range(100)}},
    ]

    bypassed = False
    for i, payload in enumerate(payloads):
        clean_marker()
        info(f"Testing operator abuse variant {i+1}...")

        try:
            predicate = create_predicate(payload)
            if predicate is not None:
                try:
                    vertex = FakeVertex({"x": 42, "a": "1", "b": "2", "c": "whatever"})
                    result = predicate(vertex)
                    info(f"  Predicate returned: {result}")
                except Exception as e:
                    info(f"  Predicate invocation error: {type(e).__name__}: {e}")

            found, content = check_bypass()
            if found:
                success(f"  BYPASS SUCCESSFUL! Marker content: {content}")
                bypassed = True
            else:
                info(f"  No bypass - safe comparison (EXPECTED)")
        except Exception as e:
            info(f"  Exception: {type(e).__name__}: {e}")

    return bypassed


# ============================================================================
# Main
# ============================================================================
def main():
    print(f"""
{BOLD}{CYAN}╔══════════════════════════════════════════════════════════════════════╗
║   CVE-2026-28370 Bypass Attempt Against Patched Vitrage            ║
║   Fix: commit 5b57e2b3 - "Replace eval with function matching"    ║
║   Testing 7 bypass hypotheses against Vitrage 12.0.1               ║
╚══════════════════════════════════════════════════════════════════════╝{RESET}
""")

    # Verify we're testing the patched version
    import vitrage
    info(f"Vitrage version: {vitrage.__version__}")

    import inspect
    from vitrage.graph.query import create_predicate
    source = inspect.getsource(create_predicate)
    if 'eval(' in source:
        warn("WARNING: eval() found in create_predicate() - this is the VULNERABLE version!")
        warn("This script should be run against the PATCHED version (12.0.1+)")
    else:
        success("Confirmed: eval() is NOT present in create_predicate() (PATCHED version)")

    # Create evidence directory
    os.makedirs(EVIDENCE_DIR, exist_ok=True)

    results = {}

    # Test each bypass hypothesis
    results["H1_original_injection"] = test_original_injection()
    results["H2_type_confusion"] = test_type_confusion()
    results["H3_operator_injection"] = test_operator_injection()
    results["H4_dunder_abuse"] = test_dunder_abuse()
    results["H5_unicode_encoding"] = test_unicode_bypass()
    results["H6_logical_operator"] = test_logical_operator_abuse()
    results["H7_operator_module"] = test_operator_abuse()

    # ======================================================================
    # Summary
    # ======================================================================
    header("BYPASS ATTEMPT RESULTS")

    any_bypassed = False
    for test_name, bypassed in results.items():
        if bypassed:
            status = f"{RED}BYPASSED{RESET}"
            any_bypassed = True
        else:
            status = f"{GREEN}FIX HOLDS{RESET}"
        print(f"  [{status}] {test_name}")

    print()
    if any_bypassed:
        success("BYPASS FOUND! The fix is INCOMPLETE!")
        return 1
    else:
        success("ALL 7 BYPASS HYPOTHESES FAILED")
        success("The fix appears COMPLETE — eval() removal eliminates the attack vector")
        info("No code execution possible through the patched create_predicate()")
        return 0


if __name__ == "__main__":
    sys.exit(main())
