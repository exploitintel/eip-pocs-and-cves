# Vulnerability Analysis: CVE-2025-4981

## Root Cause

**Path traversal via unsanitized filename in archive document extractor.**

The function `archiveExtractor.Extract()` in `server/platform/services/docextractor/archive.go` constructs a temporary file path using an unsanitized `name` parameter via `os.Create(filepath.Join(dir, name))`. Go's `filepath.Join()` resolves `..` path components, so when `name` contains traversal sequences like `../../tmp/evil.zip`, the resulting path escapes the intended temporary directory.

The unsanitized `name` parameter originates from the **Upload Session API** (`POST /api/v4/uploads`). When a user creates an upload session, the `filename` field in the JSON body is stored verbatim in the database as `UploadSession.Filename`. When the upload completes, `UploadData()` passes `us.Filename` directly to `genFileInfoFromReader()`, which sets `info.Name = name` without any path sanitization. This `info.Name` then flows through the content extraction pipeline to the vulnerable `archiveExtractor.Extract()`.

The alternate upload path (`POST /api/v4/files` multipart) is NOT vulnerable because `UploadFileX()` applies `filepath.Base(name)` which strips directory components.

## Vulnerable File(s) and Function(s)

### Primary Vulnerability (Sink)
- **File**: `server/platform/services/docextractor/archive.go`
- **Function**: `archiveExtractor.Extract(name string, r io.ReadSeeker) (string, error)`
- **Line 37**: `f, err := os.Create(filepath.Join(dir, name))` — path traversal via unsanitized `name`

### Unsanitized Entry Point (Source)
- **File**: `server/channels/app/upload.go`
- **Function**: `genFileInfoFromReader(name string, file io.ReadSeeker, size int64) (*model.FileInfo, error)`
- **Line 29**: `Name: name` — assigns raw user-controlled `us.Filename` to `info.Name` without `filepath.Base()`

### Data Flow (Complete Chain)
1. `POST /api/v4/uploads` → `createUpload()` → `CreateUploadSession()` — stores `us.Filename` as-is (line 130 uses `filepath.Base()` for `us.Path`, but `us.Filename` is NOT sanitized)
2. `POST /api/v4/uploads/{id}` → `uploadData()` → `UploadData()` — calls `genFileInfoFromReader(us.Filename, file, us.FileSize)` at line 267
3. `genFileInfoFromReader()` → `info.Name = name` (line 29) — tainted value stored in `fileInfo.Name`
4. `UploadData()` saves `info` to database (line 310), then triggers async extraction (line 322-327)
5. `ExtractContentFromFileInfo()` → `docextractor.Extract(logger, fileInfo.Name, file, settings)` at file.go:1477
6. `combineExtractor.Extract()` → `archiveExtractor.Match(filename)` checks if name has archive extension
7. `archiveExtractor.Extract(name, r)` → `os.Create(filepath.Join(dir, name))` — **PATH TRAVERSAL**

## Triggering Input

### Filename
A filename containing `../` traversal sequences that ends with a recognized archive extension. Examples:
- `../../tmp/cve-2025-4981-proof.zip`
- `../../tmp/pwned.tar.gz`
- `../../../../../tmp/test.zip`

### Recognized Archive Extensions
The filename must match `archiver.ByExtension()` from `github.com/mholt/archiver/v3@v3.5.1`:
- `.zip`, `.tar`, `.tar.gz`, `.tar.bz2`, `.tar.xz`, `.tar.lz4`, `.tar.sz`, `.tar.zst`
- `.rar`, `.gz`, `.bz2`, `.lz4`, `.xz`, `.zst`

### File Content
The uploaded data becomes the file content written to the traversed path. The content can be arbitrary — it is written to disk via `io.Copy(f, r)` BEFORE `archiver.Walk()` attempts to parse the archive. Even if `archiver.Walk()` subsequently fails (invalid archive), the file has already been written, and it's outside the temp directory (so `defer os.RemoveAll(dir)` doesn't clean it up).

For the most reliable trigger, the content SHOULD be a valid zip/tar.gz archive so that `archiver.Walk()` doesn't log errors. But arbitrary content works for the file write.

## Attack Scenario

### Prerequisites
1. A valid Mattermost user account (any role — low privilege)
2. Membership in at least one channel (to have `channel_id`)
3. `FileSettings.EnableFileAttachments` = `true` (default)
4. `FileSettings.ExtractContent` = `true` (default)

### Step-by-Step Attack

1. **Authenticate**: `POST /api/v4/users/login` with `{"login_id": "user", "password": "pass"}` → Response header `Token: <auth_token>`

2. **Get channel ID**: `GET /api/v4/users/me/teams` → get team_id → `GET /api/v4/users/me/channels` → get any channel_id

3. **Create upload session with traversal filename**:
   ```
   POST /api/v4/uploads
   Authorization: Bearer <auth_token>
   Content-Type: application/json

   {
     "channel_id": "<channel_id>",
     "filename": "../../tmp/cve-2025-4981-proof.zip",
     "file_size": <size_of_payload>
   }
   ```
   Response contains `upload_id`.

4. **Upload payload data**:
   ```
   POST /api/v4/uploads/<upload_id>
   Authorization: Bearer <auth_token>
   Content-Type: application/octet-stream

   <zip_file_bytes>
   ```

5. **Exploitation triggers automatically**: The server's content extraction pipeline (lines 320-328 in upload.go) runs asynchronously, calling `ExtractContentFromFileInfo()` which passes the tainted `fileInfo.Name` to the archive extractor.

6. **Result**: The uploaded file content is written to `/tmp/cve-2025-4981-proof.zip` (outside the intended temp directory).

### Verification
- `docker exec <mattermost_container> ls -la /tmp/cve-2025-4981-proof.zip` — file exists
- `docker exec <mattermost_container> md5sum /tmp/cve-2025-4981-proof.zip` — matches uploaded content

## Impact

**Arbitrary file write** — CVSS 9.9 Critical (AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H)

An authenticated user with minimal privileges can write attacker-controlled content to any filesystem location writable by the Mattermost server process. The written file persists because it's outside the temporary directory cleaned up by `defer os.RemoveAll(dir)`.

Potential impacts:
- **Remote Code Execution**: Via cron job injection, plugin injection, or overwriting executable files
- **Data Corruption**: Overwriting configuration files, database files, or application data
- **Denial of Service**: Overwriting critical system files or filling disk space
- **Privilege Escalation**: Overwriting authentication databases or SSH authorized_keys

### Constraint
The target file path must end with a recognized archive extension (`.zip`, `.tar.gz`, etc.). This limits some exploitation scenarios but does not prevent high-impact attacks (e.g., writing `.tar.gz` plugins).

## Authentication Requirements

### Auth Flow
1. **Endpoint**: `POST /api/v4/users/login`
2. **Request Body**: `{"login_id": "<username_or_email>", "password": "<password>"}`
3. **Response**: HTTP 200 with `Token` header containing the session token
4. **Usage**: All subsequent requests include `Authorization: Bearer <token>` header

### Default Credentials (Lab Setup)
Mattermost doesn't ship with default credentials. During lab setup, a user account must be created either:
- Through the initial setup wizard (first visit to the web UI)
- Via CLI: `mattermost user create --email admin@test.local --username admin --password Admin123!`
- Via environment variables: `MM_SERVICESETTINGS_SITEURL`, etc.

### Authentication Level
- **Minimum**: Any authenticated user (no admin required)
- **Channel access**: User must be a member of at least one channel to get a valid `channel_id`
- **Pre-auth**: NOT exploitable without authentication

## Fix Assessment

**The fix is complete for the specific vulnerability.**

The fix in commit `65aec10162f612d98edf91cc66bf7e781868448b` replaces:
```go
// BEFORE (vulnerable)
dir, err := os.MkdirTemp(os.TempDir(), "archiver")
defer os.RemoveAll(dir)
f, err := os.Create(filepath.Join(dir, name))

// AFTER (fixed)
ext := getExtAlsoTarGz(name)
f, err := os.CreateTemp("", "archiver-*"+ext)
defer os.Remove(f.Name())
```

The fix eliminates the path traversal by using `os.CreateTemp()` with a pattern string. The `*` in `"archiver-*"+ext` is replaced by a random component by the OS. The `ext` value comes from `getExtAlsoTarGz()` which returns either `.tar.gz` (for `.tar.gz` suffix) or the result of `filepath.Ext(name)` which returns just the extension from the final path component.

**Why the fix is sufficient:**
- `os.CreateTemp("", pattern)` always creates files in the default temp directory with random names
- The `ext` value cannot contain path separators: `filepath.Ext()` returns the substring from the last `.` to end of the final path component, and `".tar.gz"` is a fixed string
- There is no way for the `name` parameter to influence the directory of the temp file

**Defense-in-depth observation:** The fix addresses the symptom (unsafe path construction in the extractor) but does NOT fix the root cause (unsanitized `fileInfo.Name` from the upload session flow). `genFileInfoFromReader()` at `upload.go:29` still sets `info.Name = name` without `filepath.Base()`. If any future code path uses `fileInfo.Name` in a filesystem context, a similar vulnerability could recur. However, for this specific CVE, the fix is complete.

## Potential Bypass Vectors

No concrete bypass vectors identified for the patched code. The fix properly eliminates user-controlled path components from file creation. Theoretical considerations:

- **Extension injection**: Could the extension contain malicious characters? No — `filepath.Ext()` returns only the extension (`.zip`), and the `.tar.gz` case is hardcoded. Neither can contain `/` or `..`.
- **Null byte injection**: Go strings can contain null bytes, but OS filesystem calls reject filenames with null bytes. Not exploitable.
- **Symlink attacks**: `os.CreateTemp` creates a new file with O_CREATE|O_EXCL, preventing symlink following. Not exploitable.

## Escalation Path

The vulnerability provides an **arbitrary file write** primitive (with the constraint that the filename must end with an archive extension). Escalation paths to RCE:

1. **Mattermost Plugin Injection**: Mattermost plugins are `.tar.gz` files. The default plugin directory is `./plugins` (relative to Mattermost working dir). If the attacker knows the absolute path (e.g., `/opt/mattermost/plugins/`), they could write a malicious `.tar.gz` plugin. However, plugin installation typically requires extraction and registration, so simply placing a file there may not auto-install it.

2. **Cron Job Injection**: Write to `/etc/cron.d/backdoor.tar.gz`. However, cron implementations often require specific file permissions and may ignore files with dots in the name. Also, the file content would need to be a valid cron file, not a zip archive. Since we control content, we can write a valid cron entry, but the file must have an archive extension which most cron daemons won't process.

3. **SSH Authorized Keys**: Write to `~/.ssh/authorized_keys.zip` — won't be read by SSH since it expects `authorized_keys` exactly.

4. **Overwriting Existing Archive Files**: If any `.zip` or `.tar.gz` files are used by automation scripts, overwriting them could lead to code execution when they're next processed.

**Most practical for PoC**: Demonstrate the arbitrary file write by writing a distinctive marker file to `/tmp/` and verifying its presence. The RCE escalation is context-dependent but the file write primitive is the critical finding.

## Related Attack Surface

### Other Extractors (No Similar Vulnerability)
The other extractors in `server/platform/services/docextractor/` do NOT have the same vulnerability:
- **pdfExtractor** (pdf.go:39): Uses `os.CreateTemp()` — already safe pattern
- **documentExtractor** (documents.go): No filesystem path construction with user input
- **plainExtractor** (plain.go): No filesystem operations
- **mmPreviewExtractor** (mmpreview.go): Passes filename to HTTP multipart header (different vulnerability class — potential header injection in mmpreview service, but not filesystem path traversal)

### Unsanitized Filename in Upload Session
- **File**: `server/channels/app/upload.go`
- **Function**: `genFileInfoFromReader()` (line 25-49)
- **Code**: `info.Name = name` (line 29) — uses raw `us.Filename` without `filepath.Base()`
- **Impact**: `fileInfo.Name` in the database contains path traversal characters. While the fix prevents the archive extractor from being exploited, any future code that uses `fileInfo.Name` in a filesystem context could reintroduce a similar vulnerability.

### Import Path (Admin Only)
- **File**: `server/channels/app/import_functions.go`
- **Function**: `importAttachment()` (line 1336)
- Uses `data.Data.Name` from zip file entries or server-side file paths
- Passes through `DoUploadFile()` which applies `filepath.Base()` — safe
- Additionally requires system admin privilege — not exploitable by regular users

## Build System

- **Type**: Go 1.21.8 with Makefile
- **Build file**: `server/Makefile`
- **Go version file**: `server/.go-version` (1.21.8)
- **Module**: `github.com/mattermost/mattermost/server/v8`

## Build Commands

For building from source:
```bash
cd server
make build-linux  # or: go build -o bin/mattermost ./cmd/mattermost
```

**Recommended approach for lab**: Use the pre-built Docker image instead of building from source.
```
docker pull mattermost/mattermost-team-edition:9.11.15
```

## Dependencies

### Runtime Dependencies
- **PostgreSQL** (or MySQL): Database backend
- **Mattermost Server**: The application itself (pre-built Docker image recommended)

### Key Go Dependencies (for source builds)
- `github.com/mholt/archiver/v3 v3.5.1` — archive format handling (the library used in the vulnerable code)
- `code.sajari.com/docconv/v2` — document text extraction
- `github.com/ledongthuc/pdf` — PDF text extraction
- Standard Go 1.21.8 toolchain

## Runtime Requirements

### Docker Lab Setup
- **Mattermost image**: `mattermost/mattermost-team-edition:9.11.15` (vulnerable version)
- **PostgreSQL image**: `postgres:15` or compatible
- **Network**: Bridge network between Mattermost and PostgreSQL containers
- **Port**: 8065 (Mattermost HTTP)
- **Default config**: Both `EnableFileAttachments` and `ExtractContent` default to `true` — no config changes needed

### Environment Variables for Mattermost Container
```
MM_SQLSETTINGS_DRIVERNAME=postgres
MM_SQLSETTINGS_DATASOURCE=postgres://mmuser:mmuser_password@postgres:5432/mattermost?sslmode=disable
MM_SERVICESETTINGS_SITEURL=http://localhost:8065
```

### Initial Setup
1. Start PostgreSQL and Mattermost containers
2. Create initial admin user (via CLI or web wizard)
3. Create or identify a channel for file uploads

### Verification Access
- Mattermost API: `http://localhost:8065/api/v4/`
- Shell access to container: `docker exec -it <container> /bin/sh`
- Check file write: `docker exec <container> ls -la /tmp/cve-2025-4981-proof.zip`

## PoC Strategy Summary

The PoC should:
1. Authenticate to Mattermost (`POST /api/v4/users/login`)
2. Get a valid channel ID (`GET /api/v4/users/me/teams` + `GET /api/v4/users/me/channels`)
3. Create an upload session with a traversal filename: `../../tmp/cve-2025-4981-proof.zip`
4. Upload a valid zip archive payload
5. Wait briefly for async content extraction to trigger
6. Verify the file was written to `/tmp/cve-2025-4981-proof.zip` on the server

**Primary attack vector**: Upload Session API (`POST /api/v4/uploads` + `POST /api/v4/uploads/{id}`)
**NOT exploitable via**: Direct multipart upload (`POST /api/v4/files`) — sanitized by `filepath.Base()` in `UploadFileX()`
