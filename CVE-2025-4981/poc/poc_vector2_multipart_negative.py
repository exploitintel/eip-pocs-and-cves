#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Server — Multipart Upload Negative Test
# CVE            : CVE-2025-4981
# Vendor         : Mattermost, Inc.
# Product        : Mattermost Server
# Affected       : ≤ 9.11.15 / ≤ 10.5.5 / ≤ 10.6.5 / ≤ 10.7.2 / ≤ 10.8.0
# Fixed          : 9.11.16 / 10.5.6 / 10.6.6 / 10.7.3 / 10.8.1
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-4981 — Negative Test: Multipart Upload API (POST /api/v4/files).

This script demonstrates that the DIRECT multipart file upload API
(POST /api/v4/files) is NOT vulnerable to the path traversal, because
it applies filepath.Base() sanitization in UploadFileX().

Only the Upload Session API (POST /api/v4/uploads) is vulnerable.

Expected result: The traversal filename is stripped to just the base name,
and the file is stored normally in Mattermost's data directory.

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-4981
    - https://github.com/advisories/GHSA-qh58-9v3j-wcjc

Usage:
    python3 poc_vector2_multipart_negative.py [host] [port]
"""

import sys
import json
import time
import io
import zipfile
import http.client


DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
USERNAME = "admin"
PASSWORD = "Admin123!@#"

# Same traversal filename as the primary PoC
TRAVERSAL_FILENAME = "../../tmp/cve-2025-4981-negative-test.zip"


def create_minimal_zip(content: bytes) -> bytes:
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, 'w', zipfile.ZIP_DEFLATED) as zf:
        zf.writestr('proof.txt', content.decode('utf-8', errors='replace'))
    return buf.getvalue()


def create_multipart_body(channel_id: str, filename: str, file_data: bytes):
    """Create a multipart/form-data body for the /api/v4/files endpoint."""
    boundary = "----CVE2025Boundary"
    body = io.BytesIO()

    # channel_id field
    body.write(f"--{boundary}\r\n".encode())
    body.write(b"Content-Disposition: form-data; name=\"channel_id\"\r\n\r\n")
    body.write(f"{channel_id}\r\n".encode())

    # file field — use the traversal filename
    body.write(f"--{boundary}\r\n".encode())
    body.write(f'Content-Disposition: form-data; name="files"; filename="{filename}"\r\n'.encode())
    body.write(b"Content-Type: application/zip\r\n\r\n")
    body.write(file_data)
    body.write(b"\r\n")

    body.write(f"--{boundary}--\r\n".encode())
    return boundary, body.getvalue()


def api_request(conn, method, path, body=None, headers=None, content_type="application/json"):
    hdrs = {"Content-Type": content_type}
    if headers:
        hdrs.update(headers)
    conn.request(method, path, body=body, headers=hdrs)
    resp = conn.getresponse()
    data = resp.read()
    try:
        json_data = json.loads(data)
    except (json.JSONDecodeError, UnicodeDecodeError):
        json_data = None
    return resp.status, dict(resp.getheaders()), json_data if json_data else data


def test_multipart_upload(target_host: str, target_port: int):
    """Test that multipart upload API sanitizes the filename."""
    print("[*] CVE-2025-4981 — Negative Test: Multipart Upload API")
    print(f"[*] Target: {target_host}:{target_port}")
    print(f"[*] This tests that POST /api/v4/files is NOT vulnerable")
    print()

    conn = http.client.HTTPConnection(target_host, target_port, timeout=30)

    # Step 1: Authenticate
    print("[1] Authenticating...")
    status, resp_headers, resp_data = api_request(
        conn, "POST", "/api/v4/users/login",
        json.dumps({"login_id": USERNAME, "password": PASSWORD})
    )
    if status != 200:
        print(f"[-] Auth failed: HTTP {status}")
        sys.exit(1)

    token = resp_headers.get("Token", "")
    if not token:
        for k, v in resp_headers.items():
            if k.lower() == "token":
                token = v
                break
    print(f"[+] Authenticated (token: {token[:12]}...)")

    auth = {"Authorization": f"Bearer {token}"}

    # Step 2: Get channel ID
    print("[2] Getting channel...")
    status, _, teams = api_request(conn, "GET", "/api/v4/users/me/teams", headers=auth)
    team_id = teams[0]["id"]
    status, _, channels = api_request(
        conn, "GET", f"/api/v4/users/me/teams/{team_id}/channels", headers=auth
    )
    channel_id = None
    for ch in channels:
        if ch.get("type") in ("O", "P"):
            channel_id = ch["id"]
            break
    if not channel_id:
        channel_id = channels[0]["id"]
    print(f"[+] Channel: {channel_id}")

    # Step 3: Clean up any pre-existing file
    print("[3] Cleaning up previous proof file...")
    import subprocess
    subprocess.run(["docker", "exec", "cve-2025-4981-mattermost",
                     "rm", "-f", "/tmp/cve-2025-4981-negative-test.zip"],
                   capture_output=True)

    # Step 4: Upload via multipart API with traversal filename
    print()
    print(f"[4] Uploading via POST /api/v4/files with filename: {TRAVERSAL_FILENAME}")
    zip_payload = create_minimal_zip(b"NEGATIVE TEST - SHOULD NOT APPEAR AT TRAVERSED PATH")
    boundary, multipart_body = create_multipart_body(channel_id, TRAVERSAL_FILENAME, zip_payload)

    status, _, resp_data = api_request(
        conn, "POST", "/api/v4/files",
        body=multipart_body,
        headers=auth,
        content_type=f"multipart/form-data; boundary={boundary}"
    )

    if status == 201 and isinstance(resp_data, dict):
        file_infos = resp_data.get("file_infos", [])
        if file_infos:
            stored_name = file_infos[0].get("name", "unknown")
            print(f"[+] Upload succeeded: HTTP {status}")
            print(f"[+] Server stored filename: {stored_name}")

            if "../" not in stored_name:
                print(f"[+] CONFIRMED: Multipart API sanitized the filename!")
                print(f"    filepath.Base() stripped traversal → '{stored_name}'")
            else:
                print(f"[!] UNEXPECTED: Traversal sequences preserved in multipart upload!")
        else:
            print(f"[+] Upload succeeded: HTTP {status} (no file_infos in response)")
    else:
        print(f"[-] Upload response: HTTP {status}")
        if isinstance(resp_data, dict):
            print(f"    {resp_data.get('message', '')}")

    # Step 5: Verify the file was NOT written to traversed path
    print()
    print("[5] Checking if file was written to traversed path (should NOT exist)...")
    time.sleep(3)  # Wait for any async processing

    result = subprocess.run(
        ["docker", "exec", "cve-2025-4981-mattermost",
         "ls", "-la", "/tmp/cve-2025-4981-negative-test.zip"],
        capture_output=True, text=True
    )

    if result.returncode != 0:
        print(f"[+] PASS: File NOT found at /tmp/cve-2025-4981-negative-test.zip")
        print(f"[+] Multipart upload API (POST /api/v4/files) is NOT vulnerable")
        print(f"[+] This confirms only the Upload Session API is the attack vector")
    else:
        print(f"[-] FAIL: File found at traversed path!")
        print(f"    {result.stdout.strip()}")
        print(f"[-] This would mean the multipart API is ALSO vulnerable")

    print()
    print("=" * 70)
    print("NEGATIVE TEST COMPLETE")
    print("=" * 70)

    conn.close()


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    try:
        test_multipart_upload(target, port)
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
