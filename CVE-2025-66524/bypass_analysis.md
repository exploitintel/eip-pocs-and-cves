# Bypass Analysis: CVE-2025-66524

## CVE Overview

- **CVE ID**: CVE-2025-66524
- **Title**: Apache NiFi GetAsanaObject Processor Remote Code Execution via Unsafe Deserialization
- **Fix Commit**: `1c081c15544b8459d69daaae2056f0f433cafce6`
- **Vulnerable Version**: Apache NiFi 2.6.0
- **Patched Version**: Apache NiFi 2.7.0
- **Bypass Result**: **NO BYPASS FOUND — FIX IS ADEQUATE**

---

## Fix Summary

The fix (commit `1c081c15`) completely replaced the vulnerable `GenericObjectSerDe` class that used `ObjectInputStream.readObject()` with two type-safe serializers:

1. **`StringSerDe`** — Serializes String keys using `String.getBytes(UTF_8)` / `new String(bytes, UTF_8)` (no Java native serialization)
2. **`MapStringSerDe`** — Serializes `Map<String, String>` values using Google Gson JSON serialization (no Java native serialization)

### Serialization Format Change

| Component | Vulnerable (2.6.0) | Patched (2.7.0) |
|-----------|-------------------|-----------------|
| Key Serializer | `GenericObjectSerDe<String>` → Java `ObjectOutputStream` | `StringSerDe` → UTF-8 bytes |
| Value Serializer | `GenericObjectSerDe<Map<String, String>>` → Java `ObjectOutputStream` | `MapStringSerDe` → Gson JSON |
| Key Format | `aced0005 74 0024 <uuid-utf8>` (Java serialized) | `<uuid-utf8>` (plain UTF-8) |
| Value Format | `aced0005 7372 0011 java.util.HashMap...` (Java serialized) | `{"key":"value",...}` (JSON) |

Verified in the lab:
- **Vulnerable cache**: Key `aced000574002461373334...` (43 bytes), Value `aced0005737200...` (192 bytes)
- **Patched cache**: Key `61373631633235622d30...` (36 bytes), Value `{"org.apache.nifi.processors.asana.utils.AsanaUserFetcher.lastFingerprints":"H4sI..."}` (121 bytes)

---

## Bypass Hypotheses

### Hypothesis 1: Old Key Format Compatibility
**Theory**: The patched NiFi might still look up keys in the old Java-serialized format for backward compatibility, allowing the original attack to work.

**Rationale**: When upgrading from 2.6.0 to 2.7.0, the cache server may still contain data in the old format. If the patched code reads old-format keys, the value would still be Java-serialized, potentially triggering ObjectInputStream.

**Assessment**: LOW probability — the key format is determined by the serializer, not the data in the cache.

### Hypothesis 2: New Key Format with Java Serialized Value
**Theory**: Inject a URLDNS payload at the new-format key (plain UTF-8 UUID). If `MapStringSerDe.deserialize()` somehow falls back to `ObjectInputStream` when it encounters non-JSON data, the gadget chain would execute.

**Rationale**: Some deserializers attempt multiple parsing strategies. If Gson fails, maybe NiFi catches the exception and tries ObjectInputStream as a fallback.

**Assessment**: VERY LOW probability — the fix completely removes GenericObjectSerDe. There is no fallback code path.

### Hypothesis 3: State Corruption via JSON
**Theory**: The cache server remains unauthenticated. Inject valid JSON to corrupt the processor's state, potentially manipulating its behavior.

**Rationale**: Even without code execution, state corruption could have security implications (e.g., causing the processor to re-fetch data, reset state, or behave unexpectedly).

**Assessment**: HIGH probability for data integrity impact, NO code execution.

### Hypothesis 4: Gson Deserialization Edge Cases
**Theory**: Crafted JSON payloads might trigger Gson vulnerabilities such as stack overflow (deep nesting), OOM (huge values), or unexpected type coercion.

**Rationale**: Gson has had some edge cases with deeply nested structures. The `TypeToken<Map<String, String>>` constrains the target type, but edge cases might bypass this.

**Assessment**: VERY LOW probability for code execution — Gson is a JSON parser, not a Java object deserializer.

---

## Test Environment

### Patched Container
- **Image**: `apache/nifi:2.7.0`
- **Container**: `cve-2025-66524-nifi-patched`
- **Processor UUID**: `a761c25b-019c-1000-3372-b15e5186535a`
- **Cache Server**: `cve-2025-66524-services-patched:4557`
- **Processor State**: RUNNING, 30-second schedule

### Vulnerable Container (control)
- **Image**: `apache/nifi:2.6.0`
- **Container**: `cve-2025-66524-nifi`
- **Processor UUID**: `a734f87d-019c-1000-57b2-e511d156e143`
- **Cache Server**: `cve-2025-66524-services:4557`

---

## Test Results

### Control Test: Original PoC on Vulnerable Container (2.6.0)

**Result**: ✅ **EXPLOIT SUCCEEDED** (confirms test methodology)

```
PUT: SUCCESS
[+] VULNERABLE CONTAINER: DNS query detected - exploit works!
  03:18:13.619880 eth1 Out IP 172.28.0.3.44719 > 100.64.100.1.53: 56965+ AAAA? nifi-deser-proof-cve-2025-66524.attacker.local. (64)
  03:18:13.620081 eth1 Out IP 172.28.0.3.49095 > 100.64.100.1.53: 48775+ A? nifi-deser-proof-cve-2025-66524.attacker.local. (64)
```

The URLDNS gadget chain executed during `ObjectInputStream.readObject()`, triggering DNS queries for the canary hostname.

### Vector 1: URLDNS with Old Key Format → **NO BYPASS**

**Method**: Injected URLDNS payload using Java-serialized key format (`aced0005 74 ...`) at the patched processor's UUID.

**Result**: PUT succeeded (cache server accepts any bytes), but the patched NiFi never read this key because it looks up with the new plain-UTF-8 key format. No DNS query observed. No deserialization evidence in logs.

**Why it failed**: The patched `StringSerDe.serialize()` produces plain UTF-8 bytes for the key, so the GET request uses `a761c25b-019c-1000-3372-b15e5186535a` (36 bytes) as the key, NOT the Java-serialized version (43 bytes starting with `aced0005`). These are different byte sequences, so the cache server returns an empty value.

### Vector 2: URLDNS with New Key Format → **NO BYPASS**

**Method**: Injected URLDNS payload (337 bytes of Java serialized object) at the new-format key (plain UTF-8 UUID).

**Result**: PUT succeeded. The patched NiFi DID read this value. `MapStringSerDe.deserialize()` attempted to parse the Java serialized bytes as JSON using Gson, which threw `JsonSyntaxException`:

```
com.google.gson.JsonSyntaxException: java.lang.IllegalStateException:
  Expected BEGIN_OBJECT but was STRING at line 1 column 1 path $
```

The Java serialized bytes (starting with `0xAC 0xED`) are not valid JSON. Gson's `fromJson()` failed immediately without any code execution. **ObjectInputStream was never invoked** — it doesn't exist in the patched code.

**Why it failed**: The fix completely removes `ObjectInputStream` from the code path. `MapStringSerDe.deserialize()` only calls `GSON.fromJson(reader, MAP_TYPE_TOKEN)`. Gson is a JSON parser that creates objects through reflection based on the JSON structure, not through Java's native deserialization. There is no fallback to ObjectInputStream.

### Vector 3: State Corruption via JSON → **DATA INTEGRITY ONLY**

**Method**: Injected valid JSON (`{"org.apache.nifi.processors.asana.utils.AsanaUserFetcher.lastFingerprints": "CORRUPTED_BY_ATTACKER"}`) at the correct cache key.

**Result**: 
- ✅ State corruption **SUCCEEDED** — the crafted JSON was accepted by the patched NiFi
- ❌ No code execution — the corrupted state was parsed by Gson as a valid `Map<String, String>` and processed normally
- The processor accepted the corrupted fingerprints value without error

**Assessment**: This demonstrates that the unauthenticated cache protocol remains a **data integrity** risk. An attacker can corrupt the processor's internal state, potentially causing:
- State reset (processor re-fetches all Asana data)
- Incorrect fingerprint tracking (data duplication or missed updates)
- But **NOT** remote code execution

This is a **separate issue** from the deserialization vulnerability and was pre-existing.

### Vector 4: Gson Edge Case Attacks → **NO BYPASS**

**Method**: Tested multiple crafted JSON payloads:

| Payload | Size | Result |
|---------|------|--------|
| Deeply nested JSON (100 levels) | 603 bytes | Gson parsed without StackOverflow |
| Very large value (100KB) | 100,010 bytes | Accepted, no OOM |
| Unicode special chars (null, surrogates) | 28 bytes | Accepted |
| Non-string value types (int, bool, null) | 42 bytes | Type coercion, no error |
| Duplicate keys | 40 bytes | Last value wins |

**Result**: None of the Gson edge cases produced exploitable behavior. Proxy/timeout errors occurred from the repeated cache writes but these are connection management issues, not security vulnerabilities.

---

## Codebase-Wide Search for Related Patterns

### ObjectInputStream Usage
Searched the entire NiFi 2.6.0 codebase for `ObjectInputStream` usage:
- **Cache-related**: Only `GenericObjectSerDe.java` (the deleted vulnerable class)
- **No other Deserializer implementations** use `ObjectInputStream`
- **No cache client/server code** uses `ObjectInputStream`
- The Netty-based `MapCacheClientService` passes raw bytes directly to the Deserializer interface without any intermediate processing

### Other Serializer/Deserializer Implementations
All other implementations are safe:
- `StringSerDe` (HDFS bundle) — UTF-8 string parsing
- `LongSerDe` — Long parsing
- `CacheValueDeserializer` (FetchDistributedMapCache) — Returns raw bytes
- `CacheValueDeserializer` (DetectDuplicate) — Manual binary parsing
- `ListedEntityTracker` — GZIP + Jackson JSON

### No Sibling Vulnerabilities
`GenericObjectSerDe` is exclusively used in the `nifi-asana-bundle`. No other NiFi bundles or processors contain this pattern.

---

## Data Flow Analysis (Patched Version)

```
GetAsanaObject.onTrigger()
  → recoverState(context)
    → client.get(getIdentifier(), STATE_MAP_KEY_SERIALIZER, STATE_MAP_VALUE_SERIALIZER)
      → StringSerDe.serialize(uuid)           → plain UTF-8 bytes
      → MapCacheClientService sends GET to cache server
      → Cache server returns raw value bytes
      → MapStringSerDe.deserialize(bytes)      → Gson.fromJson(reader, TypeToken<Map<String,String>>)
                                                  ↓
                                               JSON parsing only
                                               NO ObjectInputStream
                                               NO readObject()
                                               NO gadget chain execution
```

At no point in the patched data flow is `ObjectInputStream` created or `readObject()` called. The deserialization is entirely handled by Gson's JSON parser, which:
1. Tokenizes the JSON text stream
2. Creates a `LinkedTreeMap` (Gson's Map implementation)
3. Populates it with String key-value pairs parsed from JSON
4. Returns the Map

There is no mechanism for Gson's `fromJson()` with `TypeToken<Map<String, String>>` to execute arbitrary code, instantiate arbitrary classes, or trigger JNDI lookups.

---

## Bypass Script

- **Location**: `poc/bypass_poc.py`
- **Language**: Python 3 (stdlib + json)
- **Tests 4 bypass vectors** against the patched NiFi 2.7.0
- **Also includes**: `poc/cache_probe.py` for cache enumeration

---

## Verdict

### **FIX IS ADEQUATE — NO BYPASS FOUND**

**Confidence Level: HIGH (95%+)**

The fix in commit `1c081c15544b8459d69daaae2056f0f433cafce6` is complete and effective because:

1. **Root cause eliminated**: `ObjectInputStream.readObject()` is completely removed from the code path. The vulnerable `GenericObjectSerDe` class is deleted.

2. **Both serializers fixed**: Both the key serializer (`StringSerDe`) and value serializer (`MapStringSerDe`) use safe, type-specific serialization.

3. **No fallback paths**: The patched code has no fallback to Java native deserialization. If Gson parsing fails, an exception is thrown and the processor clears its state — no ObjectInputStream is created.

4. **Format incompatibility**: The key format change (Java serialized → plain UTF-8) means old cached data with Java-serialized keys will not be found by the patched code, providing an additional layer of protection.

5. **Gson is inherently safe for this use case**: Gson's `fromJson()` with `TypeToken<Map<String, String>>` cannot trigger code execution. Unlike Jackson with default typing or Fastjson, Gson does not support polymorphic type instantiation from JSON annotations.

6. **No sibling vulnerabilities**: The vulnerable pattern exists only in the deleted `GenericObjectSerDe` class. No other NiFi processors or bundles contain similar unsafe deserialization.

### Residual Risks (Not Bypasses)

1. **Unauthenticated cache protocol**: The NiFi Distributed Map Cache server still has no authentication on TCP port 4557. An attacker can read, write, and delete any cache entries. This enables:
   - **Data integrity attacks**: Corrupt processor state
   - **Information disclosure**: Read cached data
   - These are pre-existing issues, not introduced or addressed by the deserialization fix

2. **Upgrade window**: During the period between NiFi 2.6.0 and 2.7.0, installations running the vulnerable version remain exploitable. The unauthenticated cache server makes exploitation trivial.

### Why the Fix Cannot Be Bypassed

The fundamental reason the fix cannot be bypassed is architectural: **the deserialization primitive (ObjectInputStream.readObject()) is completely removed from the code**. Any bypass would require one of:

1. Re-introducing ObjectInputStream into the data path → Not possible without code changes
2. Finding a code execution gadget chain through Gson's JSON parser → Not possible for `Map<String, String>` with TypeToken constraints
3. Finding another NiFi component that deserializes cache data unsafely → None exist
4. Exploiting the Netty cache client framework itself → It passes raw bytes without processing

None of these conditions exist in the patched codebase.
