#!/usr/bin/env python3
"""
Standalone NiFi Distributed Map Cache Server for CVE-2025-66524 lab.

Implements the NiFi Distributed Map Cache protocol (V1-V3) using TCP sockets.
Stores key-value pairs in memory. The PoC can inject malicious serialized
objects via this server, and the NiFi MapCacheClientService reads from it.

Protocol:
  Handshake: "NiFi" (4 bytes) + version (int32 BE) → RESOURCE_OK (0x14)
  Operations: writeUTF(op) + args → response

Supports: put, get, containsKey, remove, keySet, close
"""

import socket
import struct
import threading
import sys
import os

# In-memory cache store
cache = {}
cache_lock = threading.Lock()


def read_exactly(sock, n):
    """Read exactly n bytes from socket."""
    buf = b""
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise ConnectionError("Connection closed")
        buf += chunk
    return buf


def read_utf(sock):
    """Read a Java DataOutputStream.writeUTF() string."""
    length_bytes = read_exactly(sock, 2)
    length = struct.unpack(">H", length_bytes)[0]
    data = read_exactly(sock, length)
    return data.decode("utf-8")


def read_bytes(sock):
    """Read a length-prefixed byte array (4-byte int32 length)."""
    length_bytes = read_exactly(sock, 4)
    length = struct.unpack(">i", length_bytes)[0]
    if length <= 0:
        return b""
    return read_exactly(sock, length)


def write_bool(sock, val):
    """Write a boolean (1 byte)."""
    sock.sendall(b"\x01" if val else b"\x00")


def write_bytes(sock, data):
    """Write a length-prefixed byte array."""
    sock.sendall(struct.pack(">i", len(data)) + data)


def write_int(sock, val):
    """Write a 4-byte big-endian int."""
    sock.sendall(struct.pack(">i", val))


def handle_client(conn, addr):
    """Handle a single cache client connection."""
    print(f"[CacheServer] New connection from {addr}")
    try:
        # === HANDSHAKE ===
        magic = read_exactly(conn, 4)
        if magic != b"NiFi":
            print(f"[CacheServer] Bad magic from {addr}: {magic}")
            conn.close()
            return

        version_bytes = read_exactly(conn, 4)
        version = struct.unpack(">I", version_bytes)[0]
        print(f"[CacheServer] Handshake: version={version} from {addr}")

        # Accept version (RESOURCE_OK = 0x14)
        conn.sendall(bytes([0x14]))

        # === COMMAND LOOP ===
        while True:
            try:
                op = read_utf(conn)
            except ConnectionError:
                break

            print(f"[CacheServer] Op: {op} from {addr}")

            if op == "close":
                break

            elif op == "put":
                key = read_bytes(conn)
                value = read_bytes(conn)
                with cache_lock:
                    cache[key] = value
                write_bool(conn, True)  # put always succeeds
                print(f"[CacheServer] PUT key={key[:32].hex()}... value_len={len(value)}")

            elif op == "get":
                key = read_bytes(conn)
                with cache_lock:
                    value = cache.get(key, b"")
                write_bytes(conn, value)
                print(f"[CacheServer] GET key={key[:32].hex()}... value_len={len(value)}")

            elif op == "containsKey":
                key = read_bytes(conn)
                with cache_lock:
                    exists = key in cache
                write_bool(conn, exists)

            elif op == "remove":
                key = read_bytes(conn)
                with cache_lock:
                    existed = key in cache
                    if existed:
                        del cache[key]
                write_bool(conn, existed)

            elif op == "keySet":
                with cache_lock:
                    keys = list(cache.keys())
                # Write number of keys as int, then each key as length-prefixed bytes
                write_int(conn, len(keys))
                for k in keys:
                    write_bytes(conn, k)

            elif op == "putIfAbsent":
                key = read_bytes(conn)
                value = read_bytes(conn)
                with cache_lock:
                    if key not in cache:
                        cache[key] = value
                        write_bool(conn, True)
                    else:
                        write_bool(conn, False)

            elif op == "getAndPutIfAbsent":
                key = read_bytes(conn)
                value = read_bytes(conn)
                with cache_lock:
                    existing = cache.get(key, None)
                    if existing is None:
                        cache[key] = value
                        write_bytes(conn, b"")
                    else:
                        write_bytes(conn, existing)

            elif op == "subMap":
                # Read list of keys
                num_keys_bytes = read_exactly(conn, 4)
                num_keys = struct.unpack(">i", num_keys_bytes)[0]
                keys = []
                for _ in range(num_keys):
                    keys.append(read_bytes(conn))
                # Return map entries
                with cache_lock:
                    results = [(k, cache.get(k, b"")) for k in keys]
                write_int(conn, len(results))
                for k, v in results:
                    write_bytes(conn, k)
                    write_bytes(conn, v)

            elif op == "removeAndGet":
                key = read_bytes(conn)
                with cache_lock:
                    value = cache.pop(key, b"")
                write_bytes(conn, value)

            else:
                print(f"[CacheServer] Unknown op: {op}")
                break

    except (ConnectionError, struct.error, OSError) as e:
        print(f"[CacheServer] Connection error from {addr}: {e}")
    finally:
        conn.close()
        print(f"[CacheServer] Connection closed: {addr}")


def main():
    port = int(os.environ.get("CACHE_PORT", "4557"))
    host = "0.0.0.0"

    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((host, port))
    server.listen(10)
    print(f"[CacheServer] NiFi Distributed Map Cache Server listening on {host}:{port}")

    try:
        while True:
            conn, addr = server.accept()
            t = threading.Thread(target=handle_client, args=(conn, addr), daemon=True)
            t.start()
    except KeyboardInterrupt:
        print("[CacheServer] Shutting down")
        server.close()


if __name__ == "__main__":
    main()
