# CVE-2026-28268 - Vikunja Password Reset Token Reuse

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2026-28268 |
| Component | [Vikunja](https://vikunja.io/) |
| Type | CWE-640: Weak Password Recovery Mechanism / CWE-459: Incomplete Cleanup |
| CVSS | 9.8 (Critical) â€” `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| EPSS | 0.0% (9.6th percentile) |
| Affected | Vikunja < 2.1.0 |
| Fix | Upgrade to Vikunja v2.1.0 |
| Author | Exploit Intelligence Platform |
| Date | 2026-02-28 |

## Overview

CVE-2026-28268 is a critical authentication bypass vulnerability in Vikunja's password reset mechanism. An unauthenticated attacker who obtains a password reset token can reuse it **unlimited times** to change the victim's password, even after the victim has used it themselves or changed their password through normal means. The vulnerability creates a permanent backdoor that survives victim remediation attempts.

## Affected Versions

| | |
|---|---|
| **Vulnerable** | Vikunja **v2.0.0 and earlier** (all versions prior to v2.1.0) |
| **Fixed** | Vikunja **v2.1.0** |
| **Component** | `pkg/user/user_password_reset.go` (`ResetPassword()`) |

**Prerequisites for exploitation:**
1. Attacker obtains a password reset token (phishing, email compromise, log exposure, etc.)
2. Target must be a valid Vikunja user account
3. No other requirements (no timing window, no victim interaction after token obtained)

## CVSS Score

| | |
|---|---|
| **Score** | **9.8 / 10 â€” Critical** |
| **Vector** | `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| **CWE** | CWE-640 (Weak Password Recovery Mechanism for Forgotten Password), CWE-459 (Incomplete Cleanup) |
| **EPSS** | Not yet calculated (new CVE) |

## Root Cause

The vulnerability has **two compounding bugs** in Vikunja's password reset token lifecycle:

### Bug 1: Wrong Token Type Deleted After Reset (Primary)

In `pkg/user/user_password_reset.go`, the `ResetPassword()` function successfully resets the user's password but then deletes the **wrong token type**:

```go
// Line 68 (VULNERABLE):
err = removeTokens(s, user, TokenEmailConfirm)   // Deletes email confirm tokens (kind=2)
```

**Should be:**
```go
err = removeTokens(s, user, TokenPasswordReset)   // Should delete password reset tokens (kind=1)
```

Because `TokenEmailConfirm` (kind=2) is passed instead of `TokenPasswordReset` (kind=1), the password reset token **is never deleted** from the `user_tokens` database table. It remains valid for unlimited reuse.

### Bug 2: Inverted Cron Cleanup Comparison (Secondary)

In `pkg/user/token.go`, the `RegisterTokenCleanupCron()` function uses an **inverted comparison operator**:

```go
// Line 134 (VULNERABLE):
Where("created > ? AND (kind = ? OR kind = ?)",
    time.Now().Add(time.Hour*24*-1),
    TokenPasswordReset,
    TokenAccountDeletion,
)
```

- `created > (now - 24h)` selects tokens **newer** than 24 hours â†’ deletes VALID tokens
- **Should be:** `created < (now - 24h)` â†’ delete tokens **older** than 24 hours

This means old tokens are **preserved** indefinitely while new valid tokens get incorrectly deleted.

### Combined Impact

Together, these bugs create a permanent backdoor:
1. Password reset token is **never deleted** after use (Bug 1)
2. The safety net (cron cleanup) **preserves old tokens** instead of removing them (Bug 2)
3. Even if victim changes password normally, attacker's token **remains valid forever**

---

## Lab Setup

### Prerequisites

- Docker with Docker Compose plugin
- ~500 MB disk space
- Port 3456 available

### Starting the Lab

```bash
cd CVE-2026-28268
docker compose build
docker compose up -d
```

Wait 10-15 seconds for Vikunja to complete database migrations and startup.

### Verifying Lab is Ready

```bash
curl -s http://localhost:3456/api/v1/info | jq .
```

Expected output:
```json
{
  "version": "dev",
  "auth": {
    "local": {
      "enabled": true,
      "registration_enabled": true
    }
  }
  ...
}
```

### Container Inventory

| Container | Role | Port |
|-----------|------|------|
| `cve-2026-28268-vulnerable` | Vikunja v2.0.0 (vulnerable) + SQLite | 3456 |

**Single container architecture** â€” Vikunja uses embedded SQLite, no external services needed.

### Stopping the Lab

```bash
# Stop containers
docker compose down

# Full reset (remove database)
docker compose down -v
```

---

## PoC Usage

All PoC scripts are located in this directory and use **only Python 3 standard library** (no external dependencies).

### Vector 1: Primary Token Reuse (`poc.py`)

Full end-to-end demonstration of the token reuse vulnerability.

```bash
python3 poc.py localhost 3456
```

**What it does:**
1. Registers a test user
2. Verifies login with original password
3. Requests a password reset token
4. Extracts token from SQLite database (mailer disabled in lab)
5. **First use:** Resets password successfully
6. **Verifies token still exists** in database (Bug 1)
7. **Second use:** Resets password **with same token** (EXPLOIT)
8. Verifies authentication works with second password

**Expected output:**
```
[Step 6] Verifying token was NOT deleted from database...
  âš ï¸  TOKEN STILL EXISTS IN DATABASE (Bug 1 confirmed!)

[Step 7] SECOND password reset with SAME token (EXPLOIT!)...
  ðŸš¨ AUTHENTICATION BYPASS CONFIRMED! ðŸš¨
     The same token was reused successfully!

[+] CVE-2026-28268 FULLY CONFIRMED
```

### Vector 2: Persistent Backdoor (`poc_vector2_persistent_backdoor.py`)

Demonstrates how an attacker can maintain access even after the victim recovers their account.

```bash
python3 poc_vector2_persistent_backdoor.py localhost 3456
```

**Attack scenario:**
1. **Day 1:** Attacker uses token to takeover account
2. **Day 2:** Victim changes password back (normal password update)
3. **Day 2:** Attacker uses **same token again** to regain access
4. **Day 3:** Attacker uses token **third time** to regain access again

**Expected output:**
```
[Day 2] Attacker uses THE SAME RESET TOKEN AGAIN...
  ðŸš¨ TOKEN REUSE SUCCESSFUL! (Bug confirmed)
     Attacker regained control

[Day 3] Attacker uses THE SAME TOKEN A THIRD TIME...
  ðŸš¨ THIRD REUSE SUCCESSFUL!
     Same token used THREE times

[+] PERSISTENT BACKDOOR CONFIRMED
```

### Vector 3: Raw HTTP Socket (`poc_vector3_raw_http.py`)

Zero-dependency exploit using raw TCP sockets â€” demonstrates the attack at the protocol level.

```bash
python3 poc_vector3_raw_http.py localhost 3456
```

**What it does:**
- Hand-crafts HTTP requests using Python's `socket` module
- Sends raw TCP packets (no `urllib`, `requests`, or other HTTP libraries)
- Proves vulnerability exists at HTTP protocol level

**Expected output:**
```
[Step 6] RAW SOCKET: SECOND reset with SAME token...
  Raw HTTP request (second use of same token):
    POST /api/v1/user/password/reset HTTP/1.1
    Host: localhost:3456
    Content-Type: application/json
    ...
  Status: HTTP 200
  ðŸš¨ TOKEN REUSE CONFIRMED via raw socket!

[+] RAW SOCKET EXPLOIT SUCCESSFUL
```

---

## Verification: Vulnerable vs Patched

### Vikunja v2.0.0 (Vulnerable)

| Test Case | Result |
|---|---|
| First password reset with token | âœ… HTTP 200 â€” Password changed |
| Check database for token after use | âš ï¸ Token **still exists** (Bug 1) |
| Second password reset with same token | âœ… HTTP 200 â€” **BYPASS!** |
| Third password reset with same token | âœ… HTTP 200 â€” **BYPASS!** |

**Verification command:**
```bash
docker exec cve-2026-28268-vulnerable sqlite3 /data/vikunja.db \
  "SELECT COUNT(*) FROM user_tokens WHERE kind=1;"
# Returns: 1 (token persists)
```

### Vikunja v2.1.0 (Patched)

| Test Case | Expected Result |
|---|---|
| First password reset with token | âœ… HTTP 200 â€” Password changed |
| Check database for token after use | âœ… Token **deleted** |
| Second password reset with same token | âŒ HTTP 401 â€” Token not found |

---

## Fix

**Fixed in:** Vikunja v2.1.0

**Fix commits:**
- [`5c2195f9`](https://github.com/go-vikunja/vikunja/commit/5c2195f9fca9ad208477e865e6009c37889f87b2) â€” Changed `TokenEmailConfirm` â†’ `TokenPasswordReset` in `removeTokens()` call
- [`412215ee2`](https://github.com/go-vikunja/vikunja/commit/412215ee2f1e59878e5f54343edd20d3fc7356ba) â€” Changed `>` â†’ `<` in cron cleanup WHERE clause

### Fix 1: Correct Token Deletion

```diff
// pkg/user/user_password_reset.go, line 68
-err = removeTokens(s, user, TokenEmailConfirm)
+err = removeTokens(s, user, TokenPasswordReset)
```

### Fix 2: Correct Cron Cleanup

```diff
// pkg/user/token.go, line 134
-Where("created > ? AND (kind = ? OR kind = ?)", ...)
+Where("created < ? AND (kind = ? OR kind = ?)", ...)
```

**Why the fix is adequate:**
- `TokenPasswordReset` is now correctly passed to `removeTokens()`, ensuring reset tokens are deleted after use (Fix 1)
- `created < (now - 24h)` correctly selects old tokens for cleanup (Fix 2)
- Both checks placed at correct entry points
- Unit tests added to prevent regression

---

## Real-World Attack Scenario

### Attack Prerequisites

Attacker must obtain a password reset token via:
1. **Phishing** â€” Victim clicks malicious password reset request
2. **Email compromise** â€” Attacker reads victim's email
3. **Network sniffing** â€” If email transport is not TLS
4. **Server-side log exposure** â€” Tokens may appear in debug logs
5. **Database access** â€” SQL injection, backup exposure, etc.

### Attack Timeline

**Day 0:**
- Attacker sends phishing email: "Reset your Vikunja password"
- Victim clicks link, token sent to victim's email
- Attacker intercepts or reads victim's email

**Day 1:**
- Attacker uses token to change victim's password
- Victim is locked out of account
- Attacker gains full access to victim's tasks, projects, data

**Day 2:**
- Victim notices unauthorized access
- Victim contacts admin or uses "forgot password" to reset again
- Victim changes password back, thinks they've recovered

**Day 2 (later):**
- Attacker discovers they're locked out
- Attacker uses **same original token** to takeover account again
- Victim locked out again

**Day N:**
- Cycle repeats indefinitely
- Token **never expires**
- Victim **cannot permanently recover** without:
  - Manual database intervention (`DELETE FROM user_tokens WHERE kind=1`)
  - Upgrading to Vikunja v2.1.0

### Why This is Worse Than Typical Token Reuse Bugs

**Most token reuse vulnerabilities:**
- Token works 1-2 extra times before being invalidated
- Cron jobs clean up old tokens eventually
- Victim can recover by changing password

**This vulnerability:**
- Token works **unlimited times**
- Cron cleanup **preserves** old tokens (Bug 2)
- Victim **cannot recover** through normal means
- Creates a **permanent backdoor**

---

## Impact

### Technical Impact

- **Full account takeover:** Attacker can change any user's password
- **Persistent access:** Token works forever (no expiration)
- **Survives remediation:** Victim's password changes don't help
- **Session hijacking:** Password reset invalidates all active sessions
- **Data exfiltration:** Attacker gains full API access to victim's tasks, projects, attachments
- **No detection:** No UI shows tokens to users, invisible attack

### Business Impact

- **Privacy breach:** Attacker reads victim's private tasks and projects
- **Data integrity:** Attacker can modify or delete victim's data
- **Reputation damage:** If attacker uses access to harm others
- **Compliance issues:** GDPR, CCPA violations if personal data accessed

### CVSS v3.1 Breakdown

| Metric | Value | Rationale |
|--------|-------|-----------|
| Attack Vector | Network | Remote HTTP API |
| Attack Complexity | Low | No special conditions |
| Privileges Required | None | Pre-auth exploit |
| User Interaction | None | Token obtained separately |
| Scope | Unchanged | Impact to Vikunja only |
| Confidentiality | High | Full data access |
| Integrity | High | Can modify all data |
| Availability | High | Can delete account |

**CVSS Score: 9.8 Critical**

---

## References

| Source | URL |
|---|---|
| GitHub Advisory (GHSA) | https://github.com/go-vikunja/vikunja/security/advisories/GHSA-rfjg-6m84-crj2 |
| Fix Commit 1 (Primary) | https://github.com/go-vikunja/vikunja/commit/5c2195f9fca9ad208477e865e6009c37889f87b2 |
| Fix Commit 1 | https://github.com/go-vikunja/vikunja/commit/5c2195f9fca9ad208477e865e6009c37889f87b2 |
| Fix Commit 2 | https://github.com/go-vikunja/vikunja/commit/412215ee2f1e59878e5f54343edd20d3fc7356ba |
| Changelog | https://vikunja.io/changelog/vikunja-v2.1.0-was-released |
| Vikunja Docker Hub | https://hub.docker.com/r/vikunja/api |
| Source Repository | https://github.com/go-vikunja/vikunja |

---

## Timeline

| Date | Event |
|---|---|
| 2026-02-27 | Vulnerability disclosed |
| 2026-02-27 | CVE-2026-28268 published |
| 2026-02-27 | Vikunja v2.1.0 released with fix |
| 2026-02-28 | This PoC lab created and verified |

---

## Remediation

### For Vulnerable Installations

**Immediate mitigation:**
```sql
-- Manually delete all password reset and account deletion tokens
DELETE FROM user_tokens WHERE kind IN (1, 3);
```

**Short-term fix:**
```bash
# Upgrade to Vikunja v2.1.0
docker pull vikunja/api:2.1.0
docker-compose down && docker-compose up -d
```

**Long-term verification:**
```bash
# Check for lingering tokens after upgrade
docker exec <container> sqlite3 /data/vikunja.db \
  "SELECT * FROM user_tokens WHERE created < datetime('now', '-30 days');"
```

### Detection

**Check if you've been exploited:**

1. Review password reset patterns in logs:
   ```bash
   grep "password.*reset" /var/log/vikunja/*.log
   ```

2. Check for multiple password resets for same user:
   ```sql
   SELECT user_id, COUNT(*) as reset_count
   FROM password_reset_logs
   GROUP BY user_id
   HAVING reset_count > 1;
   ```

3. Review `user_tokens` table for old tokens:
   ```sql
   SELECT id, user_id, kind, created
   FROM user_tokens
   WHERE kind=1 AND created < datetime('now', '-7 days');
   ```

---

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2026-28268 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
