# Vulnerability Analysis: CVE-2026-28268

## Vikunja < 2.1.0 — Auth Bypass via Password Reset Token Reuse

---

## Root Cause

CVE-2026-28268 is a **business logic vulnerability** caused by two distinct bugs in the Vikunja password reset token lifecycle that, in combination, allow infinite password reset token reuse and permanent account takeover.

### Bug 1: Wrong Token Kind Deleted After Password Reset (Primary — CWE-459: Incomplete Cleanup)

In `pkg/user/user_password_reset.go`, the `ResetPassword()` function successfully resets the user's password but then calls `removeTokens()` with the **wrong token kind constant**:

```go
// Line 68 (VULNERABLE):
err = removeTokens(s, user, TokenEmailConfirm)   // Deletes email confirm tokens (kind=2)
```

The correct call should be:
```go
err = removeTokens(s, user, TokenPasswordReset)   // Should delete password reset tokens (kind=1)
```

The `removeTokens()` function (token.go:113-117) deletes all tokens matching `user_id` AND `kind`. Because `TokenEmailConfirm` (kind=2) is passed instead of `TokenPasswordReset` (kind=1), the password reset token that was just used **is never deleted** from the `user_tokens` table. It remains valid for unlimited reuse.

### Bug 2: Inverted Cron Job Cleanup Comparison (Secondary — CWE-640: Weak Password Recovery)

In `pkg/user/token.go`, the `RegisterTokenCleanupCron()` function runs hourly to clean up expired tokens, but uses an **inverted comparison operator**:

```go
// Line 134 (VULNERABLE):
Where("created > ? AND (kind = ? OR kind = ?)", time.Now().Add(time.Hour*24*-1), TokenPasswordReset, TokenAccountDeletion)
```

- `created > (now - 24h)` selects tokens **newer** than 24 hours — i.e., it deletes VALID, recently-issued tokens
- The intended `created < (now - 24h)` would select tokens **older** than 24 hours — i.e., expired tokens

This means:
- Expired/old tokens are **preserved** indefinitely (never cleaned up)
- Valid recent tokens are **incorrectly deleted** by the cron job

### Combined Impact

These two bugs create a permanent backdoor:
1. A password reset token, once obtained, can be reused **infinitely** — it is never deleted after use (Bug 1)
2. The safety net (cron cleanup) that should expire old tokens **instead preserves them** and deletes valid new ones (Bug 2)
3. Even if the victim changes their password through the normal password update flow, the attacker's old reset token remains valid and can be used to overwrite the new password

---

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Bug |
|---|---|---|---|
| `pkg/user/user_password_reset.go` | `ResetPassword()` | Line 68 | Wrong token kind (`TokenEmailConfirm` instead of `TokenPasswordReset`) in `removeTokens()` call |
| `pkg/user/token.go` | `RegisterTokenCleanupCron()` (anonymous cron function) | Line 134 | Inverted `>` comparison should be `<` |

### Supporting Code

| File | Function | Lines | Role |
|---|---|---|---|
| `pkg/user/token.go` | `removeTokens()` | 113-117 | Deletes tokens by user_id + kind — correct implementation, called with wrong kind |
| `pkg/user/token.go` | `getToken()` | 94-103 | Retrieves token by plaintext value and kind — **no expiration check** |
| `pkg/user/token.go` | `generateToken()` | 69-76 | Creates token with plaintext storage (not hashed) |
| `pkg/user/token.go` | Token kind constants | 32-37 | `TokenPasswordReset=1`, `TokenEmailConfirm=2`, `TokenAccountDeletion=3`, `TokenCaldavAuth=4` |
| `pkg/routes/api/v1/user_password_reset.go` | `UserResetPassword()` | 40-72 | HTTP handler for `POST /api/v1/user/password/reset` |
| `pkg/routes/api/v1/user_password_reset.go` | `UserRequestResetPasswordToken()` | 85-111 | HTTP handler for `POST /api/v1/user/password/token` |

---

## Triggering Input

### Step 1: Request a Password Reset Token
```http
POST /api/v1/user/password/token HTTP/1.1
Content-Type: application/json

{"email": "victim@example.com"}
```
Response: `{"message": "Token was sent."}`

The token is stored in plaintext in the `user_tokens` table (kind=1).

### Step 2: First Password Reset (Normal Use)
```http
POST /api/v1/user/password/reset HTTP/1.1
Content-Type: application/json

{"token": "<64_char_random_token>", "new_password": "attackerpass1"}
```
Response: `{"message": "The password was updated successfully."}`

After this call, the password reset token **remains in the database** (Bug 1). The system only deletes `TokenEmailConfirm` tokens (kind=2).

### Step 3: Token Reuse (Exploit)
```http
POST /api/v1/user/password/reset HTTP/1.1
Content-Type: application/json

{"token": "<same_64_char_token>", "new_password": "attackerpass2"}
```
Response: `{"message": "The password was updated successfully."}`

This succeeds because:
1. `getToken()` finds the token in the database (it was never deleted)
2. `getToken()` has **no expiration check** — there is no TTL verification at query time
3. The password is changed again to `attackerpass2`
4. The token is STILL not deleted (same bug repeats)

### Token Format
- 64-character cryptographically random string (via `utils.CryptoRandomString(64)`)
- Stored in **plaintext** in the `user_tokens` table (unlike CalDAV tokens which are bcrypt-hashed)
- Password in the reset request must be 8-72 characters (bcrypt constraint)

---

## Attack Scenario

### Realistic Attack: Persistent Account Takeover

**Attacker**: Remote, unauthenticated (pre-auth for reset endpoints; token acquisition requires a side channel)

1. **Obtain a password reset token** via any of these vectors:
   - Phishing the victim into clicking a crafted link (the token is in the email body as a URL parameter: `?userPasswordReset=<token>`)
   - Network sniffing if email transport is unencrypted (SMTP without TLS)
   - Compromising the victim's email account temporarily
   - Server-side log exposure (when mailer is disabled, token is generated but not sent — exists only in DB)
   - Database read access (SQL injection, backup exposure, etc.)

2. **First use**: Reset the victim's password with the token. This succeeds normally and invalidates all existing sessions for the victim (the handler calls `DeleteAllUserSessions`).

3. **Victim recovers**: The victim notices they're locked out, requests a new password reset, and regains access with a new password.

4. **Persistent backdoor**: The attacker uses the **same original token** to reset the password again. This works because:
   - The original token was never deleted from the database (Bug 1)
   - The cron job that should expire old tokens actually preserves them (Bug 2)
   - The victim requesting a new reset does NOT invalidate old tokens (no cleanup before token generation)
   
5. **Infinite loop**: Steps 3-4 can repeat indefinitely. The victim can never permanently recover their account because the attacker's token never expires.

### Lab PoC Flow (Self-Contained)

1. Start Vikunja v2.0.0 with SQLite backend, mailer disabled
2. Register a user via `POST /api/v1/register`
3. Request password reset via `POST /api/v1/user/password/token`
4. Extract the token from the SQLite database directly (`SELECT token FROM user_tokens WHERE kind=1`)
5. Use the token to reset the password → success
6. Verify the token **still exists** in the database
7. Use the **same token** to reset the password **again** → success (demonstrates Bug 1)
8. Optionally verify authentication with both passwords to confirm the second reset changed the password

---

## Impact

- **CVSS 9.8 Critical** — Network/Low-Complexity/No-Auth/No-Interaction
- **Full account takeover**: Attacker can change any user's password if they obtain a reset token
- **Persistent backdoor**: Unlike normal token reuse bugs, this creates an infinite-lifetime backdoor token
- **Session invalidation bypass**: Although the reset handler invalidates all sessions, the attacker can immediately create a new session with the newly-set password
- **No victim remediation**: The victim cannot remove the malicious token through any user-facing action (no "revoke all tokens" UI); only direct database intervention or upgrading to v2.1.0 resolves it
- **Amplified by Bug 2**: The cron cleanup that should be a safety net actively makes the problem worse by preserving old tokens and deleting valid new ones

---

## Authentication Requirements

**The vulnerable endpoint (`POST /api/v1/user/password/reset`) requires NO authentication.**

Both password reset endpoints are explicitly listed in `unauthenticatedAPIPaths` (routes.go:254-255):
```go
var unauthenticatedAPIPaths = map[string]bool{
    "/api/v1/user/password/token": true,
    "/api/v1/user/password/reset": true,
    ...
}
```

The only "credential" needed is the reset token itself. Rate limiting is available but disabled by default (`ratelimit.enabled` defaults to `false`).

For the PoC lab:
- **Registration**: `POST /api/v1/register` — no auth needed, requires `{"username": "...", "email": "...", "password": "..."}`
- **Login**: `POST /api/v1/login` — returns a JWT in `{"token": "..."}` — used to verify account access before/after exploitation
- **Token extraction**: Direct SQLite database read (since mailer is disabled, the token cannot be obtained via email in the lab)

---

## Fix Assessment

### Fix Commit 1 (`5c2195f`) — Token Deletion: **CORRECT AND COMPLETE**

The fix changes line 68 of `user_password_reset.go`:
```diff
-err = removeTokens(s, user, TokenEmailConfirm)
+err = removeTokens(s, user, TokenPasswordReset)
```

This correctly deletes all `TokenPasswordReset` tokens for the user after a successful password reset. The `removeTokens()` function deletes ALL tokens of the specified kind for the user (not just the one used), which is the correct behavior — it invalidates any other pending reset tokens as well.

### Fix Commit 2 (`412215ee`) — Cron Cleanup: **CORRECT AND COMPLETE**

The fix:
1. Extracts the cleanup logic into a standalone `CleanupOldTokens()` function (testable)
2. Changes the WHERE clause comparison:
```diff
-Where("created > ? AND (kind = ? OR kind = ?)", ...)
+Where("created < ? AND (kind = ? OR kind = ?)", ...)
```

This correctly selects tokens **older** than 24 hours for deletion.

### Overall Fix Quality: **COMPLETE**

Both fixes address their respective root causes directly. The combination of:
- Immediate token deletion after use (Fix 1)
- Correct periodic cleanup of old tokens (Fix 2)

...provides defense-in-depth. Even if one mechanism fails, the other provides protection.

**No bypass vectors identified.** The fix is comprehensive because:
- `removeTokens()` deletes ALL password reset tokens for the user, not just the one used
- The `getToken()` function does exact plaintext match — no encoding/normalization bypass possible
- Token kind is an integer enum — no type confusion possible
- The cron cleanup correctly targets both `TokenPasswordReset` and `TokenAccountDeletion`
- New unit tests verify both the token removal and cron cleanup behavior

---

## Escalation Path

The primary primitive is **authentication bypass / account takeover**. Escalation depends on the victim's permissions:

1. **Admin account takeover**: If the attacker targets an admin user's email, they gain full administrative access to the Vikunja instance (manage users, projects, settings)
2. **Data exfiltration**: Full access to the victim's tasks, projects, attachments, and shared data
3. **No direct RCE path**: Vikunja is a task management application. There is no built-in code execution feature, shell access, or plugin system that would allow escalating from account takeover to remote code execution on the server itself
4. **Lateral movement**: If the victim reuses passwords across services, the attacker could attempt credential stuffing (but this is outside Vikunja's scope)

**Escalation assessment**: Account takeover is the maximum impact achievable through this vulnerability. No RCE escalation path exists within the application.

---

## Related Attack Surface

### Other Token-Consuming Functions (Same Pattern — NOT Vulnerable)

I examined all other token consumption paths for the same "wrong token kind" bug:

| Function | File | Token Kind Deleted | Correct? |
|---|---|---|---|
| `ConfirmEmail()` | `pkg/user/user_email_confirm.go:51` | `TokenEmailConfirm` | ✅ Correct |
| `ConfirmDeletion()` | `pkg/user/delete.go:133` | `TokenAccountDeletion` | ✅ Correct |
| `DeleteCaldavTokenByID()` | `pkg/user/caldav_token.go:49` | `TokenCaldavAuth` (via `removeTokenByID`) | ✅ Correct |

**Only `ResetPassword()` has the wrong token kind bug.** All other token consumers correctly delete their own token type.

### Token Accumulation Issue

The `RequestUserPasswordResetToken()` function (user_password_reset.go:117) does NOT remove old password reset tokens before generating a new one. This means multiple tokens can accumulate for the same user. However, this is mitigated by Fix 1 (which removes ALL password reset tokens for the user when any one is used) and Fix 2 (which cleans up tokens older than 24 hours).

### Cron Bug Affects Account Deletion Tokens Too

The cron cleanup bug (Bug 2) also affects `TokenAccountDeletion` tokens. Old account deletion tokens are preserved instead of being cleaned up. However, the `ConfirmDeletion()` function correctly removes `TokenAccountDeletion` tokens after use, so this does not create a reuse vulnerability for account deletion — only a cleanup gap.

### No Additional Vulnerable Patterns Found

I searched for:
- Other uses of `removeTokens()` with mismatched token kinds — none found
- Other SQL queries with `created >` that should be `created <` — none found
- Token consumption without deletion — none found (all paths call `removeTokens` or `removeTokenByID`)

---

## Build System

| Field | Value |
|---|---|
| **Language** | Go 1.25.0 (toolchain go1.25.6) |
| **Module** | `code.vikunja.io/api` |
| **Build Tool** | `mage` (Go-based build system) or direct `go build` |
| **CGO Required** | Yes — SQLite driver (`github.com/mattn/go-sqlite3`) requires CGO |

## Build Commands

### Simplified API-only build (recommended for lab):
```bash
CGO_ENABLED=1 go build -o vikunja .
```

### Using mage:
```bash
go install github.com/magefile/mage@latest
mage build
```

### Minimal run command:
```bash
VIKUNJA_DATABASE_TYPE=sqlite \
VIKUNJA_DATABASE_PATH=/data/vikunja.db \
VIKUNJA_SERVICE_INTERFACE=:3456 \
VIKUNJA_MAILER_ENABLED=false \
VIKUNJA_SERVICE_ENABLEREGISTRATION=true \
VIKUNJA_AUTH_LOCAL_ENABLED=true \
VIKUNJA_SERVICE_JWTSECRET=changemeplease \
VIKUNJA_LOG_LEVEL=DEBUG \
./vikunja
```

## Dependencies

### Build Dependencies
- Go 1.25+ toolchain
- GCC / C compiler (for CGO — required by SQLite3 driver)
- `mage` build tool (optional — `go build` works directly)

### System Packages (for Docker/Alpine/Wolfi base)
```
go, gcc, musl-dev (or libc-dev), sqlite-dev, git
```

### Runtime Dependencies
- No external services required (SQLite is embedded)
- No mailer needed (disable for PoC — tokens stored in DB)
- No frontend build needed (API-only is sufficient for PoC)

## Runtime Requirements

### Configuration for Lab
```yaml
# config.yml (or equivalent environment variables)
database:
  type: sqlite
  path: /data/vikunja.db
service:
  interface: ":3456"
  enableregistration: true
  jwtsecret: "changemeplease"
mailer:
  enabled: false
auth:
  local:
    enabled: true
log:
  level: DEBUG
ratelimit:
  enabled: false
```

### Network
- Single port: TCP 3456 (HTTP API)
- No TLS required for lab

### Database
- SQLite (default, self-contained)
- Database file created automatically on first start
- PoC needs direct read access to the `.db` file to extract reset tokens (since mailer is disabled)
- SQLite CLI (`sqlite3`) should be available in the lab container

### Docker Base Image Recommendation
- `golang:1.25-alpine` for build stage (includes Go + Alpine base)
- `alpine:latest` for runtime (add `sqlite`, `sqlite-dev` packages)
- Or single-stage with `golang:1.25-bookworm` (Debian — avoids musl/CGO issues)

### Key Notes for Lab Build Agent
1. **CGO is mandatory** — SQLite driver requires it. Set `CGO_ENABLED=1` and ensure GCC is available.
2. **Mailer must be disabled** — So tokens are only stored in DB (no email delivery needed)
3. **SQLite CLI required** — The PoC script needs to read tokens directly from the database file
4. **No frontend needed** — API endpoints are sufficient; skip the pnpm/Node.js frontend build entirely
5. **Registration must be enabled** — PoC creates test users via the API
6. **Rate limiting should be disabled** — Default is disabled; ensure it stays off for testing
7. **JWT secret must be set** — Any string works; Vikunja won't start without it
