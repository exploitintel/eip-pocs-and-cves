# CVE-2025-67895 - Apache Airflow Edge3 Provider RCE via Exposed Internal RPC API

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2025-67895 |
| Component | [Apache Airflow Providers Edge3](https://github.com/apache/airflow) |
| Type | CWE-669: Incorrect Resource Transfer Between Spheres |
| CVSS | 9.8 (Critical) — `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| EPSS | 0.3% (57th percentile) |
| Affected | apache-airflow-providers-edge3 1.0.0 – 1.6.0 (all < 2.0.0) on Airflow 2.11.0+ |
| Fix | Upgrade to apache-airflow-providers-edge3 2.0.0+ |
| Author | Exploit Intelligence Platform |
| Date | 2026-03-01 |

## Overview

Apache Airflow Providers Edge3 versions prior to 2.0.0 expose Airflow's **entire internal RPC API** through an externally-reachable, CSRF-exempt HTTP endpoint (`/edge_worker/v1/rpcapi`) when running on Airflow 2.x (>=2.11.0) with `[edge] api_enabled=True`. An attacker who knows the `internal_api_secret_key` can invoke any of the 73 internal Airflow methods — reading secrets (Variables, Connection credentials), writing configuration, triggering DAG runs, and achieving remote code execution via malicious job injection into the Edge Worker execution pipeline.

Additionally, the provider's CSRF-exempt REST management endpoints allow registering rogue workers into the cluster, maintaining persistent access, and hijacking queued tasks.

## Affected Versions

| Component | Affected | Fixed |
|---|---|---|
| `apache-airflow-providers-edge3` | **1.0.0 through 1.6.0** (all versions < 2.0.0) | **2.0.0** |
| Apache Airflow (required) | 2.11.0+ (Airflow 2.x only) | N/A (Airflow 3.x is not affected) |

**Preconditions for exploitation:**
- Airflow 2.11.x webserver running with `apache-airflow-providers-edge3 < 2.0.0`
- `[edge] api_enabled = True` in `airflow.cfg`
- Attacker knows or can guess `[core] internal_api_secret_key`
- Attacker has network access to the Airflow webserver (port 8080 by default)

## CVSS Score

| Field | Value |
|---|---|
| **Score** | **9.8 / 10 — Critical** |
| **Vector** | `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| **CWE** | CWE-669 — Incorrect Resource Transfer Between Spheres |

- **Attack Vector**: Network (HTTP)
- **Attack Complexity**: Low
- **Privileges Required**: None (JWT auth uses shared secret key)
- **User Interaction**: None
- **Scope**: Unchanged

## Root Cause

The Edge3 provider was developed for dual compatibility with both Airflow 2.x and 3.x. The Airflow 2.x code path (`_get_airflow_2_api_endpoint()` in `edge_executor_plugin.py`) creates a Connexion-based Flask Blueprint from an OpenAPI specification (`edge_worker_api_v1.yaml`), **exempts it from CSRF protection**, and routes requests to handler functions in `_v2_routes.py`.

The most dangerous handler is `rpcapi_v2()`, which:

1. Accepts JSON-RPC 2.0 requests at `POST /edge_worker/v1/rpcapi`
2. Calls `initialize_method_map()` from `airflow.api_internal.endpoints.rpc_api_endpoint` to obtain **ALL** internal Airflow RPC methods (73 methods)
3. Deserializes attacker-controlled parameters via `BaseSerialization.deserialize()` (capable of reconstructing arbitrary Pydantic/Python objects)
4. Dispatches the deserialized parameters to any internal Airflow method

This effectively proxies the internal Airflow RPC API — intended only for trusted inter-component communication — through an externally-reachable endpoint. On the worker side, `_launch_job_af2_10()` passes job commands directly to `subprocess.Popen(command)` where the command list is reconstructed from the database via `ast.literal_eval()`, enabling remote code execution through malicious job injection.

## Lab Setup

### Prerequisites

- Docker with Compose plugin installed
- ~2 GB disk space for the Airflow Docker image

### Build and Start

```bash
cd CVE-2025-67895
docker compose build
docker compose up -d
```

Wait approximately 30-60 seconds for Airflow to initialize the database and start the webserver.

### Container Details

| Container | Role | Port | Health Check |
|---|---|---|---|
| `cve-2025-67895-db` | PostgreSQL 16 database backend | 5432 (internal) | `pg_isready -U airflow` |
| `cve-2025-67895-vulnerable` | Airflow 2.11.1 webserver with vulnerable Edge3 provider 1.6.0 | **8080** | `GET /health` |

### Default Credentials

| Service | Username | Password | Role |
|---|---|---|---|
| Airflow Web UI | `admin` | `admin` | Admin |
| PostgreSQL | `airflow` | `airflow` | DB Owner |

### Key Configuration

| Config Key | Value | Purpose |
|---|---|---|
| `[edge] api_enabled` | `True` | Enables the vulnerable Edge Worker API endpoints |
| `[core] internal_api_secret_key` | `my-secret-key-for-testing` | JWT signing key for RPC API authentication |
| `AIRFLOW_ENABLE_AIP_44` | `true` | Enables AIP-44 internal API serialization mode |

### Verify the Lab is Running

```bash
docker compose ps
# Should show both containers healthy

# Test Edge Worker health endpoint (no authentication required)
curl http://localhost:8080/edge_worker/v1/health
# Expected: {"status": "healthy"}
```

### Initialize Edge Worker Tables (Required for Vector 2)

```bash
docker exec cve-2025-67895-vulnerable python3 -c "
from airflow.providers.edge3.models.edge_worker import EdgeWorkerModel
from airflow.providers.edge3.models.edge_job import EdgeJobModel
from airflow.settings import engine
EdgeWorkerModel.metadata.create_all(engine, checkfirst=True)
EdgeJobModel.metadata.create_all(engine, checkfirst=True)
"
```

### (Optional) Seed Test Connections for Vector 3

```bash
docker exec cve-2025-67895-vulnerable python3 -c "
from airflow.settings import Session
from airflow.models.connection import Connection
session = Session()
session.add(Connection(conn_id='aws_production', conn_type='aws', login='AKIAIOSFODNN7EXAMPLE', password='wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'))
session.add(Connection(conn_id='production_db', conn_type='postgres', host='prod-db.internal.example.com', login='prod_admin', password='SuperSecretDBPassword123!', port=5432, schema='production'))
session.commit()
"
```

### Stop the Lab

```bash
docker compose down

# Full reset (including database volumes)
docker compose down -v
```

## PoC Usage

### Dependencies

```bash
pip install PyJWT requests
```

### Vector 1 - RPC API Internal Method Invocation (Primary)

```bash
python3 poc/poc.py localhost 8080
```

Tests the full RPC API exploit chain: health check, JWT generation, variable write via `Variable._set()`, variable read-back via `MetastoreBackend._fetch_variable()`, and probes additional sensitive methods (`trigger_dag`, `_fetch_connection`, `_set_state`, `BaseXCom.set`).

### Vector 2 - Fake Worker Registration via REST API

```bash
python3 poc/poc_vector2.py localhost 8080
```

Registers a rogue Edge Worker (`evil_attacker_node`) into the Airflow cluster, updates worker state via heartbeat, and attempts to fetch queued jobs (task hijacking).

### Vector 3 - Secrets Exfiltration & Integrity Poisoning

```bash
python3 poc/poc_vector3.py localhost 8080
```

Enumerates and exfiltrates Airflow Variables and Connection objects (AWS keys, database credentials), then injects poisoned variables into the Airflow metastore.

### Expected Output

```
========================================================================
  CVE-2025-67895 — Airflow Edge3 Provider RPC API Exposure PoC
  Apache Airflow Providers Edge3 < 2.0.0
  CVSS 9.8 CRITICAL | CWE-669
========================================================================

[*] Step 1: Checking Edge Worker API health (no auth)...
    [+] Edge Worker API is ACTIVE: {"status": "healthy"}

[*] Step 3: Writing Airflow variable via internal RPC API...
    HTTP Status: 200
    [+] Variable SET successfully via internal API!

[*] Step 4: Reading variable back via internal RPC API...
    HTTP Status: 200
    Response: "RCE_PROOF_OF_CONCEPT_<timestamp>"
    [+] Variable READ back successfully — value matches!
    [+] CONFIRMED: Full read/write access to Airflow internals

========================================================================
  [+] CVE-2025-67895 CONFIRMED — VULNERABLE

  73 internal Airflow methods are exposed via this endpoint.
========================================================================
```

## Verification

### Vulnerable vs Patched

| Behavior | Vulnerable (Edge3 < 2.0.0) | Patched (Edge3 >= 2.0.0) |
|---|---|---|
| `GET /edge_worker/v1/health` | `{"status": "healthy"}` | HTTP 404 |
| `POST /edge_worker/v1/rpcapi` (Variable write) | HTTP 200 — variable written | HTTP 404 |
| `POST /edge_worker/v1/rpcapi` (Variable read) | HTTP 200 — value returned | HTTP 404 |
| Worker registration via REST | HTTP 200 — worker created | HTTP 404 |
| Job fetch via REST | HTTP 204 — endpoint authenticated | HTTP 404 |

On the patched version, the entire `/edge_worker/v1/` Flask Blueprint is removed. The health endpoint returns 404, and none of the RPC or REST endpoints exist.

## Exposed Attack Surface

All endpoints registered via the CSRF-exempt Flask Blueprint:

| Endpoint | Method | Auth | Handler | Risk |
|---|---|---|---|---|
| `/edge_worker/v1/health` | GET | None | Health check | Reconnaissance |
| `/edge_worker/v1/rpcapi` | POST | JWT | `rpcapi_v2()` | **Full internal RPC API proxy (73 methods)** |
| `/edge_worker/v1/worker/{name}` | POST | JWT | `register_v2()` | Rogue worker injection |
| `/edge_worker/v1/worker/{name}` | PATCH | JWT | `set_state_v2()` | Worker state manipulation |
| `/edge_worker/v1/jobs/fetch/{name}` | POST | JWT | `job_fetch_v2()` | Task hijacking |
| `/edge_worker/v1/jobs/state/...` | PATCH | JWT | `job_state_v2()` | Job state manipulation |
| `/edge_worker/v1/logs/logfile_path/...` | GET | JWT | `logfile_path_v2()` | Information disclosure |
| `/edge_worker/v1/logs/push/...` | POST | JWT | `push_logs_v2()` | Log injection |

## Fix

The fix (commit [`fffab39f99`](https://github.com/apache/airflow/commit/fffab39f99607e3c54842342fdc982babd403707), [PR #59143](https://github.com/apache/airflow/pull/59143)) **completely removes all Airflow 2.x compatibility code** from the Edge3 provider.

### Files Deleted

| File | Purpose |
|---|---|
| `_v2_routes.py` | All Connexion/Flask route handlers including `rpcapi_v2()` |
| `_v2_compat.py` | Connexion compatibility shims including `parse_command()` with `ast.literal_eval()` |
| `edge_worker_api_v1.yaml` | OpenAPI spec defining the Airflow 2.x endpoints |

### Files Modified

| File | Change |
|---|---|
| `edge_executor_plugin.py` | Removed `_get_airflow_2_api_endpoint()`, `csrf.exempt()`, Flask Blueprint registration |
| `auth.py` | Removed Airflow 2.x `JWTSigner` auth path |
| `worker.py` | Removed `_launch_job_af2_10()` with `subprocess.Popen` |
| `edge_executor.py` | Removed `execute_async()` for Airflow 2.x |

### Why the Fix Works

By removing all Airflow 2.x support, the fix eliminates:
1. The Connexion Flask Blueprint and all v2 route handlers
2. The CSRF exemption on the entire Blueprint
3. The `/rpcapi` endpoint that proxied the internal API
4. The `BaseSerialization.deserialize()` call on untrusted input
5. The `parse_command()` using `ast.literal_eval()` on database strings
6. The `subprocess.Popen(command)` execution path
7. The `JWTSigner` authentication path

**No bypass vectors were identified.** The fix eliminates the vulnerable code rather than patching it.

## Technical Notes

- **JWT Algorithm:** The Airflow `JWTSigner` uses **HS512** (not HS256). All PoC scripts use `algorithm='HS512'`.
- **JWT Claims:** For the RPC endpoint, the `method` claim must match the fully qualified Python method name. For REST endpoints, it must match the URL path after `/edge_worker/v1/`.
- **Serialization Format:** RPC parameters must be wrapped in Airflow's `BaseSerialization` format: `{"__var": {...}, "__type": "dict"}`.
- **AIP-44 Flag:** The `AIRFLOW_ENABLE_AIP_44=true` environment variable is required for `BaseSerialization.deserialize()` to function with `use_pydantic_models=True`.
- **Scheduler not required:** The Airflow scheduler is not started in the lab — the webserver alone is sufficient to demonstrate the vulnerability.

## References

| Source | URL |
|---|---|
| **NVD** | https://nvd.nist.gov/vuln/detail/CVE-2025-67895 |
| **GHSA Advisory** | [GHSA-66h8-3g48-6hx8](https://github.com/advisories/GHSA-66h8-3g48-6hx8) |
| **Fix PR** | https://github.com/apache/airflow/pull/59143 |
| **Fix Commit** | [`fffab39f99`](https://github.com/apache/airflow/commit/fffab39f99607e3c54842342fdc982babd403707) |
| **ASF Advisory** | https://lists.apache.org/thread/hhnmmzkj5qx5gbk6pdkh8tcsx5oj1nqs |
| **OSS-Security** | http://www.openwall.com/lists/oss-security/2025/12/16/3 |
| **Repository** | https://github.com/apache/airflow (`providers/edge3/`) |

## Timeline

| Date | Event |
|---|---|
| **2025-12-07** | Fix merged (PR #59143 by jscheffl) |
| **2025-12-16** | OSS-Security disclosure |
| **2025-12-17** | CVE-2025-67895 published, advisory released |
| **2026-03-01** | This PoC lab created and verified |

## Files

```
CVE-2025-67895/
├── README.md                        # This file
├── poc/
│   ├── poc.py                       # Vector 1: RPC API method invocation (primary)
│   ├── poc_vector2.py               # Vector 2: Fake worker registration via REST API
│   └── poc_vector3.py               # Vector 3: Secrets exfiltration & integrity poisoning
├── Dockerfile.vulnerable            # Container build file
├── docker-compose.yml               # Container orchestration
├── airflow.cfg                      # Airflow config with [edge] api_enabled = True
├── entrypoint.sh                    # Container entrypoint
├── intel_brief.md                   # CVE intelligence brief
├── vulnerability_analysis.md        # Root cause analysis
├── lab_build_report.md              # Lab build report
└── poc_verification_report.md       # PoC test results
```

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2025-67895 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
