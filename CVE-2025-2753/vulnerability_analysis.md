# Vulnerability Analysis: CVE-2025-2753

## Root Cause

**Use of uninitialized pointer array leading to out-of-bounds read / SEGV (CWE-457 / CWE-125 / CWE-119)**

The Open Asset Import Library (assimp) v5.4.3 LightWave Scene (LWS) importer allocates pointer arrays for lights and cameras using `new Type *[num]` **without value-initialization** (missing trailing `()` for zero-init). When a malformed LWS file causes a mismatch between the counted number of lights/cameras during parsing and the number actually populated during scene graph traversal, uninitialized pointer slots remain in the arrays. These garbage pointers are subsequently dereferenced by `SceneCombiner::CopyScene()` → `CopyPtrArray()` → `SceneCombiner::Copy()`, causing a segmentation fault.

The core issue is a **two-phase mismatch**:
1. **Counting phase** (parsing): The LWS parser counts `AddLight` / `AddCamera` keywords to determine `num_light` / `num_camera`.
2. **Filling phase** (graph building): `BuildGraph()` only fills array slots for nodes reachable from the root traversal. Nodes with resolved parents that are themselves unreachable (due to malformed parent IDs, circular references, or garbled data) are never visited, leaving their array slots containing uninitialized heap memory.

## Vulnerable File(s) and Function(s)

### Primary Vulnerability: LWSLoader.cpp — Array Allocation Without Initialization

**File:** `code/AssetLib/LWS/LWSLoader.cpp`

**Lines 854-861** (`InternReadFile`):
```cpp
if (num_camera > 0u) {
    master->mCameras = new aiCamera *[master->mNumCameras = num_camera];  // BUG: no ()
}
aiCamera **cams = master->mCameras;
if (num_light) {
    master->mLights = new aiLight *[master->mNumLights = num_light];      // BUG: no ()
}
aiLight **lights = master->mLights;
```

The arrays are allocated with `new Type*[count]` which leaves all pointer slots **uninitialized** (containing heap garbage, e.g., `0xbebebebebebebebe` under ASan).

### Secondary: BuildGraph — Conditional Array Filling

**File:** `code/AssetLib/LWS/LWSLoader.cpp`
**Lines 320-448** (`BuildGraph`):

```cpp
void LWSImporter::BuildGraph(aiNode *nd, LWS::NodeDesc &src, ...,
        aiCamera **&camOut, aiLight **&lightOut, ...) {
    if (src.type == LWS::NodeDesc::OBJECT) {
        // ... no camOut/lightOut increment
    } else if (src.type == LWS::NodeDesc::LIGHT) {
        aiLight *lit = *lightOut++ = new aiLight();    // fills slot ONLY if reached
    } else if (src.type == LWS::NodeDesc::CAMERA) {
        aiCamera *cam = *camOut++ = new aiCamera();    // fills slot ONLY if reached
    }
    // Recurse into children
    for (...) { BuildGraph(ndd, **it, ...); }
}
```

Only nodes visited during recursive graph traversal get their slots filled. Nodes that were counted during parsing but are unreachable from the root remain unfilled.

### Trigger: CopyPtrArray — Dereferences Uninitialized Pointers

**File:** `code/Common/SceneCombiner.cpp`
**Lines 977-986** (`CopyPtrArray`):

```cpp
template <typename Type>
inline void CopyPtrArray(Type **&dest, const Type *const *src, ai_uint num) {
    if (!num) { dest = nullptr; return; }
    dest = new Type *[num];
    for (ai_uint i = 0; i < num; ++i) {
        SceneCombiner::Copy(&dest[i], src[i]);  // CRASH: src[i] is garbage pointer
    }
}
```

### Crash Location: SceneCombiner::Copy(aiLight)

**File:** `code/Common/SceneCombiner.cpp`

`Copy(aiLight**, const aiLight*)` dereferences the garbage pointer from `src[i]` when trying to copy `aiString::operator=()` on the light's name member.

## Triggering Input

The PoC is a 661-byte malformed LWS file (`poc/crash.lws`).

Key characteristics of the malformed file:
- Starts with `LWSC A` (garbled version field — version parsed as 0 or non-numeric)
- Contains multiple `AddLight` keywords (at least 3 instances visible in hex dump) that increment `num_light` during parsing
- Contains `LoadObject` and `ParentObject` keywords with malformed data that create broken parent references
- Uses `\r` (0x0D) as line separator and contains binary garbage interspersed with keywords
- Result: `num_light` ≥ 2 after parsing, but during BuildGraph traversal, only some light nodes are reachable, leaving ≥ 1 uninitialized slot

The file is already saved at: `poc/crash.lws`

## Attack Scenario

### Step-by-Step Exploitation

1. **Attacker crafts a malformed LWS file** containing:
   - Valid LWS header (`LWSC`)
   - Multiple `AddLight` or `AddCamera` keywords to allocate array slots
   - Malformed `ParentObject`/`ParentItem` references that create unreachable light/camera nodes
   - This creates a mismatch: N lights counted, M < N lights reachable during graph traversal

2. **Victim opens the file** using any application that calls assimp's import API:
   - `Assimp::Importer::ReadFile("malicious.lws", flags)`
   - `Assimp::Importer::ReadFileFromMemory(data, size, flags, ".lws")`
   - Any 3D editor, converter, or viewer using assimp (e.g., Blender with assimp plugin, assimp CLI tool, game engines)

3. **LWS importer processes the file**:
   - Parser counts lights/cameras → allocates arrays
   - BuildGraph traverses scene graph → misses some light/camera nodes
   - Uninitialized slots remain (heap garbage: `0xbebebebebebebebe` under ASan, random heap values otherwise)

4. **MergeScenes triggers the crash** via one of two paths:
   - **Path A (no objects loaded)**: `MergeScenes()` → `CopySceneFlat()` → `CopyScene()` → `CopyPtrArray()` → `Copy(aiLight)` dereferences garbage pointer → **SEGV**
   - **Path B (objects loaded)**: `MergeScenes()` directly iterates `(*cur)->mLights[i]` → copies garbage pointer → accesses `(*ppLights)->mName` → **SEGV**

5. **Crash occurs** when `aiString::operator=()` is invoked on the uninitialized pointer's memory.

### Crash Stack Trace (from ASan):
```
#0 aiString::operator=(aiString const&)
#1 SceneCombiner::Copy(aiLight**, aiLight const*)
#2 CopyPtrArray<aiLight>(aiLight**&, aiLight const* const*, unsigned int)
#3 SceneCombiner::CopyScene(aiScene**, aiScene const*)
```

## Impact

- **Denial of Service (DoS)**: Guaranteed crash (SEGV) of any application using assimp to open the malicious file
- **Potential Information Disclosure**: Without ASan, the uninitialized pointer values could point to valid heap memory, potentially leaking data from the application's heap through the copied aiLight/aiCamera structures
- **Potential Code Execution** (theoretical): If an attacker can influence heap layout (e.g., via heap spraying through prior allocations), the uninitialized pointers could be pointed to attacker-controlled data, potentially achieving controlled memory access. This is architecture and allocator dependent.
- **CVSS 6.3 (MEDIUM)**: AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L — requires user interaction (opening a file) but no authentication

## Authentication Requirements

**No authentication required.** This is a file-format vulnerability. The attack vector is:
- Remote: attacker provides a malicious `.lws` file
- No privileges needed
- Requires user interaction: victim must open/import the file
- No network service, no API keys, no sessions — purely file-based

## Fix Assessment

**No fix exists.** The vulnerability remains **unfixed** as of the latest release (v6.0.4, January 2026). The GitHub issue (#6014) was reopened on August 28, 2025.

### Recommended Fixes (in order of preference):

1. **Value-initialize arrays** (minimal, targeted fix):
   ```cpp
   master->mCameras = new aiCamera *[master->mNumCameras = num_camera]();  // zero-init
   master->mLights = new aiLight *[master->mNumLights = num_light]();      // zero-init
   ```
   Then add null-checks in CopyPtrArray:
   ```cpp
   for (ai_uint i = 0; i < num; ++i) {
       if (src[i]) SceneCombiner::Copy(&dest[i], src[i]);
       else dest[i] = nullptr;
   }
   ```

2. **Post-traversal count adjustment** (addresses root cause):
   After BuildGraph returns, compute the actual number of lights/cameras filled and adjust `mNumLights`/`mNumCameras` to match.

3. **Use `std::vector`** (comprehensive fix):
   Replace raw `new Type*[]` with `std::vector<Type*>` throughout, eliminating the uninitialized memory class entirely.

### Fix Status: UNFIXED — remaining attack surface

Since no fix exists, the entire vulnerability is exploitable as-is. No bypass analysis needed — the original attack vector works directly.

## Potential Bypass Vectors

Not applicable — no fix to bypass. The vulnerability is fully exploitable in the latest version.

## Escalation Path

The direct primitive is a **read from uninitialized heap memory → SEGV**. Escalation possibilities:

1. **DoS (guaranteed)**: Any application processing LWS files via assimp will crash
2. **Heap information disclosure (possible)**: Without ASan, uninitialized pointers may reference valid heap regions, potentially leaking application data through the copied structures
3. **Remote Code Execution (theoretical/low probability)**: Would require:
   - Heap grooming to place controlled data at the address the uninitialized pointer happens to contain
   - The `Copy()` function treats the garbage pointer as a valid aiLight/aiCamera struct and copies its contents
   - If attacker controls the heap layout, they could potentially craft a fake object with controlled vtable pointer
   - This is highly environment-dependent and unreliable

**Primary practical impact: Denial of Service via crash.**

## Related Attack Surface

### Same Vulnerability Pattern: 222 instances across 49 files

The `new Type *[count]` without `()` pattern is pervasive across assimp's importers. Every importer that allocates pointer arrays this way is potentially vulnerable if a malformed input file causes a count-vs-fill mismatch.

### Critical Related Files (use MergeScenes like LWS):

1. **`code/AssetLib/Irr/IRRLoader.cpp`** — 8 uninitialized allocations:
   - Line 1271: `tempScene->mCameras = new aiCamera *[tempScene->mNumCameras];`
   - Line 1278: `tempScene->mLights = new aiLight *[tempScene->mNumLights];`
   - Line 1301: `tempScene->mAnimations = new aiAnimation *[tempScene->mNumAnimations];`
   - Line 1315: `an->mChannels = new aiNodeAnim *[an->mNumChannels];`
   - Line 1321: `tempScene->mMeshes = new aiMesh *[tempScene->mNumMeshes];`
   - Line 1328: `tempScene->mMaterials = new aiMaterial *[tempScene->mNumMaterials];`
   - Lines 334, 827: children arrays
   - **Calls MergeScenes at line 1334** — same crash path as LWS

2. **`code/AssetLib/MD3/MD3Loader.cpp`** — 3 uninitialized allocations:
   - Line 765: `pScene->mMeshes = new aiMesh *[pScene->mNumMeshes];`
   - Line 768: `pScene->mMaterials = new aiMaterial *[pScene->mNumMeshes];`
   - Line 1025: `pScene->mRootNode->mChildren = new aiNode *[pcHeader->NUM_TAGS];`

3. **`code/Common/SceneCombiner.cpp`** — CopyPtrArray itself allocates `new Type *[num]` without init at line 982

### High-Instance Importers (most uninitialized allocations):
- `MDL/HalfLife/HL1MDLLoader.cpp` (17 instances)
- `MD5/MD5Loader.cpp` (12 instances)
- `glTF2/glTF2Importer.cpp` (11 instances)
- `Ogre/OgreStructs.cpp` (10 instances)
- `MDL/MDLLoader.cpp` (10 instances)
- `ASE/ASELoader.cpp` (10 instances)
- `Assbin/AssbinLoader.cpp` (9 instances)

### Files that DO use value-initialization (correct pattern):
Approximately 8 files use `new Type *[count]()` or equivalent: `Assjson`, `IQM`, some FBX paths, `XGL`, `USD`, `MS3D`, `3MF`, `C4D`, `Blender`.

## Build System

| Component | Details |
|---|---|
| **Build System** | CMake >= 3.22 |
| **Language Standard** | C++17 |
| **Compiler** | GCC/G++ (Clang also works) |

## Build Commands

### Standard Debug Build (for PoC via crash detection):
```bash
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build -j$(nproc)
```

### ASan Build (for PoC via ASan SEGV report):
```bash
cmake -B build \
  -DCMAKE_BUILD_TYPE=Debug \
  -DCMAKE_CXX_FLAGS="-fsanitize=address -fno-omit-frame-pointer" \
  -DCMAKE_C_FLAGS="-fsanitize=address -fno-omit-frame-pointer" \
  -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=address"
cmake --build build -j$(nproc)
```

### Triggering the crash:
```bash
# Method 1: assimp CLI tool
./build/bin/assimp info /path/to/crash.lws

# Method 2: assimp_cmd dump
./build/bin/assimp dump /path/to/crash.lws /dev/null

# Method 3: Fuzzer harness (if built)
./build/bin/assimp_fuzzer /path/to/crash.lws

# Method 4: Minimal C++ program using ReadFileFromMemory
```

## Dependencies

### Build Dependencies (system packages):
- `cmake` >= 3.22
- `gcc` / `g++` with C++17 support
- `make` or `ninja`
- `git` (for version info during build)

### Optional but recommended:
- `zlib-dev` (bundled in `contrib/zlib/` if not installed)

### All other dependencies are bundled:
- rapidjson, pugixml, utf8cpp, poly2tri, clipper, Open3DGC, openddlparser, stb, zip/unzip, draco — all in `contrib/`

## Runtime Requirements

### Minimum:
- The compiled `assimp` CLI binary (or library + test harness)
- The malformed LWS crash file (`poc/crash.lws`)

### For Docker lab:
- **Base image**: `debian:bookworm-slim` or `ubuntu:22.04` (need cmake >= 3.22)
- **Install**: `build-essential cmake git`
- No network services needed — this is a file-parsing vulnerability
- No configuration files needed
- No external data files (all test data is the crash file itself)

### PoC Validation:
- **With ASan**: Process exits with ASan error report showing SEGV at address `0xbebebebebebebebe`
- **Without ASan**: Process crashes with SIGSEGV (exit code 139)
- **Exit code check**: Non-zero exit (crash) = vulnerability confirmed
