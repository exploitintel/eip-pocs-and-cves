# Intel Brief: CVE-2025-12421

## CVE Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-12421 |
| **Affected Software** | Mattermost Server |
| **Vendor** | Mattermost, Inc. |
| **CVSS Score** | 9.9 (Critical) |
| **CVSS Vector** | CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H |
| **CWE** | CWE-303 (Incorrect Implementation of Authentication Algorithm), CWE-287 (Improper Authentication) |
| **EPSS** | 0.1% (26.6th percentile) |
| **Published** | 2025-11-27 |
| **GHSA** | GHSA-mp6x-97xj-9x62 |

## Description

Mattermost versions 11.0.x <= 11.0.2, 10.12.x <= 10.12.1, 10.11.x <= 10.11.4, 10.5.x <= 10.5.12 fail to verify that the token used during the code exchange originates from the same authentication flow. This allows an authenticated user to perform **account takeover** via a specially crafted email address used when switching authentication methods and sending a request to the `/users/login/sso/code-exchange` endpoint.

## Affected Versions

| Branch | Vulnerable Range | Patched Version |
|---|---|---|
| 11.0.x | 11.0.0 - 11.0.2 | **11.0.3** |
| 10.12.x | 10.12.0 - 10.12.1 | **10.12.2** |
| 10.11.x | 10.11.0 - 10.11.4 | **10.11.5** |
| 10.5.x | 10.5.0 - 10.5.12 | **10.5.13** |

## Repository

| Field | Value |
|---|---|
| **Repository URL** | https://github.com/mattermost/mattermost.git |
| **Vulnerable Version (checked out)** | `v11.0.2` (tag) |
| **Patched Version** | `v11.0.3` (tag) |
| **Primary Language** | Go (1.24.6) |
| **Server Module** | `github.com/mattermost/mattermost/server/v8` |

## Fix Commits

| Commit | Description | Branch |
|---|---|---|
| `acda1fb5dd46a2f46c76ae67012423c760525eaa` | **Original fix**: MM-66299: type handling for ConsumeTokenOnce (#34247) | main |
| `5072bbf689a46b3b97b2373f26149f5891396e6b` | Cherry-pick to release-10.5 (#34256) | release-10.5 |
| `f361e7d75a7ab9df5a2106e1ceb919b94b55e41d` | Cherry-pick to release-10.11 (#34257) | release-10.11 |
| `feb598ed2b7ac3cb78a253b032ad7e4628b0de00` | Cherry-pick to release-11.0 (#34261) | release-11.0 |

## Vulnerability Analysis

### Root Cause

The `ConsumeTokenOnce()` function in `server/channels/app/user.go` and the underlying `ConsumeOnce()` in `server/channels/store/sqlstore/tokens_store.go` did **not validate the token type** when consuming a token. The SQL query was:

```sql
DELETE FROM Tokens WHERE Token = ? RETURNING *
```

This means **any valid token** (regardless of its type — `oauth`, `saml`, or any other) could be consumed at the `/users/login/sso/code-exchange` endpoint, which is intended only for SSO code exchange tokens.

### Vulnerable Code Path

1. **Endpoint**: `POST /users/login/sso/code-exchange` → `loginSSOCodeExchange()` in `server/channels/api4/user.go:117`
2. **Token consumption**: `c.App.ConsumeTokenOnce(loginCode)` (line 133) — accepts ANY token type
3. **Token parsing**: The function then parses `token.Extra` as JSON expecting `user_id`, `code_challenge`, `code_challenge_method`, `state` fields
4. **Session creation**: If the token extra data has valid fields, a session is created for the specified `user_id`

### Attack Vector

The attack exploits the authentication method switching flow:

1. An authenticated attacker initiates a SAML SSO login flow that creates a token of type `TokenTypeSaml` in the `Tokens` table (line 253 of `server/channels/web/saml.go`)
2. The SAML completion flow (`completeSaml`) creates a token with the victim's `user_id` and PKCE challenge values in the `Extra` field
3. The attacker intercepts or controls the `login_code` token value
4. The attacker calls `/users/login/sso/code-exchange` with this SAML token — since `ConsumeTokenOnce()` doesn't check the token type, it is accepted
5. The endpoint returns a valid session token for the victim user → **account takeover**

### Prerequisites

- `FeatureFlags.MobileSSOCodeExchange` must be enabled (controls access to the endpoint)
- `ExperimentalEnableAuthenticationTransfer` should be enabled (default: true) — allows auth method switching
- `RequireEmailVerification` should be disabled (default: disabled) — allows crafted email addresses
- Attacker needs a valid authenticated session (low-privilege, PR:L)

### Fix Applied

The fix adds a `tokenType` parameter to both `ConsumeTokenOnce()` and `ConsumeOnce()`:

**Before (vulnerable)**:
```go
func (a *App) ConsumeTokenOnce(tokenStr string) (*model.Token, *model.AppError)
// SQL: DELETE FROM Tokens WHERE Token = ? RETURNING *
```

**After (fixed)**:
```go
func (a *App) ConsumeTokenOnce(tokenType, tokenStr string) (*model.Token, *model.AppError)
// SQL: DELETE FROM Tokens WHERE Token = ? AND Type = ? RETURNING *
```

Additionally, a new token type `TokenTypeSSOCodeExchange` was added, and the SAML completion flow now creates tokens with the correct type for mobile SSO code exchange.

### Key Files (Vulnerable Version v11.0.2)

| File | Relevance |
|---|---|
| `server/channels/api4/user.go` | Contains `loginSSOCodeExchange()` — the vulnerable endpoint (line 117) |
| `server/channels/app/user.go` | Contains `ConsumeTokenOnce()` — missing type check (line 1754) |
| `server/channels/store/sqlstore/tokens_store.go` | Contains `ConsumeOnce()` — SQL query without type filter (line 81) |
| `server/channels/web/saml.go` | Contains `completeSaml()` — creates SAML tokens with user data (line 253) |
| `server/channels/app/oauth.go` | Contains `SwitchEmailToOAuth()` — creates SAML relay tokens (line 977) |
| `server/channels/app/saml.go` | Contains `CreateSamlRelayToken()` — token creation helper (line 298) |
| `server/public/model/token.go` | Token model — missing `TokenTypeSSOCodeExchange` constant |

## Build System

| Component | Details |
|---|---|
| **Build Tool** | Go modules + Make |
| **Go Version** | 1.24.6 |
| **Build Command** | `make build-server` (from `server/` directory) |
| **Server Module Path** | `server/` |
| **Server Entrypoint** | `server/cmd/mattermost/` |

### Key Dependencies for Lab

| Dependency | Purpose | Docker Image |
|---|---|---|
| **PostgreSQL 14** | Primary database | `postgres:14` |
| **MinIO** | Object storage (optional) | `minio/minio:RELEASE.2024-06-22T05-26-45Z` |
| **Inbucket** | Email testing (optional) | `inbucket/inbucket:stable` |
| **Keycloak 23.0.7** | SAML/OAuth IDP for testing | `quay.io/keycloak/keycloak:23.0.7` |

### Database Configuration

```
Driver: postgres
DSN: postgres://mmuser:mostest@localhost/mattermost_test?sslmode=disable&connect_timeout=10&binary_parameters=yes
```

### Lab Build Strategy

**Recommended approach**: Build from source at `v11.0.2` tag.

1. Use `golang:1.24` Docker image for building
2. Run `make build-server` in `server/` directory
3. PostgreSQL 14 is the minimum required dependency
4. For the PoC, the lab needs:
   - Mattermost server (built from v11.0.2) running with `MobileSSOCodeExchange` feature flag enabled
   - PostgreSQL database
   - Optionally Keycloak for SAML IDP (or can mock SAML by directly inserting tokens into the DB)
5. The server listens on port **8065** by default

### Alternative Lab Approach (Pre-built Binary)

The `docker-preview` Dockerfile downloads pre-built release tarballs:
```
https://releases.mattermost.com/${VERSION}/mattermost-team-${VERSION}-linux-amd64.tar.gz
```

This could be used with `MATTERMOST_VERSION=11.0.2` for a quicker setup, but building from source gives more control over configuration and debugging.

## Public Exploits

**None found.** No public exploit code exists on ExploitDB, GitHub, Metasploit, or any other tracked source. No Nuclei templates available.

## PoC Strategy Guidance

The vulnerability can be demonstrated by:

1. **Setup**: Deploy Mattermost v11.0.2 with PostgreSQL, enable `MobileSSOCodeExchange` feature flag
2. **Create users**: Create an attacker user and a victim user
3. **Craft attack**:
   a. As attacker, create a token in the Tokens table with type `saml` (or `oauth`) containing victim's `user_id` and valid PKCE challenge data in the `Extra` JSON field
   b. Call `POST /users/login/sso/code-exchange` with the token value, matching `code_verifier`, and `state`
   c. The endpoint will return a valid session token for the victim user
4. **Verify**: Use the returned session token to access the API as the victim user

Since the vulnerability is in token type validation, the simplest PoC can directly insert a crafted token into the database and then call the exchange endpoint — no actual SAML IDP is needed.

## References

| Source | URL |
|---|---|
| GHSA Advisory | https://github.com/advisories/GHSA-mp6x-97xj-9x62 |
| Vendor Advisory | https://mattermost.com/security-updates |
| NVD | https://nvd.nist.gov/vuln/detail/CVE-2025-12421 |
| Source Repository | https://github.com/mattermost/mattermost |
| Original Fix Commit | https://github.com/mattermost/mattermost/commit/acda1fb5dd46a2f46c76ae67012423c760525eaa |
| Cherry-pick (11.0.x) | https://github.com/mattermost/mattermost/commit/feb598ed2b7ac3cb78a253b032ad7e4628b0de00 |
| Cherry-pick (10.5.x) | https://github.com/mattermost/mattermost/commit/5072bbf689a46b3b97b2373f26149f5891396e6b |
| Cherry-pick (10.11.x) | https://github.com/mattermost/mattermost/commit/f361e7d75a7ab9df5a2106e1ceb919b94b55e41d |
