# Vulnerability Analysis: CVE-2025-12421

## Executive Summary

CVE-2025-12421 is a **critical (CVSS 9.9)** authentication bypass vulnerability in Mattermost Server's mobile SSO code exchange flow. The root cause is a **token type confusion** flaw: the `ConsumeTokenOnce()` function consumes tokens from the `Tokens` table without verifying the token type matches the expected `sso-code-exchange` type. This allows an attacker who can obtain or influence the creation of any token in the database (type `saml`, `oauth`, `password_recovery`, `verify_email`, etc.) to exchange it for a valid session as any user whose `user_id` is embedded in the token's `Extra` JSON field, resulting in **full account takeover**.

---

## Root Cause

### Primary Flaw: Missing Token Type Validation in `ConsumeOnce()`

The `SqlTokenStore.ConsumeOnce()` function in `server/channels/store/sqlstore/tokens_store.go:81-93` executes:

```sql
DELETE FROM Tokens WHERE Token = ? RETURNING *
```

This query matches tokens **solely by their token string value** and does not filter by the `Type` column. Any token in the `Tokens` table — regardless of its type (`saml`, `oauth`, `password_recovery`, `verify_email`, `team_invitation`, `guest_invitation`, `cws_access_token`) — can be consumed by this function.

The calling function `App.ConsumeTokenOnce()` in `server/channels/app/user.go:1754-1767` passes through without adding any type validation:

```go
func (a *App) ConsumeTokenOnce(tokenStr string) (*model.Token, *model.AppError) {
    token, err := a.Srv().Store().Token().ConsumeOnce(tokenStr)
    // ... error handling only, no type check ...
    return token, nil
}
```

### Secondary Flaw: Wrong Token Type at Creation

In `server/channels/web/saml.go:253`, the SAML completion flow creates mobile SSO code exchange tokens with type `saml` instead of a dedicated type:

```go
code := model.NewToken(model.TokenTypeSaml, extra)  // Type is "saml", not "sso-code-exchange"
```

This means even in the intended flow, the token type is semantically wrong — it's a SAML relay token type being used for SSO code exchange.

---

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Role |
|------|----------|-------|------|
| `server/channels/store/sqlstore/tokens_store.go` | `ConsumeOnce()` | 81-93 | **SQL query without type filter** — core vulnerability |
| `server/channels/app/user.go` | `ConsumeTokenOnce()` | 1754-1767 | **App-layer wrapper** — no type parameter, no type check |
| `server/channels/api4/user.go` | `loginSSOCodeExchange()` | 117-210 | **Endpoint handler** — calls `ConsumeTokenOnce()` without specifying expected type |
| `server/channels/web/saml.go` | `completeSaml()` | 245-263 | **Token creation** — creates mobile SSO tokens with wrong type (`saml` instead of `sso-code-exchange`) |
| `server/channels/app/saml.go` | `CreateSamlRelayToken()` | 301-315 | **Helper** — hardcodes `TokenTypeSaml` for all callers |
| `server/public/model/token.go` | (constants) | 10-15 | **Missing type constant** — `TokenTypeSSOCodeExchange` does not exist in vulnerable version |

---

## Triggering Input

### Endpoint
```
POST /api/v4/users/login/sso/code-exchange
```

### Request Body (JSON)
```json
{
  "login_code": "<64-char-token-from-Tokens-table>",
  "code_verifier": "<PKCE-verifier-matching-challenge-in-token-Extra>",
  "state": "<state-value-matching-token-Extra>"
}
```

### Token Structure in Database (`Tokens` table)
The token must exist in the `Tokens` table with the `Extra` field containing valid JSON:
```json
{
  "user_id": "<victim-user-id>",
  "code_challenge": "<base64url-SHA256-of-code_verifier>",
  "code_challenge_method": "S256",
  "state": "<matching-state-value>"
}
```

**Critical**: The token can be **any type** — `saml`, `oauth`, `password_recovery`, `verify_email`, `team_invitation`, `guest_invitation`, or any other. The `ConsumeTokenOnce()` function does not check the `Type` column.

### PKCE Challenge Computation
The `code_challenge` is computed as:
```
code_challenge = base64url_no_padding(SHA256(code_verifier))
```

For the PoC, the attacker chooses their own `code_verifier` (arbitrary string), computes the challenge, and stores it in the token's `Extra` JSON. When calling the endpoint, they provide the same `code_verifier`.

---

## Attack Scenario

### Prerequisite Configuration
- `FeatureFlags.MobileSSOCodeExchange` must be `true` — **this is the default** (set in `server/public/model/feature_flags.go:112`)
- Mattermost Server v11.0.0–11.0.2, v10.12.0–10.12.1, v10.11.0–10.11.4, or v10.5.0–10.5.12

### Step-by-Step Attack

**Scenario A: Direct Database Token Injection (PoC Demonstration)**

1. **Identify victim**: Attacker knows or discovers the victim's Mattermost `user_id` (26-char alphanumeric string, e.g., `qwertyuiop1234567890abcdef`)
2. **Generate PKCE values**: Attacker generates a `code_verifier` (e.g., `my_secret_verifier_12345`), computes `code_challenge = base64url(SHA256(code_verifier))`
3. **Insert crafted token**: Attacker inserts into the `Tokens` table:
   ```sql
   INSERT INTO Tokens (Token, CreateAt, Type, Extra) VALUES (
     '<random-64-char-hex>',
     extract(epoch from now()) * 1000,
     'saml',  -- Any type works!
     '{"user_id":"<victim_user_id>","code_challenge":"<computed_challenge>","code_challenge_method":"S256","state":"mystate"}'
   );
   ```
4. **Call code exchange**: Attacker sends unauthenticated POST:
   ```
   POST /api/v4/users/login/sso/code-exchange
   {"login_code":"<token>","code_verifier":"my_secret_verifier_12345","state":"mystate"}
   ```
5. **Receive victim session**: Response contains:
   ```json
   {"token": "<session-token>", "csrf": "<csrf-token>"}
   ```
6. **Account takeover**: Attacker uses the session token to access the API as the victim:
   ```
   GET /api/v4/users/me
   Authorization: Bearer <session-token>
   ```

**Scenario B: Cross-Flow Token Confusion (Realistic Remote Attack)**

1. **Attacker is authenticated** (PR:L — low-privilege user on the same Mattermost instance)
2. **Attacker initiates mobile SAML login**: Triggers the `completeSaml` flow with `code_challenge` parameters under their control via the RelayState
3. **During SAML callback**: If the attacker can manipulate the SAML assertion or email matching to associate with the victim's user, the `completeSaml` handler creates a token with `user.Id` = victim's ID in the `Extra` field
4. **Token is typed as `saml`**: `model.NewToken(model.TokenTypeSaml, extra)` — the token type is `saml`
5. **Attacker captures `login_code`**: The token value is passed in the redirect URL to the mobile client
6. **Attacker calls code-exchange**: Uses the captured `login_code` at `/users/login/sso/code-exchange`
7. **No type check**: `ConsumeTokenOnce()` consumes the `saml` token without verifying it's of type `sso-code-exchange` → session issued for victim

### Authentication Requirements

- **The `/users/login/sso/code-exchange` endpoint is UNAUTHENTICATED** — it uses `api.APIHandler()` (line 68 of `server/channels/api4/user.go`) which sets `RequireSession: false`
- The attacker does NOT need a valid session to call this endpoint
- The only "authentication" is knowledge of a valid token value from the `Tokens` table plus the ability to provide matching PKCE values
- For the PoC using direct DB injection, no authentication is needed at all
- For realistic exploitation, the attacker needs low privileges (authenticated account) to initiate auth flows that create tokens

### Default Credentials (for PoC lab)
- The lab creates users via the Mattermost API. Default admin user can be created during first-time setup
- API endpoint for user creation: `POST /api/v4/users`
- No default credentials — users must be created programmatically

---

## Impact

- **Account Takeover (ATO)**: Attacker obtains a fully authenticated session for any user, including system administrators
- **Scope Change (S:C)**: The vulnerability in the SSO code exchange subsystem allows compromising any user account across the entire Mattermost instance
- **Confidentiality: High** — Full read access to all channels, messages, files accessible to the victim
- **Integrity: High** — Can post messages, modify settings, change passwords, and perform all actions as the victim
- **Availability: High** — Can deactivate users, revoke sessions, or disrupt service when targeting admin accounts

### Escalation Path

If the attacker targets a **System Admin** account:
1. **Account takeover** of admin → full administrative control
2. **Plugin upload**: Admin can upload and enable arbitrary plugins (`POST /api/v4/plugins`) which execute server-side Go code → **Remote Code Execution (RCE)**
3. **System console access**: Can modify all server configuration including database credentials, SMTP settings, file storage, etc.
4. **User management**: Can create, delete, promote, or demote any user
5. **Data exfiltration**: Can export all data via compliance exports

**Escalation chain**: Token type confusion → Account takeover → Admin session → Plugin upload → **RCE**

---

## Fix Assessment

### Changes Applied

The fix (commit `feb598ed2b7ac3cb78a253b032ad7e4628b0de00` for release-11.0) makes these changes:

1. **New token type constant** (`server/public/model/token.go`):
   ```go
   TokenTypeSSOCodeExchange = "sso-code-exchange"
   ```

2. **SQL query now filters by type** (`server/channels/store/sqlstore/tokens_store.go:81`):
   ```sql
   -- Before: DELETE FROM Tokens WHERE Token = ? RETURNING *
   -- After:  DELETE FROM Tokens WHERE Type = ? AND Token = ? RETURNING *
   ```

3. **`ConsumeOnce()` accepts `tokenType` parameter** (`tokens_store.go:81`):
   ```go
   func (s SqlTokenStore) ConsumeOnce(tokenType, tokenStr string) (*model.Token, error)
   ```

4. **`ConsumeTokenOnce()` accepts `tokenType` parameter** (`user.go:1754`):
   ```go
   func (a *App) ConsumeTokenOnce(tokenType, tokenStr string) (*model.Token, *model.AppError)
   ```

5. **Endpoint passes correct type** (`api4/user.go:133`):
   ```go
   token, appErr := c.App.ConsumeTokenOnce(model.TokenTypeSSOCodeExchange, loginCode)
   ```

6. **SAML completion creates tokens with correct type** (`web/saml.go:253`):
   ```go
   -- Before: code := model.NewToken(model.TokenTypeSaml, extra)
   -- After:  code, err = c.App.CreateSamlRelayToken(model.TokenTypeSSOCodeExchange, extra)
   ```

7. **`CreateSamlRelayToken()` accepts `tokenType` parameter** (`app/saml.go:301`):
   ```go
   func (a *App) CreateSamlRelayToken(tokenType string, extra string) (*model.Token, *model.AppError)
   ```

### Fix Quality: Complete and Thorough

The fix addresses the root cause at multiple layers:
- **Database layer**: SQL query now requires type match — even if an attacker has a valid token string, it must be of type `sso-code-exchange` to be consumed at the code-exchange endpoint
- **Application layer**: Type parameter is required by the function signature — callers cannot accidentally omit it
- **Token creation**: Tokens created in the SAML mobile flow now use the dedicated `sso-code-exchange` type, distinct from regular SAML relay tokens
- **Comprehensive tests**: The fix includes tests for wrong-type rejection, double consumption, and successful exchange

**No bypass identified.** The fix is comprehensive for this specific vulnerability. The type check is enforced at the SQL level, making it impossible to bypass through application-level manipulation. There are no alternative encodings, race conditions, or edge cases that could circumvent the `WHERE Type = ? AND Token = ?` clause.

### Note on Related `GetByToken` Pattern

The `GetByToken()` function used elsewhere (e.g., `GetTokenById()` in `user.go:1736`) does NOT use the type-checked atomic consumption pattern. However, these callers either:
- Already validate token type after retrieval (e.g., `GetOAuthStateToken`, `GetSamlEmailToken`, `GetPasswordRecoveryToken`, `GetVerifyEmailToken`, `AddUserToTeamByToken`)
- Are used in different security contexts (e.g., `GetTokenById` in `createUser` which expects invitation tokens and delegates to type-specific handling in `CreateUserWithToken`)

These are separate code paths and do not represent the same vulnerability pattern as the `ConsumeTokenOnce` issue.

---

## Related Attack Surface

### Other Token Consumption Without Type Check

1. **`GetTokenById()` — `server/channels/app/user.go:1736-1752`**
   - Called from `createUser()` handler (`server/channels/api4/user.go:236`)
   - Does NOT validate token type before returning
   - However, the calling code delegates to `CreateUserWithToken()` which performs its own validation
   - **Risk**: Low — different vulnerability class (user creation, not session issuance)

2. **CWS Token Logic — `server/channels/app/login.go:56`**
   - Retrieves token via `GetByToken()` but only checks existence (non-nil), not type
   - Used for Cloud Workspace Service login — requires `CWS_CLOUD_TOKEN` environment variable
   - **Risk**: Very low — requires server-side environment variable to be set

### No Additional Instances of Token Type Confusion Found

- `GetOAuthStateToken()` validates `Type == "oauth"` ✓
- `GetSamlEmailToken()` validates `Type == "saml"` ✓
- `GetPasswordRecoveryToken()` validates `Type == "password_recovery"` ✓
- `GetVerifyEmailToken()` validates `Type == "verify_email"` ✓
- `AddUserToTeamByToken()` validates `Type == "team_invitation" || "guest_invitation"` ✓

None identified as exploitable.

---

## Build System

| Component | Details |
|-----------|---------|
| **Language** | Go 1.24.6 |
| **Module** | `github.com/mattermost/mattermost/server/v8` |
| **Build System** | Go modules + Make |
| **Server Entrypoint** | `server/cmd/mattermost/` |

### Build Commands

```bash
# From the server/ directory:
cd server/

# Build for Linux amd64:
env GOOS=linux GOARCH=amd64 go build -o bin/mattermost -trimpath ./cmd/mattermost

# Or use the Makefile:
make build-linux-amd64
```

### Alternative: Pre-built Binary (Recommended for Lab)

```bash
# Download pre-built release tarball:
wget https://releases.mattermost.com/11.0.2/mattermost-team-11.0.2-linux-amd64.tar.gz
tar -xzf mattermost-team-11.0.2-linux-amd64.tar.gz
```

This is significantly faster than building from source and is the recommended approach for the lab.

### Dependencies

| Dependency | Purpose | Docker Image |
|------------|---------|--------------|
| **PostgreSQL 14** | Primary database (required) | `postgres:14` |
| **Go 1.24.6** | Build only (if building from source) | `golang:1.24` |

### Runtime Requirements

1. **PostgreSQL 14** — Database with user `mmuser`, password `mostest`, database `mattermost_test`
2. **Mattermost Server v11.0.2** — Listening on port 8065
3. **Configuration overrides needed**:
   - `FeatureFlags.MobileSSOCodeExchange = true` (this is already the default)
   - `ServiceSettings.SiteURL` should be set (e.g., `http://localhost:8065`)
   - `SqlSettings.DriverName = "postgres"`
   - `SqlSettings.DataSource = "postgres://mmuser:mostest@db:5432/mattermost_test?sslmode=disable&connect_timeout=10&binary_parameters=yes"`
4. **No SAML IDP required** — The PoC can demonstrate the vulnerability by directly inserting tokens into the database
5. **Network**: Server exposes port 8065 for HTTP API access

### Recommended Lab Architecture

```
docker-compose.yml:
  - postgres:14 (port 5432)
  - mattermost:v11.0.2 (port 8065, connected to postgres)
```

Use the docker-preview Dockerfile pattern (`server/build/docker-preview/Dockerfile`) with `MATTERMOST_VERSION=11.0.2` for a simple all-in-one container, or a two-container setup with separate PostgreSQL.

### Configuration File Template

Base the config on `server/build/docker-preview/config_docker.json` with:
```json
{
  "ServiceSettings": {
    "SiteURL": "http://localhost:8065",
    "EnableOAuthServiceProvider": true
  },
  "SqlSettings": {
    "DriverName": "postgres",
    "DataSource": "postgres://mmuser:mostest@db:5432/mattermost_test?sslmode=disable&connect_timeout=10&binary_parameters=yes"
  },
  "TeamSettings": {
    "EnableOpenServer": true
  },
  "FeatureFlags": {
    "MobileSSOCodeExchange": true
  }
}
```

Note: FeatureFlags are set in the Go code defaults (`feature_flags.go:112`) and apply automatically. They can also be overridden via environment variable `MM_FEATUREFLAGS_MOBILESSOCODEEXCHANGE=true`.

---

## PoC Strategy Summary

The PoC should:
1. Deploy Mattermost v11.0.2 + PostgreSQL in Docker
2. Create an admin user and a victim user via the API
3. Directly insert a crafted token into the `Tokens` table with:
   - `Type = 'saml'` (any type works — this demonstrates the bug)
   - `Extra` containing victim's `user_id`, attacker-chosen `code_challenge`, `code_challenge_method = "S256"`, and `state`
4. Call `POST /api/v4/users/login/sso/code-exchange` with the token value, matching `code_verifier`, and `state`
5. Receive a valid session token for the victim
6. Verify by calling `GET /api/v4/users/me` with the stolen session token
7. Confirm the response shows the victim's user data (account takeover confirmed)

No SAML IDP, no OAuth provider, and no complex authentication flow is needed for the PoC.
