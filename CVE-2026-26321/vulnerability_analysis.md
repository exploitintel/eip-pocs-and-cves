# Vulnerability Analysis: CVE-2026-26321

## Root Cause

The Feishu (Lark) extension in OpenClaw contains **two distinct vulnerabilities** stemming from the same root cause: unsafe handling of media URLs without validation or sandboxing.

### Primary: Arbitrary Local File Read (CWE-22)

The `sendMediaFeishu()` function in `extensions/feishu/src/media.ts` accepts a `mediaUrl` parameter from AI tool calls. The helper function `isLocalPath()` classifies file-system paths (paths starting with `/`, `~`, drive letters, `file://` protocol, or anything that fails URL parsing) and then reads them **directly from disk** using `fs.readFileSync()` with no path restriction, no directory whitelisting, and no sandboxing.

This allows an attacker who can influence the `mediaUrl` parameter to read **any file** readable by the OpenClaw process (typically running as the user who started it).

### Secondary: SSRF (CWE-918)

Two code paths perform unrestricted HTTP fetches:

1. **media.ts line 503**: When `isLocalPath()` returns false (i.e., the URL looks like a remote URL), `fetch(mediaUrl)` is called without SSRF protection — no DNS rebinding protection, no private IP blocking.
2. **docx.ts line 179**: The `downloadImage()` function calls `fetch(url)` on URLs extracted from markdown image references (`![alt](url)`) without any SSRF validation.

Both paths allow an attacker to reach internal services, cloud metadata endpoints (e.g., `http://169.254.169.254/`), and other internal network resources.

## Vulnerable File(s) and Function(s)

### media.ts — Primary Vulnerability

- **File**: `extensions/feishu/src/media.ts`
- **Function `isLocalPath()`**: Lines 455–467
  - Classifies strings as local paths if they start with `/`, `~`, match `/^[a-zA-Z]:/`, have `file:` protocol, or fail URL parsing
- **Function `sendMediaFeishu()`**: Lines 472–541
  - Lines 490–500: When `isLocalPath(mediaUrl)` is true, reads file with `fs.readFileSync(filePath)` (line 499)
  - Lines 501–508: When `isLocalPath(mediaUrl)` is false, fetches URL with bare `fetch(mediaUrl)` (line 503) — no SSRF protection

### docx.ts — Secondary Vulnerability

- **File**: `extensions/feishu/src/docx.ts`
- **Function `downloadImage()`**: Lines 178–184
  - Calls `fetch(url)` with no SSRF validation
- **Function `extractImageUrls()`**: Lines 20–31
  - Extracts URLs from markdown `![alt](url)` patterns; only filters for `http://` or `https://` prefixes
- **Function `processImages()`**: Lines 187–226
  - Calls `downloadImage(url)` for each extracted image URL (line 207)

### outbound.ts — Entry Point

- **File**: `extensions/feishu/src/outbound.ts`
- **Function `feishuOutbound.sendMedia()`**: Lines 15–44
  - Receives `mediaUrl` from AI tool call output and passes it directly to `sendMediaFeishu()` (line 24–28)

## Triggering Input

### Local File Read (Primary)

The `mediaUrl` parameter must be a local file path. Any of these forms trigger the vulnerability:

| Input | Path Classification | File Read Path |
|---|---|---|
| `/etc/passwd` | Starts with `/` → local | `fs.readFileSync("/etc/passwd")` |
| `/etc/shadow` | Starts with `/` → local | `fs.readFileSync("/etc/shadow")` |
| `~/.ssh/id_rsa` | Starts with `~` → local | `fs.readFileSync("$HOME/.ssh/id_rsa")` |
| `file:///etc/passwd` | `file:` protocol → local | `fs.readFileSync("/etc/passwd")` |
| `C:\Windows\System32\config\SAM` | Drive letter → local | `fs.readFileSync(...)` (Windows) |
| `not-a-url` | Fails URL parse → local | `fs.readFileSync("not-a-url")` |

The simplest trigger is:
```
mediaUrl = "/etc/passwd"
```

### SSRF (Secondary — media.ts)

```
mediaUrl = "http://169.254.169.254/latest/meta-data/"
```

### SSRF (Tertiary — docx.ts)

Markdown content containing:
```markdown
![img](http://169.254.169.254/latest/meta-data/)
```
Submitted via the `feishu_doc` tool with `action: "write"` or `action: "append"`.

## Attack Scenario

### Scenario 1: Direct Tool Call — Local File Exfiltration

1. Attacker has access to OpenClaw's tool-calling interface (API access, MCP client, or compromised credentials).
2. Attacker invokes `sendMediaFeishu` (via the outbound adapter) with:
   - `to`: Any valid Feishu chat target (attacker-controlled chat)
   - `mediaUrl`: `/etc/passwd` (or any sensitive file path)
3. OpenClaw's `sendMediaFeishu()` → `isLocalPath("/etc/passwd")` returns `true` → `fs.readFileSync("/etc/passwd")` reads the file.
4. The file contents are uploaded to Feishu via the Lark API and sent as a message/attachment to the specified chat.
5. Attacker retrieves the file from the Feishu chat.

### Scenario 2: Prompt Injection — Local File Exfiltration

1. Attacker crafts a prompt injection payload (e.g., in a document being processed, a chat message, or external content) that tricks the AI into calling the Feishu media tool with a local file path.
2. The AI, influenced by the injection, calls `sendMediaFeishu` with `mediaUrl: "/etc/passwd"`.
3. Same exfiltration flow as Scenario 1.

### Scenario 3: SSRF via Media URL

1. Attacker provides `mediaUrl = "http://169.254.169.254/latest/meta-data/"` through tool invocation.
2. `isLocalPath()` returns false (it's a valid URL with http protocol).
3. `fetch("http://169.254.169.254/latest/meta-data/")` is called without SSRF protection.
4. Cloud metadata (AWS IAM credentials, etc.) is fetched, uploaded to Feishu, and sent to attacker.

### Scenario 4: SSRF via Document Image

1. Attacker triggers the `feishu_doc` tool with `action: "write"` and markdown content: `![img](http://internal-admin-api:8080/users)`.
2. `extractImageUrls()` extracts the URL (it starts with `http://`).
3. `downloadImage("http://internal-admin-api:8080/users")` calls `fetch()` without SSRF protection.
4. Internal API response is uploaded to the Feishu doc as an image.

## Impact

- **Confidentiality: HIGH** — Arbitrary file read allows exfiltration of:
  - System files: `/etc/passwd`, `/etc/shadow` (if readable), `/proc/self/environ`
  - Application secrets: `.env` files, API keys, database credentials, TLS private keys
  - SSH keys: `~/.ssh/id_rsa`, `~/.ssh/authorized_keys`
  - OpenClaw configuration: `~/.openclaw/config.yaml` (contains Feishu app secrets, API keys)
  - Source code and internal data

- **SSRF Impact**: Access to cloud metadata services, internal APIs, and services not exposed to the internet. Can lead to credential theft (AWS IAM role credentials via metadata), internal service enumeration, and lateral movement.

- **Integrity: NONE** — The vulnerability is read-only.
- **Availability: NONE** — No denial of service impact.

## Authentication Requirements

**For direct tool invocation:**
- The attacker needs access to OpenClaw's tool-calling interface. This requires:
  - A valid OpenClaw configuration with Feishu extension enabled (`channels.feishu` configured with `appId` and `appSecret`)
  - Ability to invoke tools through the AI gateway (API access)
- Feishu credentials are configured in `~/.openclaw/config.yaml` under `channels.feishu.appId` and `channels.feishu.appSecret`

**For prompt injection:**
- No direct authentication required — the attacker only needs to influence content that the AI processes
- The AI must have the Feishu extension enabled and configured

**For PoC purposes:**
- The vulnerability can be triggered by directly calling `sendMediaFeishu()` from a test script that mocks the Feishu API client
- No real Feishu credentials are needed to demonstrate the file read — the `fs.readFileSync()` call happens before any Feishu API interaction
- The PoC should import `sendMediaFeishu` and call it with a crafted `mediaUrl`, mocking `resolveFeishuAccount`, `createFeishuClient`, `normalizeFeishuTarget`, and `resolveReceiveIdType`

## Fix Assessment

**The fix is thorough and complete.**

The fix in commit `5b4121d6011a48c71e747e3c18197f180b872c5d` addresses all identified attack vectors:

1. **media.ts**: Removes `isLocalPath()` entirely. Removes all `fs.readFileSync()` calls. Removes bare `fetch()`. Replaces with `getFeishuRuntime().media.loadWebMedia()` which:
   - Uses `fetchRemoteMedia()` → `fetchWithSsrFGuard()` which performs DNS pinning and blocks private/internal IPs (SSRF protection)
   - Validates protocol is `http:` or `https:` only (no `file://` protocol)
   - Does NOT support local filesystem paths at all
   - Enforces configurable byte size limits (`mediaMaxMb`, default 30MB)

2. **docx.ts**: Replaces bare `fetch(url)` in `downloadImage()` with `getFeishuRuntime().channel.media.fetchRemoteMedia()` which provides the same SSRF protections and size limits.

3. **Tests added**: `media.test.ts` and `docx.test.ts` verify that blocked URLs (private IPs) cause the operations to fail closed.

The fix is a **root cause elimination** — it removes the dangerous code paths entirely rather than adding filters or validation that could be bypassed. The core helpers (`loadWebMedia`, `fetchRemoteMedia`, `fetchWithSsrFGuard`) are mature, tested, and used by other extensions (e.g., MS Teams).

## Potential Bypass Vectors

No concrete bypass vectors identified. The fix eliminates local file access entirely and routes all fetching through the SSRF-guarded fetch infrastructure.

## Escalation Path

The local file read primitive can be escalated:

1. **Read OpenClaw config** (`~/.openclaw/config.yaml`) to obtain:
   - Feishu `appId` / `appSecret` (full API access to the Feishu app)
   - Other channel credentials (Telegram bot tokens, Slack tokens, etc.)
   - LLM API keys (OpenAI, Anthropic, etc.)
2. **Read process environment** (`/proc/self/environ`) to obtain runtime secrets
3. **Read SSH keys** (`~/.ssh/id_rsa`) for lateral movement
4. **Read cloud credentials** (AWS `~/.aws/credentials`, GCP service account JSON)
5. **Chain with SSRF**: Use the SSRF vector to access cloud metadata (e.g., `http://169.254.169.254/latest/meta-data/iam/security-credentials/`) to obtain temporary cloud credentials

However, no path to **remote code execution** was identified — the vulnerability is limited to information disclosure and SSRF.

## Related Attack Surface

### MS Teams Extension — `isLocalPath()` (NOT VULNERABLE)

- **File**: `extensions/msteams/src/media-helpers.ts`, lines 67–83
- **Usage**: `extensions/msteams/src/messenger.ts`, line 288
- The MS Teams extension has its own `isLocalPath()` function with nearly identical logic, BUT it routes local file reads through `loadWebMedia()` from the core (`openclaw/plugin-sdk`), which enforces:
  - Directory whitelisting via `assertLocalMediaAllowed()` (only `os.tmpdir()`, `~/.openclaw/media`, `~/.openclaw/agents`)
  - Symlink resolution to prevent escape
- **Verdict**: Not vulnerable to the same attack. The Feishu extension was the outlier that bypassed the core's safe helpers.

### media.ts Remote Fetch (VULNERABLE — included in fix)

- **File**: `extensions/feishu/src/media.ts`, line 503
- When `isLocalPath()` returns false, bare `fetch(mediaUrl)` is used without SSRF protection
- **Verdict**: Fixed — replaced with `loadWebMedia()` which uses SSRF-guarded fetch

### Other Extensions

- Other extensions (`googlechat`, `nextcloud-talk`, `bluebubbles`, `mattermost`) use `fetch()` but only for calls to known, authenticated API endpoints — not for user-controlled arbitrary URLs
- `voice-call`, `matrix` extensions use `fs.readFileSync()` but only on internally-derived paths (package.json, credentials file, log files) — not from external input

**No additional vulnerable instances of this pattern were found outside the Feishu extension.**

## Build System

| Field | Value |
|---|---|
| **Language** | TypeScript (Node.js) |
| **Runtime** | Node.js >= 22.12.0 |
| **Package Manager** | pnpm 10.23.0 (monorepo workspaces) |
| **Build Tool** | tsdown (Rolldown-based bundler) |
| **Test Framework** | Vitest |

### Project Structure

```
openclaw/                          # Root monorepo
├── package.json                   # Root package (openclaw v2026.2.13)
├── pnpm-workspace.yaml            # Workspaces: ., ui, packages/*, extensions/*
├── extensions/
│   └── feishu/                    # Vulnerable extension
│       ├── package.json           # @openclaw/feishu v2026.2.13
│       └── src/
│           ├── media.ts           # PRIMARY: sendMediaFeishu(), isLocalPath()
│           ├── docx.ts            # SECONDARY: downloadImage()
│           ├── outbound.ts        # Entry point: feishuOutbound.sendMedia()
│           ├── channel.ts         # Registers outbound adapter
│           ├── accounts.ts        # Account resolution
│           ├── client.ts          # Feishu SDK client creation
│           ├── runtime.ts         # Plugin runtime accessor
│           └── media.test.ts      # Existing tests (pre-fix)
└── src/
    ├── web/media.ts               # Core loadWebMedia() (the safe version)
    ├── media/fetch.ts             # Core fetchRemoteMedia()
    └── infra/net/
        ├── fetch-guard.ts         # fetchWithSsrFGuard()
        └── ssrf.ts                # SSRF protection (DNS pinning, IP blocking)
```

### Build Commands

```bash
# Install dependencies
pnpm install

# Build the project
pnpm build

# Run tests (full suite)
pnpm test

# Run specific test file
npx vitest run extensions/feishu/src/media.test.ts
```

### Dependencies

**Feishu Extension:**
- `@larksuiteoapi/node-sdk` ^1.59.0 — Feishu/Lark API SDK
- `@sinclair/typebox` 0.34.48 — Runtime type validation
- `zod` ^4.3.6 — Schema validation

**Root/Core (relevant to vulnerability):**
- `undici` — HTTP client used by `fetchWithSsrFGuard`
- `sharp` — Image processing (used by `loadWebMedia` for optimization)
- `vitest` — Test runner

**System:**
- Node.js >= 22.12.0
- pnpm 10.23.0

### Runtime Requirements

For a **minimal PoC lab**, the following is needed:

1. **Node.js 22+** with pnpm
2. **Feishu extension source code** at the vulnerable version (v2026.2.13)
3. **Mock/stub Feishu API** — No real Feishu credentials are needed. The `fs.readFileSync()` call happens before any API interaction, so mocking the Feishu client is sufficient.
4. **A target file** to read (e.g., create `/tmp/cve-2026-26321-secret.txt` with known content)

**PoC approach — Unit-test style:**
The simplest PoC is a Vitest test (or standalone Node.js script) that:
1. Imports `sendMediaFeishu` from `extensions/feishu/src/media.ts`
2. Mocks `resolveFeishuAccount`, `createFeishuClient`, `normalizeFeishuTarget`, `resolveReceiveIdType` (same pattern as existing `media.test.ts`)
3. Calls `sendMediaFeishu({ cfg: {}, to: "user:target", mediaUrl: "/etc/passwd" })`
4. Observes that the file upload mock receives a Buffer containing the actual contents of `/etc/passwd`

**PoC approach — Direct function call:**
Since the vulnerable code is in a single function, a PoC can also directly call `isLocalPath()` and `fs.readFileSync()` to demonstrate the path traversal, then show that `sendMediaFeishu()` reaches that code path.

### Docker Lab Recommendations

- **Base image**: `node:22-slim` or `node:22-bookworm-slim`
- **Install**: `pnpm` via `corepack enable`
- **Setup**: `pnpm install` in the repo root
- **The PoC does NOT need**: Docker networking, external services, real Feishu credentials, or a running OpenClaw instance
- **Sensitive test file**: Create `/tmp/cve-secret.txt` with known content to verify exfiltration
