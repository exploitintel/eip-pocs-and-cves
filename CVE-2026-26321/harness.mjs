/**
 * CVE-2026-26321 HTTP Harness — wraps vulnerable OpenClaw functions in HTTP endpoints.
 *
 * Replicates the exact vulnerable isLocalPath() + fs.readFileSync() pattern
 * from extensions/feishu/src/media.ts, and the bare fetch() SSRF path.
 *
 * POST /media       — applies isLocalPath(); local → fs.readFileSync(), remote → fetch()
 * POST /docx-image  — extracts image URLs from markdown, fetches via fetch() (SSRF)
 * GET  /health      — returns 200 OK
 */

import http from "http";
import fs from "fs";

const PORT = 8080;

// Replicated exactly from extensions/feishu/src/media.ts (not exported)
function isLocalPath(urlOrPath) {
  if (urlOrPath.startsWith("/") || urlOrPath.startsWith("~") || /^[a-zA-Z]:/.test(urlOrPath)) {
    return true;
  }
  try {
    const url = new URL(urlOrPath);
    return url.protocol === "file:";
  } catch {
    return true;
  }
}

function readBody(req) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    req.on("data", (c) => chunks.push(c));
    req.on("end", () => resolve(Buffer.concat(chunks).toString("utf-8")));
    req.on("error", reject);
  });
}

function sendJson(res, status, obj) {
  const body = JSON.stringify(obj);
  res.writeHead(status, { "Content-Type": "application/json" });
  res.end(body);
}

const server = http.createServer(async (req, res) => {
  try {
    // GET /health
    if (req.method === "GET" && req.url === "/health") {
      res.writeHead(200);
      res.end("OK");
      return;
    }

    // POST /media — replicates sendMediaFeishu() logic
    if (req.method === "POST" && req.url === "/media") {
      const raw = await readBody(req);
      const data = JSON.parse(raw);
      const mediaUrl = data.mediaUrl || "";

      if (!mediaUrl) {
        sendJson(res, 400, { error: "mediaUrl required" });
        return;
      }

      const local = isLocalPath(mediaUrl);
      if (local) {
        // Local path → fs.readFileSync (the vulnerability)
        const filePath = mediaUrl.startsWith("~")
          ? mediaUrl.replace("~", process.env.HOME ?? "")
          : mediaUrl.replace("file://", "");
        try {
          const content = fs.readFileSync(filePath, "utf-8");
          sendJson(res, 200, {
            status: "ok",
            type: "local_file_read",
            isLocalPath: true,
            filePath,
            content,
            bytes: Buffer.byteLength(content),
          });
        } catch (err) {
          sendJson(res, 200, {
            status: "error",
            type: "local_file_read",
            isLocalPath: true,
            filePath,
            error: err.message,
          });
        }
      } else {
        // Remote URL → bare fetch() (SSRF)
        try {
          const resp = await fetch(mediaUrl, { signal: AbortSignal.timeout(5000) });
          const text = await resp.text();
          sendJson(res, 200, {
            status: "ok",
            type: "ssrf_fetch",
            isLocalPath: false,
            url: mediaUrl,
            httpStatus: resp.status,
            content: text.slice(0, 4096),
            bytes: text.length,
          });
        } catch (err) {
          sendJson(res, 200, {
            status: "error",
            type: "ssrf_fetch",
            isLocalPath: false,
            url: mediaUrl,
            error: err.message,
          });
        }
      }
      return;
    }

    // POST /docx-image — replicates downloadImage() from docx.ts
    if (req.method === "POST" && req.url === "/docx-image") {
      const raw = await readBody(req);
      const data = JSON.parse(raw);
      const markdown = data.markdown || "";

      // Extract image URLs from markdown: ![alt](url)
      const imageRegex = /!\[.*?\]\((.*?)\)/g;
      const urls = [];
      let match;
      while ((match = imageRegex.exec(markdown)) !== null) {
        urls.push(match[1]);
      }

      const results = [];
      for (const url of urls) {
        try {
          const resp = await fetch(url, { signal: AbortSignal.timeout(5000) });
          const text = await resp.text();
          results.push({
            url,
            status: "fetched",
            httpStatus: resp.status,
            bytes: text.length,
            preview: text.slice(0, 256),
          });
        } catch (err) {
          results.push({ url, status: "error", error: err.message });
        }
      }

      sendJson(res, 200, { status: "ok", urls_found: urls.length, results });
      return;
    }

    // 404 for anything else
    res.writeHead(404);
    res.end("Not Found");
  } catch (err) {
    sendJson(res, 500, { error: err.message });
  }
});

server.listen(PORT, "0.0.0.0", () => {
  console.log(`CVE-2026-26321 harness listening on port ${PORT}`);
});
