# Intel Brief: CVE-2025-53606

## CVE Summary

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-53606 |
| **Affected Software** | Apache Seata (incubating) — Fury Serializer component |
| **Vendor** | Apache Software Foundation |
| **Affected Versions** | 2.4.0 (specific component: `org.apache.seata:seata-serializer-fury`) |
| **CVSS Score** | 9.8 CRITICAL — CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| **CWE** | CWE-502: Deserialization of Untrusted Data |
| **EPSS** | 0.5% (65.6th percentile) |
| **Published** | 2025-08-08 |
| **GHSA** | GHSA-g358-g2pq-c46j |

## Description

Deserialization of Untrusted Data vulnerability in the Apache Fury serializer component of Apache Seata (incubating). The `FurySerializerFactory` class implements a class whitelist checker that fails to enforce the allow list, enabling remote attackers to deserialize arbitrary Java classes and potentially achieve Remote Code Execution (RCE).

## Root Cause Analysis

### Vulnerable Code
**File**: `serializer/seata-serializer-fury/src/main/java/org/apache/seata/serializer/fury/FurySerializerFactory.java`

The vulnerable version creates a Fury serializer with:
1. `requireClassRegistration(false)` — disables mandatory class registration, allowing ANY class to be deserialized
2. A custom class checker lambda that is ineffective:

```java
f.getClassResolver().setClassChecker(
    (classResolver, className) ->
        SerializerSecurityRegistry.getAllowClassPattern().contains(className)
);
```

### Why the Whitelist Check Fails

The class checker has **two critical flaws**:

1. **No exception throwing**: Fury's `ClassChecker` interface expects the checker to **throw an exception** (e.g., `InsecureException`) to deny a class. The lambda merely returns a boolean (`true`/`false`) but does **not** throw an exception when the class is not allowed. Fury treats the absence of an exception as permission to proceed.

2. **Wildcard pattern not supported by `Set.contains()`**: The allow-list `Set<String>` includes the wildcard pattern `"org.apache.seata.*"` (from `getSeataClassPattern()`), but `Set.contains()` performs exact string matching — it does NOT support glob/wildcard matching. This means even some legitimate Seata classes not explicitly listed may fail validation.

Because the checker never throws, **all classes pass validation** regardless of the allow list, making the whitelist entirely ineffective.

### Fix (Commit d2a18aef82c08535e4134642070c39d98654f0f6)

The fix replaces the broken custom lambda with Fury's built-in `AllowListChecker`:

```java
AllowListChecker checker = new AllowListChecker(AllowListChecker.CheckLevel.STRICT);
f.getClassResolver().setClassChecker(checker);
checker.allowClasses(SerializerSecurityRegistry.getAllowClassPattern());
```

- `AllowListChecker` with `STRICT` mode properly **throws `InsecureException`** for non-allowed classes
- `allowClasses()` correctly handles wildcard patterns like `"org.apache.seata.*"`
- This is Fury's official security mechanism, integrated into all deserialization code paths

## Attack Surface

### Network Entry Point
Apache Seata server listens on a Netty-based RPC port (default: **8091**, configurable as `server.port + 1000` where `server.port` defaults to 7091).

### Serializer Selection is Attacker-Controlled
The Seata RPC protocol (v1) includes a **serializer type byte** in the message header. An attacker can specify FURY as the serializer regardless of the server's default. The server accepts ALL built-in serializer types by default:

```java
// SerializerServiceLoader.java
private static final SerializerType[] DEFAULT_SERIALIZER_TYPE =
    new SerializerType[]{SEATA, PROTOBUF, KRYO, HESSIAN, FASTJSON2, FURY};
```

### Wire Protocol Format (v1)
```
Offset  Size  Field
0       2B    Magic: 0xdada
2       1B    Protocol version: 0x01
3       4B    Full length (int32 BE, includes header+body)
7       2B    Head length (int16 BE, typically 16 for no head-map)
9       1B    Message type: 0x00 (SYNC_REQUEST)
10      1B    Serializer type: 0x56 (FURY, byte value of 0x256 truncated)
11      1B    Compressor: 0x00 (NONE)
12      4B    Request ID (int32 BE, any value)
16      NB    Body: Fury-serialized payload
```

### Attack Flow
1. Connect to Seata server RPC port (TCP 8091)
2. Send binary RPC message with FURY codec byte (0x56) in header
3. Body contains Fury-serialized payload with a malicious Java gadget chain class
4. The broken whitelist checker returns `false` but does NOT throw → Fury proceeds with deserialization
5. Arbitrary class is instantiated → RCE via gadget chain

### Additional Attack Surface
The `FuryUndoLogParser` (`rm-datasource/src/main/java/org/apache/seata/rm/datasource/undo/parser/FuryUndoLogParser.java`) also uses `requireClassRegistration(false)` with **NO class checker at all**, but this requires access to the undo log storage (database) and is a client-side component.

## Repository & Versions

| Field | Value |
|---|---|
| **Repository URL** | https://github.com/apache/incubator-seata.git |
| **Vulnerable Version** | v2.4.0 |
| **Fix Commit** | `d2a18aef82c08535e4134642070c39d98654f0f6` ("optimize: optimize fury deserialization (#7498)") |
| **Patched Version** | v2.5.0 |
| **Fix PR** | https://github.com/apache/incubator-seata/pull/7498 |

## Build System

| Field | Value |
|---|---|
| **Build System** | Maven (multi-module) |
| **Language** | Java |
| **Java Version** | 1.8 (JDK 8 baseline) |
| **Fury Version** | 0.8.0 (`org.apache.fury:fury-core:0.8.0`) |
| **Framework** | Netty (RPC), Spring Boot (management) |
| **Root POM** | `pom.xml` (revision: 2.4.0) |
| **Build POM** | `build/pom.xml` (parent with properties) |
| **Dependencies POM** | `dependencies/pom.xml` (BOM with Fury version) |
| **Vulnerable Module** | `serializer/seata-serializer-fury` |

### Key Files
- `serializer/seata-serializer-fury/src/main/java/org/apache/seata/serializer/fury/FurySerializerFactory.java` — Vulnerable whitelist checker
- `serializer/seata-serializer-fury/src/main/java/org/apache/seata/serializer/fury/FurySerializer.java` — Entry point (serialize/deserialize)
- `core/src/main/java/org/apache/seata/core/serializer/SerializerSecurityRegistry.java` — Whitelist definitions
- `core/src/main/java/org/apache/seata/core/rpc/netty/v1/ProtocolDecoderV1.java` — RPC protocol decoder
- `core/src/main/java/org/apache/seata/core/serializer/SerializerType.java` — Serializer type enum (FURY = 0x256 → byte 0x56)
- `core/src/main/java/org/apache/seata/core/protocol/ProtocolConstants.java` — Wire protocol constants

## Docker Images

Pre-built Docker images are available on Docker Hub:
- **Vulnerable**: `apache/seata-server:2.4.0` (also: `2.4.0.jdk17`, `2.4.0.jdk21`)
- **Patched**: `apache/seata-server:2.5.0`
- Base image: `eclipse-temurin:8u422-b05-jdk` (JDK 8)
- Server ports: 7091 (management/HTTP), 8091 (RPC/Netty)
- Startup: `/seata-server/bin/seata-server.sh`

### Lab Configuration Notes
- The Seata server runs in file-based mode by default (no external DB/registry required)
- The FURY serializer is enabled by default as one of the supported serializers
- No authentication is required to connect to the RPC port
- The serializer type is specified per-message by the client in the RPC header
- An attacker needs only network access to port 8091

## Public Exploits

**No public exploits found.** There are no known PoC scripts, Metasploit modules, ExploitDB entries, or Nuclei templates for this CVE.

A PoC would need to:
1. Build a Fury-serialized payload containing a Java deserialization gadget chain
2. Package it in a valid Seata RPC v1 binary message with FURY codec byte
3. Send it to the Seata server's RPC port (TCP 8091)

### Gadget Chain Considerations
- Fury uses its own serialization format (NOT Java `ObjectInputStream`), so standard ysoserial gadgets will NOT work directly
- Fury serializes objects by writing class metadata + field values; it doesn't trigger `readObject()` overrides
- Viable gadget approaches:
  - **JNDI Injection**: Deserialize an object whose constructor or field assignment triggers a JNDI lookup (e.g., `javax.naming.InitialContext`) — note: this is in `DENY_CLAZZ_PATTERN` but the deny list is never checked in the Fury serializer
  - **TemplatesImpl**: Apache Xalan `TemplatesImpl` with malicious bytecode in `_bytecodes` field, triggered by calling `getOutputProperties()` — requires a trigger after deserialization
  - **Direct approach**: Since Fury with `requireClassRegistration(false)` instantiates arbitrary classes and sets their fields, find classes on the Seata classpath that execute code during construction or field setting
  - **Fury-native gadgets**: Research Fury-specific gadget chains that exploit Fury's own class instantiation and field-writing mechanisms

## References

1. **GHSA Advisory**: https://github.com/advisories/GHSA-g358-g2pq-c46j
2. **Apache Mailing List**: https://lists.apache.org/thread/ggfd72vvvxjozs81zbcls45zxg64pphx
3. **OSS-Security**: http://www.openwall.com/lists/oss-security/2025/08/07/1
4. **Fix PR**: https://github.com/apache/incubator-seata/pull/7498
5. **Fix Commit**: https://github.com/apache/incubator-seata/commit/d2a18aef82c08535e4134642070c39d98654f0f6
6. **Repository**: https://github.com/apache/incubator-seata
7. **Docker Image**: https://hub.docker.com/r/apache/seata-server
