# Vulnerability Analysis: CVE-2025-29953

## Overview

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-29953 |
| **Affected Software** | Apache ActiveMQ NMS OpenWire Client (Apache.NMS.ActiveMQ) |
| **Vulnerability Type** | CWE-502: Deserialization of Untrusted Data (Allow/Deny List Bypass) |
| **CVSS** | 9.8 Critical (AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H) |
| **Vulnerable Versions** | < 2.1.1 (bypass specifically targets the allow/deny list added in 2.1.0) |
| **Fix Commit** | `8944c4126dfafee61ffcb4c99d21920cf4b5740b` |

---

## Root Cause

The vulnerability is a **deserialization type filter bypass** in the NMS OpenWire Client's `BinaryFormatter` `SerializationBinder` implementation. Two bugs work together:

### Bug 1: Null Type Passes Validation (`TrustedClassFilter.BindToType`)

**File:** `src/Commands/TrustedClassFilter.cs`, lines 35-49

```csharp
public override Type BindToType(string assemblyName, string typeName)
{
    var name = new AssemblyName(assemblyName);
    var assembly = Assembly.Load(name);
    var type = FormatterServices.GetTypeFromAssembly(assembly, typeName);
    // BUG: No null check on 'type'
    // When FormatterServices.GetTypeFromAssembly() returns null (type not found),
    // null is passed directly to IsTrustedType
    if (deserializationPolicy.IsTrustedType(destination, type))
    {
        return type;  // Returns null → BinaryFormatter fallback resolves actual type
    }
    // ...
}
```

When `FormatterServices.GetTypeFromAssembly()` cannot find the type in the specified assembly (because the attacker provides a mismatched assembly/type combination), it returns `null`. This null is passed to `IsTrustedType()` and, if approved, returned from `BindToType()`. **When `BindToType()` returns `null`, `BinaryFormatter` falls back to its internal `ObjectReader.FastBindToType()` resolver**, which resolves the type from the original serialization stream metadata — effectively bypassing the binder entirely.

### Bug 2: Null FullName Returns Trusted (`NmsDefaultDeserializationPolicy.IsTrustedType`)

**File:** `src/NmsDefaultDeserializationPolicy.cs`, lines 49-55

```csharp
public bool IsTrustedType(IDestination destination, Type type)
{
    var typeName = type?.FullName;  // null?.FullName evaluates to null
    if (typeName == null)
    {
        return true;  // BUG: Null FullName treated as trusted!
    }
    // ... allow/deny list checks follow ...
}
```

When `type` is `null` (from Bug 1), `type?.FullName` evaluates to `null`, and the method returns `true` — marking the null type as trusted. This allows `BindToType()` to return `null`, triggering `BinaryFormatter`'s fallback type resolution.

### Root Cause Chain

The fundamental root cause is a **fail-open design**: when type resolution produces an unexpected result (null), the code defaults to "trusted" instead of "untrusted". This, combined with the missing null check in the binder, creates a complete bypass of the allow/deny list mechanism.

---

## Vulnerable File(s) and Function(s)

| File | Function | Lines | Bug |
|------|----------|-------|-----|
| `src/Commands/TrustedClassFilter.cs` | `BindToType(string, string)` | 35-49 | Missing null check on type from `FormatterServices.GetTypeFromAssembly()` |
| `src/NmsDefaultDeserializationPolicy.cs` | `IsTrustedType(IDestination, Type)` | 49-55 | Returns `true` when `type` is null or `type.FullName` is null |
| `src/Commands/ActiveMQObjectMessage.cs` | `Body` getter (line 80) and `Formatter` property (lines 136-155) | 60-155 | Entry point: `BinaryFormatter.Deserialize()` with vulnerable binder |

---

## Triggering Input

### Exact Trigger Mechanism

The vulnerability is triggered by a **crafted BinaryFormatter serialization stream** embedded in an ActiveMQ `ObjectMessage`. The stream exploits .NET's `ISerializable` interface to manipulate `SerializationInfo`, using a technique documented by Code White Security.

#### Malicious Serializable Class (Producer Side)

```csharp
[Serializable]
public class MaliciousSerializable : ISerializable
{
    private readonly string _payloadData = "Injected Payload";

    public MaliciousSerializable() { }

    protected MaliciousSerializable(SerializationInfo info, StreamingContext context)
    {
        _payloadData = info.GetString("InjectedValue");
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        Type type = typeof(TrustedType);  // Any type on the allow list

        // Manipulate serialization info to trick deserialization
        info.SetType(type);
        info.FullTypeName = type.AssemblyQualifiedName;  // Assembly-qualified name causes null FullName
        info.AssemblyName = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

        // Inject arbitrary data
        info.AddValue("InjectedValue", _payloadData);
    }
}
```

#### How It Works Step by Step

1. **Serialization (Producer)**: `GetObjectData()` is called during `BinaryFormatter.Serialize()`. It sets:
   - `info.SetType(TrustedType)` — makes the stream record TrustedType as the type
   - `info.FullTypeName = type.AssemblyQualifiedName` — overrides the type name with the assembly-qualified form (e.g., `"Namespace.TrustedType, Assembly, Version=X.X.X.X, ..."`)
   - `info.AssemblyName = "mscorlib"` — redirects assembly resolution to mscorlib

2. **Deserialization (Consumer, BindToType)**: BinaryFormatter calls `TrustedClassFilter.BindToType("mscorlib, ...", "Namespace.TrustedType, Assembly, ...")`:
   - `Assembly.Load("mscorlib")` → loads mscorlib
   - `FormatterServices.GetTypeFromAssembly(mscorlib, "Namespace.TrustedType, Assembly, ...")` → returns `null` (TrustedType doesn't exist in mscorlib)
   - `IsTrustedType(destination, null)` → `null?.FullName = null` → `return true`
   - `BindToType` returns `null`

3. **BinaryFormatter Fallback**: When `BindToType` returns `null`, BinaryFormatter's internal `ObjectReader.FastBindToType()` resolves the type using the original stream metadata (which contains the actual TrustedType info from `info.SetType()`). This resolves to the **real type**, completely bypassing the allow/deny list.

4. **Gadget Execution**: For full RCE, replace `MaliciousSerializable` with a known .NET deserialization gadget (e.g., `TypeConfuseDelegate`, `TextFormattingRunProperties`, `ObjectDataProvider`) that executes arbitrary code during deserialization.

---

## Attack Scenario

### Prerequisites
- A victim application using Apache.NMS.ActiveMQ client library version < 2.1.1
- The client must consume `ObjectMessage`s from a queue/topic
- The client has configured an allow/deny list (i.e., not using the default wildcard `*` allow list)
  - **Note**: With the default `allowList=*`, ALL types are already allowed without needing the bypass. The bypass specifically defeats restrictive allow/deny lists.

### Attack Flow

```
[Attacker] → Sends crafted ObjectMessage to ActiveMQ broker queue
     ↓
[ActiveMQ Broker] → Routes message to consumer
     ↓
[Victim NMS Client] → consumer.Receive() → objectMessage.Body
     ↓
ActiveMQObjectMessage.Body getter → BinaryFormatter.Deserialize(stream)
     ↓
BinaryFormatter calls TrustedClassFilter.BindToType("mscorlib", "Namespace.Type, Assembly, ...")
     ↓
FormatterServices.GetTypeFromAssembly(mscorlib, ...) → null (type not in mscorlib)
     ↓
IsTrustedType(destination, null) → null?.FullName == null → return true
     ↓
BindToType returns null → BinaryFormatter fallback resolves real type from stream
     ↓
Arbitrary type deserialized → gadget chain executes → RCE
```

### Attacker Roles

1. **Malicious message producer (most likely)**: Attacker has write access to a queue the victim consumes from. This could be via:
   - Compromised or shared ActiveMQ broker
   - Legitimate producer access on a multi-tenant broker
   - Any authenticated user who can send messages

2. **Malicious broker / MITM**: Attacker operates or intercepts traffic to a broker, injecting crafted ObjectMessages into the wire protocol.

---

## Impact

### Direct Impact
- **Arbitrary code execution** on the client machine with the privileges of the client process
- Complete compromise of the client application
- Potential lateral movement if the client has network/credential access

### Impact Context
- The default allow list is `*` (allow all), meaning most unconfigured deployments are **already vulnerable to unbounded deserialization** without needing this bypass
- This CVE specifically targets the security mechanism (allow/deny lists) that was supposed to mitigate deserialization attacks — rendering it ineffective
- Users who believed they had hardened their deployment with restrictive allow lists were actually still fully vulnerable

---

## Authentication Requirements

### Broker Authentication
- ActiveMQ brokers typically use **username/password** authentication
- Default credentials: `admin`/`admin` on many ActiveMQ installations
- Authentication is configured in `activemq.xml` and `jetty-realm.properties`
- The PoC test uses empty credentials: `factory.CreateConnection("", "")`

### Attack Authentication
- **To send a malicious message**: The attacker needs producer access to a queue/topic the victim consumes from. This requires broker credentials OR an unauthenticated broker.
- **Malicious server attack**: No victim credentials needed — the victim connects to the attacker's server.

### PoC Authentication Flow
1. Create `ConnectionFactory` with broker URI: `activemq:tcp://host:61616`
2. Call `factory.CreateConnection(username, password)` — empty strings work on default ActiveMQ config
3. Create session, producer, consumer on a shared queue
4. Send malicious `ObjectMessage` via producer
5. Receive and access `Body` property via consumer → triggers deserialization

---

## Fix Assessment

### What the Fix Does

**Commit `8944c4126dfafee61ffcb4c99d21920cf4b5740b`** makes two targeted changes:

1. **`TrustedClassFilter.cs` (Layer 1 — null type guard)**:
   ```csharp
   var type = FormatterServices.GetTypeFromAssembly(assembly, typeName);
   if (type == null)  // NEW: null check
   {
       throw new SerializationException($"Type {typeName} not found in assembly {assemblyName}");
   }
   ```
   This prevents null from ever reaching `IsTrustedType()` and prevents `BindToType()` from returning null (which would trigger BinaryFormatter's fallback).

2. **`NmsDefaultDeserializationPolicy.cs` (Layer 2 — defense in depth)**:
   ```csharp
   var typeName = type.FullName;  // Changed from type?.FullName
   if (typeName == null)
   {
       return false;  // Changed from return true
   }
   ```
   Even if a non-null type with null `FullName` somehow reached this point, it would be denied.

### Assessment: Fix is Complete

The fix addresses the vulnerability with a **two-layer defense**:

- **Layer 1** blocks the exact attack technique (null type from `GetTypeFromAssembly`)
- **Layer 2** provides defense-in-depth (null FullName → deny instead of allow)

The critical insight is that when `BindToType()` returns a non-null Type, `BinaryFormatter` uses exactly that type — there is no divergence between the validated type and the deserialized type. The fallback path (`FastBindToType`) is only triggered when `BindToType()` returns null, which the fix prevents.

**No known alternative bypass exists** for these combined layers:
- Type name collisions: The resolved type is what gets validated AND deserialized
- Assembly confusion/forwarding: The resolved type's FullName is checked against allow/deny
- Nested/generic type tricks: `FormatterServices.GetTypeFromAssembly` cannot produce types with null FullName through standard resolution

### Residual Architectural Risks (Not Fix Bypasses)

1. **Default `allowList=*`**: Without explicit configuration, all types are allowed. The bypass is unnecessary — the fundamental `BinaryFormatter` risk remains.
2. **`DeserializationPolicy` can be null**: If `Connection.DeserializationPolicy` is null, no binder is set and `BinaryFormatter` is unrestricted (see `ActiveMQObjectMessage.cs` line 143).
3. **`BinaryFormatter` is deprecated**: Microsoft considers `BinaryFormatter` architecturally unsafe regardless of binder configuration.

---

## Escalation Path

The vulnerability's direct primitive is **arbitrary .NET type deserialization**, which itself constitutes arbitrary code execution via well-known .NET deserialization gadget chains:

1. **`TypeConfuseDelegate`** → Delegates to `Process.Start()` → OS command execution
2. **`ObjectDataProvider`** → Invokes arbitrary methods → `Process.Start()` → RCE
3. **`TextFormattingRunProperties`** (WPF) → XAML deserialization → arbitrary code
4. **`PSObject`** (PowerShell) → Script block execution

The escalation path is direct: **deserialization bypass → gadget chain → RCE**. No intermediate chaining through application logic is needed because `BinaryFormatter` deserialization with arbitrary types is itself an RCE primitive.

Tools like `ysoserial.net` can generate ready-to-use payloads for all standard .NET gadget chains.

---

## Related Attack Surface

### 1. RecoveryFileLogger — Unprotected BinaryFormatter (Local File)

**File:** `src/Transactions/RecoveryFileLogger.cs`

```csharp
// Line 127: Serialization (no binder, local file write)
IFormatter formatter = new BinaryFormatter();
formatter.Serialize(recoveryLog, info);

// Line 276: Deserialization (no binder, local file read)
IFormatter formatter = new BinaryFormatter();
result.Add(formatter.Deserialize(recoveryLog) as RecoveryInformation);
```

This uses `BinaryFormatter` **without any `SerializationBinder`** — no `TrustedClassFilter`, no allow/deny list at all. However, the attack surface is different: it reads from local files (`RecoveryInformation` serialized to disk), not from network messages. This would require the attacker to write to the transaction recovery log directory on the local filesystem. **Not directly related to CVE-2025-29953 but represents additional attack surface if the attacker has local file write access.**

### 2. Default Wildcard Allow List

**File:** `src/NmsDefaultDeserializationPolicy.cs`, line 47

```csharp
private IReadOnlyList<string> allowList = new[] { CATCH_ALL_WILDCARD };  // Default: allow ALL types
```

Any deployment using the default configuration allows **all** types through `BinaryFormatter` deserialization, making the bypass unnecessary. This is the same vulnerability class (unrestricted deserialization) but without needing the binder bypass.

### 3. ActiveMQObjectMessage.Formatter — Null DeserializationPolicy Guard

**File:** `src/Commands/ActiveMQObjectMessage.cs`, lines 143-146

```csharp
if (Connection.DeserializationPolicy != null)  // Can be null
{
    formatter.Binder = new TrustedClassFilter(Connection.DeserializationPolicy, Destination);
}
```

If `DeserializationPolicy` is null, no binder is set. While the default is non-null, programmatically setting it to null creates an unrestricted `BinaryFormatter`.

---

## Build System

| Field | Value |
|-------|-------|
| **Build System** | .NET SDK / MSBuild |
| **SDK Version** | .NET 6.0+ (or .NET Core 3.1 for running tests) |
| **Target Framework** | `netstandard2.0` (library), `net472;netcoreapp3.1` (tests) |
| **Solution File** | `nms-openwire.sln` |
| **Language** | C# 8.0 |

### Build Commands

```bash
# Build the library only
dotnet build src/nms-openwire.csproj -c Debug

# Build the entire solution (library + tests)
dotnet build nms-openwire.sln -c Debug

# Restore NuGet dependencies
dotnet restore nms-openwire.sln
```

### Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| `Apache.NMS` | 2.0.0 | NMS API interface library (NuGet) |
| `SharpZipLib` | 1.3.3 | Compression support (NuGet) |
| `System.Runtime` | 4.3.1 | .NET Standard runtime (NuGet) |
| `Apache.NMS.Test.dll` | — | Pre-built test helper (in `ext_bin/`) |

### Runtime Requirements

| Requirement | Details |
|-------------|---------|
| **Runtime** | .NET Core 3.1+ or .NET 6+ (for netstandard2.0 compat) |
| **ActiveMQ Broker** | Apache ActiveMQ Classic 5.x (Docker: `apache/activemq-classic:5.18.6`) |
| **Broker Port** | TCP 61616 (OpenWire protocol) |
| **Broker Web Console** | TCP 8161 (optional, for monitoring) |
| **Network** | Client must connect to broker; producer and consumer can share the same connection |
| **Default Credentials** | Username: `admin`, Password: `admin` (or empty strings on permissive configs) |

### Lab Setup Notes for Lab Build Agent

1. **Broker Container**: Use `apache/activemq-classic:5.18.6` (or latest 5.x). Expose port 61616. Default config works.

2. **Client Container**: Use `mcr.microsoft.com/dotnet/sdk:6.0` (or 8.0). Must have:
   - The vulnerable `Apache.NMS.ActiveMQ` v2.1.0 library (built from source or referenced as NuGet)
   - A PoC application that:
     a. Connects to the broker
     b. Creates a producer that sends a `MaliciousSerializable` ObjectMessage
     c. Creates a consumer that reads the message and accesses `.Body`
     d. Demonstrates the bypass succeeds (arbitrary type deserialized past allow list)

3. **Two-Container Setup**: Docker Compose with:
   - `broker`: ActiveMQ Classic
   - `client`: .NET SDK with PoC app
   - Shared network for TCP connectivity

4. **PoC Strategy**: The simplest PoC approach is to create a .NET console app that:
   - Uses the vulnerable NMS library (built from `src/nms-openwire.csproj`)
   - Connects to broker with `?nms.deserializationPolicy.allowList=SomeSpecificType` (restrictive allow list)
   - Sends a `MaliciousSerializable` object (using the `ISerializable` bypass technique)
   - Consumes the message and accesses `Body`
   - If the bypass works: the `MaliciousSerializable` type is deserialized despite not being on the allow list
   - If the fix is applied: a `SerializationException` is thrown

5. **Important .NET Note**: `BinaryFormatter` is disabled by default starting .NET 9. For the PoC, use .NET 6.0 or .NET 8.0 where it is still available (with a warning but functional). If using .NET 8, may need `<EnableUnsafeBinaryFormatterSerialization>true</EnableUnsafeBinaryFormatterSerialization>` in the project file.

---

## Summary

CVE-2025-29953 is a **deserialization filter bypass** in the Apache NMS OpenWire Client. The `TrustedClassFilter` `SerializationBinder` fails to check for null types returned by `FormatterServices.GetTypeFromAssembly()`, and the `NmsDefaultDeserializationPolicy.IsTrustedType()` method incorrectly returns `true` for null types. By exploiting .NET's `ISerializable` interface to manipulate `SerializationInfo` with mismatched assembly/type names, an attacker causes `GetTypeFromAssembly()` to return null, which passes the trust check and causes `BindToType()` to return null, triggering `BinaryFormatter`'s internal fallback type resolver. This allows arbitrary types to be deserialized past the allow/deny list, enabling remote code execution via standard .NET deserialization gadget chains.

The fix is complete — it adds a null type check in `TrustedClassFilter` (throws on null) and changes the null FullName behavior in the deserialization policy from allow to deny. Both layers must be defeated simultaneously, and no known technique can bypass both.
