# Intel Brief: CVE-2025-29953

## CVE Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2025-29953 |
| **Affected Software** | Apache ActiveMQ NMS OpenWire Client (Apache.NMS.ActiveMQ) |
| **Vendor** | Apache Software Foundation |
| **CVSS Score** | 9.8 (Critical) |
| **CVSS Vector** | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| **EPSS** | 0.456% (63rd percentile) |
| **CWE** | CWE-502 (Deserialization of Untrusted Data) |
| **Published** | 2025-04-18 |
| **Finder** | g7shot (working with Trend Micro Zero Day Initiative) |

## Description

Apache ActiveMQ NMS OpenWire Client versions before 2.1.1 contain a deserialization of untrusted data vulnerability when connecting to untrusted servers. A malicious ActiveMQ broker can send crafted OpenWire messages containing serialized .NET objects that bypass the client's allow/deny list type filtering, leading to arbitrary code execution on the client.

**Root Cause:** The `NmsDefaultDeserializationPolicy.IsTrustedType()` method returns `true` (trusted) when `type.FullName` is `null`. By exploiting known .NET `SerializationBinder` bypass techniques (manipulating `SerializationInfo.FullTypeName` to produce a null `FullName`), an attacker can smuggle arbitrary types past the allow/deny list validation.

**Attack Scenario:** A malicious server (or MITM attacker) sends an `ActiveMQObjectMessage` containing a `BinaryFormatter`-serialized payload. The payload uses the `ISerializable` interface to manipulate `SerializationInfo`, setting `FullTypeName` to an assembly-qualified name that resolves to a type with a `null` `FullName` property. When the `TrustedClassFilter.BindToType()` calls `IsTrustedType()`, the null check returns `true`, bypassing all allow/deny list restrictions.

## Affected Versions

- **All versions before 2.1.1** are vulnerable to unbounded deserialization
- **Version 2.1.0** introduced the allow/deny list mechanism but it was bypassable (this CVE specifically targets the bypass)
- **Versions before 2.0.0** had no type filtering at all (fully unbounded deserialization)
- **NuGet package:** `Apache.NMS.ActiveMQ` versions 0 through < 2.1.1

## Repository Information

| Field | Value |
|-------|-------|
| **Repository URL** | https://github.com/apache/activemq-nms-openwire.git |
| **Primary Language** | C# (.NET Standard 2.0) |
| **Vulnerable Version Tag** | `2.1.0` (checked out in workspace) |
| **Vulnerable Version Commit** | `b89b7498d12fe2f68ee5ee248bb2168c62ceaf3a` |
| **Fix Commit** | `8944c4126dfafee61ffcb4c99d21920cf4b5740b` (AMQNET-844) |
| **Patched Version Tag** | `2.1.1` (commit `ea15293eba103d42fb55f4f59cf7b8d7c7362c1a`) |

## Build System & Dependencies

| Field | Value |
|-------|-------|
| **Build System** | .NET SDK / MSBuild (`.sln` + `.csproj`) |
| **Target Framework** | `netstandard2.0` |
| **Solution File** | `nms-openwire.sln` |
| **Main Project** | `src/nms-openwire.csproj` |
| **Test Project** | `test/nms-openwire-test.csproj` (targets `net472`, `netcoreapp3.1`) |

### Key Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| Apache.NMS | 2.0.0 | NMS API interface library |
| SharpZipLib | 1.3.3 | Compression support |
| NUnit | 3.12.0 | Test framework (test project) |
| System.Runtime | 4.3.1 | .NET Standard runtime |

### Build Notes for Lab Agent

- This is a **C# / .NET** project requiring the **.NET SDK** (dotnet CLI)
- The library targets **netstandard2.0** — build with `dotnet build src/nms-openwire.csproj`
- For testing/PoC, target **.NET Core 3.1** or **.NET 6+** (both support netstandard2.0)
- The project uses **BinaryFormatter** for object message deserialization — this is the core attack surface
- An **Apache ActiveMQ broker** is required for integration testing (the client connects to a broker)
- Docker image `apache/activemq-classic:5.18.6` or similar provides the broker
- PoC needs to simulate a malicious broker or use a real broker to relay crafted messages

## Vulnerability Analysis

### Vulnerable Code (v2.1.0)

**File: `src/NmsDefaultDeserializationPolicy.cs`** (lines 48-53):
```csharp
public bool IsTrustedType(IDestination destination, Type type)
{
    var typeName = type?.FullName;  // Uses null-conditional operator
    if (typeName == null)
    {
        return true;  // BUG: Returns trusted for null FullName!
    }
    // ... allow/deny list checks follow ...
}
```

**File: `src/Commands/TrustedClassFilter.cs`** (lines 37-47):
```csharp
public override Type BindToType(string assemblyName, string typeName)
{
    var name = new AssemblyName(assemblyName);
    var assembly = Assembly.Load(name);
    var type = FormatterServices.GetTypeFromAssembly(assembly, typeName);
    // BUG: No null check on 'type' — if null, passes to IsTrustedType which returns true
    if (deserializationPolicy.IsTrustedType(destination, type))
    {
        return type;  // Returns null, causing BinaryFormatter fallback resolution
    }
    // ...
}
```

### Fix Applied (commit 8944c41)

1. **`NmsDefaultDeserializationPolicy.cs`**: Changed `type?.FullName` to `type.FullName` and when `typeName == null`, returns `false` instead of `true`
2. **`TrustedClassFilter.cs`**: Added null check for `type` after `FormatterServices.GetTypeFromAssembly()` — throws `SerializationException` if type is null

### Bypass Technique

The exploit leverages the technique documented at: https://codewhitesec.blogspot.com/2022/06/bypassing-dotnet-serialization-binders.html

**Mechanism:**
1. Craft a serializable class implementing `ISerializable`
2. In `GetObjectData()`, manipulate `SerializationInfo`:
   - Set `info.SetType()` to a trusted type
   - Set `info.FullTypeName` to an assembly-qualified name that causes `FullName` to be null
   - Set `info.AssemblyName` to a base library (e.g., `mscorlib`)
3. When `BindToType()` is called with the manipulated names:
   - `FormatterServices.GetTypeFromAssembly()` returns `null` (type not found with that name)
   - `IsTrustedType(destination, null)` → `null?.FullName` = `null` → returns `true`
   - `BindToType()` returns `null`, triggering BinaryFormatter's internal fallback type resolver
   - The fallback resolver uses the original type info from the stream, loading the actual dangerous type

### Attack Flow

```
[Malicious Broker/Server] → OpenWire ObjectMessage with crafted BinaryFormatter payload
        ↓
[NMS Client] receives message, calls objectMessage.Body getter
        ↓
ActiveMQObjectMessage.Body → BinaryFormatter.Deserialize(stream)
        ↓
BinaryFormatter calls TrustedClassFilter.BindToType(assemblyName, typeName)
        ↓
BindToType: FormatterServices.GetTypeFromAssembly() returns null (manipulated names)
        ↓
IsTrustedType(destination, null) returns true (null?.FullName == null → return true)
        ↓
BindToType returns null → BinaryFormatter fallback resolves actual malicious type
        ↓
Arbitrary type deserialized → code execution via gadget chain
```

## Public Exploits

**No public exploits found** in ExploitDB, Metasploit, GitHub, or other tracked sources as of this writing.

However, the fix commit includes a comprehensive test case (`test/MessageConsumerTest.cs`) that demonstrates the bypass technique with a `MaliciousSerializable` class implementing `ISerializable`. This test serves as a near-complete PoC template.

### Test Case Analysis (from fix commit)

The `MaliciousSerializable` class in the test:
```csharp
public void GetObjectData(SerializationInfo info, StreamingContext context)
{
    Type type = typeof(TrustedType);
    info.SetType(type);
    info.FullTypeName = type.AssemblyQualifiedName; // Causes null FullName on deserialize
    info.AssemblyName = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    info.AddValue("InjectedValue", _payloadData);
}
```

This demonstrates:
- Manipulating `SerializationInfo` to trick the binder
- Setting `FullTypeName` to `AssemblyQualifiedName` (which includes assembly info, causing parser confusion)
- Using `mscorlib` as the assembly name to redirect type resolution

## References

| Source | URL |
|--------|-----|
| **Apache Advisory** | https://lists.apache.org/thread/vc1sj9y3056d3kkhcvrs9fyw5w8kpmlx |
| **OSS-Security** | http://www.openwall.com/lists/oss-security/2025/04/18/3 |
| **GHSA** | https://github.com/advisories/GHSA-9g64-r942-fvmp |
| **NVD** | https://nvd.nist.gov/vuln/detail/CVE-2025-29953 |
| **JIRA Tracker** | https://issues.apache.org/jira/browse/AMQNET-844 |
| **Fix Commit** | https://github.com/apache/activemq-nms-openwire/commit/8944c4126dfafee61ffcb4c99d21920cf4b5740b |
| **Source Repository** | https://github.com/apache/activemq-nms-openwire |
| **NuGet Package** | https://www.nuget.org/packages/Apache.NMS.ActiveMQ |
| **Bypass Technique Reference** | https://codewhitesec.blogspot.com/2022/06/bypassing-dotnet-serialization-binders.html |

## PoC Strategy Notes (for downstream agents)

1. **Lab Setup**: Need an Apache ActiveMQ broker (Docker: `apache/activemq-classic`) + a .NET application using the vulnerable NMS OpenWire client (v2.1.0)
2. **Attack Vector**: The client must connect to a broker and consume an `ObjectMessage`. The malicious payload is sent as a message by a producer (could be on the same or different broker).
3. **PoC Approach A** (Integration test): Write a .NET test/app that creates a producer sending a `MaliciousSerializable` object message and a consumer that reads it — demonstrating the bypass.
4. **PoC Approach B** (Malicious server): Create a fake/modified broker that sends crafted ObjectMessages to connecting clients.
5. **Gadget Chains**: For full RCE, chain with .NET deserialization gadgets (e.g., `TypeConfuseDelegate`, `PSObject`, `ObjectDataProvider`). Libraries like `ysoserial.net` can generate payloads.
6. **Simplest Demonstration**: Use the test case from the fix commit as a template — it proves the bypass without needing a full gadget chain. The bypass itself (allowing untrusted types past the filter) is the vulnerability; code execution follows from standard .NET deserialization gadgets.
