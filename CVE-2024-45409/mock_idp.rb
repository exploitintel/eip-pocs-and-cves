#!/usr/bin/env ruby
# Mock SAML Identity Provider - generates legitimately signed SAML responses
# Manually handles XML signing to ensure verification compatibility with ruby-saml
#
# The signing process:
# 1. Build the complete Response XML with unsigned assertion
# 2. Parse with Nokogiri, find the assertion
# 3. Canonicalize the assertion (exclusive C14N, no inclusive namespaces)
# 4. Compute the digest of the canonical assertion
# 5. Build SignedInfo with the digest, canonicalize and sign it
# 6. Insert the Signature element into the assertion
# 7. Output the complete signed Response

require 'nokogiri'
require 'openssl'
require 'base64'
require 'securerandom'
require 'time'

CERT_FILE = '/app/certs/ruby-saml.crt'
KEY_FILE = '/app/certs/ruby-saml.key'

DSIG = "http://www.w3.org/2000/09/xmldsig#"
SAML = "urn:oasis:names:tc:SAML:2.0:assertion"
SAMLP = "urn:oasis:names:tc:SAML:2.0:protocol"

cert_text = File.read(CERT_FILE)
key_text = File.read(KEY_FILE)
key = OpenSSL::PKey::RSA.new(key_text)
cert_b64 = cert_text.gsub(/-----BEGIN CERTIFICATE-----/, '').gsub(/-----END CERTIFICATE-----/, '').gsub(/\s+/, '')

# Parameters
name_id = ARGV[0] || 'user@example.com'
output_file = ARGV[1] || '/app/legitimate_response.xml'
audience = ARGV[2] || 'http://sp.example.com'

now = Time.now.utc
not_before = (now - 300).strftime('%Y-%m-%dT%H:%M:%SZ')
not_on_or_after = (now + 3600).strftime('%Y-%m-%dT%H:%M:%SZ')
issue_instant = now.strftime('%Y-%m-%dT%H:%M:%SZ')
session_not_on_or_after = (now + 28800).strftime('%Y-%m-%dT%H:%M:%SZ')

response_id = "pfx" + SecureRandom.hex(16)
assertion_id = "pfx" + SecureRandom.hex(16)

# Step 1: Build the complete Response XML (unsigned)
response_xml = %Q{<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" ID="#{response_id}" Version="2.0" IssueInstant="#{issue_instant}" Destination="http://localhost:4567/saml/acs">
  <saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">idp.example.com</saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
  </samlp:Status>
  <saml:Assertion xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" Version="2.0" ID="#{assertion_id}" IssueInstant="#{issue_instant}">
    <saml:Issuer>idp.example.com</saml:Issuer>
    <saml:Subject>
      <saml:NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress">#{name_id}</saml:NameID>
      <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <saml:SubjectConfirmationData NotOnOrAfter="#{not_on_or_after}" Recipient="http://localhost:4567/saml/acs"/>
      </saml:SubjectConfirmation>
    </saml:Subject>
    <saml:Conditions NotBefore="#{not_before}" NotOnOrAfter="#{not_on_or_after}">
      <saml:AudienceRestriction>
        <saml:Audience>#{audience}</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    <saml:AuthnStatement AuthnInstant="#{issue_instant}" SessionNotOnOrAfter="#{session_not_on_or_after}" SessionIndex="#{assertion_id}">
      <saml:AuthnContext>
        <saml:AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport</saml:AuthnContextClassRef>
      </saml:AuthnContext>
    </saml:AuthnStatement>
  </saml:Assertion>
</samlp:Response>}

# Step 2: Parse with Nokogiri and find the assertion
doc = Nokogiri::XML(response_xml) { |c| c.strict.nonet }
assertion = doc.at_xpath('//saml:Assertion', 'saml' => SAML)

# Step 3: Canonicalize the assertion (exclusive C14N, no inclusive namespaces)
# This matches what ruby-saml does during verification when there is no InclusiveNamespaces element
canon_assertion = assertion.canonicalize(Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0)

# Step 4: Compute digest
digest = OpenSSL::Digest::SHA1.digest(canon_assertion)
digest_b64 = Base64.strict_encode64(digest)

# Step 5: Build SignedInfo, canonicalize, and sign
signed_info_xml = %Q{<ds:SignedInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/><ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/><ds:Reference URI="##{assertion_id}"><ds:Transforms><ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/><ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/></ds:Transforms><ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><ds:DigestValue>#{digest_b64}</ds:DigestValue></ds:Reference></ds:SignedInfo>}

signed_info_doc = Nokogiri::XML(signed_info_xml)
canon_signed_info = signed_info_doc.root.canonicalize(Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0)

signature_value = key.sign(OpenSSL::Digest::SHA1.new, canon_signed_info)
sig_b64 = Base64.strict_encode64(signature_value)

# Step 6: Build the complete Signature element and insert into assertion
sig_xml = %Q{<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#"><ds:SignedInfo><ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/><ds:SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1"/><ds:Reference URI="##{assertion_id}"><ds:Transforms><ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/><ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/></ds:Transforms><ds:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/><ds:DigestValue>#{digest_b64}</ds:DigestValue></ds:Reference></ds:SignedInfo><ds:SignatureValue>#{sig_b64}</ds:SignatureValue><ds:KeyInfo><ds:X509Data><ds:X509Certificate>#{cert_b64}</ds:X509Certificate></ds:X509Data></ds:KeyInfo></ds:Signature>}

# Insert Signature after Issuer in the assertion
issuer = assertion.at_xpath('saml:Issuer', 'saml' => SAML)
sig_fragment = Nokogiri::XML::DocumentFragment.parse(sig_xml)
issuer.add_next_sibling(sig_fragment)

# Step 7: Output
File.write(output_file, doc.to_xml)

$stderr.puts "[IdP] Generated signed SAML Response:"
$stderr.puts "  Response ID: #{response_id}"
$stderr.puts "  Assertion ID: #{assertion_id}"
$stderr.puts "  NameID: #{name_id}"
$stderr.puts "  NotOnOrAfter: #{not_on_or_after}"
$stderr.puts "  Signature: RSA-SHA1 / Exclusive C14N"
$stderr.puts "  Output: #{output_file}"
$stderr.puts "[IdP] Done."
