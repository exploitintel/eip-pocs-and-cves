# Intel Brief: CVE-2025-32897

## CVE Overview

| Field | Value |
|---|---|
| **CVE ID** | CVE-2025-32897 |
| **Title** | Apache Seata — Insecure Deserialization in Raft Cluster Components |
| **Affected Software** | Apache Seata (incubating) — Server component |
| **Vendor** | Apache Software Foundation |
| **CVSS Score** | 9.8 CRITICAL |
| **CVSS Vector** | CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H |
| **EPSS** | 0.4% (58.4th percentile) |
| **CWE** | CWE-502 — Deserialization of Untrusted Data |
| **Published** | 2025-06-28 |

## Description

Deserialization of Untrusted Data vulnerability in Apache Seata (incubating) server, specifically in the Raft cluster consensus components. This CVE is an extension of CVE-2024-47552 — the original CVE's version range was too narrow and did not cover all affected deserialization paths.

The vulnerability exists in **three locations** within the Raft cluster serialization layer:

1. **`CustomDeserializer.java`** — A Jackson JSON deserializer for `Class<?>` types that calls `Class.forName(className)` on attacker-controlled input without any package allowlist. An attacker can supply an arbitrary fully-qualified Java class name, which gets loaded via reflection, enabling JNDI injection or gadget chain exploitation.

2. **`RaftSnapshotSerializer.decode()`** — Uses raw `ObjectInputStream` without any `resolveClass()` override, meaning any Java serializable class can be deserialized from snapshot data. This is a classic Java deserialization vulnerability.

3. **`RaftSyncMessageSerializer.decode()`** — While this already had a PERMITS allowlist for `resolveClass()`, the error handling did not properly propagate `SeataRuntimeException` through the Jackson/JSON deserialization layer, allowing security violations to be silently swallowed.

### Attack Vector

The Raft cluster protocol uses SOFABolt (TCP-based RPC) on a configurable port (default 9091+). When Seata is deployed in Raft mode (`seata.store.mode=raft`), cluster nodes communicate using serialized Java objects and Jackson JSON. An attacker who can send crafted Raft protocol messages to the Raft port can trigger arbitrary class loading/instantiation.

The test case in the fix commit demonstrates exploitation via `dm.jdbc.driver.DmdbJdbcRowSet` (a known JNDI injection gadget) with an Oracle JNDI URL payload.

## Affected Versions

| Version Range | Status |
|---|---|
| **2.0.0 — 2.2.0** (inclusive) | Vulnerable |
| **< 2.0.0** | Not affected (Raft mode not present) |
| **≥ 2.3.0** | Patched |

**Note:** The vulnerability only affects Seata deployments using **Raft mode** (`seata.store.mode=raft`). File-mode and DB-mode deployments do not use the vulnerable code paths.

## Repository

| Field | Value |
|---|---|
| **Repository URL** | https://github.com/apache/incubator-seata.git |
| **Vulnerable Version (checked out)** | `v2.2.0` (tag, commit `f127e50ee`) |
| **Fix Commit (CVE-2025-32897)** | `7eda23e948312ed52c3336de70a11f4d2ab06a48` |
| **Fix Commit (CVE-2024-47552, ProcessorYaml)** | `c0d2ac540b5579e909ae3240f112575313fcad34` |
| **Patched Version** | `v2.3.0` |

## Vulnerable Files (at v2.2.0)

1. **`server/src/main/java/org/apache/seata/server/cluster/raft/serializer/CustomDeserializer.java`**
   - `Class.forName(className)` without any allowlist — loads arbitrary classes from JSON deserialization
   
2. **`server/src/main/java/org/apache/seata/server/cluster/raft/snapshot/RaftSnapshotSerializer.java`**
   - `ObjectInputStream` without `resolveClass()` override — unrestricted Java deserialization

3. **`server/src/main/java/org/apache/seata/server/cluster/raft/sync/RaftSyncMessageSerializer.java`**
   - Error handling doesn't propagate `SeataRuntimeException` through `JsonMappingException` wrapper

### Call Paths (entry points for triggering deserialization)

- **`RaftStateMachine.onApply()`** → `RaftSyncMessageSerializer.decode(byteBuffer.array())` — triggered when Raft log entries are applied
- **`StoreSnapshotFile.load()`** → `RaftSnapshotSerializer.decode(...)` — triggered when Raft snapshots are loaded
- Both paths are invoked by the JRaft framework when receiving data from Raft peers over the network

## Build System

| Field | Value |
|---|---|
| **Build System** | Apache Maven (multi-module) |
| **Java Version** | 1.8 (Java 8) |
| **Primary Language** | Java |
| **Root Artifact** | `org.apache.seata:seata-parent` |
| **Vulnerable Module** | `seata-server` |

### Key Dependencies

| Dependency | Version | Purpose |
|---|---|---|
| `com.alipay.sofa:jraft-core` | 1.3.14 | Raft consensus framework |
| `com.alipay.sofa:sofa-bolt` | 1.6.7 | TCP RPC framework (network layer) |
| `org.yaml:snakeyaml` | 2.0 | YAML parsing |
| `com.fasterxml.jackson` | (managed by Spring Boot) | JSON serialization |
| `org.codehaus.jackson:jackson-mapper-asl` | (declared in server POM) | Legacy JSON mapper |

## Docker Images

Official Docker images are available on Docker Hub:

- **Vulnerable**: `apache/seata-server:2.2.0` (recommended for lab reproduction)
- **Also vulnerable**: `apache/seata-server:2.1.0`, `apache/seata-server:2.0.0`
- **Patched**: `apache/seata-server:2.3.0`

Available variants: `2.2.0`, `2.2.0.jre17`, `2.2.0.jre17-slim`, `2.2.0-slim`

### Raft Mode Configuration

To enable the vulnerable code path, configure Seata in Raft mode:

```yaml
seata:
  store:
    mode: raft
  server:
    raft:
      group: default
      server-addr: <ip1>:9091,<ip2>:9092,<ip3>:9093
      serialization: jackson
      compressor: none
```

**Ports:**
- `7091` — HTTP console (Spring Boot)
- `8091` — Seata TC (Transaction Coordinator) service port
- `9091+` — Raft cluster communication (SOFABolt TCP RPC)

## Public Exploits

**No public exploits or PoC scripts found** for either CVE-2025-32897 or CVE-2024-47552.

However, the vulnerability is a well-understood pattern:
- Java `ObjectInputStream` deserialization without class filtering → standard ysoserial/JNDI gadget chains apply
- `Class.forName()` on user input → JNDI injection via known JDBC RowSet gadgets (e.g., `dm.jdbc.driver.DmdbJdbcRowSet`, `com.sun.rowset.JdbcRowSetImpl`)

### PoC Strategy

The most promising approach is based on the fix commit's test case:
1. Craft a `RaftSyncMessage` or `RaftSnapshot` containing a malicious serialized payload
2. The payload should reference a class outside the `org.apache.seata` namespace
3. For RCE: use a JNDI injection gadget (e.g., JdbcRowSetImpl pointing to an attacker-controlled LDAP/RMI server)
4. Send the crafted message via the SOFABolt RPC protocol to the Raft port

**Two attack vectors:**
- **RaftSnapshotSerializer** (easier): No class filtering at all — pure Java deserialization; standard ysoserial payloads should work directly
- **CustomDeserializer** (via JSON): Requires crafting a JSON payload with a malicious `clz` field containing an arbitrary class name

## Related CVEs

| CVE | Fix Version | Scope |
|---|---|---|
| CVE-2024-47552 | 2.2.0 | ProcessorYaml.java — unsafe SnakeYAML `Yaml.load()` |
| CVE-2025-32897 | 2.3.0 | Raft serializers — `CustomDeserializer`, `RaftSnapshotSerializer`, `RaftSyncMessageSerializer` |

## References

- **Apache Advisory**: https://lists.apache.org/thread/9fhtf7yvpjpzlwd1m0wfgg6tp2btxpy1
- **GHSA (CVE-2025-32897)**: https://github.com/advisories/GHSA-m964-fjrh-xxq2
- **GHSA (CVE-2024-47552)**: https://github.com/advisories/GHSA-2r4x-667f-mpfh
- **Fix Commit (Raft deserializers)**: https://github.com/apache/incubator-seata/commit/7eda23e948312ed52c3336de70a11f4d2ab06a48
- **Fix Commit (ProcessorYaml)**: https://github.com/apache/incubator-seata/commit/c0d2ac540b5579e909ae3240f112575313fcad34
- **Fix PR #7049**: https://github.com/apache/incubator-seata/pull/7049
- **CVE-2024-47552 reference**: https://www.cve.org/CVERecord?id=CVE-2024-47552
- **OSS-Security**: http://www.openwall.com/lists/oss-security/2025/03/19/5
- **Snyk Advisory**: https://security.snyk.io/vuln/SNYK-JAVA-ORGAPACHESEATA-9515233
- **Docker Hub**: https://hub.docker.com/r/apache/seata-server
- **Release v2.2.0**: https://github.com/apache/incubator-seata/releases/tag/v2.2.0
- **Release v2.3.0**: https://github.com/apache/incubator-seata/releases/tag/v2.3.0

## Lab Build Notes

### Recommended Approach: Use Official Docker Image

The simplest approach is to use the official `apache/seata-server:2.2.0` Docker image configured in Raft mode. This avoids the need to build from source (which requires Java 8 and Maven, and the full multi-module build is heavy).

**Minimum lab setup for Raft mode:**
- 3 Seata server instances (Raft requires a cluster) OR a single node configured with its own address
- Configure `seata.store.mode=raft` and `seata.server.raft.server-addr`
- Expose the Raft port (default 9091)

### Building from Source (if needed)

```bash
# Requires Java 8+ and Maven 3.6+
mvn -Prelease-seata -Dmaven.test.skip=true clean install -U
# Server distribution: distribution/target/apache-seata-*-bin/
```

### Key Observation for PoC

The `RaftSnapshotSerializer.decode()` path is the **easiest to exploit** because it uses completely unfiltered `ObjectInputStream` deserialization. The `RaftSyncMessageSerializer` has a PERMITS allowlist but the `RaftSnapshotSerializer` has NO filtering whatsoever at v2.2.0. Standard Java deserialization payloads (ysoserial gadget chains) targeting libraries on the Seata classpath should work directly.
