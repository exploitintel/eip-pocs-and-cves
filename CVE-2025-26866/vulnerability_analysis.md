# Vulnerability Analysis: CVE-2025-26866

## Root Cause

**Insecure Hessian2 Deserialization in Apache HugeGraph PD Raft RPC**

The Apache HugeGraph Placement Driver (PD) component uses SOFAJRaft (version 1.3.13) for Raft consensus-based cluster coordination. The Raft RPC communication layer uses the SOFABolt binary TCP protocol. When Raft log entries are replicated to follower nodes, the `KVOperation.fromByteArray()` method deserializes the log entry payload using `Hessian2Input.readObject()` **without any class whitelist or `SerializerFactory`**. This allows an attacker to send arbitrarily crafted Hessian-serialized objects that trigger Java deserialization gadget chains present on the classpath, leading to Remote Code Execution (RCE).

**Two compounding root causes:**
1. **No deserialization whitelist**: `Hessian2Input` in `KVOperation.fromByteArray()` instantiates any Java class encoded in the Hessian2 stream, with no `SerializerFactory` restriction applied.
2. **No network-level authentication**: The Raft RPC server (`createRaftRpcServer` in `RaftEngine.java`) accepts TCP connections from **any IP address** — there is no peer-based IP filtering or any form of authentication.

## Vulnerable File(s) and Function(s)

### Primary Sink — `KVOperation.fromByteArray()`
- **File**: `hugegraph-pd/hg-pd-core/src/main/java/org/apache/hugegraph/pd/raft/KVOperation.java`
- **Lines**: 83–95 (specifically line 91: `op.arg = input.readObject()`)
- **Code**:
```java
public static KVOperation fromByteArray(byte[] value) throws IOException {
    try (ByteArrayInputStream bis = new ByteArrayInputStream(value, 1, value.length - 1)) {
        Hessian2Input input = new Hessian2Input(bis);
        // NO SerializerFactory — any class can be deserialized
        KVOperation op = new KVOperation();
        op.op = value[0];
        op.key = input.readBytes();    // line 89
        op.value = input.readBytes();  // line 90
        op.arg = input.readObject();   // line 91 ← DANGEROUS: arbitrary object deserialization
        input.close();
        return op;
    }
}
```

### Caller — `RaftStateMachine.onApply()`
- **File**: `hugegraph-pd/hg-pd-core/src/main/java/org/apache/hugegraph/pd/raft/RaftStateMachine.java`
- **Lines**: 76–99 (specifically line 84)
- **Code**:
```java
@Override
public void onApply(Iterator iter) {
    while (iter.hasNext()) {
        final RaftClosureAdapter done = (RaftClosureAdapter) iter.done();
        try {
            KVOperation kvOp;
            if (done != null) {
                kvOp = done.op;  // Leader path: already has KVOperation object
            } else {
                kvOp = KVOperation.fromByteArray(iter.getData().array());  // Follower path: DESERIALIZES from wire data
            }
            // ... invokes task handlers with the deserialized operation
```

### No-Auth RPC Server — `RaftEngine.createRaftRpcServer()`
- **File**: `hugegraph-pd/hg-pd-core/src/main/java/org/apache/hugegraph/pd/raft/RaftEngine.java`
- **Lines**: 133–139
- **Code**:
```java
private RpcServer createRaftRpcServer(String raftAddr) {
    Endpoint endpoint = JRaftUtils.getEndPoint(raftAddr);
    RpcServer rpcServer = RaftRpcServerFactory.createRaftRpcServer(endpoint);
    // NO IP whitelist — accepts connections from any source
    RaftRpcProcessor.registerProcessor(rpcServer, this);
    rpcServer.init(null);
    return rpcServer;
}
```

### Secondary Sink — `IdMetaStore.deserialize()`
- **File**: `hugegraph-pd/hg-pd-core/src/main/java/org/apache/hugegraph/pd/meta/IdMetaStore.java`
- **Lines**: 248–257 (specifically line 251: `input.readObject()`)
- **Note**: This is an internal deserialization method for cyclic ID metadata stored in RocksDB. Its data originates from `IdMetaStore.serialize()` and is stored via the Raft KV store. An attacker who can write arbitrary KV data through the Raft channel can also poison this deserialization path.

## Triggering Input

### Wire Format
The attacker must send a SOFABolt RPC frame to TCP port **8610** containing a crafted Hessian2-serialized payload. The payload must be structured as a valid `KVOperation` byte array:

**KVOperation byte array format:**
```
[byte 0]    → op code (e.g., 0x01 = PUT)
[bytes 1..] → Hessian2 stream containing:
    1. key   (readBytes)   — arbitrary byte[] (can be empty)
    2. value (readBytes)   — arbitrary byte[] (can be empty)
    3. arg   (readObject)  — MALICIOUS GADGET CHAIN OBJECT
```

The `arg` field at position 3 is deserialized via `input.readObject()` which will instantiate any class encoded in the Hessian2 stream.

### Gadget Chain Construction
The HugeGraph PD classpath contains these known gadget chain libraries:
- **Apache Commons Collections 3.2.2** — `ChainedTransformer` / `InvokerTransformer` chains
- **Apache Commons BeanUtils 1.9.4** — `BeanComparator` chains
- **Spring Framework 5.3.20** — `ClassPathXmlApplicationContext` JNDI gadgets, `SpringPartiallyComparableAdvisorHolder`
- **Hessian-native gadgets** — `com.caucho.hessian` deserializer allows `java.lang.reflect.Proxy` instantiation via `MapDeserializer`, enabling JNDI lookup chains

**Recommended gadget**: Hessian-specific gadgets from the `marshalsec` project. The `com.sun.rowset.JdbcRowSetImpl` → JNDI lookup chain works well with Hessian2 deserialization:
1. Craft a Hessian2 stream containing a `JdbcRowSetImpl` proxy with `dataSourceName` set to an attacker-controlled JNDI URL (`ldap://attacker:1389/Exploit`)
2. Upon deserialization, `JdbcRowSetImpl.setAutoCommit()` triggers JNDI lookup
3. JNDI response serves a malicious serialized object or remote class → RCE

**Alternative (no external dependencies)**: Use `Runtime.exec()` via `InvokerTransformer` chain from Commons Collections 3.2.2. This is classpath-native and requires no outbound connectivity for the initial trigger (though JNDI is simpler for Hessian2).

### SOFABolt Protocol
The exploit must speak the SOFABolt binary wire protocol. The simplest approach is to use the JRaft client library directly:
1. Create a `CliClientServiceImpl` or raw `BoltCliClientService` connection to the target
2. Send an `AppendEntriesRequest` containing the malicious serialized payload as a Raft log entry
3. The JRaft Raft state machine will process the entry and call `KVOperation.fromByteArray()`

**Alternative approach**: Construct raw SOFABolt frames. SOFABolt uses a simple frame format:
```
[1 byte: protocol code (0x01)]
[1 byte: type (request=0x01)]
[2 bytes: command code]
[1 byte: version]
[4 bytes: request ID]
[1 byte: codec (hessian=0x01)]
[... serialized request body ...]
```

## Attack Scenario

### Step-by-Step Exploitation

1. **Reconnaissance**: Attacker identifies a HugeGraph deployment and scans for TCP port 8610 (PD Raft) or 8510 (Store Raft).

2. **Payload Crafting**: Attacker constructs a `KVOperation` byte array:
   - Byte 0: `0x01` (PUT operation)
   - Bytes 1+: Hessian2 stream with:
     - Two byte arrays (key, value — can be empty/dummy)
     - A malicious gadget object (e.g., `JdbcRowSetImpl` JNDI proxy, or Commons Collections `ChainedTransformer`)

3. **Delivery**: Attacker connects to the Raft port (8610) using SOFABolt protocol and sends the payload as a Raft AppendEntries request. There are two approaches:
   - **Direct**: Use JRaft `CliClientServiceImpl` to connect as a Raft client and submit a task
   - **Raw SOFABolt**: Construct the SOFABolt binary frame manually and send via TCP

4. **Deserialization**: The PD's `RaftStateMachine.onApply()` receives the log entry. Since `done == null` (replicated entry, not local), it calls `KVOperation.fromByteArray(iter.getData().array())`. The `Hessian2Input.readObject()` call on the `arg` field deserializes the malicious object.

5. **Gadget Execution**: The gadget chain executes (e.g., JNDI lookup → remote class loading → arbitrary code execution). The attacker achieves RCE as the Java process user.

6. **Verification**: Attacker confirms execution (e.g., checks for `touch /tmp/pwned` file, receives DNS callback, or gets a reverse shell).

### Attack Complexity
- **Network access**: TCP to port 8610 (PD) or 8510 (Store)
- **Authentication**: NONE required
- **User interaction**: NONE
- **Privileges**: NONE (pre-auth, any network attacker)

## Impact

- **Remote Code Execution (RCE)** — arbitrary command execution on the HugeGraph PD server as the Java process user
- **Full system compromise** — the PD server is the cluster coordinator; compromising it gives the attacker control over the entire HugeGraph cluster
- **Data exfiltration** — access to all graph data stored across the cluster
- **Lateral movement** — since PD knows all store node addresses, the attacker can pivot to compromise store nodes

## Authentication Requirements

**No authentication is required.** The vulnerability is pre-auth. The Raft RPC server on port 8610 accepts connections from any IP address without any form of credential checking, peer verification, or TLS mutual authentication.

The PoC agent does NOT need to implement any authentication flow — just a raw TCP connection to port 8610 using the SOFABolt protocol.

## Fix Assessment

### What the Fix Does (Commit `42f9a7638ba0d3d75744c69690938c4ca1074e56`)

**Defense Layer 1 — Hessian Deserialization Whitelist:**
- New class `HugegraphHessianSerializerFactory` implements a strict whitelist of ~40 allowed classes (primitives, standard collections, time classes, `KVOperation`, `byte[]`)
- Applied to `KVOperation.fromByteArray()` via `input.setSerializerFactory(HugegraphHessianSerializerFactory.getInstance())`
- Any class not in the whitelist throws `SecurityException("hessian serialize unauthorized class: " + className)`

**Defense Layer 2 — IP-Based Authentication:**
- New class `IpAuthHandler` (Netty `ChannelDuplexHandler`) restricts connections to only IPs from the configured Raft peer list
- Applied as a front-channel handler on the `BoltRpcServer` via SOFABolt's `ExtendedNettyChannelHandler`
- Non-peer connections are immediately closed via `ctx.close()`

### Fix Completeness Assessment for PD Module
The fix for the **PD module specifically** is thorough and well-designed:
- The whitelist approach is correct — it's an allowlist (not a denylist), so novel gadget classes are blocked by default
- The whitelist is tight — only necessary business types are included, no gadget-useful classes (no Transformer, no Proxy, no Runtime)
- The IP authentication adds defense-in-depth at the network layer
- The `SerializerFactory` is applied via singleton pattern, ensuring consistency

### Remaining Attack Surface — hugegraph-store Module

**CRITICAL FINDING**: The fix is incomplete because it only covers the `hugegraph-pd` module. The **`hugegraph-store`** module has the **identical vulnerability pattern** that is NOT addressed by the fix:

1. **`RaftOperation.toObject()` in `hugegraph-store/hg-store-core`** (line 118–126) — performs `Hessian2Input.readObject()` with no `SerializerFactory`
2. **`HgStoreEngine.createRaftRpcServer()`** (line 158–168) — creates Raft RPC server with no IP whitelist
3. **Store Raft port 8510** — same unauthenticated SOFABolt protocol

The fix commit (`42f9a7638ba`) modifies **zero files** in `hugegraph-store/`. No subsequent commits in the repository address this either.

### Remaining Attack Surface — IdMetaStore

The `IdMetaStore.deserialize()` method (line 248–257) in `hg-pd-core` also uses unfiltered `Hessian2Input.readObject()`. The fix does NOT apply the whitelist to this deserialization path. However, this is a **secondary concern** because:
- The data comes from RocksDB (local storage), not directly from the network
- To exploit it, an attacker would first need to write malicious data through the Raft KV store — which itself requires the primary vulnerability

## Potential Bypass Vectors

### 1. Attack the Store Module Instead (confirmed remaining attack surface)
The `hugegraph-store` module's `RaftOperation.toObject()` on port 8510 has the exact same vulnerability and was NOT patched. An attacker can target port 8510 instead of 8610.

### 2. IP Spoofing of Peer IPs
The `IpAuthHandler` checks `ctx.channel().remoteAddress()` which reflects the source IP of the TCP connection. In environments where IP spoofing is possible (e.g., same L2 segment), the IP whitelist could be bypassed. However, maintaining a TCP session with a spoofed source IP is generally not practical.

### 3. Single-Node Deployment Self-Allow
In a single-node PD deployment (common for development), the `peers-list` contains only `127.0.0.1:8610`. The `IpAuthHandler` would allow connections from `127.0.0.1`. If the attacker has local access or can exploit an SSRF vulnerability to reach localhost, they bypass the IP filter.

## Escalation Path

The vulnerability provides **direct RCE** — no escalation needed. The deserialization leads directly to arbitrary command execution via gadget chains. The attacker achieves code execution as the HugeGraph Java process user.

Further escalation paths from initial RCE:
1. **Cluster takeover**: The PD server knows all store addresses; attacker can pivot to compromise store nodes via the same Raft vulnerability on port 8510
2. **Data exfiltration**: Direct access to all graph data via the PD's RocksDB storage and gRPC control plane
3. **Container escape**: If running in Docker with mounted Docker socket or privileged mode

## Related Attack Surface

### 1. `hugegraph-store` — `RaftOperation.toObject()` (SAME VULNERABILITY, UNFIXED)
- **File**: `hugegraph-store/hg-store-core/src/main/java/org/apache/hugegraph/store/raft/RaftOperation.java`
- **Lines**: 118–126
- **Code**:
```java
public static Object toObject(final byte[] bytes, int offset) throws IOException {
    try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes, offset + 1,
                                                             bytes.length - offset)) {
        Hessian2Input input = new Hessian2Input(bis);  // NO SerializerFactory
        Object obj = input.readObject();               // UNSAFE
        input.close();
        return obj;
    }
}
```
- **Called from**: `PartitionEngine.java` line 1202 during Raft apply for `IN_WRITE_OP`, `RAFT_UPDATE_PARTITION`, `IN_CLEAN_OP`, `DB_COMPACTION` operations
- **Port**: 8510 (Store Raft, SOFABolt protocol)
- **Status**: **NOT FIXED** — the fix commit did not touch any file in `hugegraph-store/`

### 2. `hugegraph-store` — `HgStoreEngine.createRaftRpcServer()` (NO IP AUTH)
- **File**: `hugegraph-store/hg-store-core/src/main/java/org/apache/hugegraph/store/HgStoreEngine.java`
- **Lines**: 158–168
- **Code**:
```java
private RpcServer createRaftRpcServer(String raftAddr) {
    Endpoint endpoint = JRaftUtils.getEndPoint(raftAddr);
    RpcServer rpcServer = RaftRpcServerFactory.createRaftRpcServer(endpoint, ...);
    // NO IpAuthHandler — accepts all connections
    HgCmdProcessor.registerProcessor(rpcServer, this);
    rpcServer.init(null);
    return rpcServer;
}
```
- **Status**: **NOT FIXED**

### 3. `hugegraph-pd` — `IdMetaStore.deserialize()` (UNFIXED SECONDARY SINK)
- **File**: `hugegraph-pd/hg-pd-core/src/main/java/org/apache/hugegraph/pd/meta/IdMetaStore.java`
- **Lines**: 248–257
- **Code**: `Hessian2Input` without `SerializerFactory` on data from RocksDB
- **Status**: **NOT FIXED**, but lower risk (requires prior write access to KV store)

### 4. `hugegraph-store` test utility (LOW RISK)
- **File**: `hugegraph-store/hg-store-test/src/main/java/org/apache/hugegraph/store/util/CopyOnWriteCacheTest.java`
- **Line**: 94 — uses `Hessian2Input.readObject()` in test code
- **Status**: Test code only, not deployed in production

## Build System

### Build Tool
- **Apache Maven 3.5+**
- **Java**: OpenJDK 11 (compiler source/target = 11)

### Build Commands
Full project build (required due to inter-module dependencies):
```bash
mvn clean package -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -pl hugegraph-pd -am
```

Or from the root:
```bash
mvn clean package -Dmaven.test.skip=true -Dmaven.javadoc.skip=true
```

The PD service JAR is produced at:
```
hugegraph-pd/hg-pd-dist/target/apache-hugegraph-pd-incubating-*/lib/hg-pd-service-*.jar
```

### Dependencies (hg-pd-core)
| Dependency | Version | Role |
|---|---|---|
| `com.alipay.sofa:jraft-core` | 1.3.13 | Raft consensus (brings SOFABolt + Hessian transitively) |
| `org.rocksdb:rocksdbjni` | 6.29.5 | Storage engine |
| `org.springframework:spring-context` | 5.3.20 | DI framework (gadget source) |
| `org.springframework.boot:spring-boot` | 2.5.14 | Application framework |
| `commons-collections:commons-collections` | 3.2.2 | Utility (gadget source) |
| `commons-beanutils:commons-beanutils` | 1.9.4 | Utility (gadget source) |
| `org.apache.commons:commons-lang3` | 3.12.0 | Utility |
| `com.google.code.gson:gson` | 2.8.9 | JSON |
| `org.projectlombok:lombok` | 1.18.30 | Code generation |
| `io.github.lognet:grpc-spring-boot-starter` | 4.5.5 | gRPC integration |

### Dependencies (hg-pd-service — runtime)
| Dependency | Version | Role |
|---|---|---|
| `spring-boot-starter-web` | 2.5.14 | REST API |
| `spring-boot-starter-actuator` | 2.5.14 | Monitoring |
| `spring-boot-starter-jetty` | 2.5.14 | Embedded server |
| `spring-boot-starter-log4j2` | 2.5.14 | Logging |
| `protobuf-java-util` | 3.17.2 | Protobuf support |

## Runtime Requirements

### Service Ports
| Service | Port | Protocol | Role |
|---|---|---|---|
| PD Raft | **8610** | SOFABolt (TCP) | **Attack surface** |
| PD REST | 8620 | HTTP | Health check |
| PD gRPC | 8686 | gRPC | Control plane |

### Configuration
Default `application.yml` settings for single-node lab:
```yaml
grpc:
  port: 8686
  host: 0.0.0.0      # Must bind to container IP for Docker
server:
  port: 8620
pd:
  data-path: ./pd_data
  initial-store-count: 1
  initial-store-list: 127.0.0.1:8500
raft:
  address: 0.0.0.0:8610     # Must bind to container IP or 0.0.0.0
  peers-list: <container-ip>:8610
```

### Docker Lab Setup
- **Base image**: `openjdk:11-slim` (matches existing Dockerfile)
- **Build image**: `maven:3.9.0-eclipse-temurin-11`
- **Exposed ports**: 8610 (Raft attack surface), 8620 (REST health check)
- **Startup**: `./bin/start-hugegraph-pd.sh` → runs `hg-pd-service-*.jar`
- **Health check**: `curl http://localhost:8620/actuator/health`
- **Verification**: Check for file creation (`/tmp/pwned`) or DNS callback after exploit
- **Critical config**: The `raft.address` and `raft.peers-list` must use the container's actual IP (not `127.0.0.1`) so the Raft port is accessible from outside the container
- **Existing Dockerfile**: `hugegraph-pd/Dockerfile` (multi-stage Maven build) can be adapted

### Exploit Requirements
The PoC should be Java-based and use `jraft-core` 1.3.13 (and transitively SOFABolt) as a dependency. This is the most reliable way to speak the SOFABolt protocol. The exploit JAR should:
1. Connect to target port 8610 via SOFABolt
2. Send a crafted Hessian2 payload with a gadget chain in the `arg` field of a `KVOperation`
3. The gadget chain should execute `touch /tmp/pwned` or equivalent system command
4. Available gadget chains: Commons Collections 3.2.2 `ChainedTransformer`, `JdbcRowSetImpl` JNDI, Spring `ClassPathXmlApplicationContext`
